{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Property, Complex, ChildProperty, Collection, extend } from '@syncfusion/ej2-base';\nimport { Font, Border } from '../../common/model/base';\nimport { rotateTextSize, firstToLowerCase, valueToCoefficient, inside, isBreakLabel } from '../../common/utils/helper';\nimport { Size, Rect, measureText } from '@syncfusion/ej2-svg-base';\nimport { DoubleRange } from '../utils/double-range';\nimport { Double } from '../axis/double-axis';\nimport { Theme } from '../../common/model/theme';\nimport { axisRangeCalculated } from '../../common/model/constants';\nimport { StripLineSettings, MultiLevelLabels, LabelBorder, ScrollbarSettings } from '../model/chart-base';\nimport { textWrap } from '../../common/utils/helper';\nvar axisPadding = 10;\n/**\n * Configures the `rows` of the chart.\n */\n\nvar Row =\n/** @class */\nfunction (_super) {\n  __extends(Row, _super);\n\n  function Row() {\n    /**\n     * The height of the row as a string accept input both as '100px' and '100%'.\n     * If specified as '100%, row renders to the full height of its chart.\n     * @default '100%'\n     */\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** @private */\n\n\n    _this.axes = [];\n    /** @private */\n\n    _this.nearSizes = [];\n    /** @private */\n\n    _this.farSizes = [];\n    return _this;\n  }\n  /**\n   * Measure the row size\n   * @return {void}\n   * @private\n   */\n\n\n  Row.prototype.computeSize = function (axis, clipRect, scrollBarHeight) {\n    var width = 0;\n    var innerPadding = 5;\n\n    if (axis.visible) {\n      width += axis.findTickSize(axis.crossInAxis) + scrollBarHeight + axis.findLabelSize(axis.crossInAxis, innerPadding) + axis.lineStyle.width * 0.5;\n    }\n\n    if (axis.opposedPosition) {\n      this.farSizes.push(width);\n    } else {\n      this.nearSizes.push(width);\n    }\n  };\n\n  __decorate([Property('100%')], Row.prototype, \"height\", void 0);\n\n  __decorate([Complex({}, Border)], Row.prototype, \"border\", void 0);\n\n  return Row;\n}(ChildProperty);\n\nexport { Row };\n/**\n * Configures the `columns` of the chart.\n */\n\nvar Column =\n/** @class */\nfunction (_super) {\n  __extends(Column, _super);\n\n  function Column() {\n    /**\n     * The width of the column as a string accepts input both as like '100px' or '100%'.\n     * If specified as '100%, column renders to the full width of its chart.\n     * @default '100%'\n     */\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** @private */\n\n\n    _this.axes = [];\n    /** @private */\n\n    _this.nearSizes = [];\n    /** @private */\n\n    _this.farSizes = [];\n    /** @private */\n\n    _this.padding = 0;\n    return _this;\n  }\n  /**\n   * Measure the column size\n   * @return {void}\n   * @private\n   */\n\n\n  Column.prototype.computeSize = function (axis, clipRect, scrollBarHeight) {\n    var height = 0;\n    var innerPadding = 5;\n\n    if (axis.visible) {\n      height += axis.findTickSize(axis.crossInAxis) + scrollBarHeight + axis.findLabelSize(axis.crossInAxis, innerPadding) + axis.lineStyle.width * 0.5;\n    }\n\n    if (axis.opposedPosition) {\n      this.farSizes.push(height);\n    } else {\n      this.nearSizes.push(height);\n    }\n  };\n\n  __decorate([Property('100%')], Column.prototype, \"width\", void 0);\n\n  __decorate([Complex({}, Border)], Column.prototype, \"border\", void 0);\n\n  return Column;\n}(ChildProperty);\n\nexport { Column };\n/**\n * Configures the major grid lines in the `axis`.\n */\n\nvar MajorGridLines =\n/** @class */\nfunction (_super) {\n  __extends(MajorGridLines, _super);\n\n  function MajorGridLines() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(1)], MajorGridLines.prototype, \"width\", void 0);\n\n  __decorate([Property('')], MajorGridLines.prototype, \"dashArray\", void 0);\n\n  __decorate([Property(null)], MajorGridLines.prototype, \"color\", void 0);\n\n  return MajorGridLines;\n}(ChildProperty);\n\nexport { MajorGridLines };\n/**\n * Configures the minor grid lines in the `axis`.\n */\n\nvar MinorGridLines =\n/** @class */\nfunction (_super) {\n  __extends(MinorGridLines, _super);\n\n  function MinorGridLines() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(0.7)], MinorGridLines.prototype, \"width\", void 0);\n\n  __decorate([Property('')], MinorGridLines.prototype, \"dashArray\", void 0);\n\n  __decorate([Property(null)], MinorGridLines.prototype, \"color\", void 0);\n\n  return MinorGridLines;\n}(ChildProperty);\n\nexport { MinorGridLines };\n/**\n * Configures the axis line of a chart.\n */\n\nvar AxisLine =\n/** @class */\nfunction (_super) {\n  __extends(AxisLine, _super);\n\n  function AxisLine() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(1)], AxisLine.prototype, \"width\", void 0);\n\n  __decorate([Property('')], AxisLine.prototype, \"dashArray\", void 0);\n\n  __decorate([Property(null)], AxisLine.prototype, \"color\", void 0);\n\n  return AxisLine;\n}(ChildProperty);\n\nexport { AxisLine };\n/**\n * Configures the major tick lines.\n */\n\nvar MajorTickLines =\n/** @class */\nfunction (_super) {\n  __extends(MajorTickLines, _super);\n\n  function MajorTickLines() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(1)], MajorTickLines.prototype, \"width\", void 0);\n\n  __decorate([Property(5)], MajorTickLines.prototype, \"height\", void 0);\n\n  __decorate([Property(null)], MajorTickLines.prototype, \"color\", void 0);\n\n  return MajorTickLines;\n}(ChildProperty);\n\nexport { MajorTickLines };\n/**\n * Configures the minor tick lines.\n */\n\nvar MinorTickLines =\n/** @class */\nfunction (_super) {\n  __extends(MinorTickLines, _super);\n\n  function MinorTickLines() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(0.7)], MinorTickLines.prototype, \"width\", void 0);\n\n  __decorate([Property(5)], MinorTickLines.prototype, \"height\", void 0);\n\n  __decorate([Property(null)], MinorTickLines.prototype, \"color\", void 0);\n\n  return MinorTickLines;\n}(ChildProperty);\n\nexport { MinorTickLines };\n/**\n * Configures the crosshair ToolTip.\n */\n\nvar CrosshairTooltip =\n/** @class */\nfunction (_super) {\n  __extends(CrosshairTooltip, _super);\n\n  function CrosshairTooltip() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(false)], CrosshairTooltip.prototype, \"enable\", void 0);\n\n  __decorate([Property(null)], CrosshairTooltip.prototype, \"fill\", void 0);\n\n  __decorate([Complex(Theme.crosshairLabelFont, Font)], CrosshairTooltip.prototype, \"textStyle\", void 0);\n\n  return CrosshairTooltip;\n}(ChildProperty);\n\nexport { CrosshairTooltip };\n/**\n * Configures the axes in the chart.\n * @public\n */\n\nvar Axis =\n/** @class */\nfunction (_super) {\n  __extends(Axis, _super); // tslint:disable-next-line:no-any\n\n\n  function Axis(parent, propName, defaultValue, isArray) {\n    var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;\n    /** @private */\n\n\n    _this.visibleLabels = [];\n    /** @private */\n\n    _this.series = [];\n    /** @private */\n\n    _this.rect = new Rect(undefined, undefined, 0, 0);\n    /** @private */\n\n    _this.axisBottomLine = null;\n    /** @private */\n\n    _this.intervalDivs = [10, 5, 2, 1];\n    /** @private */\n\n    _this.angle = _this.labelRotation;\n    /** @private */\n\n    _this.isStack100 = false;\n    /** @private */\n\n    _this.crossAt = null;\n    /** @private */\n\n    _this.updatedRect = null;\n    /** @private */\n\n    _this.multiLevelLabelHeight = 0;\n    /** @private */\n\n    _this.isChart = true;\n    return _this;\n  }\n  /**\n   * The function used to find tick size.\n   * @return {number}\n   * @private\n   */\n\n\n  Axis.prototype.findTickSize = function (crossAxis) {\n    if (this.tickPosition === 'Inside') {\n      return 0;\n    }\n\n    if (crossAxis && (!crossAxis.visibleRange || this.isInside(crossAxis.visibleRange))) {\n      return 0;\n    }\n\n    return this.majorTickLines.height;\n  };\n  /**\n   * The function used to find axis position.\n   * @return {number}\n   * @private\n   */\n\n\n  Axis.prototype.isInside = function (range) {\n    return inside(this.crossAt, range) || !this.opposedPosition && this.crossAt >= range.max || this.opposedPosition && this.crossAt <= range.min;\n  };\n  /**\n   * The function used to find label Size.\n   * @return {number}\n   * @private\n   */\n\n\n  Axis.prototype.findLabelSize = function (crossAxis, innerPadding) {\n    var titleSize = 0;\n\n    if (this.title) {\n      titleSize = measureText(this.title, this.titleStyle).height + innerPadding;\n    }\n\n    if (this.labelPosition === 'Inside') {\n      return titleSize + innerPadding;\n    }\n\n    var diff;\n    var value;\n    var labelSize = titleSize + innerPadding + axisPadding + (this.orientation === 'Vertical' ? this.maxLabelSize.width : this.maxLabelSize.height) + this.multiLevelLabelHeight;\n\n    if (crossAxis && this.placeNextToAxisLine) {\n      var range = crossAxis.visibleRange;\n      var size = crossAxis.orientation === 'Horizontal' ? crossAxis.rect.width : crossAxis.rect.height;\n\n      if (!range || !size) {\n        return 0;\n      } else if (this.isInside(range)) {\n        value = this.findDifference(crossAxis);\n        diff = value * (size / range.delta);\n        diff = value * ((size - (diff < labelSize ? labelSize - diff : 0)) / range.delta);\n        labelSize = diff < labelSize ? labelSize - diff : 0;\n      }\n    }\n\n    return labelSize;\n  };\n  /**\n   * The function used to find axis position.\n   * @return {number}\n   * @private\n   */\n\n\n  Axis.prototype.updateCrossValue = function (chart) {\n    var value = this.crossAt;\n\n    if (value === null || !this.isInside(this.crossInAxis.visibleRange)) {\n      this.updatedRect = this.rect;\n      return null;\n    }\n\n    var range = this.crossInAxis.visibleRange;\n\n    if (!this.opposedPosition) {\n      if (this.crossAt > range.max) {\n        value = range.max;\n      }\n    } else {\n      if (this.crossAt < range.min) {\n        value = range.min;\n      }\n    }\n\n    this.updatedRect = extend({}, this.rect, null, true);\n\n    if (this.orientation === 'Horizontal') {\n      value = this.crossInAxis.rect.height - valueToCoefficient(value, this.crossInAxis) * this.crossInAxis.rect.height;\n      this.updatedRect.y = this.crossInAxis.rect.y + value;\n    } else {\n      value = valueToCoefficient(value, this.crossInAxis) * this.crossInAxis.rect.width;\n      this.updatedRect.x = this.crossInAxis.rect.x + value;\n    }\n  };\n\n  Axis.prototype.findDifference = function (crossAxis) {\n    var value = 0;\n\n    if (this.opposedPosition) {\n      value = crossAxis.isInversed ? crossAxis.visibleRange.min : crossAxis.visibleRange.max;\n    } else {\n      value = crossAxis.isInversed ? crossAxis.visibleRange.max : crossAxis.visibleRange.min;\n    }\n\n    return Math.abs(this.crossAt - value);\n  };\n  /**\n   * Calculate visible range for axis.\n   * @return {void}\n   * @private\n   */\n\n\n  Axis.prototype.calculateVisibleRange = function (size) {\n    if (this.zoomFactor < 1 || this.zoomPosition > 0) {\n      var baseRange = this.actualRange;\n      var start = void 0;\n      var end = void 0;\n\n      if (!this.isInversed) {\n        start = this.actualRange.min + this.zoomPosition * this.actualRange.delta;\n        end = start + this.zoomFactor * this.actualRange.delta;\n      } else {\n        start = this.actualRange.max - this.zoomPosition * this.actualRange.delta;\n        end = start - this.zoomFactor * this.actualRange.delta;\n      }\n\n      if (start < baseRange.min) {\n        end = end + (baseRange.min - start);\n        start = baseRange.min;\n      }\n\n      if (end > baseRange.max) {\n        start = start - (end - baseRange.max);\n        end = baseRange.max;\n      }\n\n      this.doubleRange = new DoubleRange(start, end);\n      this.visibleRange = {\n        min: this.doubleRange.start,\n        max: this.doubleRange.end,\n        delta: this.doubleRange.delta,\n        interval: this.visibleRange.interval\n      };\n    }\n  };\n  /**\n   * Triggers the event.\n   * @return {void}\n   * @private\n   */\n\n\n  Axis.prototype.triggerRangeRender = function (chart, minimum, maximum, interval) {\n    var argsData;\n    argsData = {\n      cancel: false,\n      name: axisRangeCalculated,\n      axis: this,\n      minimum: minimum,\n      maximum: maximum,\n      interval: interval\n    };\n    chart.trigger(axisRangeCalculated, argsData);\n\n    if (!argsData.cancel) {\n      this.visibleRange = {\n        min: argsData.minimum,\n        max: argsData.maximum,\n        interval: argsData.interval,\n        delta: argsData.maximum - argsData.minimum\n      };\n    }\n  };\n  /**\n   * Calculate padding for the axis.\n   * @return {string}\n   * @private\n   */\n\n\n  Axis.prototype.getRangePadding = function (chart) {\n    var padding = this.rangePadding;\n\n    if (padding !== 'Auto') {\n      return padding;\n    }\n\n    switch (this.orientation) {\n      case 'Horizontal':\n        if (chart.requireInvertedAxis) {\n          padding = this.isStack100 || this.baseModule.chart.stockChart ? 'Round' : 'Normal';\n        } else {\n          padding = 'None';\n        }\n\n        break;\n\n      case 'Vertical':\n        if (!chart.requireInvertedAxis) {\n          padding = this.isStack100 || this.baseModule.chart.stockChart ? 'Round' : 'Normal';\n        } else {\n          padding = 'None';\n        }\n\n        break;\n    }\n\n    return padding;\n  };\n  /**\n   * Calculate maximum label width for the axis.\n   * @return {void}\n   * @private\n   */\n\n\n  Axis.prototype.getMaxLabelWidth = function (chart) {\n    var pointX;\n    var previousEnd = 0;\n    var isIntersect = false;\n    var isAxisLabelBreak;\n    this.angle = this.labelRotation;\n    this.maxLabelSize = new Size(0, 0);\n    var action = this.labelIntersectAction;\n    var label;\n\n    for (var i = 0, len = this.visibleLabels.length; i < len; i++) {\n      label = this.visibleLabels[i];\n      isAxisLabelBreak = isBreakLabel(label.originalText);\n\n      if (isAxisLabelBreak) {\n        label.size = measureText(label.originalText.replace(/<br>/g, ' '), this.labelStyle);\n        label.breakLabelSize = measureText(this.enableTrim ? label.text.join('<br>') : label.originalText, this.labelStyle);\n      } else {\n        label.size = measureText(label.text, this.labelStyle);\n      }\n\n      var width = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;\n\n      if (width > this.maxLabelSize.width) {\n        this.maxLabelSize.width = width;\n        this.rotatedLabel = label.text;\n      }\n\n      var height = isAxisLabelBreak ? label.breakLabelSize.height : label.size.height;\n\n      if (height > this.maxLabelSize.height) {\n        this.maxLabelSize.height = height;\n      }\n\n      if (isAxisLabelBreak) {\n        label.text = this.enableTrim ? label.text : label.originalText.split('<br>');\n      }\n\n      if (action === 'None' || action === 'Hide' || action === 'Trim') {\n        continue;\n      }\n\n      if ((action !== 'None' || this.angle % 360 === 0) && this.orientation === 'Horizontal' && this.rect.width > 0 && !isIntersect) {\n        var width1 = isAxisLabelBreak ? label.breakLabelSize.width : label.size.width;\n        var height1 = isAxisLabelBreak ? label.breakLabelSize.height : label.size.height;\n        pointX = valueToCoefficient(label.value, this) * this.rect.width + this.rect.x;\n        pointX -= width1 / 2;\n\n        if (this.edgeLabelPlacement === 'Shift') {\n          if (i === 0 && pointX < this.rect.x) {\n            pointX = this.rect.x;\n          }\n\n          if (i === this.visibleLabels.length - 1 && pointX + width1 > this.rect.x + this.rect.width) {\n            pointX = this.rect.x + this.rect.width - width1;\n          }\n        }\n\n        switch (action) {\n          case 'MultipleRows':\n            if (i > 0) {\n              this.findMultiRows(i, pointX, label, isAxisLabelBreak);\n            }\n\n            break;\n\n          case 'Rotate45':\n          case 'Rotate90':\n            if (i > 0 && (!this.isInversed ? pointX <= previousEnd : pointX + width1 >= previousEnd)) {\n              this.angle = action === 'Rotate45' ? 45 : 90;\n              isIntersect = true;\n            }\n\n            break;\n\n          default:\n            if (isAxisLabelBreak) {\n              var result = void 0;\n              var result1 = [];\n              var str = void 0;\n\n              for (var index = 0; index < label.text.length; index++) {\n                result = textWrap(label.text[index], this.rect.width / this.visibleLabels.length, this.labelStyle);\n\n                if (result.length > 1) {\n                  for (var j = 0; j < result.length; j++) {\n                    str = result[j];\n                    result1.push(str);\n                  }\n                } else {\n                  result1.push(result[0]);\n                }\n              }\n\n              label.text = result1;\n            } else {\n              label.text = textWrap(label.text, this.rect.width / this.visibleLabels.length, this.labelStyle);\n            }\n\n            var height_1 = height1 * label.text.length;\n\n            if (height_1 > this.maxLabelSize.height) {\n              this.maxLabelSize.height = height_1;\n            }\n\n            break;\n        }\n\n        previousEnd = this.isInversed ? pointX : pointX + width1;\n      }\n    }\n\n    if (this.angle !== 0 && this.orientation === 'Horizontal') {\n      if (isBreakLabel(this.rotatedLabel)) {\n        this.maxLabelSize = measureText(this.rotatedLabel, this.labelStyle);\n      } else {\n        this.maxLabelSize = rotateTextSize(this.labelStyle, this.rotatedLabel, this.angle, chart);\n      }\n    }\n\n    if (chart.multiLevelLabelModule && this.multiLevelLabels.length > 0) {\n      chart.multiLevelLabelModule.getMultilevelLabelsHeight(this);\n    }\n  };\n  /**\n   * Finds the multiple rows for axis.\n   * @return {void}\n   */\n\n\n  Axis.prototype.findMultiRows = function (length, currentX, currentLabel, isBreakLabels) {\n    var label;\n    var pointX;\n    var width2;\n    var store = [];\n    var isMultiRows;\n\n    for (var i = length - 1; i >= 0; i--) {\n      label = this.visibleLabels[i];\n      width2 = isBreakLabels ? label.breakLabelSize.width : label.size.width;\n      pointX = valueToCoefficient(label.value, this) * this.rect.width + this.rect.x;\n      isMultiRows = !this.isInversed ? currentX < pointX + width2 * 0.5 : currentX + currentLabel.size.width > pointX - width2 * 0.5;\n\n      if (isMultiRows) {\n        store.push(label.index);\n        currentLabel.index = currentLabel.index > label.index ? currentLabel.index : label.index + 1;\n      } else {\n        currentLabel.index = store.indexOf(label.index) > -1 ? currentLabel.index : label.index;\n      }\n    }\n\n    var height = (isBreakLabels ? currentLabel.breakLabelSize.height : currentLabel.size.height) * currentLabel.index + 5 * (currentLabel.index - 1);\n\n    if (height > this.maxLabelSize.height) {\n      this.maxLabelSize.height = height;\n    }\n  };\n  /**\n   * Finds the default module for axis.\n   * @return {void}\n   * @private\n   */\n\n\n  Axis.prototype.getModule = function (chart) {\n    if (this.valueType === 'Double') {\n      this.baseModule = new Double(chart);\n    } else {\n      this.baseModule = chart[firstToLowerCase(this.valueType) + 'Module'];\n    }\n  };\n\n  __decorate([Complex(Theme.axisLabelFont, Font)], Axis.prototype, \"labelStyle\", void 0);\n\n  __decorate([Complex({}, CrosshairTooltip)], Axis.prototype, \"crosshairTooltip\", void 0);\n\n  __decorate([Property('')], Axis.prototype, \"title\", void 0);\n\n  __decorate([Complex(Theme.axisTitleFont, Font)], Axis.prototype, \"titleStyle\", void 0);\n\n  __decorate([Property('')], Axis.prototype, \"labelFormat\", void 0);\n\n  __decorate([Property('')], Axis.prototype, \"skeleton\", void 0);\n\n  __decorate([Property('DateTime')], Axis.prototype, \"skeletonType\", void 0);\n\n  __decorate([Property(0)], Axis.prototype, \"plotOffset\", void 0);\n\n  __decorate([Property(false)], Axis.prototype, \"isIndexed\", void 0);\n\n  __decorate([Property(10)], Axis.prototype, \"logBase\", void 0);\n\n  __decorate([Property(0)], Axis.prototype, \"columnIndex\", void 0);\n\n  __decorate([Property(0)], Axis.prototype, \"rowIndex\", void 0);\n\n  __decorate([Property(1)], Axis.prototype, \"span\", void 0);\n\n  __decorate([Property(null)], Axis.prototype, \"desiredIntervals\", void 0);\n\n  __decorate([Property(3)], Axis.prototype, \"maximumLabels\", void 0);\n\n  __decorate([Property(1)], Axis.prototype, \"zoomFactor\", void 0);\n\n  __decorate([Property(0)], Axis.prototype, \"zoomPosition\", void 0);\n\n  __decorate([Property(false)], Axis.prototype, \"opposedPosition\", void 0);\n\n  __decorate([Property(true)], Axis.prototype, \"enableAutoIntervalOnZooming\", void 0);\n\n  __decorate([Property('Auto')], Axis.prototype, \"rangePadding\", void 0);\n\n  __decorate([Property('Double')], Axis.prototype, \"valueType\", void 0);\n\n  __decorate([Property('None')], Axis.prototype, \"edgeLabelPlacement\", void 0);\n\n  __decorate([Property('Auto')], Axis.prototype, \"intervalType\", void 0);\n\n  __decorate([Property('BetweenTicks')], Axis.prototype, \"labelPlacement\", void 0);\n\n  __decorate([Property('Outside')], Axis.prototype, \"tickPosition\", void 0);\n\n  __decorate([Property('Outside')], Axis.prototype, \"labelPosition\", void 0);\n\n  __decorate([Property('')], Axis.prototype, \"name\", void 0);\n\n  __decorate([Property(true)], Axis.prototype, \"visible\", void 0);\n\n  __decorate([Property(0)], Axis.prototype, \"minorTicksPerInterval\", void 0);\n\n  __decorate([Property(0)], Axis.prototype, \"labelRotation\", void 0);\n\n  __decorate([Property(null)], Axis.prototype, \"crossesAt\", void 0);\n\n  __decorate([Property(true)], Axis.prototype, \"placeNextToAxisLine\", void 0);\n\n  __decorate([Property(null)], Axis.prototype, \"crossesInAxis\", void 0);\n\n  __decorate([Property(null)], Axis.prototype, \"minimum\", void 0);\n\n  __decorate([Property(null)], Axis.prototype, \"maximum\", void 0);\n\n  __decorate([Property(null)], Axis.prototype, \"interval\", void 0);\n\n  __decorate([Property(34)], Axis.prototype, \"maximumLabelWidth\", void 0);\n\n  __decorate([Property(false)], Axis.prototype, \"enableTrim\", void 0);\n\n  __decorate([Complex({}, MajorTickLines)], Axis.prototype, \"majorTickLines\", void 0);\n\n  __decorate([Complex({}, MinorTickLines)], Axis.prototype, \"minorTickLines\", void 0);\n\n  __decorate([Complex({}, MajorGridLines)], Axis.prototype, \"majorGridLines\", void 0);\n\n  __decorate([Complex({}, MinorGridLines)], Axis.prototype, \"minorGridLines\", void 0);\n\n  __decorate([Complex({}, AxisLine)], Axis.prototype, \"lineStyle\", void 0);\n\n  __decorate([Property('Trim')], Axis.prototype, \"labelIntersectAction\", void 0);\n\n  __decorate([Property(false)], Axis.prototype, \"isInversed\", void 0);\n\n  __decorate([Property(100)], Axis.prototype, \"coefficient\", void 0);\n\n  __decorate([Property(0)], Axis.prototype, \"startAngle\", void 0);\n\n  __decorate([Property(null)], Axis.prototype, \"description\", void 0);\n\n  __decorate([Property(2)], Axis.prototype, \"tabIndex\", void 0);\n\n  __decorate([Collection([], StripLineSettings)], Axis.prototype, \"stripLines\", void 0);\n\n  __decorate([Collection([], MultiLevelLabels)], Axis.prototype, \"multiLevelLabels\", void 0);\n\n  __decorate([Complex({\n    color: null,\n    width: 0,\n    type: 'Rectangle'\n  }, LabelBorder)], Axis.prototype, \"border\", void 0);\n\n  __decorate([Complex({}, ScrollbarSettings)], Axis.prototype, \"scrollbarSettings\", void 0);\n\n  return Axis;\n}(ChildProperty);\n\nexport { Axis };\n/** @private */\n\nvar VisibleLabels =\n/** @class */\nfunction () {\n  function VisibleLabels(text, value, labelStyle, originalText, size, breakLabelSize, index) {\n    if (size === void 0) {\n      size = new Size(0, 0);\n    }\n\n    if (breakLabelSize === void 0) {\n      breakLabelSize = new Size(0, 0);\n    }\n\n    if (index === void 0) {\n      index = 1;\n    }\n\n    this.text = text;\n    this.originalText = originalText;\n    this.value = value;\n    this.labelStyle = labelStyle;\n    this.size = size;\n    this.breakLabelSize = breakLabelSize;\n    this.index = 1;\n  }\n\n  return VisibleLabels;\n}();\n\nexport { VisibleLabels };","map":null,"metadata":{},"sourceType":"module"}