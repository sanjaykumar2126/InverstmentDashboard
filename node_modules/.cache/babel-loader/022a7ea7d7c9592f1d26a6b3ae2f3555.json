{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { RectOption, appendChildElement, getElement, appendClipElement } from '../../common/utils/helper';\nimport { findlElement, drawSymbol, markerAnimate, CircleOption } from '../../common/utils/helper';\nimport { PathOption, Size } from '@syncfusion/ej2-svg-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { pointRender } from '../../common/model/constants';\nimport { MarkerExplode } from './marker-explode';\nimport { getSaturationColor } from '../../common/utils/helper';\n/**\n * Marker module used to render the marker for line type series.\n */\n\nvar Marker =\n/** @class */\nfunction (_super) {\n  __extends(Marker, _super);\n  /**\n   * Constructor for the marker module.\n   * @private\n   */\n\n\n  function Marker(chart) {\n    var _this = _super.call(this, chart) || this;\n\n    _this.addEventListener();\n\n    return _this;\n  }\n  /**\n   * Render the marker for series.\n   * @return {void}\n   * @private\n   */\n\n\n  Marker.prototype.render = function (series) {\n    var _this = this;\n\n    var redraw = series.chart.redraw;\n    this.createElement(series, redraw);\n\n    var _loop_1 = function (point) {\n      if (point.visible && point.symbolLocations.length) {\n        point.symbolLocations.map(function (location, index) {\n          _this.renderMarker(series, point, location, index, redraw);\n        });\n      }\n    };\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      _loop_1(point);\n    }\n  };\n\n  Marker.prototype.renderMarker = function (series, point, location, index, redraw) {\n    var seriesIndex = series.index === undefined ? series.category : series.index;\n    var marker = series.marker;\n    var border = {\n      color: marker.border.color,\n      width: marker.border.width\n    };\n    var borderColor = marker.border.color;\n    var symbolId;\n    var previousLocation;\n    var previousPath;\n    var circlePath;\n    var shapeOption;\n    var isBoxPlot = series.type === 'BoxAndWhisker';\n    var fill = marker.fill || (isBoxPlot ? point.interior || series.interior : '#ffffff');\n    var argsData;\n    var markerElement;\n    var parentElement = isBoxPlot ? findlElement(series.seriesElement.childNodes, 'Series_' + series.index + '_Point_' + point.index) : series.symbolElement;\n    border.color = borderColor || series.setPointColor(point, series.interior);\n    symbolId = this.elementId + '_Series_' + seriesIndex + '_Point_' + point.index + '_Symbol' + (index ? index : '');\n    argsData = {\n      cancel: false,\n      name: pointRender,\n      series: series,\n      point: point,\n      fill: point.isEmpty ? series.emptyPointSettings.fill || fill : fill,\n      border: {\n        color: series.type === 'BoxAndWhisker' ? !isNullOrUndefined(borderColor) && borderColor !== 'transparent' ? borderColor : getSaturationColor(fill, -0.6) : border.color,\n        width: border.width\n      },\n      height: marker.height,\n      width: marker.width,\n      shape: marker.shape\n    };\n    argsData.border = series.setBorderColor(point, {\n      width: argsData.border.width,\n      color: argsData.border.color\n    });\n\n    if (!series.isRectSeries || series.type === 'BoxAndWhisker') {\n      this.chart.trigger(pointRender, argsData);\n      point.color = argsData.fill;\n    }\n\n    point.color = argsData.fill;\n\n    if (!argsData.cancel) {\n      var y = void 0;\n\n      if (series.type === 'RangeArea' || series.type === 'RangeColumn') {\n        y = index ? point.low : point.high;\n      } else if (isBoxPlot) {\n        y = point.outliers[index];\n      } else {\n        y = point.y;\n      }\n\n      shapeOption = new PathOption(symbolId, argsData.fill, argsData.border.width, argsData.border.color, marker.opacity, null);\n\n      if (parentElement !== undefined && parentElement !== null || this.chart.enableCanvas) {\n        if (redraw && getElement(shapeOption.id)) {\n          markerElement = getElement(shapeOption.id);\n          circlePath = argsData.shape === 'Circle' ? 'c' : '';\n          previousLocation = {\n            x: +markerElement.getAttribute(circlePath + 'x'),\n            y: +markerElement.getAttribute(circlePath + 'y')\n          };\n          previousPath = markerElement.getAttribute('d');\n        }\n\n        markerElement = drawSymbol(location, argsData.shape, new Size(argsData.width, argsData.height), marker.imageUrl, shapeOption, point.x.toString() + ':' + y.toString(), this.chart.renderer, series.clipRect);\n        appendChildElement(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + 'x', circlePath + 'y', previousLocation, previousPath, false, false, null, series.chart.duration);\n      }\n\n      point.marker = {\n        border: argsData.border,\n        fill: argsData.fill,\n        height: argsData.height,\n        visible: true,\n        shape: argsData.shape,\n        width: argsData.width\n      };\n    } else {\n      location = null;\n      point.marker = {\n        visible: false\n      };\n    }\n  };\n\n  Marker.prototype.createElement = function (series, redraw) {\n    var markerClipRect;\n    var marker = series.marker; // 8 for extend border value 5 for extend size value\n\n    var explodeValue = marker.border.width + 8 + 5;\n    var render = series.chart.svgRenderer;\n    var transform;\n    var index = series.index === undefined ? series.category : series.index;\n    var options;\n    transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')' : '';\n\n    if (marker.visible) {\n      var markerHeight = (marker.height + explodeValue) / 2;\n      var markerWidth = (marker.width + explodeValue) / 2;\n\n      if (series.chart.chartAreaType === 'Cartesian') {\n        options = new RectOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, {\n          x: -markerWidth,\n          y: -markerHeight,\n          width: series.clipRect.width + markerWidth * 2,\n          height: series.clipRect.height + markerHeight * 2\n        });\n        markerClipRect = appendClipElement(redraw, options, render);\n      } else {\n        options = new CircleOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));\n        markerClipRect = appendClipElement(redraw, options, render, 'drawCircularClipPath');\n      }\n\n      options = {\n        'id': this.elementId + 'SymbolGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.elementId + '_ChartMarkerClipRect_' + index + ')'\n      };\n      series.symbolElement = render.createGroup(options);\n      series.symbolElement.appendChild(markerClipRect);\n\n      if (this.chart.enableCanvas) {\n        var element = document.getElementById(this.chart.element.id + '_tooltip_svg');\n        element.appendChild(series.symbolElement);\n      }\n    }\n  };\n\n  Marker.prototype.getRangeLowPoint = function (region, series) {\n    var x = region.x;\n    var y = region.y;\n\n    if (series.chart.requireInvertedAxis) {\n      y += region.height / 2;\n      x += series.yAxis.isInversed ? region.width : 0;\n    } else {\n      y += series.yAxis.isInversed ? 0 : region.height;\n      x += region.width / 2;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /**\n   * Animates the marker.\n   * @return {void}.\n   * @private\n   */\n\n\n  Marker.prototype.doMarkerAnimation = function (series) {\n    if (!(series.type === 'Scatter' || series.type === 'Bubble' || series.type === 'Candle' || series.type === 'Hilo' || series.type === 'HiloOpenClose' || series.chart.chartAreaType === 'PolarRadar' && series.drawType === 'Scatter')) {\n      var markerElements = series.symbolElement.childNodes;\n      var delay = series.animation.delay + series.animation.duration;\n      var duration = series.chart.animated ? series.chart.duration : 200;\n      var j = 1;\n      var incFactor = series.type === 'RangeArea' || series.type === 'RangeColumn' ? 2 : 1;\n\n      for (var i = 0; i < series.points.length; i++) {\n        if (!series.points[i].symbolLocations.length || !markerElements[j]) {\n          continue;\n        }\n\n        markerAnimate(markerElements[j], delay, duration, series, i, series.points[i].symbolLocations[0], false);\n\n        if (incFactor === 2) {\n          var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);\n          markerAnimate(markerElements[j + 1], delay, duration, series, i, lowPoint, false);\n        }\n\n        j += incFactor;\n      }\n    }\n  };\n\n  return Marker;\n}(MarkerExplode);\n\nexport { Marker };","map":null,"metadata":{},"sourceType":"module"}