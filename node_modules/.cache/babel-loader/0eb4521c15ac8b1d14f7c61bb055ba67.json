{"ast":null,"code":"import PlotAreaBase from './plotarea-base';\nimport AxisGroupRangeTracker from '../axis-group-range-tracker';\nimport PlotAreaEventsMixin from '../mixins/plotarea-events-mixin';\nimport ScatterChart from '../scatter-charts/scatter-chart';\nimport ScatterLineChart from '../scatter-charts/scatter-line-chart';\nimport BubbleChart from '../bubble-chart/bubble-chart';\nimport SeriesBinder from '../series-binder';\nimport { NumericAxis, LogarithmicAxis, DateValueAxis, Point } from '../../core';\nimport filterSeriesByType from '../utils/filter-series-by-type';\nimport equalsIgnoreCase from '../utils/equals-ignore-case';\nimport singleItemOrArray from '../utils/single-item-or-array';\nimport { SCATTER, SCATTER_LINE, BUBBLE, LOGARITHMIC } from '../constants';\nimport { DATE } from '../../common/constants';\nimport { deepExtend, eventElement, grep, inArray, setDefaultOptions } from '../../common';\n\nvar XYPlotArea = function (PlotAreaBase) {\n  function XYPlotArea() {\n    PlotAreaBase.apply(this, arguments);\n  }\n\n  if (PlotAreaBase) XYPlotArea.__proto__ = PlotAreaBase;\n  XYPlotArea.prototype = Object.create(PlotAreaBase && PlotAreaBase.prototype);\n  XYPlotArea.prototype.constructor = XYPlotArea;\n\n  XYPlotArea.prototype.initFields = function initFields() {\n    this.namedXAxes = {};\n    this.namedYAxes = {};\n    this.xAxisRangeTracker = new AxisGroupRangeTracker();\n    this.yAxisRangeTracker = new AxisGroupRangeTracker();\n  };\n\n  XYPlotArea.prototype.render = function render(panes) {\n    var this$1 = this;\n    if (panes === void 0) panes = this.panes;\n    var seriesByPane = this.groupSeriesByPane();\n\n    for (var i = 0; i < panes.length; i++) {\n      var pane = panes[i];\n      var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n      this$1.addToLegend(paneSeries);\n      var filteredSeries = this$1.filterVisibleSeries(paneSeries);\n\n      if (!filteredSeries) {\n        continue;\n      }\n\n      this$1.createScatterChart(filterSeriesByType(filteredSeries, SCATTER), pane);\n      this$1.createScatterLineChart(filterSeriesByType(filteredSeries, SCATTER_LINE), pane);\n      this$1.createBubbleChart(filterSeriesByType(filteredSeries, BUBBLE), pane);\n    }\n\n    this.createAxes(panes);\n  };\n\n  XYPlotArea.prototype.appendChart = function appendChart(chart, pane) {\n    this.xAxisRangeTracker.update(chart.xAxisRanges);\n    this.yAxisRangeTracker.update(chart.yAxisRanges);\n    PlotAreaBase.prototype.appendChart.call(this, chart, pane);\n  };\n\n  XYPlotArea.prototype.removeAxis = function removeAxis(axis) {\n    var axisName = axis.options.name;\n    PlotAreaBase.prototype.removeAxis.call(this, axis);\n\n    if (axis.options.vertical) {\n      this.yAxisRangeTracker.reset(axisName);\n      delete this.namedYAxes[axisName];\n    } else {\n      this.xAxisRangeTracker.reset(axisName);\n      delete this.namedXAxes[axisName];\n    }\n\n    if (axis === this.axisX) {\n      delete this.axisX;\n    }\n\n    if (axis === this.axisY) {\n      delete this.axisY;\n    }\n  }; // TODO: Refactor, optionally use series.pane option\n\n\n  XYPlotArea.prototype.seriesPaneName = function seriesPaneName(series) {\n    var options = this.options;\n    var xAxisName = series.xAxis;\n    var xAxisOptions = [].concat(options.xAxis);\n    var xAxis = grep(xAxisOptions, function (a) {\n      return a.name === xAxisName;\n    })[0];\n    var yAxisName = series.yAxis;\n    var yAxisOptions = [].concat(options.yAxis);\n    var yAxis = grep(yAxisOptions, function (a) {\n      return a.name === yAxisName;\n    })[0];\n    var panes = options.panes || [{}];\n    var defaultPaneName = panes[0].name || \"default\";\n    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n    return paneName;\n  };\n\n  XYPlotArea.prototype.createScatterChart = function createScatterChart(series, pane) {\n    if (series.length > 0) {\n      this.appendChart(new ScatterChart(this, {\n        series: series,\n        clip: pane.options.clip\n      }), pane);\n    }\n  };\n\n  XYPlotArea.prototype.createScatterLineChart = function createScatterLineChart(series, pane) {\n    if (series.length > 0) {\n      this.appendChart(new ScatterLineChart(this, {\n        series: series,\n        clip: pane.options.clip\n      }), pane);\n    }\n  };\n\n  XYPlotArea.prototype.createBubbleChart = function createBubbleChart(series, pane) {\n    if (series.length > 0) {\n      this.appendChart(new BubbleChart(this, {\n        series: series,\n        clip: pane.options.clip\n      }), pane);\n    }\n  };\n\n  XYPlotArea.prototype.createXYAxis = function createXYAxis(options, vertical, axisIndex) {\n    var axisName = options.name;\n    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n    var tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;\n    var axisOptions = deepExtend({\n      reverse: !vertical && this.chartService.rtl\n    }, options, {\n      vertical: vertical\n    });\n    var isLog = equalsIgnoreCase(axisOptions.type, LOGARITHMIC);\n    var defaultRange = tracker.query();\n    var defaultAxisRange = isLog ? {\n      min: 0.1,\n      max: 1\n    } : {\n      min: 0,\n      max: 1\n    };\n    var range = tracker.query(axisName) || defaultRange || defaultAxisRange;\n    var typeSamples = [axisOptions.min, axisOptions.max];\n    var series = this.series;\n\n    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      var currentSeries = series[seriesIx];\n      var seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n\n      if (seriesAxisName === axisOptions.name || axisIndex === 0 && !seriesAxisName) {\n        var firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n        typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n        break;\n      }\n    }\n\n    if (axisIndex === 0 && defaultRange) {\n      range.min = Math.min(range.min, defaultRange.min);\n      range.max = Math.max(range.max, defaultRange.max);\n    }\n\n    var inferredDate;\n\n    for (var i = 0; i < typeSamples.length; i++) {\n      if (typeSamples[i] instanceof Date) {\n        inferredDate = true;\n        break;\n      }\n    }\n\n    var axisType;\n\n    if (equalsIgnoreCase(axisOptions.type, DATE) || !axisOptions.type && inferredDate) {\n      axisType = DateValueAxis;\n    } else if (isLog) {\n      axisType = LogarithmicAxis;\n    } else {\n      axisType = NumericAxis;\n    }\n\n    var axis = new axisType(range.min, range.max, axisOptions, this.chartService);\n    axis.axisIndex = axisIndex;\n\n    if (axisName) {\n      if (namedAxes[axisName]) {\n        throw new Error((vertical ? \"Y\" : \"X\") + \" axis with name \" + axisName + \" is already defined\");\n      }\n\n      namedAxes[axisName] = axis;\n    }\n\n    this.appendAxis(axis);\n    return axis;\n  };\n\n  XYPlotArea.prototype.createAxes = function createAxes(panes) {\n    var this$1 = this;\n    var options = this.options;\n    var xAxesOptions = [].concat(options.xAxis);\n    var xAxes = [];\n    var yAxesOptions = [].concat(options.yAxis);\n    var yAxes = [];\n\n    for (var idx = 0; idx < xAxesOptions.length; idx++) {\n      var axisPane = this$1.findPane(xAxesOptions[idx].pane);\n\n      if (inArray(axisPane, panes)) {\n        xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));\n      }\n    }\n\n    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {\n      var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);\n\n      if (inArray(axisPane$1, panes)) {\n        yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));\n      }\n    }\n\n    this.axisX = this.axisX || xAxes[0];\n    this.axisY = this.axisY || yAxes[0];\n  };\n\n  XYPlotArea.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {\n    var coords = chart._eventCoordinates(e);\n\n    var point = new Point(coords.x, coords.y);\n    var allAxes = this.axes;\n    var length = allAxes.length;\n    var xValues = [];\n    var yValues = [];\n\n    for (var i = 0; i < length; i++) {\n      var axis = allAxes[i];\n      var values = axis.options.vertical ? yValues : xValues;\n      var currentValue = axis.getValue(point);\n\n      if (currentValue !== null) {\n        values.push(currentValue);\n      }\n    }\n\n    if (xValues.length > 0 && yValues.length > 0) {\n      chart.trigger(eventType, {\n        element: eventElement(e),\n        originalEvent: e,\n        x: singleItemOrArray(xValues),\n        y: singleItemOrArray(yValues)\n      });\n    }\n  };\n\n  XYPlotArea.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options) {\n    var vertical = axis.options.vertical;\n    var axes = this.groupAxes(this.panes);\n    var index = (vertical ? axes.y : axes.x).indexOf(axis);\n    updateAxisOptions(this.options, index, vertical, options);\n    updateAxisOptions(this.originalOptions, index, vertical, options);\n  };\n\n  return XYPlotArea;\n}(PlotAreaBase);\n\nfunction updateAxisOptions(targetOptions, axisIndex, vertical, options) {\n  var axisOptions = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];\n  deepExtend(axisOptions, options);\n}\n\nsetDefaultOptions(XYPlotArea, {\n  xAxis: {},\n  yAxis: {}\n});\ndeepExtend(XYPlotArea.prototype, PlotAreaEventsMixin);\nexport default XYPlotArea;","map":null,"metadata":{},"sourceType":"module"}