{"ast":null,"code":"import { createTemplate, measureElementRect, logBase, removeElement } from '../utils/helper';\nimport { ChartLocation, stringToNumber, appendElement, withIn } from '../utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { getPoint } from '../utils/helper';\nimport { createElement, updateBlazorTemplate } from '@syncfusion/ej2-base';\nimport { annotationRender } from '../model/constants';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * Annotation Module handles the Annotation for chart and accumulation series.\n */\n\nvar AnnotationBase =\n/** @class */\nfunction () {\n  /**\n   * Constructor for chart and accumulation annotation\n   * @param control\n   */\n  function AnnotationBase(control) {\n    this.control = control;\n  }\n  /**\n   * Method to render the annotation for chart and accumulation series.\n   * @private\n   * @param annotation\n   * @param index\n   */\n\n\n  AnnotationBase.prototype.render = function (annotation, index) {\n    this.isChart = this.control.getModuleName() === 'chart';\n    this.annotation = annotation;\n    var childElement = createTemplate(createElement('div', {\n      id: this.control.element.id + '_Annotation_' + index,\n      styles: 'position: absolute;'\n    }), index, annotation.content, this.control);\n    return childElement;\n  };\n  /**\n   * Method to calculate the location for annotation - coordinate unit as pixel.\n   * @private\n   * @param location\n   */\n\n\n  AnnotationBase.prototype.setAnnotationPixelValue = function (location) {\n    var rect;\n    rect = this.annotation.region === 'Chart' ? new Rect(0, 0, this.control.availableSize.width, this.control.availableSize.height) : this.isChart ? this.control.chartAxisLayoutPanel.seriesClipRect : this.control.series[0].accumulationBound;\n    location.x = (typeof this.annotation.x !== 'string' ? typeof this.annotation.x === 'number' ? this.annotation.x : 0 : stringToNumber(this.annotation.x, rect.width)) + rect.x;\n    location.y = (typeof this.annotation.y === 'number' ? this.annotation.y : stringToNumber(this.annotation.y, rect.height)) + rect.y;\n    return true;\n  };\n  /**\n   * Method to calculate the location for annotation - coordinate unit as point.\n   * @private\n   * @param location\n   */\n\n\n  AnnotationBase.prototype.setAnnotationPointValue = function (location) {\n    var symbolLocation = new ChartLocation(0, 0);\n\n    if (this.isChart) {\n      var xAxis = void 0;\n      var yAxis = void 0;\n      var chart = this.control;\n      var annotation = this.annotation;\n      var xValue = void 0;\n      var isLog = false;\n      var xAxisName = annotation.xAxisName;\n      var yAxisName = annotation.yAxisName;\n      var isInverted = chart.requireInvertedAxis;\n\n      for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n        var axis = _a[_i];\n\n        if (xAxisName === axis.name || xAxisName == null && axis.name === 'primaryXAxis') {\n          xAxis = axis;\n\n          if (xAxis.valueType.indexOf('Category') > -1) {\n            var xAnnotation = xAxis.valueType === 'DateTimeCategory' ? annotation.x.getTime().toString() : annotation.x;\n\n            if (xAxis.labels.indexOf(xAnnotation) < 0) {\n              return false;\n            } else {\n              xValue = xAxis.labels.indexOf(xAnnotation);\n            }\n          } else if (xAxis.valueType === 'DateTime') {\n            var option = {\n              skeleton: 'full',\n              type: 'dateTime'\n            };\n            xValue = typeof this.annotation.x === 'object' ? Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({\n              val: annotation.x\n            }).val)))) : 0;\n          } else {\n            xValue = +annotation.x;\n          }\n        } else if (yAxisName === axis.name || yAxisName == null && axis.name === 'primaryYAxis') {\n          yAxis = axis;\n          isLog = yAxis.valueType === 'Logarithmic';\n        }\n      }\n\n      if (xAxis && yAxis && withIn(xAxis.valueType === 'Logarithmic' ? logBase(xValue, xAxis.logBase) : xValue, xAxis.visibleRange) && withIn(yAxis.valueType === 'Logarithmic' ? logBase(+annotation.y, yAxis.logBase) : +annotation.y, yAxis.visibleRange)) {\n        symbolLocation = getPoint(xValue, +annotation.y, xAxis, yAxis, isInverted);\n        location.x = symbolLocation.x + (isInverted ? yAxis.rect.x : xAxis.rect.x);\n        location.y = symbolLocation.y + (isInverted ? xAxis.rect.y : yAxis.rect.y);\n      } else {\n        return false;\n      }\n\n      return true;\n    } else {\n      return this.setAccumulationPointValue(location);\n    }\n  };\n  /**\n   * To process the annotation for accumulation chart\n   * @param annotation\n   * @param index\n   * @param parentElement\n   */\n\n\n  AnnotationBase.prototype.processAnnotation = function (annotation, index, parentElement) {\n    var annotationElement;\n    var location;\n    location = new ChartLocation(0, 0);\n    annotationElement = this.render(annotation, index);\n\n    if (this['setAnnotation' + annotation.coordinateUnits + 'Value'](location)) {\n      this.setElementStyle(location, annotationElement, parentElement);\n    } else if (this.control.redraw) {\n      removeElement(annotationElement.id);\n    }\n\n    updateBlazorTemplate(this.control.element.id + 'Annotation' + index, 'ContentTemplate', this.control.annotations[index]);\n  };\n  /**\n   * Method to calculate the location for annotation - coordinate unit as point in accumulation chart.\n   * @private\n   * @param location\n   */\n\n\n  AnnotationBase.prototype.setAccumulationPointValue = function (location) {\n    var accumulation = this.control;\n    var point;\n\n    for (var _i = 0, _a = accumulation.visibleSeries[0].points; _i < _a.length; _i++) {\n      var accPoint = _a[_i];\n\n      if (typeof accPoint.x === 'object') {\n        if (Date.parse(accPoint.x) === Date.parse(this.annotation.x) && // tslint:disable-next-line    \n        accPoint.y == this.annotation.y) {\n          point = accPoint;\n          break;\n        }\n      } else {\n        // tslint:disable-next-line\n        if (accPoint.x == this.annotation.x && accPoint.y == this.annotation.y) {\n          point = accPoint;\n          break;\n        }\n      }\n    }\n\n    if (point && point.visible) {\n      location.x = point.symbolLocation.x;\n      location.y = point.symbolLocation.y;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * Method to set the element style for accumulation / chart annotation.\n   * @private\n   * @param location\n   * @param element\n   * @param parentElement\n   */\n\n\n  AnnotationBase.prototype.setElementStyle = function (location, element, parentElement) {\n    var elementRect = measureElementRect(element, this.control.redraw);\n    var argsData = {\n      cancel: false,\n      name: annotationRender,\n      content: element,\n      location: location\n    };\n    this.control.trigger(annotationRender, argsData);\n\n    if (!argsData.cancel) {\n      argsData.content.style.left = this.setAlignmentValue(this.annotation.horizontalAlignment, elementRect.width, argsData.location.x) + 'px';\n      argsData.content.style.top = this.setAlignmentValue(this.annotation.verticalAlignment, elementRect.height, argsData.location.y) + 'px';\n      argsData.content.setAttribute('aria-label', this.annotation.description || 'Annotation');\n      appendElement(argsData.content, parentElement, this.control.redraw, true, 'left', 'top');\n    }\n  };\n  /**\n   * Method to calculate the alignment value for annotation.\n   * @private\n   * @param alignment\n   * @param size\n   * @param value\n   */\n\n\n  AnnotationBase.prototype.setAlignmentValue = function (alignment, size, value) {\n    switch (alignment) {\n      case 'Top':\n      case 'Near':\n        value -= size;\n        break;\n\n      case 'Bottom':\n      case 'Far':\n        value += 0;\n        break;\n\n      case 'Middle':\n      case 'Center':\n        value -= size / 2;\n        break;\n    }\n\n    return value;\n  };\n\n  return AnnotationBase;\n}();\n\nexport { AnnotationBase };","map":null,"metadata":{},"sourceType":"module"}