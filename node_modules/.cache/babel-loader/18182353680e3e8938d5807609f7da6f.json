{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-react-chart\n * Generated: 2019-09-16\n * Version: 2.0.5\n * License: https://js.devexpress.com/Licensing\n */\nimport { createElement, PureComponent, createRef, Component, isValidElement, Fragment } from 'react';\nimport { Plugin, Getter, Template, TemplatePlaceholder, TemplateConnector, Sizer, createStateHelper, Action, withComponents, PluginHost, clearSelection } from '@devexpress/dx-react-core';\nimport { defaultDomains, buildScales, scaleSeriesPoints, TOP, LEFT, RIGHT, BOTTOM, bBoxes, getRanges, getLegendItems, findSeriesByName, ARGUMENT_DOMAIN, getValueDomainName, addSeries, extendDomains, addDomain, getStackedDomains, getStackedSeries, buildAnimatedStyleGetter, HOVERED, SELECTED, getAreaAnimationStyle, dRotateArea, dArea, getAreaPointTransformer, createAreaHitTester, dBar, getVisibility, adjustBarSize, getBarPointTransformer, createBarHitTester, dRotateLine, dLine, getLinePointTransformer, createLineHitTester, dPie, getPieAnimationStyle, getPiePointTransformer, createPieHitTester, dSymbol, getScatterAnimationStyle, getScatterPointTransformer, createScatterHitTester, dRotateSpline, dSpline, createSplineHitTester, isValidPosition, getTickCoordinates, tickCoordinatesGetter, gridCoordinatesGetter, getRotatedPosition, processHandleTooltip, getParameters, createReference, getOffset as getOffset$1, getEventCoords, isKeyPressed, setCursorType, isMultiTouch, getDeltaForTouches, getRect, getViewport, getWheelDelta, detachEvents, attachEvents, adjustLayout, buildEventHandlers, processPointerMove, changeSeriesState } from '@devexpress/dx-chart-core';\nimport { stackOffsetDiverging, stackOrderNone } from 'd3-shape';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\nvar series = [];\n\nvar getAnimatedStyle = function (style) {\n  return style;\n};\n\nvar BasicData = function (_a) {\n  var data = _a.data,\n      rotated = _a.rotated;\n  return createElement(Plugin, {\n    name: \"Basis\"\n  }, createElement(Getter, {\n    name: \"data\",\n    value: data\n  }), createElement(Getter, {\n    name: \"domains\",\n    value: defaultDomains\n  }), createElement(Getter, {\n    name: \"series\",\n    value: series\n  }), createElement(Getter, {\n    name: \"getAnimatedStyle\",\n    value: getAnimatedStyle\n  }), createElement(Getter, {\n    name: \"rotated\",\n    value: rotated\n  }));\n};\n\nvar getScales = function (_a) {\n  var domains = _a.domains,\n      ranges = _a.ranges;\n  return buildScales(domains, ranges);\n};\n\nvar getSeries = function (_a) {\n  var series = _a.series,\n      scales = _a.scales,\n      rotated = _a.rotated;\n  return scaleSeriesPoints(series, scales, rotated);\n};\n\nvar ChartCore =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ChartCore, _super);\n\n  function ChartCore() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ChartCore.prototype.render = function () {\n    return createElement(Plugin, null, createElement(Getter, {\n      name: \"scales\",\n      computed: getScales\n    }), createElement(Getter, {\n      name: \"series\",\n      computed: getSeries\n    }));\n  };\n\n  return ChartCore;\n}(PureComponent);\n\nvar AxesLayout = function () {\n  return createElement(Plugin, null, createElement(Template, {\n    name: \"canvas\"\n  }, createElement(\"div\", {\n    id: \"center-center\",\n    style: {\n      display: 'flex',\n      flexDirection: 'column',\n      flexGrow: 1\n    }\n  }, createElement(\"div\", {\n    id: TOP + \"-axis-container\",\n    style: {\n      display: 'flex',\n      flexDirection: 'row'\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: TOP + \"-\" + LEFT + \"-axis\"\n  }), createElement(TemplatePlaceholder, {\n    name: TOP + \"-axis\"\n  }), createElement(TemplatePlaceholder, {\n    name: TOP + \"-\" + RIGHT + \"-axis\"\n  })), createElement(\"div\", {\n    id: \"center-axis-container\",\n    style: {\n      display: 'flex',\n      flexDirection: 'row',\n      flexGrow: 1\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: LEFT + \"-axis\"\n  }), createElement(TemplatePlaceholder, null), createElement(TemplatePlaceholder, {\n    name: RIGHT + \"-axis\"\n  })), createElement(\"div\", {\n    id: BOTTOM + \"-axis-container\",\n    style: {\n      display: 'flex',\n      flexDirection: 'row'\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: BOTTOM + \"-\" + LEFT + \"-axis\"\n  }), createElement(TemplatePlaceholder, {\n    name: BOTTOM + \"-axis\"\n  }), createElement(TemplatePlaceholder, {\n    name: BOTTOM + \"-\" + RIGHT + \"-axis\"\n  })))));\n};\n\nvar SpaceFillingRects =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(SpaceFillingRects, _super);\n\n  function SpaceFillingRects() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SpaceFillingRects.prototype.render = function () {\n    var placeholders = this.props.placeholders;\n    return createElement(Plugin, {\n      name: \"SpaceFillingRects\"\n    }, placeholders.map(function (name) {\n      return createElement(Template, {\n        name: name,\n        key: name\n      }, createElement(TemplateConnector, null, function (_a) {\n        var layouts = _a.layouts;\n        var key = name.slice(name.indexOf('-') + 1);\n        var width = Object.keys(layouts).reduce(function (prev, cur) {\n          if (cur.includes(key)) {\n            return prev + layouts[cur].width;\n          }\n\n          return prev;\n        }, 0);\n        return createElement(\"div\", {\n          id: name,\n          style: {\n            width: width\n          }\n        });\n      }));\n    }));\n  };\n\n  return SpaceFillingRects;\n}(PureComponent);\n\nvar EXTRA_PIXELS = 2;\n\nvar ClipPath =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ClipPath, _super);\n\n  function ClipPath() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ClipPath.prototype.render = function () {\n    var _a = this.props,\n        id = _a.id,\n        width = _a.width,\n        height = _a.height;\n    return createElement(\"defs\", null, createElement(\"clipPath\", {\n      id: id\n    }, createElement(\"rect\", {\n      x: -EXTRA_PIXELS / 2,\n      y: -EXTRA_PIXELS / 2,\n      width: width + EXTRA_PIXELS,\n      height: height + EXTRA_PIXELS\n    })));\n  };\n\n  return ClipPath;\n}(PureComponent); // It is located in a separate file only for testing purpose -\n// it should actually be placed next to PaneLayout.\n\n\nvar UpdatableSizer =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(UpdatableSizer, _super);\n\n  function UpdatableSizer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.ref = createRef();\n    return _this;\n  }\n\n  UpdatableSizer.prototype.componentDidUpdate = function () {\n    this.ref.current.setupListeners();\n  };\n\n  UpdatableSizer.prototype.render = function () {\n    return createElement(Sizer, __assign({\n      ref: this.ref\n    }, this.props));\n  };\n\n  return UpdatableSizer;\n}(PureComponent);\n\nvar DIV_STYLE = {\n  flex: 1,\n  zIndex: 1,\n  position: 'relative',\n  width: '100%'\n};\nvar SVG_STYLE = {\n  position: 'absolute',\n  left: 0,\n  top: 0,\n  overflow: 'visible'\n};\n\nvar SizerContainer = function (_a) {\n  var children = _a.children;\n  return createElement(\"div\", {\n    style: DIV_STYLE\n  }, children);\n};\n\nvar numDefs = 0;\n\nvar getUniqueId = function () {\n  numDefs += 1;\n  return numDefs;\n};\n\nvar PaneLayout =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(PaneLayout, _super);\n\n  function PaneLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.ref = createRef();\n    _this.clipPathId = \"clip_path_\" + getUniqueId();\n    return _this;\n  }\n\n  PaneLayout.prototype.render = function () {\n    var _this = this;\n\n    return createElement(Plugin, {\n      name: \"PaneLayout\"\n    }, createElement(Getter, {\n      name: \"rootRef\",\n      value: this.ref\n    }), createElement(Getter, {\n      name: \"clipPathId\",\n      value: this.clipPathId\n    }), createElement(Template, {\n      name: \"canvas\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var layouts = _a.layouts;\n        var changeBBox = _b.changeBBox;\n        var _c = layouts.pane,\n            width = _c.width,\n            height = _c.height;\n        return createElement(UpdatableSizer, {\n          containerComponent: SizerContainer,\n          onSizeChange: function (size) {\n            return changeBBox({\n              placeholder: 'pane',\n              bBox: size\n            });\n          }\n        }, createElement(\"svg\", __assign({\n          ref: _this.ref\n        }, params, {\n          width: width,\n          height: height,\n          style: SVG_STYLE\n        }), createElement(ClipPath, {\n          id: _this.clipPathId,\n          width: width,\n          height: height\n        }), createElement(TemplatePlaceholder, {\n          name: \"series\"\n        })));\n      });\n    }));\n  };\n\n  return PaneLayout;\n}(PureComponent);\n\nvar doGetRanges = function (_a) {\n  var layouts = _a.layouts,\n      rotated = _a.rotated;\n  return getRanges(layouts.pane, rotated);\n};\n\nvar LayoutManager =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(LayoutManager, _super);\n\n  function LayoutManager(props) {\n    var _this = _super.call(this, props) || this;\n\n    var _a = _this.props,\n        width = _a.width,\n        height = _a.height;\n    _this.state = {\n      bBoxes: {\n        pane: {\n          width: width,\n          height: height\n        }\n      }\n    };\n    var stateHelper = createStateHelper(_this);\n    _this.changeBBox = stateHelper.applyFieldReducer.bind(stateHelper, 'bBoxes', bBoxes);\n    return _this;\n  }\n\n  LayoutManager.prototype.render = function () {\n    var _a = this.props,\n        width = _a.width,\n        height = _a.height,\n        Root = _a.rootComponent,\n        restProps = __rest(_a, [\"width\", \"height\", \"rootComponent\"]);\n\n    var stateBBoxes = this.state.bBoxes;\n    return createElement(Plugin, null, createElement(Getter, {\n      name: \"layouts\",\n      value: stateBBoxes\n    }), createElement(Getter, {\n      name: \"ranges\",\n      computed: doGetRanges\n    }), createElement(Action, {\n      name: \"changeBBox\",\n      action: this.changeBBox\n    }), createElement(Template, {\n      name: \"root\"\n    }, createElement(Root, __assign({\n      width: width,\n      height: height\n    }, restProps), createElement(TemplatePlaceholder, {\n      name: \"canvas\"\n    }))));\n  };\n\n  LayoutManager.defaultProps = {\n    width: 0\n  };\n  return LayoutManager;\n}(Component);\n\nvar ComponentLayout = function () {\n  return createElement(Plugin, {\n    name: \"ComponentLayout\"\n  }, createElement(Template, {\n    name: \"canvas\"\n  }, createElement(\"div\", {\n    id: TOP + \"-container\",\n    style: {\n      display: 'flex',\n      flexDirection: 'row'\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: TOP + \"-\" + LEFT\n  }), createElement(TemplatePlaceholder, {\n    name: TOP\n  }), createElement(TemplatePlaceholder, {\n    name: TOP + \"-\" + RIGHT\n  })), createElement(\"div\", {\n    id: \"center-container\",\n    style: {\n      display: 'flex',\n      flexDirection: 'row',\n      flexGrow: 1\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: LEFT\n  }), createElement(TemplatePlaceholder, null), createElement(TemplatePlaceholder, {\n    name: RIGHT\n  })), createElement(\"div\", {\n    id: BOTTOM + \"-container\",\n    style: {\n      display: 'flex',\n      flexDirection: 'row'\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: BOTTOM + \"-\" + LEFT\n  }), createElement(TemplatePlaceholder, {\n    name: BOTTOM\n  }), createElement(TemplatePlaceholder, {\n    name: BOTTOM + \"-\" + RIGHT\n  }))));\n};\n\nvar PaletteBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(PaletteBase, _super);\n\n  function PaletteBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PaletteBase.prototype.render = function () {\n    var scheme = this.props.scheme;\n    return createElement(Plugin, {\n      name: \"Palette\"\n    }, createElement(Getter, {\n      name: \"palette\",\n      value: scheme\n    }));\n  };\n\n  return PaletteBase;\n}(PureComponent);\n\nvar Palette = PaletteBase;\n\nvar Root =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Root, _super);\n\n  function Root() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Root.prototype.render = function () {\n    var _a = this.props,\n        children = _a.children,\n        width = _a.width,\n        height = _a.height,\n        style = _a.style,\n        restProps = __rest(_a, [\"children\", \"width\", \"height\", \"style\"]);\n\n    return createElement(\"div\", __assign({\n      style: __assign(__assign(__assign({}, style), {\n        height: height + \"px\"\n      }), width ? {\n        width: width + \"px\"\n      } : null)\n    }, restProps), children);\n  };\n\n  return Root;\n}(PureComponent);\n\nvar Label =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Label, _super);\n\n  function Label() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Label.prototype.render = function () {\n    return createElement(\"text\", __assign({}, this.props));\n  };\n\n  return Label;\n}(PureComponent);\n\nvar scheme = [];\nvar placeholders = [TOP + \"-\" + LEFT, TOP + \"-\" + RIGHT, BOTTOM + \"-\" + LEFT, BOTTOM + \"-\" + RIGHT, TOP + \"-\" + LEFT + \"-axis\", TOP + \"-\" + RIGHT + \"-axis\", BOTTOM + \"-\" + LEFT + \"-axis\", BOTTOM + \"-\" + RIGHT + \"-axis\"];\n\nvar RawChart =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RawChart, _super);\n\n  function RawChart() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RawChart.prototype.render = function () {\n    var _a = this.props,\n        data = _a.data,\n        width = _a.width,\n        height = _a.height,\n        children = _a.children,\n        rotated = _a.rotated,\n        rootComponent = _a.rootComponent,\n        restProps = __rest(_a, [\"data\", \"width\", \"height\", \"children\", \"rotated\", \"rootComponent\"]);\n\n    return createElement(PluginHost, null, createElement(BasicData, {\n      data: data,\n      rotated: rotated\n    }), createElement(Palette, {\n      scheme: scheme\n    }), createElement(LayoutManager, __assign({\n      width: width,\n      height: height,\n      rootComponent: rootComponent\n    }, restProps)), createElement(PaneLayout, null), createElement(AxesLayout, null), createElement(ComponentLayout, null), createElement(SpaceFillingRects, {\n      placeholders: placeholders\n    }), children, createElement(ChartCore, null));\n  };\n\n  RawChart.defaultProps = {\n    height: 500,\n    rotated: false\n  };\n  RawChart.components = {\n    rootComponent: 'Root'\n  };\n  return RawChart;\n}(PureComponent);\n\nvar Chart = withComponents({\n  Root: Root\n})(RawChart);\nChart.Label = Label;\n\nvar Marker =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Marker, _super);\n\n  function Marker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Marker.prototype.render = function () {\n    var _a = this.props,\n        color = _a.color,\n        restProps = __rest(_a, [\"color\"]);\n\n    return createElement(\"svg\", __assign({\n      fill: color,\n      width: \"10\",\n      height: \"10\"\n    }, restProps), createElement(\"circle\", __assign({\n      r: 5,\n      cx: 5,\n      cy: 5\n    }, restProps)));\n  };\n\n  return Marker;\n}(PureComponent);\n\nvar RawLegend =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RawLegend, _super);\n\n  function RawLegend() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RawLegend.prototype.render = function () {\n    var _a = this.props,\n        MarkerComponent = _a.markerComponent,\n        Label = _a.labelComponent,\n        Root = _a.rootComponent,\n        Item = _a.itemComponent,\n        position = _a.position,\n        getItems = _a.getItems;\n    var placeholder = position;\n    return createElement(Plugin, {\n      name: \"Legend\"\n    }, createElement(Template, {\n      name: placeholder\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (getters) {\n      return createElement(Root, {\n        name: \"legend-\" + placeholder\n      }, getItems(getters).map(function (_a) {\n        var text = _a.text,\n            color = _a.color;\n        return createElement(Item, {\n          key: text\n        }, createElement(MarkerComponent, {\n          name: text,\n          color: color\n        }), createElement(Label, {\n          text: text\n        }));\n      }));\n    })));\n  };\n\n  RawLegend.defaultProps = {\n    position: 'right',\n    getItems: function (_a) {\n      var series = _a.series;\n      return getLegendItems(series);\n    }\n  };\n  RawLegend.components = {\n    rootComponent: 'Root',\n    itemComponent: 'Item',\n    markerComponent: 'Marker',\n    labelComponent: 'Label'\n  };\n  return RawLegend;\n}(PureComponent);\n\nvar Legend = withComponents({\n  Marker: Marker\n})(RawLegend);\n\nvar TitleBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TitleBase, _super);\n\n  function TitleBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TitleBase.prototype.render = function () {\n    var _a = this.props,\n        Text = _a.textComponent,\n        text = _a.text,\n        position = _a.position;\n    var placeholder = position;\n    return createElement(Plugin, {\n      name: \"Title\"\n    }, createElement(Template, {\n      name: placeholder\n    }, createElement(TemplatePlaceholder, null), createElement(Text, {\n      text: text\n    })));\n  };\n\n  TitleBase.components = {\n    textComponent: 'Text'\n  };\n  TitleBase.defaultProps = {\n    position: 'top'\n  };\n  return TitleBase;\n}(PureComponent);\n\nvar Title = TitleBase;\n/** @internal */\n\nvar declareSeries = function (pluginName, _a) {\n  var components = _a.components,\n      getPointTransformer = _a.getPointTransformer,\n      createHitTester = _a.createHitTester;\n\n  var Component =\n  /*#__PURE__*/\n  function (_super) {\n    __extends(Component, _super);\n\n    function Component() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    Component.prototype.render = function () {\n      var _a = this.props,\n          name = _a.name,\n          argumentField = _a.argumentField,\n          valueField = _a.valueField,\n          scaleName = _a.scaleName,\n          seriesComponent = _a.seriesComponent,\n          pointComponent = _a.pointComponent,\n          color = _a.color,\n          restProps = __rest(_a, [\"name\", \"argumentField\", \"valueField\", \"scaleName\", \"seriesComponent\", \"pointComponent\", \"color\"]);\n\n      var symbolName = Symbol(name);\n\n      var seriesItem = __assign(__assign({\n        getPointTransformer: getPointTransformer,\n        createHitTester: createHitTester\n      }, this.props), {\n        symbolName: symbolName\n      });\n\n      var getSeries = function (_a) {\n        var series = _a.series,\n            data = _a.data,\n            palette = _a.palette;\n        return addSeries(series, data, palette, seriesItem, restProps);\n      };\n\n      var getDomains = function (_a) {\n        var series = _a.series,\n            domains = _a.domains;\n        return extendDomains(domains, findSeriesByName(symbolName, series));\n      };\n\n      return createElement(Plugin, {\n        name: pluginName\n      }, createElement(Getter, {\n        name: \"series\",\n        computed: getSeries\n      }), createElement(Getter, {\n        name: \"domains\",\n        computed: getDomains\n      }), createElement(Template, {\n        name: \"series\"\n      }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a) {\n        var series = _a.series,\n            scales = _a.scales,\n            getAnimatedStyle = _a.getAnimatedStyle,\n            rotated = _a.rotated,\n            layouts = _a.layouts,\n            clipPathId = _a.clipPathId;\n        var currentSeries = findSeriesByName(symbolName, series);\n        var argScale = scales[ARGUMENT_DOMAIN];\n        var valScale = scales[getValueDomainName(currentSeries.scaleName)]; // TODO_THIS: This code is expected to be removed when frame animation is used.\n\n        var currentScales = {\n          xScale: rotated ? valScale : argScale,\n          yScale: rotated ? argScale : valScale\n        };\n        var Path = currentSeries.seriesComponent;\n        return createElement(Path, {\n          index: currentSeries.index,\n          pointComponent: currentSeries.pointComponent,\n          coordinates: currentSeries.points,\n          rotated: rotated,\n          state: currentSeries.state,\n          color: currentSeries.color,\n          scales: currentScales,\n          getAnimatedStyle: getAnimatedStyle,\n          pane: layouts.pane,\n          clipPathId: clipPathId\n        });\n      })));\n    };\n\n    Component.defaultProps = {\n      name: 'defaultSeriesName'\n    };\n    return Component;\n  }(PureComponent);\n\n  Component.components = {};\n\n  if (components.Path) {\n    Component.components.seriesComponent = 'Path';\n  }\n\n  if (components.Point) {\n    Component.components.pointComponent = 'Point';\n  }\n\n  return withComponents(components)(Component);\n};\n/** @internal */\n\n\nvar withPatchedProps = function (patch) {\n  return function (Target) {\n    var Component =\n    /*#__PURE__*/\n    function (_super) {\n      __extends(Component, _super);\n\n      function Component() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      Component.prototype.render = function () {\n        var props = patch(this.props);\n        return createElement(Target, __assign({}, props));\n      };\n\n      Component.components = Target.components;\n      return Component;\n    }(PureComponent);\n\n    return Component;\n  };\n};\n/** @internal */\n\n\nvar Scale =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Scale, _super);\n\n  function Scale() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Scale.prototype.render = function () {\n    var _a = this.props,\n        name = _a.name,\n        factory = _a.factory,\n        modifyDomain = _a.modifyDomain;\n    var args = {\n      factory: factory,\n      modifyDomain: modifyDomain\n    };\n\n    var getDomains = function (_a) {\n      var domains = _a.domains;\n      return addDomain(domains, name, args);\n    };\n\n    return createElement(Plugin, {\n      name: \"Scale\"\n    }, createElement(Getter, {\n      name: \"domains\",\n      computed: getDomains\n    }));\n  };\n\n  return Scale;\n}(PureComponent);\n\nvar ArgumentScale = withPatchedProps(function (props) {\n  return __assign(__assign({}, props), {\n    name: ARGUMENT_DOMAIN\n  });\n})(Scale);\nvar ValueScale = withPatchedProps(function (props) {\n  return __assign(__assign({}, props), {\n    name: getValueDomainName(props.name)\n  });\n})(Scale);\n\nvar getDomains = function (_a) {\n  var domains = _a.domains,\n      series = _a.series;\n  return getStackedDomains(domains, series);\n};\n\nvar StackBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(StackBase, _super);\n\n  function StackBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  StackBase.prototype.render = function () {\n    var _a = this.props,\n        stacks = _a.stacks,\n        offset = _a.offset,\n        order = _a.order;\n    var params = {\n      stacks: stacks,\n      offset: offset,\n      order: order\n    };\n\n    var getSeries = function (_a) {\n      var series = _a.series,\n          data = _a.data;\n      return getStackedSeries(series, data, params);\n    };\n\n    return createElement(Plugin, {\n      name: \"Stack\"\n    }, createElement(Getter, {\n      name: \"series\",\n      computed: getSeries\n    }), createElement(Getter, {\n      name: \"domains\",\n      computed: getDomains\n    }));\n  };\n\n  StackBase.defaultProps = {\n    stacks: [],\n    offset: stackOffsetDiverging,\n    order: stackOrderNone\n  };\n  return StackBase;\n}(PureComponent);\n\nvar Stack = StackBase;\n\nvar getBuildAnimatedStyle = function (_a) {\n  var rotated = _a.rotated;\n  return buildAnimatedStyleGetter(rotated);\n};\n\nvar AnimationBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(AnimationBase, _super);\n\n  function AnimationBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AnimationBase.prototype.render = function () {\n    return createElement(Plugin, {\n      name: \"Animation\"\n    }, createElement(Getter, {\n      name: \"getAnimatedStyle\",\n      computed: getBuildAnimatedStyle\n    }));\n  };\n\n  return AnimationBase;\n}(PureComponent);\n\nvar Animation = AnimationBase;\n\nvar withStates = function (states) {\n  return function (Component) {\n    var ComponentWithStates =\n    /*#__PURE__*/\n    function (_super) {\n      __extends(ComponentWithStates, _super);\n\n      function ComponentWithStates() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      ComponentWithStates.prototype.render = function () {\n        var _a = this.props,\n            state = _a.state,\n            restProps = __rest(_a, [\"state\"]);\n\n        var stateFunc = state && states[state];\n        var result = stateFunc ? stateFunc(restProps) : restProps;\n        return isValidElement(result) ? result : createElement(Component, __assign({}, result));\n      };\n\n      return ComponentWithStates;\n    }(PureComponent);\n\n    return ComponentWithStates;\n  };\n};\n\nvar Pattern =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Pattern, _super);\n\n  function Pattern() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Pattern.prototype.render = function () {\n    var _a = this.props,\n        id = _a.id,\n        size = _a.size,\n        color = _a.color,\n        opacity = _a.opacity;\n    return createElement(\"defs\", null, createElement(\"pattern\", {\n      id: id,\n      width: size,\n      height: size,\n      patternUnits: \"userSpaceOnUse\"\n    }, createElement(\"rect\", {\n      x: 0,\n      y: 0,\n      width: size,\n      height: size,\n      fill: color,\n      opacity: opacity\n    }), createElement(\"path\", {\n      // tslint:disable-next-line: max-line-length\n      d: \"M \" + size / 2 + \" \" + -size / 2 + \" L \" + -size / 2 + \" \" + size / 2 + \" M 0 \" + size + \" L \" + size + \" 0 M \" + size * 1.5 + \" \" + size / 2 + \" L \" + size / 2 + \" \" + size * 1.5,\n      strokeWidth: 2,\n      stroke: color\n    })));\n  };\n\n  Pattern.defaultProps = {\n    size: 6,\n    opacity: 0.75\n  };\n  return Pattern;\n}(PureComponent); // Function is returned (not PureComponent descendant) because\n// result is invoked as function (not as React component).\n\n\nvar withPattern = function (getPatternId, props) {\n  return function (Target) {\n    return function (targetProps) {\n      var color = targetProps.color,\n          restProps = __rest(targetProps, [\"color\"]);\n\n      var patternId = getPatternId(restProps);\n      return createElement(Fragment, null, createElement(Target, __assign({\n        color: \"url(#\" + patternId + \")\"\n      }, restProps)), createElement(Pattern, __assign({\n        id: patternId,\n        color: color\n      }, props)));\n    };\n  };\n};\n\nvar _a;\n\nvar RawArea =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RawArea, _super);\n\n  function RawArea() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RawArea.prototype.render = function () {\n    var _a = this.props,\n        path = _a.path,\n        coordinates = _a.coordinates,\n        index = _a.index,\n        state = _a.state,\n        pointComponent = _a.pointComponent,\n        color = _a.color,\n        clipPathId = _a.clipPathId,\n        style = _a.style,\n        scales = _a.scales,\n        getAnimatedStyle = _a.getAnimatedStyle,\n        rotated = _a.rotated,\n        restProps = __rest(_a, [\"path\", \"coordinates\", \"index\", \"state\", \"pointComponent\", \"color\", \"clipPathId\", \"style\", \"scales\", \"getAnimatedStyle\", \"rotated\"]);\n\n    var dPath = path === undefined ? rotated ? dRotateArea : dArea : path;\n    return createElement(\"path\", __assign({\n      clipPath: \"url(#\" + clipPathId + \")\",\n      d: dPath(coordinates),\n      fill: color,\n      opacity: 0.5,\n      style: getAnimatedStyle(style, getAreaAnimationStyle, scales)\n    }, restProps));\n  };\n\n  return RawArea;\n}(PureComponent); // It should actually be `withPattern<AreaSeries.PointProps>` but `opacity` is not decleared there.\n// It is not clear if `opacity` should be explicitly enumerated or stay as part of `restProps`.\n\n\nvar Area = withStates((_a = {}, _a[HOVERED] = withPattern(function (_a) {\n  var index = _a.index;\n  return \"series-\" + index + \"-hover\";\n}, {\n  opacity: 0.75\n})(RawArea), _a[SELECTED] = withPattern(function (_a) {\n  var index = _a.index;\n  return \"series-\" + index + \"-selection\";\n}, {\n  opacity: 0.5\n})(RawArea), _a))(RawArea); // tslint:disable-next-line: max-line-length\n\nvar AreaSeries = declareSeries('AreaSeries', {\n  getPointTransformer: getAreaPointTransformer,\n  createHitTester: createAreaHitTester,\n  components: {\n    Path: Area\n  }\n});\n/** @internal */\n\nvar PointCollection =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(PointCollection, _super);\n\n  function PointCollection() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PointCollection.prototype.render = function () {\n    var _a = this.props,\n        pointComponent = _a.pointComponent,\n        coordinates = _a.coordinates,\n        index = _a.index,\n        state = _a.state,\n        clipPathId = _a.clipPathId,\n        restProps = __rest(_a, [\"pointComponent\", \"coordinates\", \"index\", \"state\", \"clipPathId\"]) // restProps are used because of getAnimatedStyle and scale\n    ;\n\n    var Point = pointComponent;\n    return coordinates.map(function (point) {\n      return createElement(Point, __assign({\n        key: String(point.index),\n        seriesIndex: index\n      }, restProps, point));\n    });\n  };\n\n  return PointCollection;\n}(PureComponent);\n\nvar _a$1;\n\nvar RawBar =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RawBar, _super);\n\n  function RawBar() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RawBar.prototype.render = function () {\n    var _a = this.props,\n        arg = _a.arg,\n        val = _a.val,\n        startVal = _a.startVal,\n        barWidth = _a.barWidth,\n        maxBarWidth = _a.maxBarWidth,\n        argument = _a.argument,\n        value = _a.value,\n        seriesIndex = _a.seriesIndex,\n        index = _a.index,\n        state = _a.state,\n        rotated = _a.rotated,\n        color = _a.color,\n        pane = _a.pane,\n        style = _a.style,\n        scales = _a.scales,\n        getAnimatedStyle = _a.getAnimatedStyle,\n        restProps = __rest(_a, [\"arg\", \"val\", \"startVal\", \"barWidth\", \"maxBarWidth\", \"argument\", \"value\", \"seriesIndex\", \"index\", \"state\", \"rotated\", \"color\", \"pane\", \"style\", \"scales\", \"getAnimatedStyle\"]);\n\n    var width = barWidth * maxBarWidth;\n    var bar = dBar(arg, val, startVal, width, rotated);\n    var visibility = getVisibility(pane, bar.x + bar.width / 2, bar.y + bar.height, bar.width, bar.height);\n    var adjustedBar = visibility === 'visible' ? adjustBarSize(bar, pane) : bar;\n    return createElement(\"rect\", __assign({}, adjustedBar, {\n      fill: color,\n      visibility: visibility,\n      style: getAnimatedStyle(style, getAreaAnimationStyle, scales)\n    }, restProps));\n  };\n\n  return RawBar;\n}(PureComponent); // It should actually be `withPattern<BarSeries.PointProps>` but `opacity` is not decleared there.\n// It is not clear if `opacity` should be explicitly enumerated or stay as part of `restProps`.\n\n\nvar Bar = withStates((_a$1 = {}, _a$1[HOVERED] = withPattern(function (_a) {\n  var seriesIndex = _a.seriesIndex,\n      index = _a.index;\n  return \"series-\" + seriesIndex + \"-point-\" + index + \"-hover\";\n}, {\n  opacity: 0.75\n})(RawBar), _a$1[SELECTED] = withPattern(function (_a) {\n  var seriesIndex = _a.seriesIndex,\n      index = _a.index;\n  return \"series-\" + seriesIndex + \"-point-\" + index + \"-selection\";\n}, {\n  opacity: 0.5\n})(RawBar), _a$1))(RawBar); // tslint:disable-next-line: max-line-length\n\nvar BarSeries = declareSeries('BarSeries', {\n  getPointTransformer: getBarPointTransformer,\n  createHitTester: createBarHitTester,\n  components: {\n    Path: PointCollection,\n    Point: Bar\n  }\n});\nBarSeries.defaultProps = {\n  barWidth: 0.9\n};\n\nvar _a$2;\n\nvar RawPath =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RawPath, _super);\n\n  function RawPath() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RawPath.prototype.render = function () {\n    var _a = this.props,\n        path = _a.path,\n        coordinates = _a.coordinates,\n        rotated = _a.rotated,\n        index = _a.index,\n        state = _a.state,\n        pointComponent = _a.pointComponent,\n        color = _a.color,\n        clipPathId = _a.clipPathId,\n        style = _a.style,\n        scales = _a.scales,\n        getAnimatedStyle = _a.getAnimatedStyle,\n        restProps = __rest(_a, [\"path\", \"coordinates\", \"rotated\", \"index\", \"state\", \"pointComponent\", \"color\", \"clipPathId\", \"style\", \"scales\", \"getAnimatedStyle\"]);\n\n    return createElement(\"path\", __assign({\n      clipPath: \"url(#\" + clipPathId + \")\",\n      d: path(coordinates),\n      fill: \"none\",\n      strokeWidth: 2,\n      stroke: color,\n      style: getAnimatedStyle(style, getAreaAnimationStyle, scales)\n    }, restProps));\n  };\n\n  return RawPath;\n}(PureComponent);\n\nvar Path = withStates((_a$2 = {}, _a$2[HOVERED] = function (props) {\n  return __assign({\n    strokeWidth: 4\n  }, props);\n}, _a$2[SELECTED] = function (props) {\n  return __assign({\n    strokeWidth: 4\n  }, props);\n}, _a$2))(RawPath);\n\nvar Line =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Line, _super);\n\n  function Line() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Line.prototype.render = function () {\n    var _a = this.props,\n        rotated = _a.rotated,\n        path = _a.path;\n    var dPath = path === undefined ? rotated ? dRotateLine : dLine : path;\n    return createElement(Path, __assign({}, this.props, {\n      path: dPath\n    }));\n  };\n\n  return Line;\n}(PureComponent); // tslint:disable-next-line: max-line-length\n\n\nvar LineSeries = declareSeries('LineSeries', {\n  getPointTransformer: getLinePointTransformer,\n  createHitTester: createLineHitTester,\n  components: {\n    Path: Line\n  }\n});\n\nvar _a$3;\n\nvar RawSlice =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RawSlice, _super);\n\n  function RawSlice() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RawSlice.prototype.render = function () {\n    var _a = this.props,\n        x = _a.arg,\n        y = _a.val,\n        rotated = _a.rotated,\n        argument = _a.argument,\n        value = _a.value,\n        seriesIndex = _a.seriesIndex,\n        index = _a.index,\n        state = _a.state,\n        maxRadius = _a.maxRadius,\n        innerRadius = _a.innerRadius,\n        outerRadius = _a.outerRadius,\n        startAngle = _a.startAngle,\n        endAngle = _a.endAngle,\n        color = _a.color,\n        style = _a.style,\n        scales = _a.scales,\n        getAnimatedStyle = _a.getAnimatedStyle,\n        restProps = __rest(_a, [\"arg\", \"val\", \"rotated\", \"argument\", \"value\", \"seriesIndex\", \"index\", \"state\", \"maxRadius\", \"innerRadius\", \"outerRadius\", \"startAngle\", \"endAngle\", \"color\", \"style\", \"scales\", \"getAnimatedStyle\"]);\n\n    return createElement(\"g\", {\n      transform: \"translate(\" + x + \" \" + y + \")\"\n    }, createElement(\"path\", __assign({\n      d: dPie(this.props),\n      fill: color,\n      stroke: \"none\",\n      style: getAnimatedStyle(style, getPieAnimationStyle, scales, this.props)\n    }, restProps)));\n  };\n\n  return RawSlice;\n}(PureComponent); // It should actually be `withPattern<PieSeries.PointProps>` but `opacity` is not decleared there.\n// It is not clear if `opacity` should be explicitly enumerated or stay as part of `restProps`.\n\n\nvar Slice = withStates((_a$3 = {}, _a$3[HOVERED] = withPattern(function (_a) {\n  var seriesIndex = _a.seriesIndex,\n      index = _a.index;\n  return \"series-\" + seriesIndex + \"-point-\" + index + \"-hover\";\n}, {\n  opacity: 0.75\n})(RawSlice), _a$3[SELECTED] = withPattern(function (_a) {\n  var seriesIndex = _a.seriesIndex,\n      index = _a.index;\n  return \"series-\" + seriesIndex + \"-point-\" + index + \"-selection\";\n}, {\n  opacity: 0.5\n})(RawSlice), _a$3))(RawSlice); // tslint:disable-next-line: max-line-length\n\nvar PieSeries = declareSeries('PieSeries', {\n  getPointTransformer: getPiePointTransformer,\n  createHitTester: createPieHitTester,\n  components: {\n    Path: PointCollection,\n    Point: Slice\n  }\n});\nPieSeries.defaultProps = {\n  innerRadius: 0,\n  outerRadius: 1\n};\n\nvar _a$4;\n\nvar RawPoint =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RawPoint, _super);\n\n  function RawPoint() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RawPoint.prototype.render = function () {\n    var _a = this.props,\n        arg = _a.arg,\n        val = _a.val,\n        rotated = _a.rotated,\n        argument = _a.argument,\n        value = _a.value,\n        seriesIndex = _a.seriesIndex,\n        index = _a.index,\n        state = _a.state,\n        pointOptions = _a.point,\n        color = _a.color,\n        pane = _a.pane,\n        style = _a.style,\n        scales = _a.scales,\n        getAnimatedStyle = _a.getAnimatedStyle,\n        restProps = __rest(_a, [\"arg\", \"val\", \"rotated\", \"argument\", \"value\", \"seriesIndex\", \"index\", \"state\", \"point\", \"color\", \"pane\", \"style\", \"scales\", \"getAnimatedStyle\"]);\n\n    var x = rotated ? val : arg;\n    var y = rotated ? arg : val;\n    var visibility = getVisibility(pane, x, y, 0, 0);\n    return createElement(\"path\", __assign({\n      transform: \"translate(\" + x + \" \" + y + \")\",\n      d: dSymbol(pointOptions),\n      fill: color,\n      visibility: visibility,\n      stroke: \"none\",\n      style: getAnimatedStyle(style, getScatterAnimationStyle, scales)\n    }, restProps));\n  };\n\n  return RawPoint;\n}(PureComponent); // The expression is used to have 12 from 7 in default scenario\n// and to adjust hovered or selected size when custom *point.size* is defined.\n\n\nvar getAdjustedOptions = function (_a) {\n  var size = _a.size;\n  return {\n    size: Math.round(size * 1.7)\n  };\n};\n\nvar Point = withStates((_a$4 = {}, _a$4[HOVERED] = function (_a) {\n  var color = _a.color,\n      point = _a.point,\n      restProps = __rest(_a, [\"color\", \"point\"]);\n\n  return __assign({\n    stroke: color,\n    strokeWidth: 4,\n    fill: 'none',\n    point: getAdjustedOptions(point)\n  }, restProps);\n}, _a$4[SELECTED] = function (_a) {\n  var color = _a.color,\n      point = _a.point,\n      restProps = __rest(_a, [\"color\", \"point\"]);\n\n  return __assign({\n    stroke: color,\n    strokeWidth: 4,\n    fill: 'none',\n    point: getAdjustedOptions(point)\n  }, restProps);\n}, _a$4))(RawPoint); // tslint:disable-next-line: max-line-length\n\nvar ScatterSeries = declareSeries('ScatterSeries', {\n  getPointTransformer: getScatterPointTransformer,\n  createHitTester: createScatterHitTester,\n  components: {\n    Path: PointCollection,\n    Point: Point\n  }\n});\nScatterSeries.defaultProps = {\n  point: {\n    size: 7\n  }\n};\n\nvar Spline =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Spline, _super);\n\n  function Spline() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Spline.prototype.render = function () {\n    var _a = this.props,\n        rotated = _a.rotated,\n        path = _a.path;\n    var dPath = path === undefined ? rotated ? dRotateSpline : dSpline : path;\n    return createElement(Path, __assign({}, this.props, {\n      path: dPath\n    }));\n  };\n\n  return Spline;\n}(PureComponent); // tslint:disable-next-line: max-line-length\n\n\nvar SplineSeries = declareSeries('SplineSeries', {\n  getPointTransformer: getLinePointTransformer,\n  createHitTester: createSplineHitTester,\n  components: {\n    Path: Spline\n  }\n});\n\nvar getOffset = function (position) {\n  return position >= 0 ? 0 : -position;\n};\n\nvar getSize = function (position, delta) {\n  return position >= 0 ? position + delta : -position;\n};\n\nvar Root$1 =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Root, _super);\n\n  function Root(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.ref = createRef();\n    _this.state = {\n      x: 0,\n      y: 0\n    };\n    _this.adjust = _this.adjust.bind(_this);\n    return _this;\n  }\n\n  Root.prototype.componentDidMount = function () {\n    this.setState(this.adjust);\n  };\n\n  Root.prototype.componentDidUpdate = function () {\n    // *setState* is called unconditionally because PureComponent is expected to break the cycle.\n    this.setState(this.adjust);\n  }; // Since calculated state does not depend on current state non-callback version of *setState*\n  // might have been expected - it can't be done.\n  // Parent component (Axis) accesses its DOM content in *onSizeChange* handler. When\n  // this component is mounted parent is not yet - it crashes on DOM access.\n  // *setState* callback is invoked later then *componentDidMount* - by that time parent component\n  // is already mounted and can access its DOM.\n  // Because of it callback version of *setState* has to be used here.\n  // Can we rely on the fact that by the time of callback parent is mounted?\n  // For now we stick with it, but need to find a more solid solution.\n\n\n  Root.prototype.adjust = function (_, _a) {\n    var dx = _a.dx,\n        dy = _a.dy,\n        onSizeChange = _a.onSizeChange;\n    var bbox = this.ref.current.getBBox();\n    var width = dx ? bbox.width : getSize(bbox.x, bbox.width);\n    var height = dy ? bbox.height : getSize(bbox.y, bbox.height);\n    var x = dx ? 0 : getOffset(bbox.x);\n    var y = dy ? 0 : getOffset(bbox.y);\n    onSizeChange({\n      width: width,\n      height: height\n    });\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  Root.prototype.render = function () {\n    var _a = this.props,\n        children = _a.children,\n        onSizeChange = _a.onSizeChange,\n        dx = _a.dx,\n        dy = _a.dy,\n        restProps = __rest(_a, [\"children\", \"onSizeChange\", \"dx\", \"dy\"]);\n\n    var _b = this.state,\n        x = _b.x,\n        y = _b.y;\n    return createElement(\"g\", __assign({\n      ref: this.ref,\n      transform: \"translate(\" + x + \" \" + y + \")\"\n    }, restProps), children);\n  };\n\n  return Root;\n}(PureComponent);\n\nvar Label$1 =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Label, _super);\n\n  function Label() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Label.prototype.render = function () {\n    var _a = this.props,\n        text = _a.text,\n        restProps = __rest(_a, [\"text\"]);\n\n    return createElement(\"text\", __assign({}, restProps), text);\n  };\n\n  return Label;\n}(PureComponent);\n\nvar Line$1 =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Line, _super);\n\n  function Line() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Line.prototype.render = function () {\n    var _a = this.props,\n        x1 = _a.x1,\n        x2 = _a.x2,\n        y1 = _a.y1,\n        y2 = _a.y2,\n        restProps = __rest(_a, [\"x1\", \"x2\", \"y1\", \"y2\"]);\n\n    return createElement(\"path\", __assign({\n      d: \"M \" + x1 + \" \" + y1 + \" L \" + x2 + \" \" + y2\n    }, restProps));\n  };\n\n  return Line;\n}(PureComponent);\n\nvar SVG_STYLE$1 = {\n  position: 'absolute',\n  left: 0,\n  top: 0,\n  overflow: 'visible'\n};\n\nvar RawAxis =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RawAxis, _super);\n\n  function RawAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootRef = createRef();\n    _this.adjustedWidth = 0;\n    _this.adjustedHeight = 0;\n    return _this;\n  }\n\n  RawAxis.prototype.renderAxis = function (position) {\n    var _this = this;\n\n    var _a = this.props,\n        scaleName = _a.scaleName,\n        tickSize = _a.tickSize,\n        tickFormat = _a.tickFormat,\n        indentFromAxis = _a.indentFromAxis,\n        showTicks = _a.showTicks,\n        showLine = _a.showLine,\n        showLabels = _a.showLabels,\n        RootComponent = _a.rootComponent,\n        TickComponent = _a.tickComponent,\n        LabelComponent = _a.labelComponent,\n        LineComponent = _a.lineComponent;\n    var placeholder = position + \"-axis\";\n    var layoutName = placeholder + \"-\" + scaleName;\n    return createElement(Template, {\n      name: placeholder\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a, _b) {\n      var scales = _a.scales,\n          layouts = _a.layouts,\n          rotated = _a.rotated;\n      var changeBBox = _b.changeBBox;\n\n      if (!isValidPosition(position, scaleName, rotated)) {\n        return null;\n      }\n\n      var scale = scales[scaleName];\n\n      if (!scale) {\n        return null;\n      }\n\n      var _c = layouts[layoutName] || {\n        width: 0,\n        height: 0\n      },\n          width = _c.width,\n          height = _c.height;\n\n      var paneSize = layouts.pane;\n\n      var _d = getTickCoordinates({\n        callback: tickCoordinatesGetter,\n        scaleName: scaleName,\n        position: position,\n        tickSize: tickSize,\n        tickFormat: tickFormat,\n        indentFromAxis: indentFromAxis,\n        scale: scale,\n        paneSize: [paneSize.width, paneSize.height],\n        rotated: rotated\n      }),\n          _e = __read(_d.sides, 2),\n          dx = _e[0],\n          dy = _e[1],\n          ticks = _d.ticks;\n\n      var handleSizeChange = function (size) {\n        // The callback is called when DOM is available -\n        // *rootRef.current* can be surely accessed.\n        var rect = _this.rootRef.current.getBoundingClientRect();\n\n        var rectSize = [dx ? rect.width : size.width, dy ? rect.height : size.height];\n\n        if (rectSize[0] === _this.adjustedWidth && rectSize[1] === _this.adjustedHeight) {\n          return;\n        } // *setState* is not used because it would cause excessive Plugin rerenders.\n        // Template rerender is provided by *changeBBox* invocation.\n\n\n        _this.adjustedWidth = rectSize[0];\n        _this.adjustedHeight = rectSize[1];\n        changeBBox({\n          placeholder: layoutName,\n          bBox: size\n        });\n      };\n\n      return createElement(\"div\", {\n        style: {\n          position: 'relative',\n          width: dy * width || undefined,\n          height: dx * height || undefined,\n          flexGrow: dx || undefined\n        },\n        ref: _this.rootRef\n      }, createElement(\"svg\", {\n        width: _this.adjustedWidth,\n        height: _this.adjustedHeight,\n        style: SVG_STYLE$1\n      }, createElement(RootComponent, {\n        dx: dx,\n        dy: dy,\n        onSizeChange: handleSizeChange\n      }, showTicks && ticks.map(function (_a) {\n        var x1 = _a.x1,\n            x2 = _a.x2,\n            y1 = _a.y1,\n            y2 = _a.y2,\n            key = _a.key;\n        return createElement(TickComponent, {\n          key: key,\n          x1: x1,\n          x2: x2,\n          y1: y1,\n          y2: y2\n        });\n      }), showLine && createElement(LineComponent, {\n        x1: 0,\n        x2: dx * paneSize.width,\n        y1: 0,\n        y2: dy * paneSize.height\n      }), showLabels && ticks.map(function (_a) {\n        var text = _a.text,\n            xText = _a.xText,\n            yText = _a.yText,\n            delta = _a.dy,\n            textAnchor = _a.textAnchor,\n            key = _a.key;\n        return createElement(LabelComponent, {\n          key: key,\n          text: text,\n          x: xText,\n          y: yText,\n          dy: delta,\n          textAnchor: textAnchor\n        });\n      }))));\n    }));\n  };\n\n  RawAxis.prototype.renderGrid = function () {\n    var _a = this.props,\n        scaleName = _a.scaleName,\n        showGrid = _a.showGrid,\n        GridComponent = _a.gridComponent;\n    return createElement(Template, {\n      name: \"series\"\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a) {\n      var scales = _a.scales,\n          layouts = _a.layouts,\n          rotated = _a.rotated;\n      var scale = scales[scaleName];\n\n      if (!scale || !showGrid) {\n        return null;\n      }\n\n      var _b = layouts.pane,\n          width = _b.width,\n          height = _b.height;\n\n      var _c = getTickCoordinates({\n        callback: gridCoordinatesGetter,\n        scaleName: scaleName,\n        scale: scale,\n        paneSize: [width, height],\n        rotated: rotated\n      }),\n          ticks = _c.ticks,\n          _d = __read(_c.sides, 2),\n          dx = _d[0],\n          dy = _d[1];\n\n      return createElement(Fragment, null, ticks.map(function (_a) {\n        var key = _a.key,\n            x1 = _a.x1,\n            y1 = _a.y1;\n        return createElement(GridComponent, {\n          key: key,\n          x1: x1,\n          x2: x1 + dy * width,\n          y1: y1,\n          y2: y1 + dx * height\n        });\n      }));\n    }));\n  };\n\n  RawAxis.prototype.render = function () {\n    var position = this.props.position;\n    var rotatedPosition = getRotatedPosition(position); // We have to occupy two placeholders (one for default case and one for rotated case) because\n    // by now it is unknown if Chart is rotated or not.\n    // Only one of templates is rendered then, the other is discarded.\n\n    return createElement(Plugin, {\n      name: \"Axis\"\n    }, this.renderAxis(position), this.renderAxis(rotatedPosition), this.renderGrid());\n  };\n\n  RawAxis.components = {\n    rootComponent: 'Root',\n    tickComponent: 'Tick',\n    labelComponent: 'Label',\n    lineComponent: 'Line',\n    gridComponent: 'Grid'\n  };\n  RawAxis.defaultProps = {\n    tickSize: 5,\n    indentFromAxis: 10\n  };\n  return RawAxis;\n}(PureComponent);\n/** @internal */\n\n\nvar Axis = withComponents({\n  Label: Label$1,\n  Line: Line$1,\n  Root: Root$1,\n  Tick: Line$1,\n  Grid: Line$1\n})(RawAxis); // TODO: It is not axis who defines that argument is HORIZONTAL and value is VERTICAL.\n// TODO: *position* should not be *orientation* dependent -\n// if HORIZONTAL then TOP or BOTTOM, otherwise LEFT of RIGHT.\n// It should be domain dependent - something like AT_DOMAIN_START or AT_DOMAIN_END.\n\nvar ArgumentAxis = withPatchedProps(function (props) {\n  return __assign(__assign({\n    position: BOTTOM,\n    showGrid: false,\n    showTicks: true,\n    showLine: true,\n    showLabels: true\n  }, props), {\n    scaleName: ARGUMENT_DOMAIN\n  });\n})(Axis);\nvar ValueAxis = withPatchedProps(function (props) {\n  return __assign(__assign({\n    position: LEFT,\n    showGrid: true,\n    showTicks: false,\n    showLine: false,\n    showLabels: true\n  }, props), {\n    scaleName: getValueDomainName(props.scaleName)\n  });\n})(Axis);\n\nvar Target =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Target, _super);\n\n  function Target() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Target.prototype.render = function () {\n    var _a = this.props,\n        d = _a.d,\n        x = _a.x,\n        y = _a.y,\n        componentRef = _a.componentRef;\n    return createElement(\"path\", {\n      transform: \"translate(\" + x + \" \" + y + \")\",\n      fill: \"none\",\n      ref: componentRef,\n      d: d\n    });\n  };\n\n  return Target;\n}(PureComponent);\n\nvar dependencies = [{\n  name: 'EventTracker',\n  optional: true\n}];\n\nvar RawTooltip =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RawTooltip, _super);\n\n  function RawTooltip(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      target: props.targetItem || props.defaultTargetItem\n    };\n\n    var handlePointerMove = _this.handlePointerMove.bind(_this);\n\n    _this.getPointerMoveHandlers = function (_a) {\n      var _b = _a.pointerMoveHandlers,\n          pointerMoveHandlers = _b === void 0 ? [] : _b;\n      return __spread(pointerMoveHandlers, [handlePointerMove]);\n    };\n\n    return _this;\n  }\n\n  RawTooltip.getDerivedStateFromProps = function (props, state) {\n    return {\n      target: props.targetItem !== undefined ? props.targetItem : state.target\n    };\n  };\n\n  RawTooltip.prototype.handlePointerMove = function (_a) {\n    var targets = _a.targets;\n    this.setState(function (_a, _b) {\n      var currentTarget = _a.target;\n      var onTargetItemChange = _b.onTargetItemChange;\n      var target = processHandleTooltip(targets, currentTarget, onTargetItemChange);\n\n      if (target === undefined) {\n        return null;\n      }\n\n      return {\n        target: target\n      };\n    });\n  };\n\n  RawTooltip.prototype.render = function () {\n    var _a = this.props,\n        OverlayComponent = _a.overlayComponent,\n        ContentComponent = _a.contentComponent,\n        SheetComponent = _a.sheetComponent,\n        arrowComponent = _a.arrowComponent;\n    var target = this.state.target;\n    return createElement(Plugin, {\n      name: \"Tooltip\",\n      dependencies: dependencies\n    }, createElement(Getter, {\n      name: \"pointerMoveHandlers\",\n      computed: this.getPointerMoveHandlers\n    }), createElement(Template, {\n      name: \"series\"\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a) {\n      var series = _a.series,\n          rootRef = _a.rootRef,\n          rotated = _a.rotated;\n\n      if (!target) {\n        return null;\n      }\n\n      var _b = getParameters(series, target),\n          text = _b.text,\n          element = _b.element;\n\n      return createElement(OverlayComponent, {\n        key: \"\" + target.series + target.point,\n        target: createReference(element, rootRef),\n        rotated: rotated,\n        arrowComponent: arrowComponent\n      }, createElement(SheetComponent, null, createElement(ContentComponent, {\n        text: text,\n        targetItem: target\n      })));\n    })));\n  };\n\n  RawTooltip.components = {\n    overlayComponent: 'Overlay',\n    targetComponent: 'Target',\n    contentComponent: 'Content',\n    arrowComponent: 'Arrow',\n    sheetComponent: 'Sheet'\n  };\n  return RawTooltip;\n}(PureComponent);\n\nvar Tooltip = withComponents({\n  Target: Target\n})(RawTooltip);\n\nvar DragBox =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(DragBox, _super);\n\n  function DragBox() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DragBox.prototype.render = function () {\n    var _a = this.props,\n        rect = _a.rect,\n        restProps = __rest(_a, [\"rect\"]);\n\n    return createElement(\"rect\", __assign({\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    }, restProps));\n  };\n\n  return DragBox;\n}(PureComponent);\n\nvar events = {\n  wheel: {\n    func: 'onWheel'\n  },\n  mousedown: {\n    func: 'onStart',\n    extraEvents: ['mousemove', 'mouseup']\n  },\n  touchstart: {\n    func: 'onStart',\n    extraEvents: ['touchmove', 'touchend']\n  }\n};\n\nvar ZoomPanProvider =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ZoomPanProvider, _super);\n\n  function ZoomPanProvider() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ZoomPanProvider.prototype.componentDidMount = function () {\n    var _this = this;\n\n    this.svgElement = this.props.rootRef.current;\n    setCursorType(this.svgElement);\n    this.windowHandlers = Object.keys(events).reduce(function (prev, key) {\n      var _a, _b;\n\n      var extraEvents = events[key].extraEvents;\n\n      if (extraEvents) {\n        return __assign(__assign({}, prev), (_a = {}, _a[key] = (_b = {}, _b[extraEvents[0]] = function (event) {\n          _this.props.onMove(event);\n        }, _b[extraEvents[1]] = function (event) {\n          _this.props.onEnd(event);\n\n          setCursorType(_this.svgElement);\n          detachEvents(window, _this.windowHandlers[key]);\n        }, _b), _a));\n      }\n\n      return prev;\n    }, {});\n    this.handlers = Object.keys(events).reduce(function (prev, key) {\n      var _a;\n\n      return __assign(__assign({}, prev), (_a = {}, _a[key] = function (e) {\n        _this.props[events[key].func](e);\n\n        if (events[key].extraEvents) {\n          attachEvents(window, _this.windowHandlers[key]);\n        }\n      }, _a));\n    }, {});\n    attachEvents(this.svgElement, this.handlers);\n  };\n\n  ZoomPanProvider.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    detachEvents(this.svgElement, this.handlers);\n    Object.keys(this.windowHandlers).forEach(function (el) {\n      detachEvents(window, _this.windowHandlers[el]);\n    });\n  };\n\n  ZoomPanProvider.prototype.render = function () {\n    return null;\n  };\n\n  return ZoomPanProvider;\n}(PureComponent); // tslint:disable-next-line:max-classes-per-file\n\n\nvar ZoomAndPanBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ZoomAndPanBase, _super);\n\n  function ZoomAndPanBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.multiTouchDelta = null;\n    _this.lastCoordinates = null;\n    _this.rectOrigin = null;\n    _this.offset = [0, 0];\n    _this.state = {\n      viewport: props.viewport || props.defaultViewport,\n      rectBox: null\n    };\n    return _this;\n  }\n\n  ZoomAndPanBase.getDerivedStateFromProps = function (props, state) {\n    return {\n      viewport: props.viewport !== undefined ? props.viewport : state.viewport\n    };\n  };\n\n  ZoomAndPanBase.prototype.handleStart = function (zoomRegionKey, e) {\n    // Default browser behavior is prevented in \"move\" handler. It is not enough for IPad.\n    // Calling \"preventDefault\" here (on \"start\") works for IPad.\n    // Going further, since we have to call \"preventDefault\" on \"start\" we may try to get rid of\n    // \"preventDefault\" on move.\n    // TODO: Try to remove \"preventDefault\" from \"move\" handler.\n    e.preventDefault();\n    this.offset = getOffset$1(e.currentTarget);\n    var coords = getEventCoords(e, this.offset); // Rectangle mode should be canceled if \"zoomRegionKey\" is released during mouse movevent or\n    // not pressed when mouse is up. To do it access to \"event\" object is required in\n    // \"handleMove\" and \"handleEnd\".\n    // TODO: Provide rectangle mode canceling.\n\n    if (isKeyPressed(e, zoomRegionKey)) {\n      this.rectOrigin = coords;\n    } else {\n      setCursorType(e.currentTarget, 'grabbing');\n    }\n\n    if (isMultiTouch(e)) {\n      this.multiTouchDelta = getDeltaForTouches(e.touches).delta;\n    }\n\n    this.lastCoordinates = coords;\n  };\n\n  ZoomAndPanBase.prototype.handleMove = function (scales, rotated, e, pane) {\n    e.preventDefault();\n    clearSelection();\n\n    if (isMultiTouch(e)) {\n      var current = getDeltaForTouches(e.touches);\n      this.zoom(scales, rotated, current.delta - this.multiTouchDelta, current.center);\n      this.multiTouchDelta = current.delta;\n    } else {\n      this.scroll(scales, rotated, e, pane);\n    }\n  };\n\n  ZoomAndPanBase.prototype.scroll = function (scales, rotated, e, pane) {\n    var _this = this;\n\n    var coords = getEventCoords(e, this.offset);\n    var deltaX = coords[0] - this.lastCoordinates[0];\n    var deltaY = coords[1] - this.lastCoordinates[1];\n    this.lastCoordinates = coords;\n    this.setState(function (_a, _b) {\n      var viewport = _a.viewport;\n      var onViewportChange = _b.onViewportChange,\n          interactionWithArguments = _b.interactionWithArguments,\n          interactionWithValues = _b.interactionWithValues;\n\n      if (_this.rectOrigin) {\n        return {\n          rectBox: getRect(rotated, interactionWithArguments, interactionWithValues, _this.rectOrigin, coords, pane)\n        };\n      }\n\n      return getViewport(scales, rotated, [interactionWithArguments, interactionWithValues], 'pan', [-deltaX, -deltaY], null, null, viewport, onViewportChange);\n    });\n  };\n\n  ZoomAndPanBase.prototype.handleEnd = function (scales, rotated) {\n    var _this = this;\n\n    this.lastCoordinates = null;\n    this.multiTouchDelta = null;\n\n    if (this.rectOrigin) {\n      this.setState(function (_a, _b) {\n        var viewport = _a.viewport,\n            rectBox = _a.rectBox;\n        var onViewportChange = _b.onViewportChange,\n            interactionWithArguments = _b.interactionWithArguments,\n            interactionWithValues = _b.interactionWithValues;\n        _this.rectOrigin = null;\n        return __assign({\n          rectBox: null\n        }, getViewport(scales, rotated, [interactionWithArguments, interactionWithValues], 'zoom', null, null, [[rectBox.x, rectBox.x + rectBox.width], [rectBox.y, rectBox.y + rectBox.height]], viewport, onViewportChange));\n      });\n    }\n  };\n\n  ZoomAndPanBase.prototype.zoom = function (scales, rotated, delta, anchors) {\n    this.setState(function (_a, _b) {\n      var viewport = _a.viewport;\n      var onViewportChange = _b.onViewportChange,\n          interactionWithArguments = _b.interactionWithArguments,\n          interactionWithValues = _b.interactionWithValues;\n      return getViewport(scales, rotated, [interactionWithArguments, interactionWithValues], 'zoom', [delta, delta], anchors, null, viewport, onViewportChange);\n    });\n  };\n\n  ZoomAndPanBase.prototype.handleZoom = function (scales, rotated, e) {\n    e.preventDefault();\n    var center = getEventCoords(e, getOffset$1(e.currentTarget));\n    this.zoom(scales, rotated, getWheelDelta(e), center);\n  };\n\n  ZoomAndPanBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.state,\n        viewport = _a.viewport,\n        rectBox = _a.rectBox;\n    var _b = this.props,\n        DragBoxComponent = _b.dragBoxComponent,\n        zoomRegionKey = _b.zoomRegionKey;\n\n    var getAdjustedLayout = function (_a) {\n      var domains = _a.domains,\n          ranges = _a.ranges;\n      return adjustLayout(domains, ranges, viewport);\n    };\n\n    return createElement(Plugin, {\n      name: \"zoomAndPan\"\n    }, createElement(Getter, {\n      name: \"ranges\",\n      computed: getAdjustedLayout\n    }), createElement(Template, {\n      name: \"root\"\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a) {\n      var scales = _a.scales,\n          rotated = _a.rotated,\n          rootRef = _a.rootRef,\n          layouts = _a.layouts;\n      return createElement(ZoomPanProvider, {\n        rootRef: rootRef,\n        onWheel: function (e) {\n          return _this.handleZoom(scales, rotated, e);\n        },\n        onStart: function (e) {\n          return _this.handleStart(zoomRegionKey, e);\n        },\n        onMove: function (e) {\n          return _this.handleMove(scales, rotated, e, layouts.pane);\n        },\n        onEnd: function (e) {\n          return _this.handleEnd(scales, rotated);\n        }\n      });\n    })), createElement(Template, {\n      name: \"series\"\n    }, createElement(TemplatePlaceholder, null), rectBox ? createElement(DragBoxComponent, {\n      rect: rectBox\n    }) : null));\n  };\n\n  ZoomAndPanBase.components = {\n    dragBoxComponent: 'DragBox'\n  };\n  ZoomAndPanBase.defaultProps = {\n    interactionWithValues: 'none',\n    interactionWithArguments: 'both',\n    zoomRegionKey: 'shift'\n  };\n  return ZoomAndPanBase;\n}(PureComponent);\n\nvar ZoomAndPan = withComponents({\n  DragBox: DragBox\n})(ZoomAndPanBase);\n\nvar wrapToList = function (arg) {\n  return arg ? [arg] : [];\n};\n\nvar EVENT_NAME_TO_REACT_MAP = {\n  click: 'onClick',\n  mousemove: 'onMouseMove',\n  mouseleave: 'onMouseLeave',\n  touchstart: 'onTouchStart'\n}; // Translates event names from common space to React.\n// https://developer.mozilla.org/en-US/docs/Web/Events\n\nvar translateEventNames = function (handlers) {\n  var result = {};\n  Object.entries(handlers).forEach(function (_a) {\n    var _b = __read(_a, 2),\n        name = _b[0],\n        handler = _b[1];\n\n    result[EVENT_NAME_TO_REACT_MAP[name]] = handler;\n  });\n  return result;\n};\n\nvar EventTrackerBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(EventTrackerBase, _super);\n\n  function EventTrackerBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  EventTrackerBase.prototype.render = function () {\n    var _a = this.props,\n        onClick = _a.onClick,\n        onPointerMove = _a.onPointerMove;\n    return createElement(Plugin, {\n      name: \"EventTracker\"\n    }, createElement(Getter, {\n      name: \"clickHandlers\",\n      value: wrapToList(onClick)\n    }), createElement(Getter, {\n      name: \"pointerMoveHandlers\",\n      value: wrapToList(onPointerMove)\n    }), createElement(Template, {\n      name: \"canvas\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var series = _a.series,\n            clickHandlers = _a.clickHandlers,\n            pointerMoveHandlers = _a.pointerMoveHandlers;\n        var handlers = buildEventHandlers(series, {\n          clickHandlers: clickHandlers,\n          pointerMoveHandlers: pointerMoveHandlers\n        }); // TODO: Conflicts are still possible. Improve this code.\n\n        return createElement(TemplatePlaceholder, {\n          params: __assign(__assign({}, params), translateEventNames(handlers))\n        });\n      });\n    }));\n  };\n\n  return EventTrackerBase;\n}(PureComponent);\n\nvar EventTracker = EventTrackerBase;\nvar dependencies$1 = [{\n  name: 'EventTracker',\n  optional: true\n}];\n\nvar HoverStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(HoverStateBase, _super);\n\n  function HoverStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      hover: props.hover || props.defaultHover\n    };\n\n    var handlePointerMove = _this.handlePointerMove.bind(_this);\n\n    _this.getPointerMoveHandlers = function (_a) {\n      var _b = _a.pointerMoveHandlers,\n          pointerMoveHandlers = _b === void 0 ? [] : _b;\n      return __spread(pointerMoveHandlers, [handlePointerMove]);\n    };\n\n    return _this;\n  }\n\n  HoverStateBase.getDerivedStateFromProps = function (props, state) {\n    return {\n      hover: props.hover !== undefined ? props.hover : state.hover\n    };\n  };\n\n  HoverStateBase.prototype.handlePointerMove = function (_a) {\n    var targets = _a.targets;\n    this.setState(function (_a, _b) {\n      var currentTarget = _a.hover;\n      var onHoverChange = _b.onHoverChange;\n      var hover = processPointerMove(targets, currentTarget, onHoverChange);\n      return hover !== undefined ? {\n        hover: hover\n      } : null;\n    });\n  };\n\n  HoverStateBase.prototype.render = function () {\n    var hover = this.state.hover; // Function has to be recreated every time as there is no other way\n    // to notify that \"series\" is updated.\n\n    var targets = hover ? [hover] : [];\n\n    var getSeries = function (_a) {\n      var series = _a.series;\n      return changeSeriesState(series, targets, HOVERED);\n    };\n\n    return createElement(Plugin, {\n      name: \"HoverState\",\n      dependencies: dependencies$1\n    }, createElement(Getter, {\n      name: \"pointerMoveHandlers\",\n      computed: this.getPointerMoveHandlers\n    }), createElement(Getter, {\n      name: \"series\",\n      computed: getSeries\n    }));\n  };\n\n  return HoverStateBase;\n}(PureComponent);\n\nvar HoverState = HoverStateBase;\n\nvar SelectionStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(SelectionStateBase, _super);\n\n  function SelectionStateBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SelectionStateBase.prototype.render = function () {\n    var selection = this.props.selection;\n    var targets = selection || [];\n\n    var getSeries = function (_a) {\n      var series = _a.series;\n      return changeSeriesState(series, targets, SELECTED);\n    };\n\n    return createElement(Plugin, {\n      name: \"SelectionState\"\n    }, createElement(Getter, {\n      name: \"series\",\n      computed: getSeries\n    }));\n  };\n\n  return SelectionStateBase;\n}(PureComponent);\n\nvar SelectionState = SelectionStateBase;\nexport { Animation, AreaSeries, ArgumentAxis, ArgumentScale, Axis, BarSeries, Chart, EventTracker, HoverState, Legend, LineSeries, Palette, PieSeries, Scale, ScatterSeries, SelectionState, SplineSeries, Stack, Title, Tooltip, ValueAxis, ValueScale, ZoomAndPan, withPatchedProps };","map":null,"metadata":{},"sourceType":"module"}