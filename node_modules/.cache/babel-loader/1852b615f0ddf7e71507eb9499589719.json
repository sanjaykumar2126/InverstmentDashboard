{"ast":null,"code":"import { drawing as draw, Color } from '@progress/kendo-drawing';\nimport BarLabel from './bar-label';\nimport { BORDER_BRIGHTNESS, TOOLTIP_OFFSET } from '../constants';\nimport hasGradientOverlay from '../utils/has-gradient-overlay';\nimport { ChartElement, Point } from '../../core';\nimport PointEventsMixin from '../mixins/point-events-mixin';\nimport NoteMixin from '../mixins/note-mixin';\nimport { WHITE, LEFT, RIGHT, BOTTOM, TOP } from '../../common/constants';\nimport { alignPathToPixel, deepExtend, defined, getTemplate, valueOrDefault } from '../../common';\nvar BAR_ALIGN_MIN_WIDTH = 6;\n\nvar Bar = function (ChartElement) {\n  function Bar(value, options) {\n    ChartElement.call(this);\n    this.options = options;\n    this.color = options.color || WHITE;\n    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n    this.value = value;\n  }\n\n  if (ChartElement) Bar.__proto__ = ChartElement;\n  Bar.prototype = Object.create(ChartElement && ChartElement.prototype);\n  Bar.prototype.constructor = Bar;\n\n  Bar.prototype.render = function render() {\n    if (this._rendered) {\n      return;\n    }\n\n    this._rendered = true;\n    this.createLabel();\n    this.createNote();\n\n    if (this.errorBar) {\n      this.append(this.errorBar);\n    }\n  };\n\n  Bar.prototype.createLabel = function createLabel() {\n    var options = this.options;\n    var labels = options.labels;\n\n    if (labels.visible) {\n      var pointData = this.pointData();\n      var labelTemplate = getTemplate(labels);\n      var labelText;\n\n      if (labelTemplate) {\n        labelText = labelTemplate(pointData);\n      } else {\n        labelText = this.formatValue(labels.format);\n      }\n\n      this.label = new BarLabel(labelText, deepExtend({\n        vertical: options.vertical\n      }, labels), pointData);\n      this.append(this.label);\n    }\n  };\n\n  Bar.prototype.formatValue = function formatValue(format) {\n    return this.owner.formatPointValue(this, format);\n  };\n\n  Bar.prototype.reflow = function reflow(targetBox) {\n    var this$1 = this;\n    this.render();\n    var label = this.label;\n    this.box = targetBox;\n\n    if (label) {\n      label.options.aboveAxis = this.aboveAxis;\n      label.reflow(targetBox);\n    }\n\n    if (this.note) {\n      this.note.reflow(targetBox);\n    }\n\n    if (this.errorBars) {\n      for (var i = 0; i < this.errorBars.length; i++) {\n        this$1.errorBars[i].reflow(targetBox);\n      }\n    }\n  };\n\n  Bar.prototype.createVisual = function createVisual() {\n    var this$1 = this;\n    var ref = this;\n    var box = ref.box;\n    var options = ref.options;\n    var customVisual = options.visual;\n\n    if (this.visible !== false) {\n      ChartElement.prototype.createVisual.call(this);\n\n      if (customVisual) {\n        var visual = this.rectVisual = customVisual({\n          category: this.category,\n          dataItem: this.dataItem,\n          value: this.value,\n          sender: this.getSender(),\n          series: this.series,\n          percentage: this.percentage,\n          stackValue: this.stackValue,\n          runningTotal: this.runningTotal,\n          total: this.total,\n          rect: box.toRect(),\n          createVisual: function () {\n            var group = new draw.Group();\n            this$1.createRect(group);\n            return group;\n          },\n          options: options\n        });\n\n        if (visual) {\n          this.visual.append(visual);\n        }\n      } else if (box.width() > 0 && box.height() > 0) {\n        this.createRect(this.visual);\n      }\n    }\n  };\n\n  Bar.prototype.createRect = function createRect(visual) {\n    var options = this.options;\n    var border = options.border;\n    var strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;\n    var rect = this.box.toRect();\n    rect.size.width = Math.round(rect.size.width);\n    var path = this.rectVisual = draw.Path.fromRect(rect, {\n      fill: {\n        color: this.color,\n        opacity: options.opacity\n      },\n      stroke: {\n        color: this.getBorderColor(),\n        width: border.width,\n        opacity: strokeOpacity,\n        dashType: border.dashType\n      }\n    });\n    var width = this.box.width();\n    var height = this.box.height();\n    var size = options.vertical ? width : height;\n\n    if (size > BAR_ALIGN_MIN_WIDTH) {\n      alignPathToPixel(path); // Fixes lineJoin issue in firefox when the joined lines are parallel\n\n      if (width < 1 || height < 1) {\n        path.options.stroke.lineJoin = \"round\";\n      }\n    }\n\n    visual.append(path);\n\n    if (hasGradientOverlay(options)) {\n      var overlay = this.createGradientOverlay(path, {\n        baseColor: this.color\n      }, deepExtend({\n        end: !options.vertical ? [0, 1] : undefined\n      }, options.overlay));\n      visual.append(overlay);\n    }\n  };\n\n  Bar.prototype.createHighlight = function createHighlight(style) {\n    var highlight = draw.Path.fromRect(this.box.toRect(), style);\n    return alignPathToPixel(highlight);\n  };\n\n  Bar.prototype.highlightVisual = function highlightVisual() {\n    return this.rectVisual;\n  };\n\n  Bar.prototype.highlightVisualArgs = function highlightVisualArgs() {\n    return {\n      options: this.options,\n      rect: this.box.toRect(),\n      visual: this.rectVisual\n    };\n  };\n\n  Bar.prototype.getBorderColor = function getBorderColor() {\n    var color = this.color;\n    var border = this.options.border;\n    var brightness = border._brightness || BORDER_BRIGHTNESS;\n    var borderColor = border.color;\n\n    if (!defined(borderColor)) {\n      borderColor = new Color(color).brightness(brightness).toHex();\n    }\n\n    return borderColor;\n  };\n\n  Bar.prototype.tooltipAnchor = function tooltipAnchor() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var aboveAxis = ref.aboveAxis;\n    var clipBox = this.owner.pane.clipBox() || box;\n    var horizontalAlign = LEFT;\n    var verticalAlign = TOP;\n    var x, y;\n\n    if (options.vertical) {\n      x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;\n\n      if (aboveAxis) {\n        y = Math.max(box.y1, clipBox.y1);\n      } else {\n        y = Math.min(box.y2, clipBox.y2);\n        verticalAlign = BOTTOM;\n      }\n    } else {\n      var x1 = Math.max(box.x1, clipBox.x1);\n      var x2 = Math.min(box.x2, clipBox.x2);\n\n      if (options.isStacked) {\n        verticalAlign = BOTTOM;\n\n        if (aboveAxis) {\n          horizontalAlign = RIGHT;\n          x = x2;\n        } else {\n          x = x1;\n        }\n\n        y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;\n      } else {\n        if (aboveAxis) {\n          x = x2 + TOOLTIP_OFFSET;\n        } else {\n          x = x1 - TOOLTIP_OFFSET;\n          horizontalAlign = RIGHT;\n        }\n\n        y = Math.max(box.y1, clipBox.y1);\n      }\n    }\n\n    return {\n      point: new Point(x, y),\n      align: {\n        horizontal: horizontalAlign,\n        vertical: verticalAlign\n      }\n    };\n  };\n\n  Bar.prototype.overlapsBox = function overlapsBox(box) {\n    return this.box.overlaps(box);\n  };\n\n  Bar.prototype.pointData = function pointData() {\n    return {\n      dataItem: this.dataItem,\n      category: this.category,\n      value: this.value,\n      percentage: this.percentage,\n      stackValue: this.stackValue,\n      runningTotal: this.runningTotal,\n      total: this.total,\n      series: this.series\n    };\n  };\n\n  return Bar;\n}(ChartElement);\n\ndeepExtend(Bar.prototype, PointEventsMixin);\ndeepExtend(Bar.prototype, NoteMixin);\nBar.prototype.defaults = {\n  border: {\n    width: 1\n  },\n  vertical: true,\n  overlay: {\n    gradient: \"glass\"\n  },\n  labels: {\n    visible: false,\n    format: \"{0}\"\n  },\n  opacity: 1,\n  notes: {\n    label: {}\n  }\n};\nexport default Bar;","map":null,"metadata":{},"sourceType":"module"}