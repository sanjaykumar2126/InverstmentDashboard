{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * AccumulationChart Selection src file\n */\n\n\nimport { extend } from '@syncfusion/ej2-base';\nimport { indexFinder } from '../../common/utils/helper';\nimport { pointByIndex } from '../model/acc-base';\nimport { Index } from '../../common/model/base';\nimport { BaseSelection } from '../../common/user-interaction/selection';\n/**\n * `AccumulationSelection` module handles the selection for accumulation chart.\n */\n\nvar AccumulationSelection =\n/** @class */\nfunction (_super) {\n  __extends(AccumulationSelection, _super);\n\n  function AccumulationSelection(accumulation) {\n    var _this = _super.call(this, accumulation) || this;\n\n    _this.renderer = accumulation.renderer;\n    return _this;\n  }\n  /**\n   * To initialize the private variables\n   */\n\n\n  AccumulationSelection.prototype.initPrivateVariables = function (accumulation) {\n    this.styleId = accumulation.element.id + '_ej2_chart_selection';\n    this.unselected = accumulation.element.id + '_ej2_deselected';\n    this.selectedDataIndexes = [];\n    this.rectPoints = null;\n  };\n  /**\n   * Invoke selection for rendered chart.\n   * @param  {AccumulationChart} chart - Define the chart to invoke the selection.\n   * @return {void}\n   */\n\n\n  AccumulationSelection.prototype.invokeSelection = function (accumulation) {\n    this.initPrivateVariables(accumulation);\n    this.series = extend({}, accumulation.visibleSeries, null, true);\n    this.seriesStyles();\n    this.selectDataIndex(this.concatIndexes(accumulation.selectedDataIndexes, this.selectedDataIndexes), accumulation);\n  };\n  /**\n   * To get series selection style by series.\n   */\n\n\n  AccumulationSelection.prototype.generateStyle = function (series) {\n    return series.selectionStyle || this.styleId + '_series_' + series.index;\n  };\n  /**\n   * To get elements by index, series\n   */\n\n\n  AccumulationSelection.prototype.findElements = function (accumulation, series, index) {\n    return [this.getElementByIndex(index)];\n  };\n  /**\n   * To get series point element by index\n   */\n\n\n  AccumulationSelection.prototype.getElementByIndex = function (index) {\n    var elementId = this.control.element.id + '_Series_' + index.series + '_Point_' + index.point;\n    return document.getElementById(elementId);\n  };\n  /**\n   * To calculate selected elements on mouse click or touch\n   * @private\n   */\n\n\n  AccumulationSelection.prototype.calculateSelectedElements = function (accumulation, event) {\n    if (event.target.id.indexOf(accumulation.element.id + '_') === -1) {\n      return;\n    }\n\n    if (event.target.id.indexOf('_Series_') > -1 || event.target.id.indexOf('_datalabel_') > -1) {\n      this.performSelection(indexFinder(event.target.id), accumulation, event.target);\n    }\n  };\n  /**\n   * To perform the selection process based on index and element.\n   */\n\n\n  AccumulationSelection.prototype.performSelection = function (index, accumulation, element) {\n    element = element.id.indexOf('datalabel') > -1 ? accumulation.getSeriesElement().childNodes[index.series].childNodes[index.point] : element;\n\n    switch (accumulation.selectionMode) {\n      case 'Point':\n        if (!isNaN(index.point)) {\n          this.selection(accumulation, index, [element]);\n          this.blurEffect(accumulation.element.id, accumulation.visibleSeries);\n        }\n\n        break;\n    }\n  };\n  /**\n   * To select the element by index. Adding or removing selection style class name.\n   */\n\n\n  AccumulationSelection.prototype.selection = function (accumulation, index, selectedElements) {\n    if (!accumulation.isMultiSelect) {\n      this.removeMultiSelectEelments(accumulation, this.selectedDataIndexes, index, accumulation.series);\n    }\n\n    var className = selectedElements[0] && (selectedElements[0].getAttribute('class') || '');\n\n    if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {\n      this.removeStyles(selectedElements, index);\n      this.addOrRemoveIndex(this.selectedDataIndexes, index);\n    } else {\n      this.applyStyles(selectedElements, index);\n      this.addOrRemoveIndex(this.selectedDataIndexes, index, true);\n    }\n  };\n  /**\n   * To redraw the selection process on accumulation chart refresh.\n   * @private\n   */\n\n\n  AccumulationSelection.prototype.redrawSelection = function (accumulation, oldMode) {\n    var selectedDataIndexes = extend([], this.selectedDataIndexes, null, true);\n    this.removeSelectedElements(accumulation, this.selectedDataIndexes);\n    this.blurEffect(accumulation.element.id, accumulation.visibleSeries);\n    this.selectDataIndex(selectedDataIndexes, accumulation);\n  };\n  /**\n   * To remove the selected elements style classes by indexes.\n   */\n\n\n  AccumulationSelection.prototype.removeSelectedElements = function (accumulation, indexes) {\n    var seriesgroup = accumulation.getSeriesElement();\n\n    for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {\n      var index = indexes_1[_i];\n      this.removeStyles([this.getElementByIndex(index)], index);\n    }\n  };\n  /**\n   * To perform the selection for legend elements.\n   * @private\n   */\n\n\n  AccumulationSelection.prototype.legendSelection = function (accumulation, series, pointIndex) {\n    var element = accumulation.getSeriesElement().childNodes[series].childNodes[pointIndex];\n    var seriesStyle = this.generateStyle(accumulation.visibleSeries[series]);\n    var seriesElements = accumulation.getSeriesElement().childNodes[series].childNodes[pointIndex];\n    this.selection(accumulation, new Index(series, pointIndex), [seriesElements]);\n    this.blurEffect(accumulation.element.id, accumulation.visibleSeries);\n  };\n  /**\n   * To select the element by selected data indexes.\n   */\n\n\n  AccumulationSelection.prototype.selectDataIndex = function (indexes, accumulation) {\n    var element;\n\n    for (var _i = 0, indexes_2 = indexes; _i < indexes_2.length; _i++) {\n      var index = indexes_2[_i];\n      element = this.getElementByIndex(index);\n\n      if (element) {\n        this.performSelection(index, accumulation, element);\n      }\n    }\n  };\n  /**\n   * To remove the selection styles for multi selection process.\n   */\n\n\n  AccumulationSelection.prototype.removeMultiSelectEelments = function (accumulation, index, currentIndex, seriesCollection) {\n    var series;\n\n    for (var i = 0; i < index.length; i++) {\n      series = seriesCollection[index[i].series];\n\n      if (!this.checkEquals(index[i], currentIndex)) {\n        this.removeStyles(this.findElements(accumulation, series, index[i]), index[i]);\n        index.splice(i, 1);\n        i--;\n      }\n    }\n  };\n  /**\n   * To apply the opacity effect for accumulation chart series elements.\n   */\n\n\n  AccumulationSelection.prototype.blurEffect = function (pieId, visibleSeries) {\n    var visibility = this.checkPointVisibility(this.selectedDataIndexes); // legend click scenario\n\n    for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {\n      var series = visibleSeries_1[_i];\n\n      if (series.visible) {\n        this.checkSelectionElements(document.getElementById(pieId + '_SeriesCollection'), this.generateStyle(series), visibility);\n      }\n    }\n  };\n  /**\n   * To check selection elements by style class name.\n   */\n\n\n  AccumulationSelection.prototype.checkSelectionElements = function (element, className, visibility) {\n    var children = element.childNodes[0].childNodes;\n    var legendShape;\n    var elementClass;\n    var parentClass;\n\n    for (var i = 0; i < children.length; i++) {\n      elementClass = children[i].getAttribute('class') || '';\n      parentClass = children[i].parentNode.getAttribute('class') || '';\n\n      if (elementClass.indexOf(className) === -1 && parentClass.indexOf(className) === -1 && visibility) {\n        this.addSvgClass(children[i], this.unselected);\n      } else {\n        this.removeSvgClass(children[i], this.unselected);\n      }\n\n      if (this.control.accumulationLegendModule && this.control.legendSettings.visible) {\n        legendShape = document.getElementById(this.control.element.id + '_chart_legend_shape_' + i);\n\n        if (legendShape) {\n          if (elementClass.indexOf(className) === -1 && parentClass.indexOf(className) === -1 && visibility) {\n            this.addSvgClass(legendShape, this.unselected);\n          } else {\n            this.removeSvgClass(legendShape, this.unselected);\n          }\n        }\n      }\n    }\n  };\n  /**\n   * To apply selection style for elements.\n   */\n\n\n  AccumulationSelection.prototype.applyStyles = function (elements, index) {\n    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n      var element = elements_1[_i];\n      var legendShape = void 0;\n\n      if (element) {\n        if (this.control.accumulationLegendModule && this.control.legendSettings.visible) {\n          legendShape = document.getElementById(this.control.element.id + '_chart_legend_shape_' + index.point);\n          this.removeSvgClass(legendShape, this.unselected);\n          this.addSvgClass(legendShape, this.getSelectionClass(legendShape.id));\n        }\n\n        this.removeSvgClass(element.parentNode, this.unselected);\n        this.removeSvgClass(element, this.unselected);\n        this.addSvgClass(element, this.getSelectionClass(element.id));\n      }\n    }\n  };\n  /**\n   * To get selection style class name by id\n   */\n\n\n  AccumulationSelection.prototype.getSelectionClass = function (id) {\n    return this.generateStyle(this.control.series[indexFinder(id).series]);\n  };\n  /**\n   * To remove selection style for elements.\n   */\n\n\n  AccumulationSelection.prototype.removeStyles = function (elements, index) {\n    var legendShape;\n\n    for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {\n      var element = elements_2[_i];\n\n      if (element) {\n        if (this.control.accumulationLegendModule && this.control.legendSettings.visible) {\n          legendShape = document.getElementById(this.control.element.id + '_chart_legend_shape_' + index.point);\n          this.removeSvgClass(legendShape, this.getSelectionClass(legendShape.id));\n        }\n\n        this.removeSvgClass(element, this.getSelectionClass(element.id));\n      }\n    }\n  };\n  /**\n   * To apply or remove selected elements index.\n   */\n\n\n  AccumulationSelection.prototype.addOrRemoveIndex = function (indexes, index, add) {\n    for (var i = 0; i < indexes.length; i++) {\n      if (this.checkEquals(indexes[i], index)) {\n        indexes.splice(i, 1);\n        i--;\n      }\n    }\n\n    if (add) {\n      indexes.push(index);\n    }\n  };\n  /**\n   * To check two index, point and series are equal\n   */\n\n\n  AccumulationSelection.prototype.checkEquals = function (first, second) {\n    return first.point === second.point && first.series === second.series;\n  };\n  /**\n   * To check selected points are visibility\n   */\n\n\n  AccumulationSelection.prototype.checkPointVisibility = function (selectedDataIndexes) {\n    var visible = false;\n\n    for (var _i = 0, selectedDataIndexes_1 = selectedDataIndexes; _i < selectedDataIndexes_1.length; _i++) {\n      var data = selectedDataIndexes_1[_i];\n\n      if (pointByIndex(data.point, this.control.visibleSeries[0].points).visible) {\n        visible = true;\n        break;\n      }\n    }\n\n    return visible;\n  };\n  /**\n   * Get module name.\n   */\n\n\n  AccumulationSelection.prototype.getModuleName = function () {\n    return 'AccumulationSelection';\n  };\n  /**\n   * To destroy the selection.\n   * @return {void}\n   * @private\n   */\n\n\n  AccumulationSelection.prototype.destroy = function (accumulation) {// Destroy method performed here\n  };\n\n  return AccumulationSelection;\n}(BaseSelection);\n\nexport { AccumulationSelection };","map":null,"metadata":{},"sourceType":"module"}