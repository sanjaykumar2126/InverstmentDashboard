{"ast":null,"code":"import { createElement, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\nimport { subtractThickness, valueToCoefficient, sum, redrawElement, isBreakLabel } from '../../common/utils/helper';\nimport { subArray, inside, appendChildElement } from '../../common/utils/helper';\nimport { Thickness, logBase, createZoomingLabels, getElement, rotateTextSize } from '../../common/utils/helper';\nimport { Size, Rect, measureText, TextOption, PathOption } from '@syncfusion/ej2-svg-base';\nimport { textElement, textTrim } from '../../common/utils/helper';\n/**\n * Specifies the Cartesian Axis Layout.\n */\n\nvar axisPadding = 10;\n\nvar CartesianAxisLayoutPanel =\n/** @class */\nfunction () {\n  /** @private */\n  function CartesianAxisLayoutPanel(chartModule) {\n    this.chart = chartModule;\n    this.padding = 5;\n  }\n  /**\n   * Measure the axis size.\n   * @return {void}\n   * @private\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {\n    var chart = this.chart;\n    this.crossAt(chart);\n    this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);\n    this.initialClipRect = rect;\n    this.leftSize = 0;\n    this.rightSize = 0;\n    this.topSize = 0;\n    this.bottomSize = 0; //Measure Axis size with initial Rect\n\n    this.measureRowAxis(chart, this.initialClipRect);\n    this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n    this.measureColumnAxis(chart, this.initialClipRect);\n    this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n\n    if (!this.chart.delayRedraw) {\n      this.calculateAxisSize(this.initialClipRect);\n    }\n\n    this.leftSize = 0;\n    this.rightSize = 0;\n    this.topSize = 0;\n    this.bottomSize = 0; //Measure Axis size with series Rect\n\n    this.measureRowAxis(chart, this.initialClipRect);\n    this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n    this.measureColumnAxis(chart, this.initialClipRect);\n    this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n\n    if (!this.chart.delayRedraw) {\n      chart.refreshAxis();\n      this.calculateAxisSize(this.seriesClipRect);\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {\n    var row;\n    this.calculateRowSize(rect);\n\n    for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n      var item = _a[_i];\n      row = item;\n      row.nearSizes = [];\n      row.farSizes = [];\n      this.arrangeAxis(row);\n      this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight), rect);\n\n      if (this.leftSize < sum(row.nearSizes)) {\n        this.leftSize = sum(row.nearSizes);\n      }\n\n      if (this.rightSize < sum(row.farSizes)) {\n        this.rightSize = sum(row.farSizes);\n      }\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {\n    var column;\n    this.calculateColumnSize(rect);\n\n    for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n      var item = _a[_i];\n      column = item;\n      column.farSizes = [];\n      column.nearSizes = [];\n      this.arrangeAxis(column);\n      this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height), rect);\n\n      if (this.bottomSize < sum(column.nearSizes)) {\n        this.bottomSize = sum(column.nearSizes);\n      }\n\n      if (this.topSize < sum(column.farSizes)) {\n        this.topSize = sum(column.farSizes);\n      }\n    }\n  };\n  /**\n   * Measure the column and row in chart.\n   * @return {void}\n   * @private\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size, clipRect) {\n    var ele = 16; // scrollbar element height is 16.\n\n    for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {\n      var axis = _a[_i];\n      axis.scrollBarHeight = chart.scrollBarModule && chart.zoomSettings.enableScrollbar && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;\n      axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable) ? ele : 0;\n      axis.getModule(chart);\n      axis.baseModule.calculateRangeAndInterval(size, axis);\n      definition.computeSize(axis, clipRect, axis.scrollBarHeight);\n    }\n\n    if (definition.farSizes.length > 0) {\n      definition.farSizes[definition.farSizes.length - 1] -= axisPadding;\n    }\n\n    if (definition.nearSizes.length > 0) {\n      definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;\n    }\n  };\n  /**\n   * Measure the axis.\n   * @return {void}\n   * @private\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {\n    var chart = this.chart;\n    var row;\n    var column;\n    var definition;\n    var axis;\n    var nearCount = 0;\n    var farCount = 0;\n    var size = 0;\n    var x;\n    var y;\n    this.calculateRowSize(rect);\n\n    for (var i = 0, len = chart.rows.length; i < len; i++) {\n      row = chart.rows[i];\n      nearCount = 0;\n      farCount = 0;\n\n      for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {\n        axis = row.axes[j];\n\n        if (axis.rect.height === 0) {\n          axis.rect.height = row.computedHeight;\n          size = 0;\n\n          for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {\n            definition = chart.rows[k];\n            size += definition.computedHeight;\n          }\n\n          axis.rect.y = row.computedTop - size + axis.plotOffset;\n          axis.rect.height = axis.rect.height + size - 2 * axis.plotOffset;\n          axis.rect.width = 0;\n        }\n\n        if (axis.opposedPosition) {\n          x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));\n          axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;\n          farCount++;\n        } else {\n          x = rect.x - sum(subArray(row.nearSizes, nearCount));\n          axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;\n          nearCount++;\n        }\n      }\n    }\n\n    this.calculateColumnSize(rect);\n\n    for (var i = 0, len = chart.columns.length; i < len; i++) {\n      column = chart.columns[i];\n      nearCount = 0;\n      farCount = 0;\n\n      for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {\n        axis = column.axes[j];\n\n        if (axis.rect.width === 0) {\n          for (var k = i, len_4 = i + axis.span; k < len_4; k++) {\n            definition = chart.columns[k];\n            axis.rect.width += definition.computedWidth;\n          }\n\n          axis.rect.x = column.computedLeft + axis.plotOffset;\n          axis.rect.width -= 2 * axis.plotOffset;\n          axis.rect.height = 0;\n        }\n\n        if (axis.opposedPosition) {\n          y = rect.y - sum(subArray(column.farSizes, farCount));\n          axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;\n          farCount++;\n        } else {\n          y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));\n          axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;\n          nearCount++;\n        }\n      }\n    }\n  };\n  /**\n   * Measure the axis.\n   * @return {void}\n   * @private\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.measure = function () {\n    var chart = this.chart;\n    var row;\n    var column;\n    var definition;\n    var actualIndex;\n    var span;\n\n    for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n      var axis = _a[_i]; //definition.Axes = axis;\n\n      if (axis.orientation === 'Vertical') {\n        chart.verticalAxes.push(axis);\n        actualIndex = this.getActualRow(axis);\n        row = chart.rows[actualIndex];\n        this.pushAxis(row, axis);\n        span = actualIndex + axis.span > chart.rows.length ? chart.rows.length : actualIndex + axis.span;\n\n        for (var j = actualIndex + 1; j < span; j++) {\n          definition = chart.rows[j];\n          definition.axes[row.axes.length - 1] = axis;\n          chart.rows[j] = definition;\n        }\n\n        chart.rows[actualIndex] = row;\n      } else {\n        chart.horizontalAxes.push(axis);\n        actualIndex = this.getActualColumn(axis);\n        column = chart.columns[actualIndex];\n        this.pushAxis(column, axis);\n        span = actualIndex + axis.span > chart.columns.length ? chart.columns.length : actualIndex + axis.span;\n\n        for (var j = actualIndex + 1; j < span; j++) {\n          definition = chart.columns[j];\n          definition.axes[column.axes.length - 1] = axis;\n          chart.columns[j] = definition;\n        }\n\n        chart.columns[actualIndex] = column;\n      }\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.crossAt = function (chart) {\n    for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n      var axis = _a[_i];\n\n      if (axis.crossesAt === null) {\n        continue;\n      }\n\n      if (!axis.crossesInAxis) {\n        if (chart.requireInvertedAxis) {\n          axis.crossInAxis = axis.orientation === 'Horizontal' ? chart.primaryXAxis : chart.primaryYAxis;\n        } else {\n          axis.crossInAxis = axis.orientation === 'Horizontal' ? chart.primaryYAxis : chart.primaryXAxis;\n        }\n\n        axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n        continue;\n      } else {\n        for (var i = 2, len = chart.axisCollections.length; i < len; i++) {\n          if (axis.crossesInAxis === chart.axisCollections[i].name) {\n            axis.crossInAxis = chart.axisCollections[i];\n            axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n            continue;\n          }\n        }\n      }\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.updateCrossAt = function (axis, crossAt) {\n    switch (axis.valueType) {\n      case 'DateTime':\n        var option = {\n          skeleton: 'full',\n          type: 'dateTime'\n        };\n        var dateParser = this.chart.intl.getDateParser(option);\n        var dateFormatter = this.chart.intl.getDateFormat(option);\n        return Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n          val: crossAt\n        }).val))));\n\n      case 'Category':\n        return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);\n\n      case 'Logarithmic':\n        return logBase(crossAt, axis.logBase);\n\n      default:\n        return crossAt;\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {\n    for (var i = 0, len = definition.axes.length; i <= len; i++) {\n      if (!definition.axes[i]) {\n        definition.axes[i] = axis;\n        break;\n      }\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {\n    var axisCollection = [];\n\n    for (var i = 0, len = definition.axes.length; i <= len; i++) {\n      if (definition.axes[i]) {\n        axisCollection.push(definition.axes[i]);\n      }\n    }\n\n    definition.axes = axisCollection;\n  };\n\n  CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {\n    var actualLength = this.chart.columns.length;\n    var pos = axis.columnIndex;\n    var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;\n    return result;\n  };\n\n  CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {\n    var actualLength = this.chart.rows.length;\n    var pos = axis.rowIndex;\n    var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;\n    return result;\n  };\n  /**\n   * Measure the row size.\n   * @return {void}\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {\n    /*! Calculate row size */\n    var chart = this.chart;\n    var row;\n    var rowTop = rect.y + rect.height;\n    var height = 0;\n    var remainingHeight = Math.max(0, rect.height);\n\n    for (var i = 0, len = chart.rows.length; i < len; i++) {\n      row = chart.rows[i];\n\n      if (row.height.indexOf('%') !== -1) {\n        height = Math.min(remainingHeight, rect.height * parseInt(row.height, 10) / 100);\n      } else {\n        height = Math.min(remainingHeight, parseInt(row.height, 10));\n      }\n\n      height = i !== len - 1 ? height : remainingHeight;\n      row.computedHeight = height;\n      rowTop -= height;\n      row.computedTop = rowTop;\n      remainingHeight -= height;\n    }\n  };\n  /**\n   * Measure the row size.\n   * @param rect\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {\n    /*! Calculate column size */\n    var chart = this.chart;\n    var column;\n    var columnLeft = rect.x;\n    var width = 0;\n    var remainingWidth = Math.max(0, rect.width);\n\n    for (var i = 0, len = chart.columns.length; i < len; i++) {\n      column = chart.columns[i];\n\n      if (column.width.indexOf('%') !== -1) {\n        width = Math.min(remainingWidth, rect.width * parseInt(column.width, 10) / 100);\n      } else {\n        width = Math.min(remainingWidth, parseInt(column.width, 10));\n      }\n\n      width = i !== len - 1 ? width : remainingWidth;\n      column.computedWidth = width;\n      column.computedLeft = columnLeft;\n      columnLeft += width;\n      remainingWidth -= width;\n    }\n  };\n  /**\n   * To render the axis element.\n   * @return {void}\n   * @private\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.renderAxes = function () {\n    var chart = this.chart;\n    var axis;\n    var axisElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisInsideCollection'\n    });\n    var axisLineElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisOutsideCollection'\n    });\n    var outsideElement;\n    var isInside;\n\n    for (var i = 0, len = chart.axisCollections.length; i < len; i++) {\n      axis = chart.axisCollections[i];\n      this.element = chart.renderer.createGroup({\n        id: chart.element.id + 'AxisGroup' + i + 'Inside'\n      });\n      outsideElement = chart.renderer.createGroup({\n        id: chart.element.id + 'AxisGroup' + i + 'Outside'\n      });\n      isInside = this.findAxisPosition(axis);\n\n      if (axis.orientation === 'Horizontal') {\n        axis.updateCrossValue(chart);\n\n        if (axis.visible && axis.lineStyle.width > 0) {\n          this.drawAxisLine(axis, i, axis.plotOffset, 0, isInside ? outsideElement : this.element, axis.updatedRect);\n        }\n\n        if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\n          this.drawXAxisGridLine(axis, i, isInside || axis.tickPosition === 'Inside' ? outsideElement : this.element, axis.updatedRect);\n        }\n\n        if (axis.visible) {\n          this.drawXAxisLabels(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawXAxisBorder(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawXAxisTitle(axis, i, isInside ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n        }\n      } else {\n        axis.updateCrossValue(chart);\n\n        if (axis.visible && axis.lineStyle.width > 0) {\n          this.drawAxisLine(axis, i, 0, axis.plotOffset, isInside ? outsideElement : this.element, axis.updatedRect);\n        }\n\n        if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\n          this.drawYAxisGridLine(axis, i, isInside || axis.tickPosition === 'Inside' ? outsideElement : this.element, axis.updatedRect);\n        }\n\n        if (axis.visible) {\n          this.drawYAxisLabels(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawYAxisBorder(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawYAxisTitle(axis, i, isInside ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n        }\n      }\n\n      if (!this.chart.enableCanvas) {\n        axisElement.appendChild(this.element);\n\n        if (outsideElement && outsideElement.childNodes.length > 0) {\n          axisLineElement.appendChild(outsideElement);\n        }\n      }\n\n      if (chart.scrollBarModule && (chart.zoomSettings.enableScrollbar || axis.scrollbarSettings.enable)) {\n        this.renderScrollbar(chart, axis);\n      }\n    }\n\n    this.element = chart.renderer.createGroup({\n      id: chart.element.id + 'DefinitionLine'\n    });\n\n    for (var j = 0, len = chart.rows.length; j < len; j++) {\n      var row = chart.rows[j];\n\n      if (row.border.color) {\n        this.drawBottomLine(row, j, true);\n      }\n    }\n\n    for (var j = 0, len = chart.columns.length; j < len; j++) {\n      var column = chart.columns[j];\n\n      if (column.border.color) {\n        this.drawBottomLine(column, j, false);\n      }\n    }\n\n    if (!this.chart.enableCanvas) {\n      axisElement.appendChild(this.element);\n    }\n\n    appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);\n    return axisLineElement;\n  };\n  /**\n   * To render the axis scrollbar\n   * @param chart\n   * @param axis\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.renderScrollbar = function (chart, axis) {\n    var isZoomed = isNullOrUndefined(chart.zoomModule) ? false : chart.zoomModule.isZoomed;\n\n    if ((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable && (axis.zoomFactor <= 1 || axis.zoomPosition >= 0)) && !axis.zoomingScrollBar.isScrollUI) {\n      if (!chart.scrollElement) {\n        chart.scrollElement = redrawElement(chart.redraw, chart.element.id + '_scrollElement') || createElement('div', {\n          id: chart.element.id + '_scrollElement'\n        });\n      }\n\n      appendChildElement(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);\n    } else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {\n      axis.zoomingScrollBar.destroy();\n    }\n\n    if (axis.zoomingScrollBar.isScrollUI) {\n      axis.zoomingScrollBar.isScrollUI = false;\n    }\n  };\n  /**\n   * To find the axis position\n   * @param axis\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.findAxisPosition = function (axis) {\n    return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);\n  };\n  /**\n   * To render the bootom line of the columns and rows\n   * @param definition\n   * @param index\n   * @param isRow\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawBottomLine = function (definition, index, isRow) {\n    var chart = this.chart;\n    var optionsLine = {};\n    var x1;\n    var x2;\n    var y1;\n    var y2;\n    var definitionName;\n\n    if (isRow) {\n      definition = definition;\n      y1 = y2 = definition.computedTop + definition.computedHeight;\n      x1 = this.seriesClipRect.x;\n      x2 = x1 + this.seriesClipRect.width;\n      definitionName = 'Row';\n    } else {\n      definition = definition;\n      x1 = x2 = definition.computedLeft;\n      y1 = this.seriesClipRect.y;\n      y2 = y1 + this.seriesClipRect.height;\n      definitionName = 'Column';\n    }\n\n    optionsLine = {\n      'id': chart.element.id + '_AxisBottom_' + definitionName + index,\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      'stroke-width': definition.border.width,\n      'stroke': definition.border.color\n    };\n    this.htmlObject = chart.renderer.drawLine(optionsLine);\n    this.element.appendChild(this.htmlObject);\n  };\n  /**\n   * To render the axis line\n   * @param axis\n   * @param index\n   * @param plotX\n   * @param plotY\n   * @param parent\n   * @param rect\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawAxisLine = function (axis, index, plotX, plotY, parent, rect) {\n    var chart = this.chart;\n    var optionsLine = {};\n    var element = getElement(chart.element.id + 'AxisLine_' + index);\n    var direction = element ? element.getAttribute('d') : '';\n    element = null;\n    optionsLine = {\n      'id': chart.element.id + 'AxisLine_' + index,\n      'd': 'M ' + (rect.x - plotX) + ' ' + (rect.y - plotY) + ' L ' + (rect.x + rect.width + plotX) + ' ' + (rect.y + rect.height + plotY),\n      'stroke-dasharray': axis.lineStyle.dashArray,\n      'stroke-width': axis.lineStyle.width,\n      'stroke': axis.lineStyle.color || chart.themeStyle.axisLine\n    };\n    this.htmlObject = chart.renderer.drawPath(optionsLine);\n    appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction);\n  };\n  /**\n   * To render the yAxis grid line\n   * @param axis\n   * @param index\n   * @param parent\n   * @param rect\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawYAxisGridLine = function (axis, index, parent, rect) {\n    var tempInterval;\n    var pointY = 0;\n    var majorGrid = '';\n    var majorTick = '';\n    var minorGridDirection;\n    var tickSize = axis.opposedPosition ? axis.majorTickLines.height : -axis.majorTickLines.height;\n    var axisLineSize = axis.opposedPosition ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;\n    var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.opposedPosition ? axis.scrollBarHeight : -axis.scrollBarHeight : 0;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var ticks = isTickInside ? rect.x - tickSize - axisLineSize : rect.x + tickSize + axisLineSize + scrollBarHeight;\n    var length = axis.visibleLabels.length;\n    var chartThemeStyle = this.chart.themeStyle;\n\n    if (axis.valueType.indexOf('Category') && axis.labelPlacement === 'BetweenTicks' && length > 0) {\n      length += 1;\n    }\n\n    var minorGridLines = axis.minorGridLines;\n    var minorTickLines = axis.minorTickLines; //Gridlines\n\n    for (var i = 0; i < length; i++) {\n      tempInterval = !axis.visibleLabels[i] ? axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel : axis.visibleLabels[i].value - ticksbwtLabel;\n      pointY = valueToCoefficient(tempInterval, axis) * rect.height;\n      pointY = pointY * -1 + (rect.y + rect.height);\n\n      if (pointY >= rect.y && rect.y + rect.height >= pointY) {\n        if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointY)) {\n          majorGrid = 'M ' + this.seriesClipRect.x + ' ' + pointY + ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointY;\n          this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n        }\n\n        majorTick = 'M ' + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' ' + pointY + ' L ' + ticks + ' ' + pointY;\n        this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n\n        if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {\n          minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n          this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);\n          this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n        }\n      }\n    }\n  };\n  /**\n   * To check the border of the axis\n   * @param axis\n   * @param index\n   * @param value\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.isBorder = function (axis, index, value) {\n    var border = this.chart.chartArea.border;\n    var rect = this.seriesClipRect;\n    var orientation = axis.orientation;\n    var start = orientation === 'Horizontal' ? rect.x : rect.y;\n    var size = orientation === 'Horizontal' ? rect.width : rect.height;\n    var startIndex = orientation === 'Horizontal' ? 0 : axis.visibleLabels.length - 1;\n    var endIndex = orientation === 'Horizontal' ? axis.visibleLabels.length - 1 : 0;\n\n    if (axis.plotOffset > 0) {\n      return true;\n    } else if ((value === start || value === start + size) && (border.width <= 0 || border.color === 'transparent')) {\n      return true;\n    } else if (value !== start && index === startIndex || value !== start + size && index === endIndex) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * To render the yAxis label\n   * @param axis\n   * @param index\n   * @param parent\n   * @param rect\n   * @private\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawYAxisLabels = function (axis, index, parent, rect) {\n    var chart = this.chart;\n    var pointX = 0;\n    var pointY = 0;\n    var elementSize;\n    var options;\n    var isAxisBreakLabel;\n    var isLabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.opposedPosition;\n    var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n    var padding = tickSpace + this.padding + axis.lineStyle.width * 0.5;\n    padding = axis.opposedPosition ? padding : -padding;\n    var anchor = isOpposed && isLabelInside || !isOpposed && !isLabelInside ? 'end' : 'start';\n    var labelElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels' + index\n    });\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;\n\n    for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n      isAxisBreakLabel = isBreakLabel(axis.visibleLabels[i].originalText);\n      pointX = isLabelInside ? rect.x - padding : rect.x + padding + scrollBarHeight;\n      elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;\n      pointY = valueToCoefficient(axis.visibleLabels[i].value, axis) * rect.height + (chart.stockChart ? 7 : 0);\n      pointY = Math.floor(pointY * -1 + (rect.y + rect.height));\n      pointY = isAxisBreakLabel ? pointY - elementSize.height / 8 * axis.visibleLabels[i].text.length / 2 : pointY + elementSize.height / 4;\n      options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor, axis.visibleLabels[i].text);\n\n      if (axis.edgeLabelPlacement) {\n        switch (axis.edgeLabelPlacement) {\n          case 'None':\n            break;\n\n          case 'Hide':\n            if ((i === 0 || axis.isInversed && i === len - 1) && options.y > rect.y + rect.height || (i === len - 1 || axis.isInversed && i === 0) && options.y - elementSize.height * 0.5 < rect.y) {\n              options.text = '';\n            }\n\n            break;\n\n          case 'Shift':\n            if ((i === 0 || axis.isInversed && i === len - 1) && options.y > rect.y + rect.height) {\n              options.y = pointY = rect.y + rect.height;\n            } else if ((i === len - 1 || axis.isInversed && i === 0) && options.y - elementSize.height * 0.5 < rect.y) {\n              options.y = pointY = rect.y + elementSize.height * 0.5;\n            }\n\n            break;\n        }\n      }\n\n      textElement(chart.renderer, options, axis.labelStyle, axis.labelStyle.color || chart.themeStyle.axisLabel, labelElement, false, chart.redraw, true, true);\n    }\n\n    if (!this.chart.enableCanvas) {\n      if (!chart.delayRedraw) {\n        appendChildElement(chart.enableCanvas, parent, labelElement, chart.redraw);\n      } else if (axis.visible) {\n        this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n      }\n    }\n  };\n  /**\n   * To render the yAxis label border.\n   * @param axis\n   * @param index\n   * @param parent\n   * @param rect\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawYAxisBorder = function (axis, index, parent, rect) {\n    if (axis.border.width > 0) {\n      var startY = void 0;\n      var pointY = void 0;\n      var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\n      scrollBarHeight = (axis.opposedPosition ? 1 : -1) * scrollBarHeight;\n      var gap = rect.height / axis.visibleRange.delta * (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n      var endY = void 0;\n      var length_1 = axis.maxLabelSize.width + 10 + (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0);\n      var labelBorder = '';\n      var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? -0.5 : 0;\n      var endX = axis.opposedPosition && axis.labelPosition === 'Inside' || !axis.opposedPosition && axis.labelPosition === 'Outside' ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;\n\n      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n        pointY = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n        pointY = (axis.isInversed ? 1 - pointY : pointY) * rect.height;\n\n        if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n          startY = pointY * -1 + (rect.y + rect.height);\n          endY = pointY * -1 - gap + (rect.y + rect.height);\n        } else {\n          startY = pointY * -1 + gap / 2 + (rect.y + rect.height);\n          endY = pointY * -1 - gap / 2 + (rect.y + rect.height);\n        }\n\n        switch (axis.border.type) {\n          case 'Rectangle':\n          case 'WithoutTopBorder':\n            if (startY > rect.y + rect.height) {\n              labelBorder += 'M' + ' ' + endX + ' ' + (rect.y + rect.height) + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n            } else if (Math.floor(rect.y) > endY) {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + rect.y + ' ';\n            } else {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n\n              if (i === axis.visibleLabels.length - 1) {\n                labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n              }\n            }\n\n            break;\n\n          case 'WithoutTopandBottomBorder':\n            if (!(startY > rect.y + rect.height) && !(endY < Math.floor(rect.y))) {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'M' + ' ' + endX + ' ' + endY + ' ' + 'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY;\n            }\n\n            break;\n        }\n      }\n\n      labelBorder += axis.border.type === 'Rectangle' ? 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + rect.y + ' ' + 'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + (rect.y + rect.height) + ' ' : '';\n\n      if (labelBorder !== '') {\n        this.createAxisBorderElement(axis, index, labelBorder, parent);\n      }\n    }\n\n    if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule) {\n      this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);\n    }\n  };\n  /**\n   * To render the yAxis title\n   * @param axis\n   * @param index\n   * @param parent\n   * @param rect\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawYAxisTitle = function (axis, index, parent, rect) {\n    var chart = this.chart;\n    var labelRotation = axis.opposedPosition ? 90 : -90;\n    var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + this.padding) + (axis.labelPosition === 'Inside' ? 0 : axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding);\n    padding = axis.opposedPosition ? padding + axis.scrollBarHeight : -padding - axis.scrollBarHeight;\n    var x = rect.x + padding;\n    var y = rect.y + rect.height * 0.5;\n    var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y - this.padding, 'middle', axis.title, 'rotate(' + labelRotation + ',' + x + ',' + y + ')', null, labelRotation);\n    var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitle, parent);\n    element.setAttribute('tabindex', axis.tabIndex.toString());\n    element.setAttribute('aria-label', axis.description || axis.title);\n  };\n  /**\n   * xAxis grid line calculation performed here\n   * @param axis\n   * @param index\n   * @param parent\n   * @param rect\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawXAxisGridLine = function (axis, index, parent, rect) {\n    var tempInterval;\n    var pointX = 0;\n    var majorGrid = '';\n    var majorTick = '';\n    var minorDirection;\n    var tickSize = axis.opposedPosition ? -axis.majorTickLines.height : axis.majorTickLines.height;\n    var axisLineSize = axis.opposedPosition ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.opposedPosition ? -axis.scrollBarHeight : axis.scrollBarHeight : 0;\n    var ticksbwtLabel = axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n    var length = axis.visibleLabels.length;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var ticks = isTickInside ? rect.y - tickSize - axisLineSize : rect.y + tickSize + axisLineSize + scrollBarHeight;\n    var chartThemeStyle = this.chart.themeStyle;\n\n    if (axis.valueType.indexOf('Category') > -1 && length > 0 && axis.labelPlacement === 'BetweenTicks') {\n      length += 1;\n    } //Gridlines\n\n\n    for (var i = 0; i < length; i++) {\n      if (axis.valueType !== 'DateTimeCategory') {\n        tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel;\n      } else {\n        tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;\n      }\n\n      pointX = valueToCoefficient(tempInterval, axis) * rect.width + rect.x;\n\n      if (pointX >= rect.x && rect.x + rect.width >= pointX) {\n        if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {\n          majorGrid = 'M ' + pointX + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) + ' L ' + pointX + ' ' + this.seriesClipRect.y;\n          this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n        }\n\n        majorTick = 'M ' + pointX + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' L ' + pointX + ' ' + ticks;\n        this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n\n        if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {\n          minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n          this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\n          this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n        }\n      }\n    }\n  };\n  /**\n   * To calcualte the axis minor line\n   * @param axis\n   * @param tempInterval\n   * @param rect\n   * @param labelIndex\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, rect, labelIndex) {\n    var value = tempInterval;\n    var coor = 0;\n    var position = 0;\n    var range = axis.visibleRange;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var direction = [];\n    var tickSize = axis.opposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;\n    var logStart;\n    var logEnd;\n    var logInterval = 1;\n    var logPosition = 1;\n    var ticksX = isTickInside ? rect.y - tickSize : rect.y + tickSize;\n    var ticksY = isTickInside ? rect.x + tickSize : rect.x - tickSize;\n    var minorGird = '';\n    var minorTick = '';\n\n    if (axis.valueType === 'Logarithmic') {\n      logStart = Math.pow(axis.logBase, value - range.interval);\n      logEnd = Math.pow(axis.logBase, value);\n      logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);\n      logPosition = logStart + logInterval;\n    }\n\n    if (axis.orientation === 'Horizontal') {\n      for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n        value = this.findLogNumeric(axis, logPosition, logInterval, value, labelIndex);\n        logPosition += logInterval;\n\n        if (inside(value, range)) {\n          position = (value - range.min) / (range.max - range.min);\n          position = Math.ceil((axis.isInversed ? 1 - position : position) * rect.width);\n          coor = Math.floor(position + rect.x);\n          minorGird = minorGird.concat('M' + ' ' + coor + ' ' + this.seriesClipRect.y + 'L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height));\n          coor = Math.floor(position + rect.x);\n          minorTick = minorTick.concat('M' + ' ' + coor + ' ' + rect.y + 'L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n        }\n      }\n    } else {\n      tickSize = axis.opposedPosition ? axis.minorTickLines.height : -axis.minorTickLines.height;\n\n      for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n        value = this.findLogNumeric(axis, logPosition, logInterval, value, labelIndex);\n\n        if (inside(value, range)) {\n          position = Math.ceil((value - range.min) / (range.max - range.min) * rect.height) * -1;\n          coor = Math.floor(position + rect.y + rect.height);\n          minorGird = minorGird.concat('M' + ' ' + this.seriesClipRect.x + ' ' + coor + 'L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor + ' ');\n          coor = Math.floor(position + rect.y + rect.height);\n          minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + 'L ' + (ticksY - axis.scrollBarHeight) + ' ' + coor + ' ');\n        }\n\n        logPosition += logInterval;\n      }\n    }\n\n    direction.push(minorGird);\n    direction.push(minorTick);\n    return direction;\n  };\n  /**\n   * To find the numeric value of the log\n   * @param axis\n   * @param logPosition\n   * @param logInterval\n   * @param value\n   * @param labelIndex\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.findLogNumeric = function (axis, logPosition, logInterval, value, labelIndex) {\n    var range = axis.visibleRange;\n\n    if (axis.valueType === 'Logarithmic') {\n      value = logBase(logPosition, axis.logBase);\n    } else if (axis.valueType === 'DateTime') {\n      value += axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);\n    } else if (axis.valueType === 'DateTimeCategory') {\n      var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n      value += ((axis.visibleLabels[labelIndex + 1] ? axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) - (axis.visibleLabels[labelIndex] ? axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) / (axis.minorTicksPerInterval + 1);\n    } else {\n      value += range.interval / (axis.minorTicksPerInterval + 1);\n    }\n\n    return value;\n  };\n  /**\n   * To render the xAxis Labels\n   * @param axis\n   * @param index\n   * @param parent\n   * @param rect\n   * @private\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawXAxisLabels = function (axis, index, parent, rect) {\n    var chart = this.chart;\n    var pointX = 0;\n    var pointY = 0;\n    var elementSize;\n    var labelPadding;\n    var xValue = 0;\n    var labelElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels' + index\n    });\n    var islabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.opposedPosition;\n    var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n    var padding = tickSpace + this.padding + axis.lineStyle.width * 0.5;\n    var rotateSize;\n    var diffHeight;\n    var angle = axis.angle % 360;\n    var anglePadding = angle === 90 || angle === -90 ? -2 : 0;\n    var options;\n    var yLocation;\n    var labelWidth;\n    var previousEnd = axis.isInversed ? rect.x + rect.width : rect.x;\n    var width = 0;\n    var length = axis.visibleLabels.length;\n    var intervalLength;\n    var label;\n    var isAxisBreakLabel;\n    var scrollBarHeight = axis.scrollbarSettings.enable || !islabelInside && isNullOrUndefined(axis.crossesAt) && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? axis.scrollBarHeight : 0;\n\n    for (var i = 0, len = length; i < len; i++) {\n      label = axis.visibleLabels[i];\n      isAxisBreakLabel = isBreakLabel(label.originalText);\n      pointX = valueToCoefficient(label.value, axis) * rect.width + rect.x;\n      elementSize = label.size;\n      intervalLength = rect.width / length;\n      labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;\n      width = (axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle === 0 && labelWidth > intervalLength ? intervalLength : labelWidth;\n      pointX -= width / 2;\n\n      if (islabelInside && angle) {\n        pointY = isOpposed ? rect.y + padding : rect.y - padding;\n      } else {\n        labelPadding = isOpposed && !islabelInside || !isOpposed && islabelInside ? -(padding + scrollBarHeight + (angle ? elementSize.height * 0.5 + 2 * axis.maxLabelSize.height / 5 : label.index > 1 ? 2 * (elementSize.height / 4) : 0)) : padding + scrollBarHeight + (angle ? axis.maxLabelSize.height * 0.5 : 3 * (elementSize.height / 4));\n        pointY = rect.y + labelPadding * label.index;\n      }\n\n      options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, '');\n\n      if (axis.edgeLabelPlacement) {\n        switch (axis.edgeLabelPlacement) {\n          case 'None':\n            break;\n\n          case 'Hide':\n            if ((i === 0 || axis.isInversed && i === len - 1) && options.x < rect.x || (i === len - 1 || axis.isInversed && i === 0) && options.x + width > rect.x + rect.width) {\n              continue;\n            }\n\n            break;\n\n          case 'Shift':\n            if ((i === 0 || axis.isInversed && i === len - 1) && options.x < rect.x) {\n              intervalLength -= rect.x - options.x;\n              options.x = pointX = rect.x;\n            } else if ((i === len - 1 || axis.isInversed && i === 0) && options.x + width > rect.x + rect.width) {\n              if (elementSize.width > intervalLength && axis.labelIntersectAction === 'Trim') {\n                intervalLength -= options.x + width - (rect.x + rect.width);\n              } else {\n                intervalLength = width;\n              }\n\n              options.x = pointX = rect.x + rect.width - intervalLength;\n            }\n\n            break;\n        }\n      }\n\n      options.text = this.getLabelText(label, axis, intervalLength);\n\n      if (angle === 0 && axis.labelIntersectAction === 'Hide' && i !== 0 && (!axis.isInversed ? options.x <= previousEnd : options.x + width >= previousEnd)) {\n        continue;\n      }\n\n      previousEnd = axis.isInversed ? options.x : options.x + width;\n\n      if (angle !== 0) {\n        rotateSize = this.getRotateText(isAxisBreakLabel, axis, label, angle, chart);\n        diffHeight = islabelInside ? rotateSize.height : axis.maxLabelSize.height - Math.ceil(rotateSize.height);\n        yLocation = axis.opposedPosition ? diffHeight * 0.5 : -diffHeight * 0.5;\n        options.transform = 'rotate(' + angle + ',' + (pointX + width * 0.5 + anglePadding) + ',' + (pointY + yLocation) + ')';\n        options.y = isAxisBreakLabel ? options.y + (isOpposed ? 4 * label.text.length : -(4 * label.text.length)) : options.y + yLocation;\n      }\n\n      textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabel, labelElement, axis.opposedPosition !== (axis.labelPosition === 'Inside'), chart.redraw, true);\n    }\n\n    if (!this.chart.enableCanvas) {\n      if (!chart.delayRedraw) {\n        parent.appendChild(labelElement);\n      } else if (axis.visible) {\n        this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n      }\n    }\n  };\n  /**\n   * To get axis label text\n   * @param breakLabels\n   * @param label\n   * @param axis\n   * @param intervalLength\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.getLabelText = function (label, axis, intervalLength) {\n    if (isBreakLabel(label.originalText)) {\n      var result = [];\n      var str = void 0;\n\n      for (var index = 0; index < label.text.length; index++) {\n        str = this.findAxisLabel(axis, label.text[index], intervalLength);\n        result.push(str);\n      }\n\n      return result;\n    } else {\n      return this.findAxisLabel(axis, label.text, intervalLength);\n    }\n  };\n  /**\n   * To render the x-axis label border.\n   * @param axis\n   * @param index\n   * @param parent\n   * @param axisRect\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawXAxisBorder = function (axis, index, parent, axisRect) {\n    if (axis.border.width > 0) {\n      var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\n      var startX = void 0;\n      var startY = axisRect.y + (axis.opposedPosition ? -1 : 1) * scrollBarHeight;\n      var padding = 10;\n      var pointX = void 0;\n      var gap = axisRect.width / axis.visibleRange.delta * (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n      var endX = void 0;\n      var length_2 = axis.maxLabelSize.height + (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0);\n      var labelBorder = '';\n      var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? -0.5 : 0;\n      var endY = axis.opposedPosition && axis.labelPosition === 'Inside' || !axis.opposedPosition && axis.labelPosition === 'Outside' ? axisRect.y + length_2 + padding + scrollBarHeight : axisRect.y - length_2 - padding - scrollBarHeight;\n\n      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n        pointX = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n        pointX = (axis.isInversed ? 1 - pointX : pointX) * axisRect.width;\n\n        if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n          startX = pointX + axisRect.x;\n          endX = pointX + gap + axisRect.x;\n        } else {\n          startX = pointX - gap * 0.5 + axisRect.x;\n          endX = pointX + gap * 0.5 + axisRect.x;\n        }\n\n        switch (axis.border.type) {\n          case 'Rectangle':\n          case 'WithoutTopBorder':\n            if (startX < axisRect.x) {\n              labelBorder += 'M' + ' ' + axisRect.x + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n            } else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1)) {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'L' + ' ' + (axisRect.width + axisRect.x) + ' ' + endY + ' ';\n            } else {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n\n              if (i === 0) {\n                labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'M ' + startX + ' ' + endY + ' L ' + axisRect.x + ' ' + endY;\n              }\n\n              if (i === axis.visibleLabels.length - 1) {\n                labelBorder += 'M' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ' + 'M ' + endX + ' ' + endY + ' L ' + (axisRect.width + axisRect.x) + ' ' + endY;\n              }\n            }\n\n            break;\n\n          case 'WithoutTopandBottomBorder':\n            if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'M ' + endX + ' ' + startY + ' L ' + endX + ' ' + endY;\n            }\n\n            break;\n        }\n      }\n\n      labelBorder += axis.border.type === 'Rectangle' ? 'M ' + ' ' + axisRect.x + ' ' + startY + 'L' + ' ' + (axisRect.x + axisRect.width) + ' ' + startY : '';\n\n      if (labelBorder !== '') {\n        this.createAxisBorderElement(axis, index, labelBorder, parent);\n      }\n    }\n\n    if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0) {\n      this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);\n    }\n  };\n  /**\n   * To create border element of the axis\n   * @param axis\n   * @param index\n   * @param labelBorder\n   * @param parent\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.createAxisBorderElement = function (axis, index, labelBorder, parent) {\n    var element = getElement(this.chart.element.id + '_BorderLine_' + index);\n    var direction = element ? element.getAttribute('d') : '';\n    var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + '_BorderLine_' + index, 'transparent', axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, '', labelBorder));\n    borderElement.setAttribute('style', 'pointer-events: none');\n    appendChildElement(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, true, 'x', 'y', null, direction, true);\n  };\n  /**\n   * To find the axis label of the intersect action\n   * @param axis\n   * @param label\n   * @param width\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.findAxisLabel = function (axis, label, width) {\n    return axis.labelIntersectAction === 'Trim' ? axis.angle === 0 && !axis.enableTrim ? textTrim(width, label, axis.labelStyle) : label : label;\n  };\n  /**\n   * X-Axis Title function performed\n   * @param axis\n   * @param index\n   * @param parent\n   * @param rect\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawXAxisTitle = function (axis, index, parent, rect) {\n    var chart = this.chart;\n    var elementSize = measureText(axis.title, axis.titleStyle);\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;\n    var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + this.padding) + (axis.labelPosition === 'Inside' ? 0 : axis.maxLabelSize.height + axis.multiLevelLabelHeight + this.padding);\n    padding = axis.opposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight) : padding + 3 * elementSize.height / 4 + scrollBarHeight;\n    var options = new TextOption(chart.element.id + '_AxisTitle_' + index, rect.x + rect.width * 0.5, rect.y + padding, 'middle', axis.title);\n    var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitle, parent);\n    element.setAttribute('aria-label', axis.description || axis.title);\n    element.setAttribute('tabindex', axis.tabIndex.toString());\n  };\n  /**\n   * To render the axis grid and tick lines(Both Major and Minor)\n   * @param axis\n   * @param index\n   * @param gridDirection\n   * @param gridModel\n   * @param gridId\n   * @param gridIndex\n   * @param parent\n   * @param themeColor\n   * @param dashArray\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.renderGridLine = function (axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray) {\n    if (dashArray === void 0) {\n      dashArray = null;\n    }\n\n    var chart = this.chart;\n    var direction;\n    var element;\n\n    if (gridModel.width > 0 && axis.visible && gridDirection) {\n      element = getElement(chart.element.id + gridId + index + '_' + gridIndex);\n      direction = element ? element.getAttribute('d') : null;\n      element = null;\n      this.htmlObject = chart.renderer.drawPath(new PathOption(chart.element.id + gridId + index + '_' + gridIndex, 'transparent', gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));\n      appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, true);\n    }\n  };\n  /**\n   * To Find the parent node of the axis\n   * @param chart\n   * @param label\n   * @param axis\n   * @param index\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.findParentNode = function (elementId, label, axis, index) {\n    if (axis.crossAt === null) {\n      return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');\n    }\n\n    if (document.getElementById(elementId + 'AxisGroup' + index + 'Inside').contains(document.getElementById(label.id))) {\n      return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');\n    } else {\n      return document.getElementById(elementId + 'AxisGroup' + index + 'Outside');\n    }\n  };\n  /**\n   * Create Zooming Labels Function Called here\n   * @param chart\n   * @param labelElement\n   * @param axis\n   * @param index\n   * @param rect\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.createZoomingLabel = function (chart, labelElement, axis, index, rect) {\n    var parentNode = this.findParentNode(chart.element.id, labelElement, axis, index);\n    labelElement.setAttribute('opacity', '0.3');\n    var zoomElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels_Zoom' + index\n    });\n    zoomElement = createZoomingLabels(chart, axis, zoomElement, index, axis.orientation === 'Vertical', rect);\n    parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));\n\n    if (getElement(chart.element.id + 'AxisLabels_Zoom' + index)) {\n      parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));\n    } else {\n      parentNode.appendChild(zoomElement);\n    }\n  };\n  /**\n   * To get Rotate text size\n   * @param isBreakLabel\n   * @param axis\n   * @param label\n   * @param angle\n   * @param chart\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.getRotateText = function (isBreakLabel, axis, label, angle, chart) {\n    if (isBreakLabel) {\n      return new Size(measureText(label.originalText, axis.labelStyle).height, measureText(label.originalText, axis.labelStyle).width);\n    } else {\n      return rotateTextSize(axis.labelStyle, label.text, angle, chart);\n    }\n  };\n\n  return CartesianAxisLayoutPanel;\n}();\n\nexport { CartesianAxisLayoutPanel };","map":null,"metadata":{},"sourceType":"module"}