{"ast":null,"code":"import { drawing } from '@progress/kendo-drawing';\nimport { Box } from '../../core';\nimport { setDefaultOptions, deepExtend, isArray } from '../../common';\nimport { ARROW, DEFAULT_WIDTH, DEFAULT_HEIGHT } from '../constants';\nimport Gauge from '../gauge';\nimport LinearScale from './linear-scale';\nimport ArrowLinearPointer from './arrow-linear-pointer';\nimport BarLinearPointer from './bar-linear-pointer';\nvar DEFAULT_MIN_WIDTH = 60;\nvar DEFAULT_MIN_HEIGHT = 60;\nvar Group = drawing.Group;\n\nvar LinearGauge = function (Gauge) {\n  function LinearGauge() {\n    Gauge.apply(this, arguments);\n  }\n\n  if (Gauge) LinearGauge.__proto__ = Gauge;\n  LinearGauge.prototype = Object.create(Gauge && Gauge.prototype);\n  LinearGauge.prototype.constructor = LinearGauge;\n\n  LinearGauge.prototype.reflow = function reflow(bbox) {\n    var pointers = this.pointers;\n    var bboxX = bbox.origin.x;\n    var bboxY = bbox.origin.y;\n    var box = new Box(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());\n    this.scale.reflow(box);\n\n    this._shrinkScaleWidth(box);\n\n    for (var i = 0; i < pointers.length; i++) {\n      pointers[i].reflow();\n    }\n\n    this.bbox = this._getBox(box);\n\n    this._alignElements();\n\n    this._shrinkElements();\n\n    this._buildVisual();\n\n    this._draw();\n  };\n\n  LinearGauge.prototype._buildVisual = function _buildVisual() {\n    var visuals = new Group();\n    var scaleElements = this.scale.render();\n    var pointers = this.pointers;\n    visuals.append(this.gaugeArea);\n    visuals.append(scaleElements);\n\n    for (var i = 0; i < pointers.length; i++) {\n      var current = pointers[i];\n      visuals.append(current.render());\n      current.value(current.options.value);\n    }\n\n    this._visuals = visuals;\n  };\n\n  LinearGauge.prototype._createModel = function _createModel() {\n    var this$1 = this;\n    var options = this.options;\n    var scale = this.scale = new LinearScale(options.scale, this.contextService);\n    this.pointers = [];\n    var pointers = options.pointer;\n    pointers = isArray(pointers) ? pointers : [pointers];\n\n    for (var i = 0; i < pointers.length; i++) {\n      var currentOptions = deepExtend({}, pointers[i], {\n        animation: {\n          transitions: options.transitions\n        }\n      });\n      var pointerType = currentOptions.shape === ARROW ? ArrowLinearPointer : BarLinearPointer;\n      this$1.pointers.push(new pointerType(scale, currentOptions));\n    }\n  };\n\n  LinearGauge.prototype._defaultSize = function _defaultSize() {\n    var vertical = this.options.scale.vertical;\n    return {\n      width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH,\n      height: vertical ? DEFAULT_HEIGHT : DEFAULT_MIN_HEIGHT\n    };\n  };\n\n  LinearGauge.prototype._getBox = function _getBox(box) {\n    var ref = this;\n    var scale = ref.scale;\n    var pointers = ref.pointers;\n    var boxCenter = box.center();\n    var plotAreaBox = pointers[0].box.clone().wrap(scale.box);\n\n    for (var i = 0; i < pointers.length; i++) {\n      plotAreaBox.wrap(pointers[i].box.clone());\n    }\n\n    var size;\n\n    if (scale.options.vertical) {\n      size = plotAreaBox.width() / 2;\n      plotAreaBox = new Box(boxCenter.x - size, box.y1, boxCenter.x + size, box.y2);\n    } else {\n      size = plotAreaBox.height() / 2;\n      plotAreaBox = new Box(box.x1, boxCenter.y - size, box.x2, boxCenter.y + size);\n    }\n\n    return plotAreaBox;\n  };\n\n  LinearGauge.prototype._alignElements = function _alignElements() {\n    var this$1 = this;\n    var ref = this;\n    var scale = ref.scale;\n    var pointers = ref.pointers;\n    var scaleBox = scale.box;\n    var box = pointers[0].box.clone().wrap(scale.box);\n    var plotAreaBox = this.bbox;\n\n    for (var i = 0; i < pointers.length; i++) {\n      box.wrap(pointers[i].box.clone());\n    }\n\n    var diff;\n\n    if (scale.options.vertical) {\n      diff = plotAreaBox.center().x - box.center().x;\n      scale.reflow(new Box(scaleBox.x1 + diff, plotAreaBox.y1, scaleBox.x2 + diff, plotAreaBox.y2));\n    } else {\n      diff = plotAreaBox.center().y - box.center().y;\n      scale.reflow(new Box(scaleBox.x1, scaleBox.y1 + diff, scaleBox.x2, scaleBox.y2 + diff));\n    }\n\n    for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n      pointers[i$1].reflow(this$1.bbox);\n    }\n  };\n\n  LinearGauge.prototype._shrinkScaleWidth = function _shrinkScaleWidth(bbox) {\n    var ref = this;\n    var scale = ref.scale;\n\n    if (!scale.options.vertical) {\n      var overflow = scale.contentBox().width() - bbox.width();\n\n      if (overflow > 0) {\n        scale.box.shrink(overflow, 0);\n        scale.box.alignTo(bbox, 'center');\n        scale.reflow(scale.box);\n      }\n    }\n  };\n\n  LinearGauge.prototype._shrinkElements = function _shrinkElements() {\n    var this$1 = this;\n    var ref = this;\n    var scale = ref.scale;\n    var pointers = ref.pointers;\n    var scaleBox = scale.box.clone();\n    var pos = scale.options.vertical ? \"y\" : \"x\";\n    var pointerBox = pointers[0].box;\n\n    for (var i = 0; i < pointers.length; i++) {\n      pointerBox.wrap(pointers[i].box.clone());\n    }\n\n    scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);\n    scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);\n    scale.reflow(scaleBox);\n\n    for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n      pointers[i$1].reflow(this$1.bbox);\n    }\n  };\n\n  return LinearGauge;\n}(Gauge);\n\nsetDefaultOptions(LinearGauge, {\n  transitions: true,\n  gaugeArea: {\n    background: \"\"\n  },\n  scale: {\n    vertical: true\n  }\n});\nexport default LinearGauge;","map":null,"metadata":{},"sourceType":"module"}