{"ast":null,"code":"import Aggregates from './aggregates';\nimport { Class, defined, inArray, isArray, isFunction, isNumber, isObject } from '../../common';\n\nvar SeriesAggregator = function (Class) {\n  function SeriesAggregator(series, binder, defaultAggregates) {\n    Class.call(this);\n    var canonicalFields = binder.canonicalFields(series);\n    var valueFields = binder.valueFields(series);\n    var sourceFields = binder.sourceFields(series, canonicalFields);\n    var seriesFields = this._seriesFields = [];\n    var defaults = defaultAggregates.query(series.type);\n    var rootAggregate = series.aggregate || defaults;\n    this._series = series;\n    this._binder = binder;\n\n    for (var i = 0; i < canonicalFields.length; i++) {\n      var field = canonicalFields[i];\n      var fieldAggregate = void 0;\n\n      if (isObject(rootAggregate)) {\n        fieldAggregate = rootAggregate[field];\n      } else if (i === 0 || inArray(field, valueFields)) {\n        fieldAggregate = rootAggregate;\n      } else {\n        break;\n      }\n\n      if (fieldAggregate) {\n        seriesFields.push({\n          canonicalName: field,\n          name: sourceFields[i],\n          transform: isFunction(fieldAggregate) ? fieldAggregate : Aggregates[fieldAggregate]\n        });\n      }\n    }\n  }\n\n  if (Class) SeriesAggregator.__proto__ = Class;\n  SeriesAggregator.prototype = Object.create(Class && Class.prototype);\n  SeriesAggregator.prototype.constructor = SeriesAggregator;\n\n  SeriesAggregator.prototype.aggregatePoints = function aggregatePoints(srcPoints, group) {\n    var this$1 = this;\n    var ref = this;\n    var series = ref._series;\n    var seriesFields = ref._seriesFields;\n\n    var data = this._bindPoints(srcPoints || []);\n\n    var firstDataItem = data.dataItems[0];\n    var result = {};\n\n    if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {\n      var fn = function () {};\n\n      fn.prototype = firstDataItem;\n      result = new fn();\n    }\n\n    for (var i = 0; i < seriesFields.length; i++) {\n      var field = seriesFields[i];\n\n      var srcValues = this$1._bindField(data.values, field.canonicalName);\n\n      var value = field.transform(srcValues, series, data.dataItems, group);\n\n      if (value !== null && isObject(value) && !defined(value.length) && !(value instanceof Date)) {\n        result = value;\n        break;\n      } else {\n        if (defined(value)) {\n          setValue(field.name, result, value);\n        }\n      }\n    }\n\n    return result;\n  };\n\n  SeriesAggregator.prototype._bindPoints = function _bindPoints(points) {\n    var ref = this;\n    var binder = ref._binder;\n    var series = ref._series;\n    var values = [];\n    var dataItems = [];\n\n    for (var i = 0; i < points.length; i++) {\n      var pointIx = points[i];\n      values.push(binder.bindPoint(series, pointIx));\n      dataItems.push(series.data[pointIx]);\n    }\n\n    return {\n      values: values,\n      dataItems: dataItems\n    };\n  };\n\n  SeriesAggregator.prototype._bindField = function _bindField(data, field) {\n    var values = [];\n    var count = data.length;\n\n    for (var i = 0; i < count; i++) {\n      var item = data[i];\n      var valueFields = item.valueFields;\n      var value = void 0;\n\n      if (defined(valueFields[field])) {\n        value = valueFields[field];\n      } else {\n        value = item.fields[field];\n      }\n\n      values.push(value);\n    }\n\n    return values;\n  };\n\n  return SeriesAggregator;\n}(Class);\n\nfunction setValue(fieldName, target, value) {\n  var parentObj = target;\n  var field = fieldName;\n\n  if (fieldName.indexOf(\".\") > -1) {\n    var parts = fieldName.split(\".\");\n\n    while (parts.length > 1) {\n      field = parts.shift();\n\n      if (!defined(parentObj[field])) {\n        parentObj[field] = {};\n      }\n\n      parentObj = parentObj[field];\n    }\n\n    field = parts.shift();\n  }\n\n  parentObj[field] = value;\n}\n\nexport default SeriesAggregator;","map":null,"metadata":{},"sourceType":"module"}