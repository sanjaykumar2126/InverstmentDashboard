{"ast":null,"code":"import { geometry as geom, Color } from '@progress/kendo-drawing';\nimport { ChartElement, TextBox } from '../../core';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport FunnelSegment from './funnel-segment';\nimport { bindSegments, evalOptions } from '../utils';\nimport { BLACK, WHITE, CENTER, LEFT } from '../../common/constants';\nimport { deepExtend, isFunction, getTemplate, limitValue, setDefaultOptions } from '../../common';\n\nvar FunnelChart = function (ChartElement) {\n  function FunnelChart(plotArea, options) {\n    ChartElement.call(this, options);\n    this.plotArea = plotArea;\n    this.points = [];\n    this.labels = [];\n    this.legendItems = [];\n    this.render();\n  }\n\n  if (ChartElement) FunnelChart.__proto__ = ChartElement;\n  FunnelChart.prototype = Object.create(ChartElement && ChartElement.prototype);\n  FunnelChart.prototype.constructor = FunnelChart;\n\n  FunnelChart.prototype.formatPointValue = function formatPointValue(point, format) {\n    return this.chartService.format.auto(format, point.value);\n  };\n\n  FunnelChart.prototype.render = function render() {\n    var this$1 = this;\n    var ref = this;\n    var options = ref.options;\n    var seriesColors = ref.plotArea.options.seriesColors;\n    if (seriesColors === void 0) seriesColors = [];\n    var series = options.series[0];\n    var data = series.data;\n\n    if (!data) {\n      return;\n    }\n\n    var ref$1 = bindSegments(series);\n    var total = ref$1.total;\n    var points = ref$1.points;\n\n    for (var i = 0; i < points.length; i++) {\n      var pointData = points[i];\n\n      if (!pointData) {\n        continue;\n      }\n\n      var fields = pointData.fields;\n\n      if (!isFunction(series.color)) {\n        series.color = fields.color || seriesColors[i % seriesColors.length];\n      }\n\n      fields = deepExtend({\n        index: i,\n        owner: this$1,\n        series: series,\n        dataItem: data[i],\n        percentage: pointData.value / total\n      }, fields, {\n        visible: pointData.visible\n      });\n      var value = pointData.valueFields.value;\n      var segment = this$1.createSegment(value, fields);\n      var label = this$1.createLabel(value, fields);\n\n      if (segment && label) {\n        segment.append(label);\n      }\n    }\n  };\n\n  FunnelChart.prototype.evalSegmentOptions = function evalSegmentOptions(options, value, fields) {\n    var series = fields.series;\n    evalOptions(options, {\n      value: value,\n      series: series,\n      dataItem: fields.dataItem,\n      index: fields.index\n    }, {\n      defaults: series._defaults,\n      excluded: [\"data\", \"content\", \"template\", \"toggle\", \"visual\"]\n    });\n  };\n\n  FunnelChart.prototype.createSegment = function createSegment(value, fields) {\n    var seriesOptions = deepExtend({}, fields.series);\n    this.evalSegmentOptions(seriesOptions, value, fields);\n    this.createLegendItem(value, seriesOptions, fields);\n\n    if (fields.visible !== false) {\n      var segment = new FunnelSegment(value, seriesOptions, fields);\n      Object.assign(segment, fields);\n      this.append(segment);\n      this.points.push(segment);\n      return segment;\n    }\n  };\n\n  FunnelChart.prototype.createLabel = function createLabel(value, fields) {\n    var series = fields.series;\n    var dataItem = fields.dataItem;\n    var labels = deepExtend({}, this.options.labels, series.labels);\n    var text = value;\n\n    if (labels.visible) {\n      var labelTemplate = getTemplate(labels);\n      var data = {\n        dataItem: dataItem,\n        value: value,\n        percentage: fields.percentage,\n        category: fields.category,\n        series: series\n      };\n\n      if (labelTemplate) {\n        text = labelTemplate(data);\n      } else if (labels.format) {\n        text = this.plotArea.chartService.format.auto(labels.format, text);\n      }\n\n      if (!labels.color) {\n        var brightnessValue = new Color(series.color).percBrightness();\n\n        if (brightnessValue > 180) {\n          labels.color = BLACK;\n        } else {\n          labels.color = WHITE;\n        }\n\n        if (!labels.background) {\n          labels.background = series.color;\n        }\n      }\n\n      this.evalSegmentOptions(labels, value, fields);\n      var textBox = new TextBox(text, deepExtend({\n        vAlign: labels.position\n      }, labels), data);\n      this.labels.push(textBox);\n      return textBox;\n    }\n  };\n\n  FunnelChart.prototype.labelPadding = function labelPadding() {\n    var labels = this.labels;\n    var padding = {\n      left: 0,\n      right: 0\n    };\n\n    for (var i = 0; i < labels.length; i++) {\n      var label = labels[i];\n      var align = label.options.align;\n\n      if (align !== CENTER) {\n        var width = labels[i].box.width();\n\n        if (align === LEFT) {\n          padding.left = Math.max(padding.left, width);\n        } else {\n          padding.right = Math.max(padding.right, width);\n        }\n      }\n    }\n\n    return padding;\n  };\n\n  FunnelChart.prototype.dynamicSlopeReflow = function dynamicSlopeReflow(box, width, totalHeight) {\n    var ref = this;\n    var options = ref.options;\n    var segments = ref.points;\n    var count = segments.length;\n    var firstSegment = segments[0];\n    var maxSegment = firstSegment;\n\n    for (var idx = 0; idx < segments.length; idx++) {\n      if (segments[idx].percentage > maxSegment.percentage) {\n        maxSegment = segments[idx];\n      }\n    }\n\n    var lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;\n    var previousOffset = (width - lastUpperSide) / 2;\n    var previousHeight = 0;\n\n    for (var idx$1 = 0; idx$1 < count; idx$1++) {\n      var percentage = segments[idx$1].percentage;\n      var nextSegment = segments[idx$1 + 1];\n      var nextPercentage = nextSegment ? nextSegment.percentage : percentage;\n      var points = segments[idx$1].points = [];\n      var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;\n      var offset = void 0;\n\n      if (!percentage) {\n        offset = nextPercentage ? 0 : width / 2;\n      } else {\n        offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\n      }\n\n      offset = limitValue(offset, 0, width);\n      points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - offset, box.y1 + height + previousHeight));\n      points.push(new geom.Point(box.x1 + offset, box.y1 + height + previousHeight));\n      previousOffset = offset;\n      previousHeight += height + options.segmentSpacing;\n      lastUpperSide = limitValue(width - 2 * offset, 0, width);\n    }\n  };\n\n  FunnelChart.prototype.constantSlopeReflow = function constantSlopeReflow(box, width, totalHeight) {\n    var ref = this;\n    var options = ref.options;\n    var segments = ref.points;\n    var count = segments.length;\n    var decreasingWidth = options.neckRatio <= 1;\n    var neckRatio = decreasingWidth ? options.neckRatio * width : width;\n    var previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\n    var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\n    var finalNarrow = (topMostWidth - neckRatio) / 2;\n    var previousHeight = 0;\n\n    for (var idx = 0; idx < count; idx++) {\n      var points = segments[idx].points = [];\n      var percentage = segments[idx].percentage;\n      var offset = options.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;\n      var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;\n      points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\n      points.push(new geom.Point(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));\n      previousOffset += offset;\n      previousHeight += height + options.segmentSpacing;\n    }\n  };\n\n  FunnelChart.prototype.reflow = function reflow(chartBox) {\n    var points = this.points;\n    var count = points.length;\n\n    if (!count) {\n      return;\n    }\n\n    var options = this.options;\n    var box = chartBox.clone().unpad(this.labelPadding());\n    var totalHeight = box.height() - options.segmentSpacing * (count - 1);\n    var width = box.width();\n\n    if (options.dynamicSlope) {\n      this.dynamicSlopeReflow(box, width, totalHeight);\n    } else {\n      this.constantSlopeReflow(box, width, totalHeight);\n    }\n\n    for (var idx = 0; idx < count; idx++) {\n      points[idx].reflow(chartBox);\n    }\n  };\n\n  return FunnelChart;\n}(ChartElement);\n\nsetDefaultOptions(FunnelChart, {\n  neckRatio: 0.3,\n  width: 300,\n  dynamicSlope: false,\n  dynamicHeight: true,\n  segmentSpacing: 0,\n  labels: {\n    visible: false,\n    align: CENTER,\n    position: CENTER,\n    zIndex: 1\n  }\n});\ndeepExtend(FunnelChart.prototype, PieChartMixin);\nexport default FunnelChart;","map":null,"metadata":{},"sourceType":"module"}