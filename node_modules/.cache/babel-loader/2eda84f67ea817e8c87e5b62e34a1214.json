{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { ChartLocation, ControlPoints } from '../../common/utils/helper';\nimport { extend, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { LineBase } from './line-base';\n/**\n * render Line series\n */\n\nvar SplineBase =\n/** @class */\nfunction (_super) {\n  __extends(SplineBase, _super);\n  /** @private */\n\n\n  function SplineBase(chartModule) {\n    var _this = _super.call(this, chartModule) || this;\n\n    _this.splinePoints = [];\n    return _this;\n  }\n  /**\n   * To find the control points for spline.\n   * @return {void}\n   * @private\n   */\n\n\n  SplineBase.prototype.findSplinePoint = function (series) {\n    var value;\n    var points = this.filterEmptyPoints(series);\n    this.splinePoints = this.findSplineCoefficients(points, series);\n\n    if (points.length > 1) {\n      series.drawPoints = [];\n\n      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n        var point = points_1[_i];\n\n        if (point.index !== 0) {\n          var previous = this.getPreviousIndex(points, point.index - 1, series);\n          value = this.getControlPoints(points[previous], point, this.splinePoints[previous], this.splinePoints[point.index], series);\n          series.drawPoints.push(value); // fix for Y-Axis of Spline chart not adjusting scale to suit dataSource issue \n\n          var delta = series.yMax - series.yMin;\n\n          if (point.yValue && value.controlPoint1.y && value.controlPoint2.y && delta > 1) {\n            series.yMin = Math.floor(Math.min(series.yMin, point.yValue, value.controlPoint1.y, value.controlPoint2.y));\n            series.yMax = Math.ceil(Math.max(series.yMax, point.yValue, value.controlPoint1.y, value.controlPoint2.y));\n          }\n        }\n      }\n    }\n  };\n\n  SplineBase.prototype.getPreviousIndex = function (points, i, series) {\n    if (series.emptyPointSettings.mode !== 'Drop') {\n      return i;\n    }\n\n    while (isNullOrUndefined(points[i]) && i > -1) {\n      i = i - 1;\n    }\n\n    return i;\n  };\n\n  SplineBase.prototype.getNextIndex = function (points, i, series) {\n    if (series.emptyPointSettings.mode !== 'Drop') {\n      return i;\n    }\n\n    while (isNullOrUndefined(points[i]) && i < points.length) {\n      i = i + 1;\n    }\n\n    return i;\n  };\n\n  SplineBase.prototype.filterEmptyPoints = function (series) {\n    if (series.emptyPointSettings.mode !== 'Drop') {\n      return series.points;\n    }\n\n    var points = extend([], series.points, null, true);\n\n    for (var i = 0; i < points.length; i++) {\n      points[i].index = i;\n\n      if (points[i].isEmpty) {\n        points[i].symbolLocations = [];\n        points[i].regions = [];\n        points.splice(i, 1);\n        i--;\n      }\n    }\n\n    return points;\n  };\n  /**\n   * To find the natural spline.\n   * @return {void}\n   * @private\n   */\n\n\n  SplineBase.prototype.findSplineCoefficients = function (points, series) {\n    var count = points.length;\n    var ySpline = [];\n    var ySplineDuplicate = [];\n    var coefficient1;\n    var coefficient2;\n    var coefficient3;\n    var dy1;\n    var dy2;\n    var dx = [];\n    var dy = [];\n    var slope = [];\n    var interPoint;\n    var slopeLength;\n    var cardinalSplineTension = series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;\n    cardinalSplineTension = cardinalSplineTension < 0 ? 0 : cardinalSplineTension > 1 ? 1 : cardinalSplineTension;\n\n    switch (series.splineType) {\n      case 'Monotonic':\n        for (var i = 0; i < count - 1; i++) {\n          dx[i] = points[i + 1].xValue - points[i].xValue;\n          dy[i] = points[i + 1].yValue - points[i].yValue;\n          slope[i] = dy[i] / dx[i];\n        } //interpolant points\n\n\n        slopeLength = slope.length; // to find the first and last co-efficient value\n\n        ySpline[0] = slope[0];\n        ySpline[count - 1] = slope[slopeLength - 1]; //to find the other co-efficient values\n\n        for (var j = 0; j < dx.length; j++) {\n          if (slopeLength > j + 1) {\n            if (slope[j] * slope[j + 1] <= 0) {\n              ySpline[j + 1] = 0;\n            } else {\n              interPoint = dx[j] + dx[j + 1];\n              ySpline[j + 1] = 3 * interPoint / ((interPoint + dx[j + 1]) / slope[j] + (interPoint + dx[j]) / slope[j + 1]);\n            }\n          }\n        }\n\n        break;\n\n      case 'Cardinal':\n        for (var i = 0; i < count; i++) {\n          if (i === 0) {\n            ySpline[i] = count > 2 ? cardinalSplineTension * (points[i + 2].xValue - points[i].xValue) : 0;\n          } else if (i === count - 1) {\n            ySpline[i] = count > 2 ? cardinalSplineTension * (points[count - 1].xValue - points[count - 3].xValue) : 0;\n          } else {\n            ySpline[i] = cardinalSplineTension * (points[i + 1].xValue - points[i - 1].xValue);\n          }\n        }\n\n        break;\n\n      default:\n        if (series.splineType === 'Clamped') {\n          var firstIndex = (points[1].yValue - points[0].yValue) / (points[1].xValue - points[0].xValue);\n          var lastIndex = (points[count - 1].xValue - points[count - 2].xValue) / (points[count - 1].yValue - points[count - 2].yValue);\n          ySpline[0] = 3 * (points[1].yValue - points[0].yValue) / (points[1].xValue - points[0].xValue) - 3;\n          ySplineDuplicate[0] = 0.5;\n          ySpline[points.length - 1] = 3 * (points[points.length - 1].yValue - points[points.length - 2].yValue) / (points[points.length - 1].xValue - points[points.length - 2].xValue);\n          ySpline[0] = ySplineDuplicate[0] = Math.abs(ySpline[0]) === Infinity ? 0 : ySpline[0];\n          ySpline[points.length - 1] = ySplineDuplicate[points.length - 1] = Math.abs(ySpline[points.length - 1]) === Infinity ? 0 : ySpline[points.length - 1];\n        } else {\n          // assigning the first and last value as zero\n          ySpline[0] = ySplineDuplicate[0] = 0;\n          ySpline[points.length - 1] = 0;\n        }\n\n        for (var i = 1; i < count - 1; i++) {\n          coefficient1 = points[i].xValue - points[i - 1].xValue;\n          coefficient2 = points[i + 1].xValue - points[i - 1].xValue;\n          coefficient3 = points[i + 1].xValue - points[i].xValue;\n          dy1 = points[i + 1].yValue - points[i].yValue || null;\n          dy2 = points[i].yValue - points[i - 1].yValue || null;\n\n          if (coefficient1 === 0 || coefficient2 === 0 || coefficient3 === 0) {\n            ySpline[i] = 0;\n            ySplineDuplicate[i] = 0;\n          } else {\n            var p = 1 / (coefficient1 * ySpline[i - 1] + 2 * coefficient2);\n            ySpline[i] = -p * coefficient3;\n            ySplineDuplicate[i] = p * (6 * (dy1 / coefficient3 - dy2 / coefficient1) - coefficient1 * ySplineDuplicate[i - 1]);\n          }\n        }\n\n        for (var k = count - 2; k >= 0; k--) {\n          ySpline[k] = ySpline[k] * ySpline[k + 1] + ySplineDuplicate[k];\n        }\n\n        break;\n    }\n\n    return ySpline;\n  };\n  /**\n   * To find the control points for spline.\n   * @return {void}\n   * @private\n   */\n\n\n  SplineBase.prototype.getControlPoints = function (point1, point2, ySpline1, ySpline2, series) {\n    var controlPoint1;\n    var controlPoint2;\n    var point;\n    var ySplineDuplicate1 = ySpline1;\n    var ySplineDuplicate2 = ySpline2;\n\n    switch (series.splineType) {\n      case 'Cardinal':\n        if (series.xAxis.valueType === 'DateTime') {\n          ySplineDuplicate1 = ySpline1 / this.dateTimeInterval(series);\n          ySplineDuplicate2 = ySpline2 / this.dateTimeInterval(series);\n        }\n\n        controlPoint1 = new ChartLocation(point1.xValue + ySpline1 / 3, point1.yValue + ySplineDuplicate1 / 3);\n        controlPoint2 = new ChartLocation(point2.xValue - ySpline2 / 3, point2.yValue - ySplineDuplicate2 / 3);\n        point = new ControlPoints(controlPoint1, controlPoint2);\n        break;\n\n      case 'Monotonic':\n        var value = (point2.xValue - point1.xValue) / 3;\n        controlPoint1 = new ChartLocation(point1.xValue + value, point1.yValue + ySpline1 * value);\n        controlPoint2 = new ChartLocation(point2.xValue - value, point2.yValue - ySpline2 * value);\n        point = new ControlPoints(controlPoint1, controlPoint2);\n        break;\n\n      default:\n        var one3 = 1 / 3.0;\n        var deltaX2 = point2.xValue - point1.xValue;\n        deltaX2 = deltaX2 * deltaX2;\n        var y1 = one3 * (2 * point1.yValue + point2.yValue - one3 * deltaX2 * (ySpline1 + 0.5 * ySpline2));\n        var y2 = one3 * (point1.yValue + 2 * point2.yValue - one3 * deltaX2 * (0.5 * ySpline1 + ySpline2));\n        controlPoint1 = new ChartLocation((2 * point1.xValue + point2.xValue) * one3, y1);\n        controlPoint2 = new ChartLocation((point1.xValue + 2 * point2.xValue) * one3, y2);\n        point = new ControlPoints(controlPoint1, controlPoint2);\n        break;\n    }\n\n    return point;\n  };\n  /**\n   * calculate datetime interval in hours\n   *\n   */\n\n\n  SplineBase.prototype.dateTimeInterval = function (series) {\n    var interval = series.xAxis.actualIntervalType;\n    var intervalInMilliseconds;\n\n    if (interval === 'Years') {\n      intervalInMilliseconds = 365 * 24 * 60 * 60 * 1000;\n    } else if (interval === 'Months') {\n      intervalInMilliseconds = 30 * 24 * 60 * 60 * 1000;\n    } else if (interval === 'Days') {\n      intervalInMilliseconds = 24 * 60 * 60 * 1000;\n    } else if (interval === 'Hours') {\n      intervalInMilliseconds = 60 * 60 * 1000;\n    } else if (interval === 'Minutes') {\n      intervalInMilliseconds = 60 * 1000;\n    } else if (interval === 'Seconds') {\n      intervalInMilliseconds = 1000;\n    } else {\n      intervalInMilliseconds = 30 * 24 * 60 * 60 * 1000;\n    }\n\n    return intervalInMilliseconds;\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  SplineBase.prototype.doAnimation = function (series) {\n    var option = series.animation;\n    this.doLinearAnimation(series, option);\n  };\n\n  return SplineBase;\n}(LineBase);\n\nexport { SplineBase };","map":null,"metadata":{},"sourceType":"module"}