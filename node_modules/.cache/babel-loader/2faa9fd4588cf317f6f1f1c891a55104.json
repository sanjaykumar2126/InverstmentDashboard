{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Property, Complex, ChildProperty } from '@syncfusion/ej2-base';\nimport { measureText, Rect, TextOption, Size, PathOption } from '@syncfusion/ej2-svg-base';\nimport { Font, Border, Margin } from '../model/base';\nimport { Theme } from '../model/theme';\nimport { subtractThickness, Thickness, drawSymbol, ChartLocation } from '../utils/helper';\nimport { RectOption, textElement, stringToNumber } from '../utils/helper';\nimport { removeElement, showTooltip, getElement, appendChildElement } from '../utils/helper';\n/**\n * Configures the location for the legend.\n */\n\nvar Location =\n/** @class */\nfunction (_super) {\n  __extends(Location, _super);\n\n  function Location() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(0)], Location.prototype, \"x\", void 0);\n\n  __decorate([Property(0)], Location.prototype, \"y\", void 0);\n\n  return Location;\n}(ChildProperty);\n\nexport { Location };\n/**\n * Configures the legends in charts.\n */\n\nvar LegendSettings =\n/** @class */\nfunction (_super) {\n  __extends(LegendSettings, _super);\n\n  function LegendSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(true)], LegendSettings.prototype, \"visible\", void 0);\n\n  __decorate([Property(null)], LegendSettings.prototype, \"height\", void 0);\n\n  __decorate([Property(null)], LegendSettings.prototype, \"width\", void 0);\n\n  __decorate([Complex({\n    x: 0,\n    y: 0\n  }, Location)], LegendSettings.prototype, \"location\", void 0);\n\n  __decorate([Property('Auto')], LegendSettings.prototype, \"position\", void 0);\n\n  __decorate([Property(8)], LegendSettings.prototype, \"padding\", void 0);\n\n  __decorate([Property('Center')], LegendSettings.prototype, \"alignment\", void 0);\n\n  __decorate([Complex(Theme.legendLabelFont, Font)], LegendSettings.prototype, \"textStyle\", void 0);\n\n  __decorate([Property(10)], LegendSettings.prototype, \"shapeHeight\", void 0);\n\n  __decorate([Property(10)], LegendSettings.prototype, \"shapeWidth\", void 0);\n\n  __decorate([Complex({}, Border)], LegendSettings.prototype, \"border\", void 0);\n\n  __decorate([Complex({\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  }, Margin)], LegendSettings.prototype, \"margin\", void 0);\n\n  __decorate([Property(5)], LegendSettings.prototype, \"shapePadding\", void 0);\n\n  __decorate([Property('transparent')], LegendSettings.prototype, \"background\", void 0);\n\n  __decorate([Property(1)], LegendSettings.prototype, \"opacity\", void 0);\n\n  __decorate([Property(true)], LegendSettings.prototype, \"toggleVisibility\", void 0);\n\n  __decorate([Property(null)], LegendSettings.prototype, \"description\", void 0);\n\n  __decorate([Property(3)], LegendSettings.prototype, \"tabIndex\", void 0);\n\n  return LegendSettings;\n}(ChildProperty);\n\nexport { LegendSettings };\n/**\n * Legend base class for Chart and Accumulation chart.\n * @private\n */\n\nvar BaseLegend =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the dateTime module.\n   * @private\n   */\n  function BaseLegend(chart) {\n    this.rowCount = 0; // legend row counts per page\n\n    this.columnCount = 0; // legend column counts per page\n\n    this.pageButtonSize = 8;\n    this.pageXCollections = []; // pages of x locations\n\n    this.maxColumns = 0;\n    this.isTrimmed = false;\n    this.maxWidth = 0;\n    this.currentPage = 1;\n    this.currentPageNumber = 1;\n    this.legendRegions = [];\n    this.pagingRegions = [];\n    this.chart = chart;\n    this.legend = chart.legendSettings;\n    this.legendID = chart.element.id + '_chart_legend';\n    this.isChartControl = chart.getModuleName() === 'chart';\n  }\n  /**\n   * Calculate the bounds for the legends.\n   * @return {void}\n   * @private\n   */\n\n\n  BaseLegend.prototype.calculateLegendBounds = function (rect, availableSize) {\n    var legend = this.legend;\n    this.getPosition(legend.position, availableSize);\n    this.legendBounds = new Rect(rect.x, rect.y, 0, 0);\n    this.isVertical = this.position === 'Left' || this.position === 'Right';\n\n    if (this.isVertical) {\n      this.legendBounds.height = stringToNumber(legend.height, availableSize.height - (rect.y - this.chart.margin.top)) || rect.height;\n      this.legendBounds.width = stringToNumber(legend.width || '20%', availableSize.width);\n    } else {\n      this.legendBounds.width = stringToNumber(legend.width, availableSize.width) || rect.width;\n      this.legendBounds.height = stringToNumber(legend.height || '20%', availableSize.height);\n    }\n\n    this.library.getLegendBounds(availableSize, this.legendBounds, legend);\n    this.getLocation(this.position, legend.alignment, this.legendBounds, rect, availableSize);\n  };\n  /**\n   * To find legend position based on available size for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.getPosition = function (position, availableSize) {\n    if (this.isChartControl) {\n      this.position = position !== 'Auto' ? position : 'Bottom';\n    } else {\n      if (position === 'Auto' && this.chart.visibleSeries && (this.chart.visibleSeries[0].type === 'Funnel' || this.chart.visibleSeries[0].type === 'Pyramid')) {\n        position = 'Top';\n      }\n\n      this.position = position !== 'Auto' ? position : availableSize.width > availableSize.height ? 'Right' : 'Bottom';\n    }\n  };\n  /**\n   * To set bounds for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.setBounds = function (computedWidth, computedHeight, legend, legendBounds) {\n    computedWidth = computedWidth < legendBounds.width ? computedWidth : legendBounds.width;\n    computedHeight = computedHeight < legendBounds.height ? computedHeight : legendBounds.height;\n    legendBounds.width = !legend.width ? computedWidth : legendBounds.width;\n    legendBounds.height = !legend.height ? computedHeight : legendBounds.height;\n    this.rowCount = Math.max(1, Math.ceil((legendBounds.height - legend.padding) / (this.maxItemHeight + legend.padding)));\n  };\n  /**\n   * To find legend location based on position, alignment for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.getLocation = function (position, alignment, legendBounds, rect, availableSize) {\n    var padding = this.legend.border.width;\n    var legendHeight = legendBounds.height + padding + this.legend.margin.top + this.legend.margin.bottom;\n    var legendWidth = legendBounds.width + padding + this.legend.margin.left + this.legend.margin.right;\n    var marginBottom = this.chart.margin.bottom;\n\n    if (position === 'Bottom') {\n      legendBounds.x = this.alignLegend(legendBounds.x, availableSize.width, legendBounds.width, alignment);\n      legendBounds.y = rect.y + (rect.height - legendHeight) + padding + this.legend.margin.top;\n      subtractThickness(rect, new Thickness(0, 0, 0, legendHeight));\n    } else if (position === 'Top') {\n      legendBounds.x = this.alignLegend(legendBounds.x, availableSize.width, legendBounds.width, alignment);\n      legendBounds.y = rect.y + padding + this.legend.margin.top;\n      subtractThickness(rect, new Thickness(0, 0, legendHeight, 0));\n    } else if (position === 'Right') {\n      legendBounds.x = rect.x + (rect.width - legendBounds.width) - this.legend.margin.right;\n      legendBounds.y = rect.y + this.alignLegend(0, availableSize.height - (rect.y + marginBottom), legendBounds.height, alignment);\n      subtractThickness(rect, new Thickness(0, legendWidth, 0, 0));\n    } else if (position === 'Left') {\n      legendBounds.x = legendBounds.x + this.legend.margin.left;\n      legendBounds.y = rect.y + this.alignLegend(0, availableSize.height - (rect.y + marginBottom), legendBounds.height, alignment);\n      subtractThickness(rect, new Thickness(legendWidth, 0, 0, 0));\n    } else {\n      legendBounds.x = this.legend.location.x;\n      legendBounds.y = this.legend.location.y;\n      subtractThickness(rect, new Thickness(0, 0, 0, 0));\n    }\n  };\n  /**\n   * To find legend alignment for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.alignLegend = function (start, size, legendSize, alignment) {\n    switch (alignment) {\n      case 'Far':\n        start = size - legendSize - start;\n        break;\n\n      case 'Center':\n        start = (size - legendSize) / 2;\n        break;\n    }\n\n    return start;\n  };\n  /**\n   * Renders the legend.\n   * @return {void}\n   * @private\n   */\n\n\n  BaseLegend.prototype.renderLegend = function (chart, legend, legendBounds, redraw) {\n    var firstLegend = this.findFirstLegendPosition(this.legendCollections);\n    var padding = legend.padding;\n    this.legendRegions = [];\n    this.maxItemHeight = Math.max(this.legendCollections[0].textSize.height, legend.shapeHeight);\n    var legendGroup = chart.renderer.createGroup({\n      id: this.legendID + '_g'\n    });\n    var legendTranslateGroup = this.createLegendElements(chart, legendBounds, legendGroup, legend, this.legendID, redraw);\n\n    if (firstLegend !== this.legendCollections.length) {\n      var legendSeriesGroup = void 0; // legendItem group for each series group element\n\n      var start = void 0; // starting shape center x,y position && to resolve lint error used new line for declaration\n\n      start = new ChartLocation(legendBounds.x + padding + legend.shapeWidth / 2, legendBounds.y + padding + this.maxItemHeight / 2);\n      var textOptions = new TextOption('', start.x, start.y, 'start'); //  initialization for totalPages legend click totalpage again calculate\n\n      this.totalPages = this.isChartControl ? this.totalPages : 0;\n      var textPadding = legend.shapePadding + padding + legend.shapeWidth;\n      var count = 0;\n      this.pageXCollections = [];\n      this.legendCollections[firstLegend].location = start;\n      var previousLegend = this.legendCollections[firstLegend];\n\n      for (var _i = 0, _a = this.legendCollections; _i < _a.length; _i++) {\n        var legendOption = _a[_i];\n\n        if (this.chart.getModuleName() === 'accumulationchart') {\n          legendOption.fill = this.chart.visibleSeries[0].points[legendOption.pointIndex].color;\n        }\n\n        if (legendOption.render && legendOption.text !== '') {\n          legendSeriesGroup = chart.renderer.createGroup({\n            id: this.legendID + this.generateId(legendOption, '_g_', count)\n          });\n\n          if (legendSeriesGroup) {\n            legendSeriesGroup.setAttribute('tabindex', legend.tabIndex.toString());\n            legendSeriesGroup.setAttribute('aria-label', legend.description || 'Click to show or hide the ' + legendOption.text + ' series');\n          }\n\n          this.library.getRenderPoint(legendOption, start, textPadding, previousLegend, legendBounds, count, firstLegend);\n          this.renderSymbol(legendOption, legendSeriesGroup, count);\n          this.renderText(chart, legendOption, legendSeriesGroup, textOptions, count);\n\n          if (legendSeriesGroup) {\n            legendSeriesGroup.setAttribute('style', 'cursor: ' + (!legend.toggleVisibility && chart.selectionMode === 'None' ? 'auto' : 'pointer'));\n          }\n\n          if (legendTranslateGroup) {\n            legendTranslateGroup.appendChild(legendSeriesGroup);\n          }\n\n          previousLegend = legendOption;\n        }\n\n        count++;\n      }\n\n      if (this.isPaging) {\n        this.renderPagingElements(chart, legendBounds, textOptions, legendGroup);\n      } else {\n        this.totalPages = 1;\n      }\n    }\n\n    appendChildElement(chart.enableCanvas, chart.svgObject, legendGroup, redraw);\n  };\n  /**\n   * To find first valid legend text index for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.findFirstLegendPosition = function (legendCollection) {\n    var count = 0;\n\n    for (var _i = 0, legendCollection_1 = legendCollection; _i < legendCollection_1.length; _i++) {\n      var legend = legendCollection_1[_i];\n\n      if (legend.render && legend.text !== '') {\n        break;\n      }\n\n      count++;\n    }\n\n    return count;\n  };\n  /**\n   * To create legend rendering elements for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.createLegendElements = function (chart, legendBounds, legendGroup, legend, id, redraw) {\n    var padding = legend.padding;\n    var options = new RectOption(id + '_element', legend.background, legend.border, legend.opacity, legendBounds);\n    legendGroup ? legendGroup.appendChild(chart.renderer.drawRectangle(options)) : chart.renderer.drawRectangle(options);\n    var legendItemsGroup = chart.renderer.createGroup({\n      id: id + '_collections'\n    });\n    var isCanvas = chart.enableCanvas;\n\n    if (!isCanvas) {\n      legendGroup.appendChild(legendItemsGroup);\n    }\n\n    this.legendTranslateGroup = chart.renderer.createGroup({\n      id: id + '_translate_g'\n    });\n\n    if (!isCanvas) {\n      legendItemsGroup.appendChild(this.legendTranslateGroup);\n    }\n\n    var clippath = chart.renderer.createClipPath({\n      id: id + '_clipPath'\n    });\n    options.y += padding;\n    options.id += '_clipPath_rect';\n    options.width = !this.isChartControl && this.isVertical ? this.maxWidth - padding : legendBounds.width;\n\n    if (!isCanvas) {\n      this.clipRect = chart.renderer.drawRectangle(options);\n      clippath.appendChild(this.clipRect);\n    } else {\n      this.pagingClipRect = options;\n    }\n\n    appendChildElement(isCanvas, chart.svgObject, clippath, redraw);\n\n    if (!isCanvas) {\n      legendItemsGroup.setAttribute('style', 'clip-path:url(#' + clippath.id + ')');\n    }\n\n    return this.legendTranslateGroup;\n  };\n  /**\n   * To render legend symbols for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.renderSymbol = function (legendOption, group, i) {\n    var symbolColor = legendOption.visible ? legendOption.fill : '#D3D3D3';\n    var shape = legendOption.shape === 'SeriesType' ? legendOption.type : legendOption.shape;\n    shape = shape === 'Scatter' ? legendOption.markerShape : shape;\n    var isStrokeWidth = this.chart.getModuleName() === 'chart' && legendOption.shape === 'SeriesType' && legendOption.type.toLowerCase().indexOf('line') > -1 && legendOption.type.toLowerCase().indexOf('area') === -1;\n    var strokewidth = isStrokeWidth ? this.chart.visibleSeries[i].width : 1;\n    var symbolOption = new PathOption(this.legendID + this.generateId(legendOption, '_shape_', i), symbolColor, strokewidth, symbolColor, 1, '', '');\n    var regionPadding;\n    var isCanvas = this.chart.enableCanvas;\n\n    if (!isCanvas) {\n      group.appendChild(drawSymbol(legendOption.location, shape, new Size(this.legend.shapeWidth, this.legend.shapeHeight), '', symbolOption, 'Click to show or hide the ' + legendOption.text + ' series', this.chart.renderer));\n    } else {\n      regionPadding = -this.translatePage(null, this.currentPageNumber - 1, this.currentPageNumber);\n      drawSymbol(legendOption.location, shape, new Size(this.legend.shapeWidth, this.legend.shapeHeight), '', symbolOption, 'Click to show or hide the ' + legendOption.text + ' series', this.chart.renderer, this.currentPageNumber ? new Rect(0, regionPadding, 0, 0) : null);\n      this.legendRegions.push({\n        rect: new Rect(legendOption.location.x, legendOption.location.y, this.legend.shapeWidth, this.legend.shapeHeight + regionPadding),\n        index: i\n      });\n    }\n\n    if (shape === 'Line' && legendOption.markerVisibility && legendOption.markerShape !== 'Image' || legendOption.type === 'Doughnut') {\n      symbolOption.id = this.legendID + this.generateId(legendOption, '_shape_marker_', i);\n      shape = legendOption.type === 'Doughnut' ? 'Circle' : legendOption.markerShape;\n      symbolOption.fill = legendOption.type === 'Doughnut' ? '#FFFFFF' : symbolOption.fill;\n\n      if (!isCanvas) {\n        group.appendChild(drawSymbol(legendOption.location, shape, new Size(this.legend.shapeWidth / 2, this.legend.shapeHeight / 2), '', symbolOption, 'Click to show or hide the ' + legendOption.text + ' series'));\n      } else {\n        drawSymbol(legendOption.location, shape, new Size(this.legend.shapeWidth / 2, this.legend.shapeHeight / 2), '', symbolOption, 'Click to show or hide the ' + legendOption.text + ' series', this.chart.renderer, this.currentPageNumber ? new Rect(0, -this.translatePage(null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null);\n      }\n    }\n  };\n  /**\n   * To render legend text for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.renderText = function (chart, legendOption, group, textOptions, i) {\n    var legend = chart.legendSettings;\n    var hiddenColor = '#D3D3D3';\n    textOptions.id = this.legendID + this.generateId(legendOption, '_text_', i);\n    var fontcolor = legendOption.visible ? legend.textStyle.color || chart.themeStyle.legendLabel : hiddenColor;\n    textOptions.text = legendOption.text;\n    textOptions.x = legendOption.location.x + legend.shapeWidth / 2 + legend.shapePadding;\n    textOptions.y = legendOption.location.y + this.maxItemHeight / 4;\n    var isCanvas = this.chart.enableCanvas;\n    var element = textElement(chart.renderer, textOptions, legend.textStyle, fontcolor, group, false, false, false, false, null, this.currentPageNumber && isCanvas ? new Rect(0, -this.translatePage(null, this.currentPageNumber - 1, this.currentPageNumber), 0, 0) : null);\n\n    if (element) {\n      element.setAttribute('aria-label', legend.description || 'Click to show or hide the ' + legendOption.text + ' series');\n    }\n\n    if (isCanvas) {\n      var textSize = measureText(textOptions.text, legend.textStyle);\n      this.legendRegions[i].rect.y = textOptions.y < this.legendRegions[i].rect.y ? textOptions.y : this.legendRegions[i].rect.y;\n      this.legendRegions[i].rect.width += textSize.width;\n      this.legendRegions[i].rect.height = textSize.height;\n      this.legendRegions[i].rect.y -= textSize.height * 0.5;\n    }\n  };\n  /**\n   * To render legend paging elements for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.renderPagingElements = function (chart, bounds, textOption, legendGroup) {\n    var paginggroup = chart.renderer.createGroup({\n      id: this.legendID + '_navigation'\n    });\n    this.pagingRegions = [];\n    var isCanvas = chart.enableCanvas;\n\n    if (!isCanvas) {\n      legendGroup.appendChild(paginggroup);\n    }\n\n    var grayColor = '#545454';\n    var legend = chart.legendSettings; // to solve parameter lint error, legend declaration is here\n\n    var padding = 8; // const padding for paging elements\n\n    if (this.isChartControl || !this.isVertical) {\n      this.totalPages = Math.ceil(this.totalPages / Math.max(1, this.rowCount - 1));\n    } else {\n      this.totalPages = Math.ceil(this.totalPages / this.maxColumns);\n    }\n\n    var symbolOption = new PathOption(this.legendID + '_pageup', 'transparent', 5, grayColor, 1, '', '');\n    var iconSize = this.pageButtonSize;\n\n    if (paginggroup) {\n      paginggroup.setAttribute('style', 'cursor: pointer');\n    } // Page left arrow drawing calculation started here\n\n\n    this.clipPathHeight = (this.rowCount - 1) * (this.maxItemHeight + legend.padding);\n\n    if (!isCanvas) {\n      this.clipRect.setAttribute('height', this.clipPathHeight.toString());\n    } else {\n      //paging clipRect only for canvas mode\n      this.pagingClipRect.height = this.legendBounds.height - this.clipPathHeight - (this.pagingClipRect.y - this.legendBounds.y) - legend.border.width;\n      this.pagingClipRect.y = this.pagingClipRect.y + this.clipPathHeight;\n      this.pagingClipRect.x += legend.border.width;\n      this.pagingClipRect.width -= legend.border.width + legend.border.width / 2;\n      this.chart.renderer.clearRect(new Rect(this.pagingClipRect.x, this.pagingClipRect.y, this.pagingClipRect.width, this.pagingClipRect.height));\n    }\n\n    var x = bounds.x + iconSize / 2;\n    var y = bounds.y + this.clipPathHeight + (bounds.height - this.clipPathHeight) / 2;\n    var size = measureText(this.totalPages + '/' + this.totalPages, legend.textStyle);\n\n    if (!isCanvas) {\n      paginggroup.appendChild(drawSymbol({\n        x: x,\n        y: y\n      }, 'LeftArrow', new Size(iconSize, iconSize), '', symbolOption, 'LeftArrow'));\n    } else {\n      drawSymbol({\n        x: x,\n        y: y\n      }, 'LeftArrow', new Size(iconSize, iconSize), '', symbolOption, 'LeftArrow', this.chart.renderer, new Rect(bounds.width - (2 * (iconSize + padding) + padding + size.width), 0, 0, 0));\n    }\n\n    this.pagingRegions.push(new Rect(x + bounds.width - (2 * (iconSize + padding) + padding + size.width) - iconSize * 0.5, y - iconSize * 0.5, iconSize, iconSize)); // Page numbering rendering calculation started here\n\n    textOption.x = x + iconSize / 2 + padding;\n    textOption.y = y + size.height / 4;\n    textOption.id = this.legendID + '_pagenumber';\n    textOption.text = '1/' + this.totalPages;\n\n    if (isCanvas && this.totalNoOfPages) {\n      textOption.text = this.currentPageNumber + '/' + this.totalNoOfPages;\n    }\n\n    var pageTextElement = textElement(chart.renderer, textOption, legend.textStyle, legend.textStyle.color, paginggroup, false, false, false, false, null, new Rect(bounds.width - (2 * (iconSize + padding) + padding + size.width), 0, 0, 0)); // Page right arrow rendering calculation started here\n\n    x = textOption.x + padding + iconSize / 2 + size.width;\n    symbolOption.id = this.legendID + '_pagedown';\n\n    if (!isCanvas) {\n      paginggroup.appendChild(drawSymbol({\n        x: x,\n        y: y\n      }, 'RightArrow', new Size(iconSize, iconSize), '', symbolOption, 'RightArrow'));\n    } else {\n      drawSymbol({\n        x: x,\n        y: y\n      }, 'RightArrow', new Size(iconSize, iconSize), '', symbolOption, 'RightArrow', this.chart.renderer, new Rect(bounds.width - (2 * (iconSize + padding) + padding + size.width), 0, 0, 0));\n    }\n\n    this.pagingRegions.push(new Rect(x + (bounds.width - (2 * (iconSize + padding) + padding + size.width) - iconSize * 0.5), y - iconSize * 0.5, iconSize, iconSize));\n\n    if (!isCanvas) {\n      //placing the navigation buttons and page numbering in legend right corner\n      paginggroup.setAttribute('transform', 'translate(' + (bounds.width - (2 * (iconSize + padding) + padding + size.width)) + ', ' + 0 + ')');\n    } else {\n      if (this.currentPageNumber === 1 && this.calTotalPage) {\n        this.totalNoOfPages = this.totalPages;\n        this.calTotalPage = false;\n      }\n    }\n\n    this.translatePage(pageTextElement, this.currentPage - 1, this.currentPage);\n  };\n  /**\n   * To translate legend pages for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.translatePage = function (pagingText, page, pageNumber) {\n    var size = this.clipPathHeight * page;\n    var translate = 'translate(0,-' + size + ')';\n\n    if (!this.isChartControl && this.isVertical) {\n      var pageLength = page * this.maxColumns;\n      size = this.pageXCollections[page * this.maxColumns] - this.legendBounds.x;\n      size = size < 0 ? 0 : size; // to avoid small pixel variation\n\n      translate = 'translate(-' + size + ',0)';\n    }\n\n    if (!this.chart.enableCanvas) {\n      this.legendTranslateGroup.setAttribute('transform', translate);\n    }\n\n    if (!this.chart.enableCanvas) {\n      pagingText.textContent = pageNumber + '/' + this.totalPages;\n    }\n\n    this.currentPage = pageNumber;\n    return size;\n  };\n  /**\n   * To change legend pages for chart and accumulation chart\n   */\n\n\n  BaseLegend.prototype.changePage = function (event, pageUp) {\n    var pageText = document.getElementById(this.legendID + '_pagenumber');\n    var page = parseInt(pageText.textContent.split('/')[0], 10);\n\n    if (pageUp && page > 1) {\n      this.translatePage(pageText, page - 2, page - 1);\n    } else if (!pageUp && page < this.totalPages) {\n      this.translatePage(pageText, page, page + 1);\n    }\n  };\n  /**\n   * To find legend elements id based on chart or accumulation chart\n   * @private\n   */\n\n\n  BaseLegend.prototype.generateId = function (option, prefix, count) {\n    if (this.isChartControl) {\n      return prefix + count;\n    } else {\n      return prefix + option.pointIndex;\n    }\n  };\n  /**\n   * To show or hide trimmed text tooltip for legend.\n   * @return {void}\n   * @private\n   */\n\n\n  BaseLegend.prototype.move = function (event) {\n    var _this = this;\n\n    var x = this.chart.mouseX;\n    var y = this.chart.mouseY;\n\n    if (event.target.textContent.indexOf('...') > -1) {\n      var targetId = event.target.id.split(this.legendID + '_text_');\n\n      if (targetId.length === 2) {\n        var index = parseInt(targetId[1], 10);\n        var element = this.chart.element;\n\n        if (!isNaN(index)) {\n          if (this.chart.isTouch) {\n            removeElement(this.chart.element.id + '_EJ2_Legend_Tooltip');\n          }\n\n          if (this.isChartControl) {\n            showTooltip(this.chart.series[index].name, x, y, element.offsetWidth, element.id + '_EJ2_Legend_Tooltip', getElement(this.chart.element.id + '_Secondary_Element'));\n          } else {\n            showTooltip(this.chart.visibleSeries[0].points[index].x.toString(), x + 10, y + 10, element.offsetWidth, element.id + '_EJ2_Legend_Tooltip', getElement(this.chart.element.id + '_Secondary_Element'));\n          }\n        }\n      }\n    } else {\n      removeElement(this.chart.element.id + '_EJ2_Legend_Tooltip');\n    }\n\n    if (this.chart.isTouch) {\n      clearTimeout(this.clearTooltip);\n      this.clearTooltip = setTimeout(function () {\n        removeElement(_this.chart.element.id + '_EJ2_Legend_Tooltip');\n      }, 1000);\n    }\n  };\n\n  return BaseLegend;\n}();\n\nexport { BaseLegend };\n/**\n * Class for legend options\n * @private\n */\n\nvar LegendOptions =\n/** @class */\nfunction () {\n  function LegendOptions(text, fill, shape, visible, type, markerShape, markerVisibility, pointIndex, seriesIndex) {\n    this.location = {\n      x: 0,\n      y: 0\n    };\n    this.text = text;\n    this.fill = fill;\n    this.shape = shape;\n    this.visible = visible;\n    this.type = type;\n    this.markerVisibility = markerVisibility;\n    this.markerShape = markerShape;\n    this.pointIndex = pointIndex;\n    this.seriesIndex = seriesIndex;\n  }\n\n  return LegendOptions;\n}();\n\nexport { LegendOptions };","map":null,"metadata":{},"sourceType":"module"}