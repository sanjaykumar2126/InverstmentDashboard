{"ast":null,"code":"import { withInBounds, PointData, getValueXByPoint, getValueYByPoint } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\n/**\n * To get the data on mouse move.\n * @private\n */\n\nvar ChartData =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the data.\n   * @private\n   */\n  function ChartData(chart) {\n    /** @private */\n    this.currentPoints = [];\n    /** @private */\n\n    this.previousPoints = [];\n    this.insideRegion = false;\n    this.chart = chart;\n    this.lierIndex = 0;\n  }\n  /**\n   * Method to get the Data.\n   * @private\n   */\n\n\n  ChartData.prototype.getData = function () {\n    var chart = this.chart;\n    var point = null;\n    var series = null;\n    var width;\n    var height;\n    var mouseX;\n    var mouseY;\n\n    for (var len = chart.visibleSeries.length, i = len - 1; i >= 0; i--) {\n      series = chart.visibleSeries[i];\n      width = series.type === 'Scatter' || series.drawType === 'Scatter' || !series.isRectSeries && series.marker.visible ? (series.marker.height + 5) / 2 : 0;\n      height = series.type === 'Scatter' || series.drawType === 'Scatter' || !series.isRectSeries && series.marker.visible ? (series.marker.width + 5) / 2 : 0;\n      mouseX = chart.mouseX;\n      mouseY = chart.mouseY;\n\n      if (series.dragSettings.enable && series.isRectSeries) {\n        if (!(series.type === 'Bar' && chart.isTransposed) && (chart.isTransposed || series.type === 'Bar')) {\n          var markerWidth = series.marker.width / 2;\n          mouseX = series.yAxis.isInversed ? mouseX + markerWidth : mouseX - markerWidth;\n        } else {\n          var markerHeight = series.marker.height / 2;\n          mouseY = series.yAxis.isInversed ? mouseY - markerHeight : mouseY + markerHeight;\n        }\n      }\n\n      if (series.visible && withInBounds(mouseX, mouseY, series.clipRect, width, height)) {\n        point = this.getRectPoint(series, series.clipRect, mouseX, mouseY);\n      }\n\n      if (point) {\n        return new PointData(point, series);\n      }\n    }\n\n    return new PointData(point, series);\n  };\n\n  ChartData.prototype.isSelected = function (chart) {\n    return chart.selectionMode.indexOf('Drag') > -1 && chart.selectionModule && chart.selectionModule.rectPoints !== null;\n  };\n\n  ChartData.prototype.getRectPoint = function (series, rect, x, y) {\n    var currentRect;\n    var chart = this.chart;\n    var fromCenterX;\n    var fromCenterY;\n    var clickAngle;\n    var arcAngle = 0;\n    var startAngle;\n    var endAngle;\n    var distanceFromCenter;\n\n    if (chart.isScrolling) {\n      return null;\n    }\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      if (!point.regionData) {\n        if (!point.regions || !point.regions.length) {\n          continue;\n        }\n      }\n\n      if (point.regionData && this.chart.chartAreaType === 'PolarRadar' && series.drawType.indexOf('Column') > -1) {\n        fromCenterX = x - (series.clipRect.width / 2 + series.clipRect.x);\n        fromCenterY = y - (series.clipRect.height / 2 + series.clipRect.y);\n        arcAngle = 2 * Math.PI * (point.regionData.currentXPosition < 0 ? 1 + point.regionData.currentXPosition : point.regionData.currentXPosition);\n        clickAngle = (Math.atan2(fromCenterY, fromCenterX) + 0.5 * Math.PI - arcAngle) % (2 * Math.PI);\n        clickAngle = clickAngle < 0 ? 2 * Math.PI + clickAngle : clickAngle;\n        clickAngle = clickAngle + 2 * Math.PI * series.chart.primaryXAxis.startAngle;\n        startAngle = point.regionData.startAngle;\n        startAngle -= arcAngle;\n        startAngle = startAngle < 0 ? 2 * Math.PI + startAngle : startAngle;\n        endAngle = point.regionData.endAngle;\n        endAngle -= arcAngle;\n        endAngle = endAngle < 0 ? 2 * Math.PI + endAngle : endAngle;\n        distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));\n\n        if (clickAngle >= startAngle && clickAngle <= endAngle && (distanceFromCenter >= point.regionData.innerRadius && distanceFromCenter <= point.regionData.radius || distanceFromCenter <= point.regionData.innerRadius && distanceFromCenter >= point.regionData.radius) && distanceFromCenter <= series.chart.radius) {\n          return point;\n        }\n      }\n\n      if (series.dragSettings.enable && series.isRectSeries) {\n        if (this.rectRegion(x, y, point, rect, series)) {\n          this.insideRegion = true;\n          return point;\n        }\n      }\n\n      if (!this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {\n        return point;\n      } else if (this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {\n        return point;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Checks whether the region contains a point\n   */\n\n\n  ChartData.prototype.checkRegionContainsPoint = function (regionRect, rect, x, y) {\n    var _this = this;\n\n    return regionRect.some(function (region, index) {\n      _this.lierIndex = index;\n      return withInBounds(x, y, new Rect((_this.chart.chartAreaType === 'Cartesian' ? rect.x : 0) + region.x, (_this.chart.chartAreaType === 'Cartesian' ? rect.y : 0) + region.y, region.width, region.height));\n    });\n  };\n  /**\n   * To find drag region for column and bar series\n   * @param x\n   * @param y\n   * @param point\n   * @param rect\n   * @param series\n   */\n\n\n  ChartData.prototype.rectRegion = function (x, y, point, rect, series) {\n    var _this = this;\n\n    var isBar = series.type === 'Bar';\n    var isInversed = series.yAxis.isInversed;\n    var isTransposed = series.chart.isTransposed;\n    var heightValue = 10;\n    var yValue = 0;\n    var xValue = 0;\n    var width;\n    var height = width = 2 * heightValue;\n\n    if (isInversed && isTransposed) {\n      if (isBar) {\n        yValue = point.regions[0].height - heightValue;\n        width = point.regions[0].width;\n      } else {\n        xValue = -heightValue;\n        height = point.regions[0].height;\n      }\n    } else if (isInversed || point.yValue < 0) {\n      if (isBar) {\n        xValue = -heightValue;\n        height = point.regions[0].height;\n      } else {\n        yValue = point.regions[0].height - heightValue;\n        width = point.regions[0].width;\n      }\n    } else if (isTransposed) {\n      if (isBar) {\n        yValue = -heightValue;\n        width = point.regions[0].width;\n      } else {\n        xValue = point.regions[0].width - heightValue;\n        height = point.regions[0].height;\n      }\n    } else {\n      if (isBar) {\n        xValue = point.regions[0].width - heightValue;\n        height = point.regions[0].height;\n      } else {\n        yValue = -heightValue;\n        width = point.regions[0].width;\n      }\n    }\n\n    return point.regions.some(function (region) {\n      return withInBounds(x, y, new Rect((_this.chart.chartAreaType === 'Cartesian' ? rect.x : 0) + region.x + xValue, (_this.chart.chartAreaType === 'Cartesian' ? rect.y : 0) + region.y + yValue, width, height));\n    });\n  };\n  /**\n   * @private\n   */\n\n\n  ChartData.prototype.getClosest = function (series, value) {\n    var xData = series.xData;\n    var closest;\n\n    if (value >= series.xMin - 0.5 && value <= series.xMax + 0.5) {\n      for (var _i = 0, xData_1 = xData; _i < xData_1.length; _i++) {\n        var data = xData_1[_i];\n\n        if (closest == null || Math.abs(data - value) < Math.abs(closest - value)) {\n          closest = data;\n        }\n      }\n    }\n\n    return closest;\n  };\n\n  ChartData.prototype.getClosestX = function (chart, series) {\n    var value;\n    var rect = series.clipRect;\n\n    if (!chart.requireInvertedAxis) {\n      value = getValueXByPoint(chart.mouseX - rect.x, rect.width, series.xAxis);\n    } else {\n      value = getValueYByPoint(chart.mouseY - rect.y, rect.height, series.xAxis);\n    }\n\n    var closest = this.getClosest(series, value);\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      if (closest === point.xValue && point.visible) {\n        return new PointData(point, series);\n      }\n    }\n\n    return null;\n  };\n\n  return ChartData;\n}();\n\nexport { ChartData };","map":null,"metadata":{},"sourceType":"module"}