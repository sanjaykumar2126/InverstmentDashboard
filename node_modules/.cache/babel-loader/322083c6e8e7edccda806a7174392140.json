{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\n\nvar Axis = function (ChartElement) {\n  function Axis(options, chartService) {\n    if (chartService === void 0) chartService = new ChartService();\n    ChartElement.call(this, options);\n    this.chartService = chartService;\n\n    if (!this.options.visible) {\n      this.options = deepExtend({}, this.options, {\n        labels: {\n          visible: false\n        },\n        line: {\n          visible: false\n        },\n        margin: 0,\n        majorTickSize: 0,\n        minorTickSize: 0\n      });\n    }\n\n    this.options.minorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.minorTickType !== NONE\n    }, this.options.minorTicks, {\n      size: this.options.minorTickSize,\n      align: this.options.minorTickType\n    });\n    this.options.majorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.majorTickType !== NONE\n    }, this.options.majorTicks, {\n      size: this.options.majorTickSize,\n      align: this.options.majorTickType\n    });\n    this.initFields();\n\n    if (!this.options._deferLabels) {\n      this.createLabels();\n    }\n\n    this.createTitle();\n    this.createNotes();\n  }\n\n  if (ChartElement) Axis.__proto__ = ChartElement;\n  Axis.prototype = Object.create(ChartElement && ChartElement.prototype);\n  Axis.prototype.constructor = Axis;\n\n  Axis.prototype.initFields = function initFields() {}; // abstract labelsCount(): Number\n  // abstract createAxisLabel(index, options): AxisLabel\n\n\n  Axis.prototype.labelsRange = function labelsRange() {\n    return {\n      min: this.options.labels.skip,\n      max: this.labelsCount()\n    };\n  };\n\n  Axis.prototype.createLabels = function createLabels() {\n    var this$1 = this;\n    var options = this.options;\n    var align = options.vertical ? RIGHT : CENTER;\n    var labelOptions = deepExtend({}, options.labels, {\n      align: align,\n      zIndex: options.zIndex\n    });\n    var step = Math.max(1, labelOptions.step);\n    this.clearLabels();\n\n    if (labelOptions.visible) {\n      var range = this.labelsRange();\n      var rotation = labelOptions.rotation;\n\n      if (isObject(rotation)) {\n        labelOptions.alignRotation = rotation.align;\n        labelOptions.rotation = rotation.angle;\n      }\n\n      if (labelOptions.rotation === \"auto\") {\n        labelOptions.rotation = 0;\n        options.autoRotateLabels = true;\n      }\n\n      for (var idx = range.min; idx < range.max; idx += step) {\n        var label = this$1.createAxisLabel(idx, labelOptions);\n\n        if (label) {\n          this$1.append(label);\n          this$1.labels.push(label);\n        }\n      }\n    }\n  };\n\n  Axis.prototype.clearLabels = function clearLabels() {\n    this.children = grep(this.children, function (child) {\n      return !(child instanceof AxisLabel);\n    });\n    this.labels = [];\n  };\n\n  Axis.prototype.clearTitle = function clearTitle() {\n    var this$1 = this;\n\n    if (this.title) {\n      this.children = grep(this.children, function (child) {\n        return child !== this$1.title;\n      });\n      this.title = undefined;\n    }\n  };\n\n  Axis.prototype.clear = function clear() {\n    this.clearLabels();\n    this.clearTitle();\n  };\n\n  Axis.prototype.lineBox = function lineBox() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var axisX = mirror ? box.x1 : box.x2;\n    var axisY = mirror ? box.y2 : box.y1;\n    var lineWidth = options.line.width || 0;\n    return vertical ? new Box(axisX, box.y1, axisX, box.y2 - lineWidth) : new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n  };\n\n  Axis.prototype.createTitle = function createTitle() {\n    var options = this.options;\n    var titleOptions = deepExtend({\n      rotation: options.vertical ? -90 : 0,\n      text: \"\",\n      zIndex: 1,\n      visualSize: true\n    }, options.title);\n\n    if (titleOptions.visible && titleOptions.text) {\n      var title = new TextBox(titleOptions.text, titleOptions);\n      this.append(title);\n      this.title = title;\n    }\n  };\n\n  Axis.prototype.createNotes = function createNotes() {\n    var this$1 = this;\n    var options = this.options;\n    var notes = options.notes;\n    var items = notes.data || [];\n    this.notes = [];\n\n    for (var i = 0; i < items.length; i++) {\n      var item = deepExtend({}, notes, items[i]);\n      item.value = this$1.parseNoteValue(item.value);\n      var note = new Note({\n        value: item.value,\n        text: item.label.text,\n        dataItem: item\n      }, item, this$1.chartService);\n\n      if (note.options.visible) {\n        if (defined(note.options.position)) {\n          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        } else {\n          if (options.vertical) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        }\n\n        this$1.append(note);\n        this$1.notes.push(note);\n      }\n    }\n  };\n\n  Axis.prototype.parseNoteValue = function parseNoteValue(value) {\n    return value;\n  };\n\n  Axis.prototype.renderVisual = function renderVisual() {\n    ChartElement.prototype.renderVisual.call(this);\n    this.createPlotBands();\n  };\n\n  Axis.prototype.createVisual = function createVisual() {\n    ChartElement.prototype.createVisual.call(this);\n    this.createBackground();\n    this.createLine();\n  };\n\n  Axis.prototype.gridLinesVisual = function gridLinesVisual() {\n    var gridLines = this._gridLines;\n\n    if (!gridLines) {\n      gridLines = this._gridLines = new draw.Group({\n        zIndex: -2\n      });\n      this.appendVisual(this._gridLines);\n    }\n\n    return gridLines;\n  };\n\n  Axis.prototype.createTicks = function createTicks(lineGroup) {\n    var options = this.options;\n    var lineBox = this.lineBox();\n    var mirror = options.labels.mirror;\n    var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n    var tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: options.vertical\n    };\n\n    function render(tickPositions, tickOptions, skipUnit) {\n      var count = tickPositions.length;\n      var step = Math.max(1, tickOptions.step);\n\n      if (tickOptions.visible) {\n        for (var i = tickOptions.skip; i < count; i += step) {\n          if (defined(skipUnit) && i % skipUnit === 0) {\n            continue;\n          }\n\n          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n          tickLineOptions.position = tickPositions[i];\n          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n      }\n    }\n\n    render(this.getMajorTickPositions(), options.majorTicks);\n    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n  };\n\n  Axis.prototype.createLine = function createLine() {\n    var options = this.options;\n    var line = options.line;\n    var lineBox = this.lineBox();\n\n    if (line.width > 0 && line.visible) {\n      var path = new draw.Path({\n        stroke: {\n          width: line.width,\n          color: line.color,\n          dashType: line.dashType\n        }\n        /* TODO\n        zIndex: line.zIndex,\n        */\n\n      });\n      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n\n      if (options._alignLines) {\n        alignPathToPixel(path);\n      }\n\n      var group = this._lineGroup = new draw.Group();\n      group.append(path);\n      this.visual.append(group);\n      this.createTicks(group);\n    }\n  };\n\n  Axis.prototype.getActualTickSize = function getActualTickSize() {\n    var options = this.options;\n    var tickSize = 0;\n\n    if (options.majorTicks.visible && options.minorTicks.visible) {\n      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n    } else if (options.majorTicks.visible) {\n      tickSize = options.majorTicks.size;\n    } else if (options.minorTicks.visible) {\n      tickSize = options.minorTicks.size;\n    }\n\n    return tickSize;\n  };\n\n  Axis.prototype.createBackground = function createBackground() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var background = options.background;\n\n    if (background) {\n      this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n        fill: {\n          color: background\n        },\n        stroke: null\n      });\n      this.visual.append(this._backgroundPath);\n    }\n  };\n\n  Axis.prototype.createPlotBands = function createPlotBands() {\n    var this$1 = this;\n    var options = this.options;\n    var plotBands = options.plotBands || [];\n    var vertical = options.vertical;\n    var plotArea = this.plotArea;\n\n    if (plotBands.length === 0) {\n      return;\n    }\n\n    var group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n    var altAxis = grep(this.pane.axes, function (axis) {\n      return axis.options.vertical !== this$1.options.vertical;\n    })[0];\n\n    for (var idx = 0; idx < plotBands.length; idx++) {\n      var item = plotBands[idx];\n      var slotX = void 0,\n          slotY = void 0;\n\n      if (vertical) {\n        slotX = (altAxis || plotArea.axisX).lineBox();\n        slotY = this$1.getSlot(item.from, item.to, true);\n      } else {\n        slotX = this$1.getSlot(item.from, item.to, true);\n        slotY = (altAxis || plotArea.axisY).lineBox();\n      }\n\n      if (slotX.width() !== 0 && slotY.height() !== 0) {\n        var bandRect = new geom.Rect([slotX.x1, slotY.y1], [slotX.width(), slotY.height()]);\n        var path = draw.Path.fromRect(bandRect, {\n          fill: {\n            color: item.color,\n            opacity: item.opacity\n          },\n          stroke: null\n        });\n        group.append(path);\n      }\n    }\n\n    this.appendVisual(group);\n  };\n\n  Axis.prototype.createGridLines = function createGridLines(altAxis) {\n    var options = this.options;\n    var minorGridLines = options.minorGridLines;\n    var majorGridLines = options.majorGridLines;\n    var minorUnit = options.minorUnit;\n    var vertical = options.vertical;\n    var axisLineVisible = altAxis.options.line.visible;\n    var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n    var lineBox = altAxis.lineBox();\n    var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n    var lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    var majorTicks = [];\n    var container = this.gridLinesVisual();\n\n    function render(tickPositions, gridLine, skipUnit) {\n      var count = tickPositions.length;\n      var step = Math.max(1, gridLine.step);\n\n      if (gridLine.visible) {\n        for (var i = gridLine.skip; i < count; i += step) {\n          var pos = round(tickPositions[i]);\n\n          if (!inArray(pos, majorTicks)) {\n            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n              lineOptions.position = pos;\n              container.append(createAxisGridLine(lineOptions, gridLine));\n              majorTicks.push(pos);\n            }\n          }\n        }\n      }\n    }\n\n    render(this.getMajorTickPositions(), majorGridLines);\n    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n    return container.children;\n  };\n\n  Axis.prototype.reflow = function reflow(box) {\n    var ref = this;\n    var options = ref.options;\n    var labels = ref.labels;\n    var title = ref.title;\n    var vertical = options.vertical;\n    var count = labels.length;\n    var sizeFn = vertical ? WIDTH : HEIGHT;\n    var titleSize = title ? title.box[sizeFn]() : 0;\n    var space = this.getActualTickSize() + options.margin + titleSize;\n    var rootBox = (this.getRoot() || {}).box || box;\n    var boxSize = rootBox[sizeFn]();\n    var maxLabelSize = 0;\n\n    for (var i = 0; i < count; i++) {\n      var labelSize = labels[i].box[sizeFn]();\n\n      if (labelSize + space <= boxSize) {\n        maxLabelSize = Math.max(maxLabelSize, labelSize);\n      }\n    }\n\n    if (vertical) {\n      this.box = new Box(box.x1, box.y1, box.x1 + maxLabelSize + space, box.y2);\n    } else {\n      this.box = new Box(box.x1, box.y1, box.x2, box.y1 + maxLabelSize + space);\n    }\n\n    this.arrangeTitle();\n    this.arrangeLabels();\n    this.arrangeNotes();\n  };\n\n  Axis.prototype.getLabelsTickPositions = function getLabelsTickPositions() {\n    return this.getMajorTickPositions();\n  };\n\n  Axis.prototype.labelTickIndex = function labelTickIndex(label) {\n    return label.index;\n  };\n\n  Axis.prototype.arrangeLabels = function arrangeLabels() {\n    var this$1 = this;\n    var ref = this;\n    var options = ref.options;\n    var labels = ref.labels;\n    var labelsBetweenTicks = this.labelsBetweenTicks();\n    var vertical = options.vertical;\n    var lineBox = this.lineBox();\n    var mirror = options.labels.mirror;\n    var tickPositions = this.getLabelsTickPositions();\n    var labelOffset = this.getActualTickSize() + options.margin;\n\n    for (var idx = 0; idx < labels.length; idx++) {\n      var label = labels[idx];\n      var tickIx = this$1.labelTickIndex(label);\n      var labelSize = vertical ? label.box.height() : label.box.width();\n      var labelPos = tickPositions[tickIx] - labelSize / 2;\n      var labelBox = void 0,\n          firstTickPosition = void 0,\n          nextTickPosition = void 0;\n\n      if (vertical) {\n        if (labelsBetweenTicks) {\n          firstTickPosition = tickPositions[tickIx];\n          nextTickPosition = tickPositions[tickIx + 1];\n          var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n          labelPos = middle - labelSize / 2;\n        }\n\n        var labelX = lineBox.x2;\n\n        if (mirror) {\n          labelX += labelOffset;\n          label.options.rotationOrigin = LEFT;\n        } else {\n          labelX -= labelOffset + label.box.width();\n          label.options.rotationOrigin = RIGHT;\n        }\n\n        labelBox = label.box.move(labelX, labelPos);\n      } else {\n        if (labelsBetweenTicks) {\n          firstTickPosition = tickPositions[tickIx];\n          nextTickPosition = tickPositions[tickIx + 1];\n        } else {\n          firstTickPosition = labelPos;\n          nextTickPosition = labelPos + labelSize;\n        }\n\n        var labelY = lineBox.y1;\n\n        if (mirror) {\n          labelY -= labelOffset + label.box.height();\n          label.options.rotationOrigin = BOTTOM;\n        } else {\n          labelY += labelOffset;\n          label.options.rotationOrigin = TOP;\n        }\n\n        labelBox = new Box(firstTickPosition, labelY, nextTickPosition, labelY + label.box.height());\n      }\n\n      label.reflow(labelBox);\n    }\n  };\n\n  Axis.prototype.autoRotateLabels = function autoRotateLabels() {\n    if (this.options.autoRotateLabels && !this.options.vertical) {\n      var tickPositions = this.getMajorTickPositions();\n      var labels = this.labels;\n      var angle;\n\n      for (var idx = 0; idx < labels.length; idx++) {\n        var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n        var labelBox = labels[idx].box;\n\n        if (labelBox.width() > width) {\n          if (labelBox.height() > width) {\n            angle = -90;\n            break;\n          }\n\n          angle = -45;\n        }\n      }\n\n      if (angle) {\n        for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n          labels[idx$1].options.rotation = angle;\n          labels[idx$1].reflow(new Box());\n        }\n\n        return true;\n      }\n    }\n  };\n\n  Axis.prototype.arrangeTitle = function arrangeTitle() {\n    var ref = this;\n    var options = ref.options;\n    var title = ref.title;\n    var mirror = options.labels.mirror;\n    var vertical = options.vertical;\n\n    if (title) {\n      if (vertical) {\n        title.options.align = mirror ? RIGHT : LEFT;\n        title.options.vAlign = title.options.position;\n      } else {\n        title.options.align = title.options.position;\n        title.options.vAlign = mirror ? TOP : BOTTOM;\n      }\n\n      title.reflow(this.box);\n    }\n  };\n\n  Axis.prototype.arrangeNotes = function arrangeNotes() {\n    var this$1 = this;\n\n    for (var idx = 0; idx < this.notes.length; idx++) {\n      var item = this$1.notes[idx];\n      var value = item.options.value;\n      var slot = void 0;\n\n      if (defined(value)) {\n        if (this$1.shouldRenderNote(value)) {\n          item.show();\n        } else {\n          item.hide();\n        }\n\n        slot = this$1.noteSlot(value);\n      } else {\n        item.hide();\n      }\n\n      item.reflow(slot || this$1.lineBox());\n    }\n  };\n\n  Axis.prototype.noteSlot = function noteSlot(value) {\n    return this.getSlot(value);\n  };\n\n  Axis.prototype.alignTo = function alignTo(secondAxis) {\n    var lineBox = secondAxis.lineBox();\n    var vertical = this.options.vertical;\n    var pos = vertical ? Y : X;\n    this.box.snapTo(lineBox, pos);\n\n    if (vertical) {\n      this.box.shrink(0, this.lineBox().height() - lineBox.height());\n    } else {\n      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n    }\n\n    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n  };\n\n  Axis.prototype.axisLabelText = function axisLabelText(value, dataItem, options) {\n    var tmpl = getTemplate(options);\n    var text = value;\n\n    if (tmpl) {\n      text = tmpl({\n        value: value,\n        dataItem: dataItem,\n        format: options.format,\n        culture: options.culture\n      });\n    } else if (options.format) {\n      text = this.chartService.format.localeAuto(options.format, [value], options.culture);\n    }\n\n    return text;\n  };\n\n  Axis.prototype.slot = function slot(from, to, limit) {\n    var slot = this.getSlot(from, to, limit);\n\n    if (slot) {\n      return slot.toRect();\n    }\n  };\n\n  Axis.prototype.contentBox = function contentBox() {\n    var box = this.box.clone();\n    var labels = this.labels;\n\n    if (labels.length) {\n      var axis = this.options.vertical ? Y : X;\n\n      if (this.chartService.isPannable(axis)) {\n        var offset = this.maxLabelOffset();\n        box[axis + 1] -= offset.start;\n        box[axis + 2] += offset.end;\n      } else {\n        if (labels[0].options.visible) {\n          box.wrap(labels[0].box);\n        }\n\n        var lastLabel = labels[labels.length - 1];\n\n        if (lastLabel.options.visible) {\n          box.wrap(lastLabel.box);\n        }\n      }\n    }\n\n    return box;\n  };\n\n  Axis.prototype.maxLabelOffset = function maxLabelOffset() {\n    var this$1 = this;\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var labelsBetweenTicks = this.labelsBetweenTicks();\n    var tickPositions = this.getLabelsTickPositions();\n    var offsetField = vertical ? Y : X;\n    var labels = this.labels;\n    var startPosition = reverse ? 1 : 0;\n    var endPosition = reverse ? 0 : 1;\n    var maxStartOffset = 0;\n    var maxEndOffset = 0;\n\n    for (var idx = 0; idx < labels.length; idx++) {\n      var label = labels[idx];\n      var tickIx = this$1.labelTickIndex(label);\n      var startTick = void 0,\n          endTick = void 0;\n\n      if (labelsBetweenTicks) {\n        startTick = tickPositions[tickIx + startPosition];\n        endTick = tickPositions[tickIx + endPosition];\n      } else {\n        startTick = endTick = tickPositions[tickIx];\n      }\n\n      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n    }\n\n    return {\n      start: maxStartOffset,\n      end: maxEndOffset\n    };\n  };\n\n  Axis.prototype.limitRange = function limitRange(from, to, min, max, offset) {\n    var options = this.options;\n\n    if (from < min && offset < 0 && (!defined(options.min) || options.min <= min) || max < to && offset > 0 && (!defined(options.max) || max <= options.max)) {\n      return null;\n    }\n\n    if (to < min && offset > 0 || max < from && offset < 0) {\n      return {\n        min: from,\n        max: to\n      };\n    }\n\n    var rangeSize = to - from;\n    var minValue = from;\n    var maxValue = to;\n\n    if (from < min && offset < 0) {\n      minValue = limitValue(from, min, max);\n      maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n    } else if (to > max && offset > 0) {\n      maxValue = limitValue(to, min, max);\n      minValue = limitValue(to - rangeSize, min, max - rangeSize);\n    }\n\n    return {\n      min: minValue,\n      max: maxValue\n    };\n  };\n\n  Axis.prototype.valueRange = function valueRange() {\n    return {\n      min: this.seriesMin,\n      max: this.seriesMax\n    };\n  };\n\n  Axis.prototype.labelsBetweenTicks = function labelsBetweenTicks() {\n    return !this.options.justified;\n  }; //add legacy fields to the options that are no longer generated by default\n\n\n  Axis.prototype.prepareUserOptions = function prepareUserOptions() {};\n\n  return Axis;\n}(ChartElement);\n\nsetDefaultOptions(Axis, {\n  labels: {\n    visible: true,\n    rotation: 0,\n    mirror: false,\n    step: 1,\n    skip: 0\n  },\n  line: {\n    width: 1,\n    color: BLACK,\n    visible: true\n  },\n  title: {\n    visible: true,\n    position: CENTER\n  },\n  majorTicks: {\n    align: OUTSIDE,\n    size: 4,\n    skip: 0,\n    step: 1\n  },\n  minorTicks: {\n    align: OUTSIDE,\n    size: 3,\n    skip: 0,\n    step: 1\n  },\n  axisCrossingValue: 0,\n  majorTickType: OUTSIDE,\n  minorTickType: NONE,\n  majorGridLines: {\n    skip: 0,\n    step: 1\n  },\n  minorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK,\n    skip: 0,\n    step: 1\n  },\n  // TODO: Move to line or labels options\n  margin: 5,\n  visible: true,\n  reverse: false,\n  justified: true,\n  notes: {\n    label: {\n      text: \"\"\n    }\n  },\n  _alignLines: true,\n  _deferLabels: false\n});\nexport default Axis;","map":null,"metadata":{},"sourceType":"module"}