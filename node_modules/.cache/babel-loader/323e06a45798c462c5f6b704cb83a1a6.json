{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * AccumulationChart file\n */\n\n\nimport { Property, Component, Complex, Collection, NotifyPropertyChanges } from '@syncfusion/ej2-base';\nimport { Internationalization, Event, Browser, EventHandler, Touch } from '@syncfusion/ej2-base';\nimport { remove, extend, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { Font, Margin, Border, TooltipSettings, Indexes } from '../common/model/base';\nimport { AccumulationSeries, PieCenter } from './model/acc-base';\nimport { Theme, getThemeColor } from '../common/model/theme';\nimport { load, pointClick } from '../common/model/constants';\nimport { pointMove, chartMouseClick, chartMouseDown } from '../common/model/constants';\nimport { chartMouseLeave, chartMouseMove, chartMouseUp, resized } from '../common/model/constants';\nimport { LegendSettings } from '../common/legend/legend';\nimport { subtractRect, indexFinder, appendChildElement, redrawElement, blazorTemplatesReset } from '../common/utils/helper';\nimport { RectOption, showTooltip } from '../common/utils/helper';\nimport { textElement, createSvg, calculateSize, removeElement, firstToLowerCase } from '../common/utils/helper';\nimport { getElement, titlePositionX } from '../common/utils/helper';\nimport { Rect, Size, measureText, TextOption } from '@syncfusion/ej2-svg-base';\nimport { Data } from '../common/model/data';\nimport { AccumulationBase } from './renderer/accumulation-base';\nimport { PieSeries } from './renderer/pie-series';\nimport { AccumulationAnnotationSettings } from './model/acc-base';\nimport { getTitle } from '../common/utils/helper';\nimport { ExportUtils } from '../common/utils/export';\n/**\n * Represents the AccumulationChart control.\n * ```html\n * <div id=\"accumulation\"/>\n * <script>\n *   var accObj = new AccumulationChart({ });\n *   accObj.appendTo(\"#accumulation\");\n * </script>\n * ```\n * @public\n */\n\nvar AccumulationChart =\n/** @class */\nfunction (_super) {\n  __extends(AccumulationChart, _super);\n  /**\n   * Constructor for creating the AccumulationChart widget\n   * @private\n   */\n\n\n  function AccumulationChart(options, element) {\n    var _this = _super.call(this, options, element) || this;\n    /** @private */\n\n\n    _this.animateselected = false;\n    /** @private explode radius internal property */\n\n    _this.explodeDistance = 0;\n    _this.chartid = 57724;\n    return _this;\n  }\n  /**\n   * Animate the series bounds on data change.\n   * @private\n   */\n\n\n  AccumulationChart.prototype.animate = function (duration) {\n    this.duration = duration ? duration : 700;\n    this.animateselected = true;\n    this.animateSeries = false;\n    var temIndex = 0;\n    var tempcolor = [];\n    var tempindex = [];\n    var tempindex1 = [];\n    var currentSeries = this.visibleSeries[0];\n    var datasource = [];\n    datasource = currentSeries.dataSource;\n    currentSeries.sumOfPoints = 0;\n\n    if (currentSeries.points.length < Object.keys(currentSeries.dataSource).length) {\n      this.refresh();\n    } else if (currentSeries.points.length > Object.keys(currentSeries.dataSource).length) {\n      var currentSeries_1 = this.visibleSeries[0];\n      currentSeries_1.points = currentSeries_1.points.filter(function (entry1) {\n        entry1.visible = false;\n        tempindex.push(entry1.index);\n        tempcolor.push(entry1.color);\n        return datasource.some(function (entry2) {\n          var accPoint = entry2;\n\n          if (entry1.x === accPoint.x) {\n            entry1.visible = true;\n            tempindex1.push(entry1.index);\n            entry1.index = temIndex;\n            temIndex++;\n          }\n\n          return entry1.x === accPoint.x;\n        });\n      });\n      var missing = tempindex.filter(function (item) {\n        return tempindex1.indexOf(item) < 0;\n      });\n      var interval = tempindex.length - missing.length;\n\n      for (var i = tempindex.length - 1; i >= interval; i--) {\n        removeElement('container_Series_0_Point_' + tempindex[i]);\n      }\n\n      for (var i = 0; i < currentSeries_1.points.length; i++) {\n        currentSeries_1.points[i].y = currentSeries_1.dataSource[i].y;\n        currentSeries_1.points[i].color = tempcolor[i];\n        currentSeries_1.sumOfPoints += currentSeries_1.dataSource[i].y;\n      }\n\n      this.redraw = this.enableAnimation;\n      this.animateSeries = false;\n      this.calculateBounds();\n      this.renderElements();\n    } else {\n      for (var i = 0; i < currentSeries.points.length; i++) {\n        currentSeries.points[i].y = currentSeries.dataSource[i].y;\n        currentSeries.sumOfPoints += currentSeries.dataSource[i].y;\n      }\n\n      this.redraw = this.enableAnimation;\n      this.animateSeries = false;\n      this.removeSvg();\n      this.refreshPoints(currentSeries.points);\n      this.renderElements();\n    }\n  };\n\n  Object.defineProperty(AccumulationChart.prototype, \"type\", {\n    /** @private */\n    get: function () {\n      if (this.series && this.series.length) {\n        return this.series[0].type;\n      }\n\n      return 'Pie';\n    },\n    enumerable: true,\n    configurable: true\n  }); // accumulation chart methods\n\n  /**\n   *  To create svg object, renderer and binding events for the container.\n   */\n\n  AccumulationChart.prototype.preRender = function () {\n    var blazor = 'Blazor';\n    this.isBlazor = window[blazor];\n    this.unWireEvents();\n    this.setCulture();\n    this.animateSeries = true;\n\n    if (this.element.id === '') {\n      var collection = document.getElementsByClassName('e-accumulationchart').length;\n      this.element.id = 'acc_chart_' + this.chartid + '_' + collection;\n    }\n\n    calculateSize(this);\n    this.wireEvents();\n  };\n  /**\n   * Themeing for chart goes here\n   */\n\n\n  AccumulationChart.prototype.setTheme = function () {\n    /*! Set theme for accumulation chart */\n    this.themeStyle = getThemeColor(this.theme);\n  };\n  /**\n   * To render the accumulation chart elements\n   */\n\n\n  AccumulationChart.prototype.render = function () {\n    this.trigger(load, {\n      accumulation: this,\n      chart: this\n    });\n    this.setTheme();\n    this.accBaseModule = new AccumulationBase(this);\n    this.pieSeriesModule = new PieSeries(this);\n    this.calculateVisibleSeries();\n    this.processData();\n    this.renderComplete();\n  };\n  /**\n   * Method to unbind events for accumulation chart\n   */\n\n\n  AccumulationChart.prototype.unWireEvents = function () {\n    /*! Find the Events type */\n    var isIE11Pointer = Browser.isPointer;\n    var start = Browser.touchStartEvent;\n    var move = Browser.touchMoveEvent;\n    var stop = Browser.touchEndEvent;\n    var cancel = isIE11Pointer ? 'pointerleave' : 'mouseleave';\n    /*! UnBind the Event handler */\n\n    EventHandler.remove(this.element, move, this.accumulationMouseMove);\n    EventHandler.remove(this.element, stop, this.accumulationMouseEnd);\n    EventHandler.remove(this.element, start, this.accumulationMouseStart);\n    EventHandler.remove(this.element, 'click', this.accumulationOnMouseClick);\n    EventHandler.remove(this.element, 'contextmenu', this.accumulationRightClick);\n    EventHandler.remove(this.element, cancel, this.accumulationMouseLeave);\n    window.removeEventListener(Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.accumulationResize);\n  };\n  /**\n   * Method to bind events for the accumulation chart\n   */\n\n\n  AccumulationChart.prototype.wireEvents = function () {\n    /*! Find the Events type */\n    var isIE11Pointer = Browser.isPointer;\n    var start = Browser.touchStartEvent;\n    var stop = Browser.touchEndEvent;\n    var move = Browser.touchMoveEvent;\n    var cancel = isIE11Pointer ? 'pointerleave' : 'mouseleave';\n    /*! Bind the Event handler */\n\n    EventHandler.add(this.element, move, this.accumulationMouseMove, this);\n    EventHandler.add(this.element, stop, this.accumulationMouseEnd, this);\n    EventHandler.add(this.element, start, this.accumulationMouseStart, this);\n    EventHandler.add(this.element, 'click', this.accumulationOnMouseClick, this);\n    EventHandler.add(this.element, 'contextmenu', this.accumulationRightClick, this);\n    EventHandler.add(this.element, cancel, this.accumulationMouseLeave, this);\n    window.addEventListener(Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.accumulationResize.bind(this));\n    new Touch(this.element); // To avoid geasture blocking for browser\n\n    /*! Apply the style for chart */\n\n    this.setStyle(this.element);\n  };\n  /**\n   * Method to set mouse x, y from events\n   */\n\n\n  AccumulationChart.prototype.setMouseXY = function (e) {\n    var pageX;\n    var pageY;\n    var svgRect = getElement(this.element.id + '_svg').getBoundingClientRect();\n    var rect = this.element.getBoundingClientRect();\n\n    if (e.type.indexOf('touch') > -1) {\n      this.isTouch = true;\n      var touchArg = e;\n      pageY = touchArg.changedTouches[0].clientY;\n      pageX = touchArg.changedTouches[0].clientX;\n    } else {\n      this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';\n      pageX = e.clientX;\n      pageY = e.clientY;\n    }\n\n    this.mouseY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);\n    this.mouseX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);\n  };\n  /**\n   * Handles the mouse end.\n   * @return {boolean}\n   * @private\n   */\n\n\n  AccumulationChart.prototype.accumulationMouseEnd = function (e) {\n    this.setMouseXY(e);\n    this.trigger(chartMouseUp, {\n      target: e.target.id,\n      x: this.mouseX,\n      y: this.mouseY\n    });\n\n    if (this.isTouch) {\n      this.titleTooltip(e, this.mouseX, this.mouseY, this.isTouch);\n\n      if (this.accumulationDataLabelModule && this.visibleSeries[0].dataLabel.visible) {\n        this.accumulationDataLabelModule.move(e, this.mouseX, this.mouseY, this.isTouch);\n      }\n\n      if (this.accumulationLegendModule && this.legendSettings.visible) {\n        this.accumulationLegendModule.move(e);\n      }\n    }\n\n    this.notify(Browser.touchEndEvent, e);\n    return false;\n  };\n  /*public removeSvgOffset(x: number, y: number): ChartLocation {\n      let rect: ClientRect = this.element.getBoundingClientRect();\n      let svgRect: ClientRect = getElement(this.element.id + '_svg').getBoundingClientRect();\n      return { x: (x - rect.left) - Math.max(svgRect.left - rect.left, 0), y: (y - rect.top) - Math.max(svgRect.top - rect.top, 0)};\n  }*/\n\n  /**\n   * Handles the mouse start.\n   * @return {boolean}\n   * @private\n   */\n\n\n  AccumulationChart.prototype.accumulationMouseStart = function (e) {\n    this.setMouseXY(e);\n    this.trigger(chartMouseDown, {\n      target: e.target.id,\n      x: this.mouseX,\n      y: this.mouseY\n    });\n    return false;\n  };\n  /**\n   * Handles the accumulation chart resize.\n   * @return {boolean}\n   * @private\n   */\n\n\n  AccumulationChart.prototype.accumulationResize = function (e) {\n    var _this = this;\n\n    this.animateSeries = false;\n    var args = {\n      accumulation: this.isBlazor ? {} : this,\n      previousSize: new Size(this.availableSize.width, this.availableSize.height),\n      name: resized,\n      currentSize: new Size(0, 0),\n      chart: this.isBlazor ? {} : this\n    };\n\n    if (this.resizeTo) {\n      clearTimeout(this.resizeTo);\n    }\n\n    this.resizeTo = setTimeout(function () {\n      if (_this.isDestroyed) {\n        clearTimeout(_this.resizeTo);\n        return;\n      }\n\n      calculateSize(_this);\n      args.currentSize = _this.availableSize;\n\n      _this.trigger(resized, args);\n\n      _this.refreshSeries();\n\n      _this.refreshChart();\n    }, 500);\n    return false;\n  };\n  /**\n   * Handles the print method for accumulation chart control.\n   */\n\n\n  AccumulationChart.prototype.print = function (id) {\n    // To handle the print funtion in IE and Edge browsers\n    var clippath = document.getElementById(this.element.id + '_Series_0').style.clipPath;\n    document.getElementById(this.element.id + '_Series_0').style.clipPath = '';\n    var exportChart = new ExportUtils(this);\n    exportChart.print(id);\n    document.getElementById(this.element.id + '_Series_0').style.clipPath = clippath;\n  };\n  /**\n   * Export method for the chart.\n   */\n\n\n  AccumulationChart.prototype.export = function (type, fileName) {\n    if (this.exportModule) {\n      this.exportModule.export(type, fileName);\n    }\n  };\n  /**\n   * Applying styles for accumulation chart element\n   */\n\n\n  AccumulationChart.prototype.setStyle = function (element) {\n    element.style.touchAction = 'element';\n    element.style.msTouchAction = 'element';\n    element.style.msContentZooming = 'none';\n    element.style.msUserSelect = 'none';\n    element.style.webkitUserSelect = 'none';\n    element.style.position = 'relative';\n    element.style.display = 'block';\n  };\n  /**\n   * Method to set the annotation content dynamically for accumulation.\n   */\n\n\n  AccumulationChart.prototype.setAnnotationValue = function (annotationIndex, content) {\n    var annotation = this.annotations[annotationIndex];\n    var element;\n    var parentNode = getElement(this.element.id + '_Annotation_Collections');\n\n    if (content) {\n      annotation.content = content;\n\n      if (parentNode) {\n        element = this.createElement('div');\n        removeElement(this.element.id + '_Annotation_' + annotationIndex);\n        this.annotationModule.processAnnotation(annotation, annotationIndex, element);\n        parentNode.appendChild(element.children[0]);\n      } else {\n        this.annotationModule.renderAnnotations(getElement(this.element.id + '_Secondary_Element'));\n      }\n    }\n  };\n  /**\n   * Handles the mouse move on accumulation chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  AccumulationChart.prototype.accumulationMouseMove = function (e) {\n    this.setMouseXY(e);\n    this.trigger(chartMouseMove, {\n      target: e.target.id,\n      x: this.mouseX,\n      y: this.mouseY\n    });\n\n    if (this.pointMove) {\n      this.triggerPointEvent(pointMove, e.target);\n    }\n\n    if (this.accumulationLegendModule && this.legendSettings.visible) {\n      this.accumulationLegendModule.move(e);\n    }\n\n    if (this.accumulationDataLabelModule && this.visibleSeries[0] && this.visibleSeries[0].dataLabel.visible) {\n      this.accumulationDataLabelModule.move(e, this.mouseX, this.mouseY);\n    }\n\n    if (!this.isTouch) {\n      this.titleTooltip(e, this.mouseX, this.mouseY);\n    }\n\n    this.notify(Browser.touchMoveEvent, e);\n    return false;\n  };\n\n  AccumulationChart.prototype.titleTooltip = function (event, x, y, isTouch) {\n    var targetId = event.target.id;\n    var id = targetId === this.element.id + '_title' || targetId === this.element.id + '_subTitle';\n\n    if (event.target.textContent.indexOf('...') > -1 && id) {\n      var title = targetId === this.element.id + '_title' ? this.title : this.subTitle;\n      showTooltip(title, x, y, this.element.offsetWidth, this.element.id + '_EJ2_Title_Tooltip', getElement(this.element.id + '_Secondary_Element'), isTouch);\n    } else {\n      removeElement(this.element.id + '_EJ2_Title_Tooltip');\n    }\n  };\n  /**\n   * Handles the mouse click on accumulation chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  AccumulationChart.prototype.accumulationOnMouseClick = function (e) {\n    this.setMouseXY(e);\n\n    if (this.accumulationLegendModule && this.legendSettings.visible) {\n      this.accumulationLegendModule.click(e);\n    }\n\n    if (this.selectionMode !== 'None' && this.accumulationSelectionModule) {\n      this.accumulationSelectionModule.calculateSelectedElements(this, e);\n    }\n\n    if (this.visibleSeries[0].explode) {\n      this.accBaseModule.processExplode(e);\n    }\n\n    this.trigger(chartMouseClick, {\n      target: e.target.id,\n      x: this.mouseX,\n      y: this.mouseY\n    });\n\n    if (this.pointClick) {\n      this.triggerPointEvent(pointClick, e.target);\n    }\n\n    return false;\n  };\n\n  AccumulationChart.prototype.triggerPointEvent = function (event, element) {\n    var indexes = indexFinder(element.id, true);\n\n    if (indexes.series >= 0 && indexes.point >= 0) {\n      this.trigger(event, {\n        series: this.isBlazor ? {} : this.series[indexes.series],\n        point: this.series[indexes.series].points[indexes.point],\n        seriesIndex: indexes.series,\n        pointIndex: indexes.point,\n        x: this.mouseX,\n        y: this.mouseY\n      });\n    }\n  };\n  /**\n   * Handles the mouse right click on accumulation chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  AccumulationChart.prototype.accumulationRightClick = function (event) {\n    if (event.buttons === 2 || event.pointerType === 'touch') {\n      event.preventDefault();\n      event.stopPropagation();\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Handles the mouse leave on accumulation chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  AccumulationChart.prototype.accumulationMouseLeave = function (e) {\n    this.setMouseXY(e);\n    this.trigger(chartMouseLeave, {\n      target: e.target.id,\n      x: this.mouseX,\n      y: this.mouseY\n    });\n    this.notify(Browser.isPointer ? 'pointerleave' : 'mouseleave', e);\n    return false;\n  };\n  /**\n   * Method to set culture for chart\n   */\n\n\n  AccumulationChart.prototype.setCulture = function () {\n    this.intl = new Internationalization();\n  };\n  /**\n   * Method to create SVG element for accumulation chart.\n   */\n\n\n  AccumulationChart.prototype.createPieSvg = function () {\n    this.removeSvg();\n    createSvg(this);\n  };\n  /**\n   * To Remove the SVG from accumulation chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  AccumulationChart.prototype.removeSvg = function () {\n    if (this.redraw) {\n      return null;\n    }\n\n    blazorTemplatesReset(this);\n    removeElement(this.element.id + '_Secondary_Element');\n\n    if (this.svgObject) {\n      while (this.svgObject.childNodes.length > 0) {\n        this.svgObject.removeChild(this.svgObject.firstChild);\n      }\n\n      if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {\n        remove(this.svgObject);\n      }\n    }\n\n    removeElement('EJ2_legend_tooltip');\n    removeElement('EJ2_datalabel_tooltip');\n  };\n  /**\n   * Method to create the secondary element for tooltip, datalabel and annotaitons.\n   */\n\n\n  AccumulationChart.prototype.createSecondaryElement = function () {\n    var element = redrawElement(this.redraw, this.element.id + '_Secondary_Element') || this.createElement('div', {\n      id: this.element.id + '_Secondary_Element',\n      styles: 'position: relative'\n    });\n    appendChildElement(false, this.element, element, this.redraw);\n  };\n  /**\n   * Method to find visible series based on series types\n   */\n\n\n  AccumulationChart.prototype.calculateVisibleSeries = function () {\n    this.visibleSeries = [];\n\n    for (var i = 0, length_1 = this.series.length; i < length_1; i++) {\n      this.series[i].index = i;\n\n      if (this.series[i].type === this.type && this.visibleSeries.length === 0) {\n        this.visibleSeries.push(this.series[i]);\n        break;\n      }\n    }\n  };\n  /**\n   * To find points from dataSource\n   */\n\n\n  AccumulationChart.prototype.processData = function (render) {\n    if (render === void 0) {\n      render = true;\n    }\n\n    this.seriesCounts = 0;\n\n    for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {\n      var series = _a[_i];\n      series.dataModule = new Data(series.dataSource || this.dataSource, series.query);\n      series.refreshDataManager(this, render);\n    }\n  };\n  /**\n   * To refresh the accumulation chart\n   * @private\n   */\n\n\n  AccumulationChart.prototype.refreshChart = function () {\n    this.doGrouppingProcess();\n    this.createPieSvg();\n    this.calculateBounds();\n    this.renderElements();\n    removeElement('chartmeasuretext');\n  };\n  /**\n   * Method to find groupped points\n   */\n\n\n  AccumulationChart.prototype.doGrouppingProcess = function () {\n    var series = this.visibleSeries[0];\n\n    if (!isNullOrUndefined(series.resultData) && !isNullOrUndefined(series.lastGroupTo) && series.lastGroupTo !== series.groupTo) {\n      series.getPoints(series.resultData, this);\n    }\n  };\n  /**\n   * Method to calculate bounds for accumulation chart\n   */\n\n\n  AccumulationChart.prototype.calculateBounds = function () {\n    this.initialClipRect = new Rect(this.margin.left, this.margin.top, this.availableSize.width, this.availableSize.height);\n    this.titleCollection = [];\n    this.subTitleCollection = [];\n    var titleHeight = 0;\n    var subTitleHeight = 0;\n    var maxWidth = 0;\n    var titleWidth = 0;\n    this.titleCollection = getTitle(this.title, this.titleStyle, this.initialClipRect.width);\n    titleHeight = measureText(this.title, this.titleStyle).height * this.titleCollection.length;\n\n    if (this.subTitle) {\n      for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {\n        var titleText = _a[_i];\n        titleWidth = measureText(titleText, this.titleStyle).width;\n        maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;\n      }\n\n      this.subTitleCollection = getTitle(this.subTitle, this.subTitleStyle, maxWidth);\n      subTitleHeight = measureText(this.subTitle, this.subTitleStyle).height * this.subTitleCollection.length;\n    }\n\n    subtractRect(this.initialClipRect, new Rect(0, subTitleHeight + titleHeight, this.margin.right + this.margin.left, this.margin.bottom + this.margin.top));\n    this.calculateLegendBounds();\n  };\n  /*\n   * Method to calculate legend bounds for accumulation chart\n   */\n\n\n  AccumulationChart.prototype.calculateLegendBounds = function () {\n    if (!this.accumulationLegendModule || !this.legendSettings.visible) {\n      return null;\n    }\n\n    this.accumulationLegendModule.getLegendOptions(this, this.visibleSeries);\n    this.accumulationLegendModule.calculateLegendBounds(this.initialClipRect, this.availableSize);\n  };\n  /**\n   * To render elements for accumulation chart\n   * @private\n   */\n\n\n  AccumulationChart.prototype.renderElements = function () {\n    this.renderBorder();\n    this.createSecondaryElement();\n    this.renderSeries();\n    this.renderTitle();\n    this.renderLegend();\n    appendChildElement(false, this.element, this.svgObject, this.redraw);\n    this.processSelection();\n    this.processExplode();\n    this.renderAnnotation();\n    this.setSecondaryElementPosition();\n    this.trigger('loaded', {\n      accumulation: this.isBlazor ? {} : this,\n      chart: this.isBlazor ? {} : this\n    });\n    this.animateSeries = false;\n  };\n  /**\n   * To set the left and top position for data label template for center aligned chart\n   * @private\n   */\n\n\n  AccumulationChart.prototype.setSecondaryElementPosition = function () {\n    var tooltipParent = getElement(this.element.id + '_Secondary_Element');\n\n    if (!tooltipParent) {\n      return;\n    }\n\n    var rect = this.element.getBoundingClientRect();\n    var svgRect = getElement(this.element.id + '_svg').getBoundingClientRect();\n    tooltipParent.style.left = Math.max(svgRect.left - rect.left, 0) + 'px';\n    tooltipParent.style.top = Math.max(svgRect.top - rect.top, 0) + 'px';\n  };\n  /**\n   * To render the annotaitions for accumulation series.\n   * @private\n   */\n\n\n  AccumulationChart.prototype.renderAnnotation = function () {\n    if (this.annotationModule) {\n      this.annotationModule.renderAnnotations(getElement(this.element.id + '_Secondary_Element'));\n    }\n  };\n  /**\n   * Method to process the explode in accumulation chart\n   * @private\n   */\n\n\n  AccumulationChart.prototype.processExplode = function () {\n    if (this.redraw) {\n      return null;\n    }\n\n    if (!this.visibleSeries[0].explode) {\n      return null;\n    }\n\n    this.accBaseModule.invokeExplode();\n  };\n  /**\n   * Method to render series for accumulation chart\n   */\n\n\n  AccumulationChart.prototype.renderSeries = function () {\n    if (!this.redraw) {\n      this.svgObject.appendChild(this.renderer.createGroup({\n        id: this.element.id + '_SeriesCollection'\n      }));\n    }\n\n    for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {\n      var series = _a[_i];\n\n      if (series.visible && this[firstToLowerCase(series.type) + 'SeriesModule']) {\n        this[firstToLowerCase(series.type) + 'SeriesModule'].initProperties(this, series);\n        series.renderSeries(this, this.redraw);\n      }\n    }\n  };\n  /**\n   * Method to render border for accumulation chart\n   */\n\n\n  AccumulationChart.prototype.renderBorder = function () {\n    var padding = this.border.width;\n    appendChildElement(false, this.svgObject, this.renderer.drawRectangle(new RectOption(this.element.id + '_border', this.background || this.themeStyle.background, this.border, 1, new Rect(padding / 2, padding / 2, this.availableSize.width - padding, this.availableSize.height - padding))), this.redraw);\n  };\n  /**\n   * Method to render legend for accumulation chart\n   */\n\n\n  AccumulationChart.prototype.renderLegend = function () {\n    if (!this.accumulationLegendModule || !this.legendSettings.visible) {\n      return null;\n    }\n\n    if (this.accumulationLegendModule.legendCollections.length) {\n      if (this.visibleSeries[0].type === 'Pie') {\n        this.accumulationLegendModule.getSmartLegendLocation(this.visibleSeries[0].labelBound, this.accumulationLegendModule.legendBounds, this.margin);\n      }\n\n      this.accumulationLegendModule.renderLegend(this, this.legendSettings, this.accumulationLegendModule.legendBounds, this.redraw);\n    }\n  };\n  /**\n   * To process the selection in accumulation chart\n   * @private\n   */\n\n\n  AccumulationChart.prototype.processSelection = function () {\n    if (!this.accumulationSelectionModule || this.selectionMode === 'None') {\n      return null;\n    }\n\n    var selectedDataIndexes = extend([], this.accumulationSelectionModule.selectedDataIndexes, null, true);\n    this.accumulationSelectionModule.invokeSelection(this);\n\n    if (selectedDataIndexes.length > 0) {\n      this.accumulationSelectionModule.selectedDataIndexes = selectedDataIndexes;\n      this.accumulationSelectionModule.redrawSelection(this, this.selectionMode);\n    }\n  };\n  /**\n   * To render title for accumulation chart\n   */\n\n\n  AccumulationChart.prototype.renderTitle = function () {\n    var rect;\n    var margin = this.margin;\n\n    if (!this.title) {\n      return null;\n    }\n\n    var alignment = this.titleStyle.textAlignment;\n    var getAnchor = alignment === 'Near' ? 'start' : alignment === 'Far' ? 'end' : 'middle';\n    var titleSize = measureText(this.title, this.titleStyle);\n    rect = new Rect(margin.left, 0, this.availableSize.width - margin.left - margin.right, 0);\n    var options = new TextOption(this.element.id + '_title', titlePositionX(rect, this.titleStyle), this.margin.top + titleSize.height * 3 / 4, getAnchor, this.titleCollection, '', 'auto');\n    var element = textElement(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitle, this.svgObject, false, this.redraw);\n\n    if (this.subTitle) {\n      this.renderSubTitle(options);\n    }\n  };\n\n  AccumulationChart.prototype.renderSubTitle = function (options) {\n    var maxWidth = 0;\n    var titleWidth = 0;\n    var padding = 10;\n    var rect;\n    var alignment = this.titleStyle.textAlignment;\n\n    var getAnchor = function (alignment) {\n      return alignment === 'Near' ? 'start' : alignment === 'Far' ? 'end' : 'middle';\n    };\n\n    var subTitleElementSize = measureText(this.subTitle, this.subTitleStyle);\n\n    for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {\n      var titleText = _a[_i];\n      titleWidth = measureText(titleText, this.titleStyle).width;\n      maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;\n    }\n\n    rect = new Rect(alignment === 'Center' ? options.x - maxWidth / 2 : alignment === 'Far' ? options.x - maxWidth : options.x, 0, maxWidth, 0);\n    var subTitleOption = new TextOption(this.element.id + '_subTitle', titlePositionX(rect, this.subTitleStyle), options.y * options.text.length + subTitleElementSize.height * 3 / 4 + padding, getAnchor(this.subTitleStyle.textAlignment), this.subTitleCollection, '', 'auto');\n    var element = textElement(this.renderer, subTitleOption, this.subTitleStyle, this.subTitleStyle.color || this.themeStyle.chartTitle, this.svgObject, false, this.redraw);\n  };\n  /**\n   * To get the series parent element\n   * @private\n   */\n\n\n  AccumulationChart.prototype.getSeriesElement = function () {\n    return this.svgObject.getElementsByTagName('g')[0];\n  };\n  /**\n   * To refresh the all visible series points\n   * @private\n   */\n\n\n  AccumulationChart.prototype.refreshSeries = function () {\n    for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {\n      var series = _a[_i];\n      this.refreshPoints(series.points);\n    }\n  };\n  /**\n   * To refresh points label region and visible\n   * @private\n   */\n\n\n  AccumulationChart.prototype.refreshPoints = function (points) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var point = points_1[_i];\n      point.labelPosition = null;\n      point.labelRegion = null;\n      point.labelVisible = true;\n    }\n  };\n  /**\n   * To get Module name\n   *  @private\n   */\n\n\n  AccumulationChart.prototype.getModuleName = function () {\n    return 'accumulationchart';\n  };\n  /**\n   * To destroy the accumulationcharts\n   * @private\n   */\n\n\n  AccumulationChart.prototype.destroy = function () {\n    this.unWireEvents();\n\n    _super.prototype.destroy.call(this);\n\n    this.element.classList.remove('e-accumulationchart');\n  };\n  /**\n   * To provide the array of modules needed for control rendering\n   * @return {ModuleDeclaration[]}\n   * @private\n   */\n\n\n  AccumulationChart.prototype.requiredModules = function () {\n    var modules = [];\n    var enableAnnotation = false;\n    modules.push({\n      member: this.type + 'Series',\n      args: [this]\n    });\n\n    if (this.legendSettings.visible) {\n      modules.push({\n        member: 'AccumulationLegend',\n        args: [this]\n      });\n    }\n\n    if (this.findDatalabelVisibility()) {\n      modules.push({\n        member: 'AccumulationDataLabel',\n        args: [this]\n      });\n    }\n\n    if (this.tooltip.enable) {\n      modules.push({\n        member: 'AccumulationTooltip',\n        args: [this]\n      });\n    }\n\n    if (this.selectionMode !== 'None') {\n      modules.push({\n        member: 'AccumulationSelection',\n        args: [this]\n      });\n    }\n\n    if (this.enableExport) {\n      modules.push({\n        member: 'Export',\n        args: [this]\n      });\n    }\n\n    enableAnnotation = this.annotations.some(function (value) {\n      return value.content !== null;\n    });\n\n    if (enableAnnotation) {\n      modules.push({\n        member: 'Annotation',\n        args: [this]\n      });\n    }\n\n    return modules;\n  };\n  /**\n   * To find datalabel visibility in series\n   */\n\n\n  AccumulationChart.prototype.findDatalabelVisibility = function () {\n    for (var _i = 0, _a = this.series; _i < _a.length; _i++) {\n      var series = _a[_i];\n\n      if (series.dataLabel.visible) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Get the properties to be maintained in the persisted state.\n   * @private\n   */\n\n\n  AccumulationChart.prototype.getPersistData = function () {\n    return '';\n  };\n  /**\n   * Called internally if any of the property value changed.\n   * @private\n   */\n\n\n  AccumulationChart.prototype.onPropertyChanged = function (newProp, oldProp) {\n    var update = {\n      refreshElements: false,\n      refreshBounds: false\n    };\n\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'theme':\n          this.animateSeries = true;\n          break;\n\n        case 'title':\n        case 'subTitle':\n        case 'height':\n        case 'width':\n        case 'margin':\n          update.refreshBounds = true;\n          break;\n\n        case 'titleStyle':\n          if (newProp.titleStyle && (newProp.titleStyle.size || newProp.titleStyle.textOverflow)) {\n            update.refreshBounds = true;\n          } else {\n            update.refreshElements = true;\n          }\n\n          break;\n\n        case 'subTitleStyle':\n          if (newProp.subTitleStyle && (newProp.subTitleStyle.size || newProp.subTitleStyle.textOverflow)) {\n            update.refreshBounds = true;\n          } else {\n            update.refreshElements = true;\n          }\n\n          break;\n\n        case 'legendSettings':\n          update.refreshBounds = true;\n          update.refreshElements = true;\n          break;\n\n        case 'dataSource':\n          this.processData(false);\n          update.refreshBounds = true;\n          break;\n\n        case 'series':\n          if (!this.animateselected) {\n            var len = this.series.length;\n            var seriesRefresh = false;\n\n            for (var i = 0; i < len; i++) {\n              if (newProp.series[i] && (newProp.series[i].dataSource || newProp.series[i].yName || newProp.series[i].xName)) {\n                seriesRefresh = true;\n              }\n\n              if (newProp.series[i] && newProp.series[i].explodeIndex !== oldProp.series[i].explodeIndex) {\n                this.accBaseModule.explodePoints(newProp.series[i].explodeIndex, this);\n                this.accBaseModule.deExplodeAll(newProp.series[i].explodeIndex, this.enableAnimation ? 300 : 0);\n              }\n            }\n\n            if (seriesRefresh) {\n              this.processData(false);\n              update.refreshBounds = true;\n            }\n          }\n\n          this.animateselected = false;\n          this.redraw = false;\n          break;\n\n        case 'locale':\n        case 'currencyCode':\n          _super.prototype.refresh.call(this);\n\n          break;\n\n        case 'background':\n        case 'border':\n        case 'annotations':\n        case 'enableSmartLabels':\n          update.refreshElements = true;\n          break;\n\n        case 'isMultiSelect':\n        case 'selectedDataIndexes':\n        case 'selectionMode':\n          if (this.accumulationSelectionModule) {\n            if (isNullOrUndefined(this.accumulationSelectionModule.selectedDataIndexes)) {\n              this.accumulationSelectionModule.invokeSelection(this);\n            } else {\n              this.accumulationSelectionModule.redrawSelection(this, oldProp.selectionMode);\n            }\n          }\n\n          break;\n      }\n    }\n\n    if (!update.refreshBounds && update.refreshElements) {\n      this.createPieSvg();\n      this.renderElements();\n    } else if (update.refreshBounds) {\n      this.refreshSeries();\n      this.createPieSvg();\n      this.calculateBounds();\n      this.renderElements();\n    }\n  };\n\n  __decorate([Property(null)], AccumulationChart.prototype, \"width\", void 0);\n\n  __decorate([Property(null)], AccumulationChart.prototype, \"height\", void 0);\n\n  __decorate([Property(null)], AccumulationChart.prototype, \"title\", void 0);\n\n  __decorate([Complex({}, PieCenter)], AccumulationChart.prototype, \"center\", void 0);\n\n  __decorate([Property('')], AccumulationChart.prototype, \"dataSource\", void 0);\n\n  __decorate([Complex(Theme.chartTitleFont, Font)], AccumulationChart.prototype, \"titleStyle\", void 0);\n\n  __decorate([Property(null)], AccumulationChart.prototype, \"subTitle\", void 0);\n\n  __decorate([Complex(Theme.chartSubTitleFont, Font)], AccumulationChart.prototype, \"subTitleStyle\", void 0);\n\n  __decorate([Complex({}, LegendSettings)], AccumulationChart.prototype, \"legendSettings\", void 0);\n\n  __decorate([Complex({}, TooltipSettings)], AccumulationChart.prototype, \"tooltip\", void 0);\n\n  __decorate([Property('None')], AccumulationChart.prototype, \"selectionMode\", void 0);\n\n  __decorate([Property(false)], AccumulationChart.prototype, \"isMultiSelect\", void 0);\n\n  __decorate([Property(true)], AccumulationChart.prototype, \"enableAnimation\", void 0);\n\n  __decorate([Collection([], Indexes)], AccumulationChart.prototype, \"selectedDataIndexes\", void 0);\n\n  __decorate([Complex({}, Margin)], AccumulationChart.prototype, \"margin\", void 0);\n\n  __decorate([Property(true)], AccumulationChart.prototype, \"enableSmartLabels\", void 0);\n\n  __decorate([Complex({\n    color: '#DDDDDD',\n    width: 0\n  }, Border)], AccumulationChart.prototype, \"border\", void 0);\n\n  __decorate([Property(null)], AccumulationChart.prototype, \"background\", void 0);\n\n  __decorate([Collection([{}], AccumulationSeries)], AccumulationChart.prototype, \"series\", void 0);\n\n  __decorate([Collection([{}], AccumulationAnnotationSettings)], AccumulationChart.prototype, \"annotations\", void 0);\n\n  __decorate([Property('Material')], AccumulationChart.prototype, \"theme\", void 0);\n\n  __decorate([Property(false)], AccumulationChart.prototype, \"useGroupingSeparator\", void 0);\n\n  __decorate([Property(true)], AccumulationChart.prototype, \"enableExport\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"loaded\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"load\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"seriesRender\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"legendRender\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"textRender\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"tooltipRender\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"pointRender\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"annotationRender\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"beforePrint\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"chartMouseMove\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"chartMouseClick\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"pointClick\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"pointMove\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"animationComplete\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"chartMouseDown\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"chartMouseLeave\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"chartMouseUp\", void 0);\n\n  __decorate([Event()], AccumulationChart.prototype, \"resized\", void 0);\n\n  __decorate([Property('USD')], AccumulationChart.prototype, \"currencyCode\", void 0);\n\n  AccumulationChart = __decorate([NotifyPropertyChanges], AccumulationChart);\n  return AccumulationChart;\n}(Component);\n\nexport { AccumulationChart };","map":null,"metadata":{},"sourceType":"module"}