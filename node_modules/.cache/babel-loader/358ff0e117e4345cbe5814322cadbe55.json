{"ast":null,"code":"import { drawing as draw, geometry as geom, Color } from '@progress/kendo-drawing';\nimport { ChartElement, ShapeBuilder, TextBox, Box } from '../../core';\nimport PointEventsMixin from '../mixins/point-events-mixin';\nimport { OUTSIDE_END, INSIDE_END, PIE, FADEIN, TOOLTIP_OFFSET } from '../constants';\nimport hasGradientOverlay from '../utils/has-gradient-overlay';\nimport { TOP, BOTTOM, LEFT, RIGHT, DEFAULT_FONT, CIRCLE, WHITE, BLACK, CENTER, DEFAULT_PRECISION } from '../../common/constants';\nimport { setDefaultOptions, getSpacing, getTemplate, deepExtend, round, rad } from '../../common';\n\nvar PieSegment = function (ChartElement) {\n  function PieSegment(value, sector, options) {\n    ChartElement.call(this, options);\n    this.value = value;\n    this.sector = sector;\n  }\n\n  if (ChartElement) PieSegment.__proto__ = ChartElement;\n  PieSegment.prototype = Object.create(ChartElement && ChartElement.prototype);\n  PieSegment.prototype.constructor = PieSegment;\n\n  PieSegment.prototype.render = function render() {\n    var labels = this.options.labels;\n    var chartService = this.owner.chartService;\n    var labelText = this.value;\n\n    if (this._rendered || this.visible === false) {\n      return;\n    }\n\n    this._rendered = true;\n    var labelTemplate = getTemplate(labels);\n    var pointData = this.pointData();\n\n    if (labelTemplate) {\n      labelText = labelTemplate(pointData);\n    } else if (labels.format) {\n      labelText = chartService.format.auto(labels.format, labelText);\n    }\n\n    if (labels.visible && (labelText || labelText === 0)) {\n      if (labels.position === CENTER || labels.position === INSIDE_END) {\n        if (!labels.color) {\n          var brightnessValue = new Color(this.options.color).percBrightness();\n\n          if (brightnessValue > 180) {\n            labels.color = BLACK;\n          } else {\n            labels.color = WHITE;\n          }\n        }\n\n        if (!labels.background) {\n          labels.background = this.options.color;\n        }\n      } else {\n        var themeLabels = chartService.theme.seriesDefaults.labels;\n        labels.color = labels.color || themeLabels.color;\n        labels.background = labels.background || themeLabels.background;\n      }\n\n      this.label = new TextBox(labelText, deepExtend({}, labels, {\n        align: CENTER,\n        vAlign: \"\",\n        animation: {\n          type: FADEIN,\n          delay: this.animationDelay\n        }\n      }), pointData);\n      this.append(this.label);\n    }\n  };\n\n  PieSegment.prototype.reflow = function reflow(targetBox) {\n    this.render();\n    this.box = targetBox;\n    this.reflowLabel();\n  };\n\n  PieSegment.prototype.reflowLabel = function reflowLabel() {\n    var ref = this;\n    var labelsOptions = ref.options.labels;\n    var label = ref.label;\n    var sector = this.sector.clone();\n    var labelsDistance = labelsOptions.distance;\n    var angle = sector.middle();\n\n    if (label) {\n      var labelHeight = label.box.height();\n      var labelWidth = label.box.width();\n      var lp;\n\n      if (labelsOptions.position === CENTER) {\n        sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;\n        lp = sector.point(angle);\n        label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n      } else if (labelsOptions.position === INSIDE_END) {\n        sector.radius = sector.radius - labelHeight / 2;\n        lp = sector.point(angle);\n        label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n      } else {\n        var x1;\n        lp = sector.clone().expand(labelsDistance).point(angle);\n\n        if (lp.x >= sector.center.x) {\n          x1 = lp.x + labelWidth;\n          label.orientation = RIGHT;\n        } else {\n          x1 = lp.x - labelWidth;\n          label.orientation = LEFT;\n        }\n\n        label.reflow(new Box(x1, lp.y - labelHeight, lp.x, lp.y));\n      }\n    }\n  };\n\n  PieSegment.prototype.createVisual = function createVisual() {\n    var this$1 = this;\n    var ref = this;\n    var sector = ref.sector;\n    var options = ref.options;\n    ChartElement.prototype.createVisual.call(this);\n\n    if (this.value) {\n      if (options.visual) {\n        var startAngle = (sector.startAngle + 180) % 360;\n        var visual = options.visual({\n          category: this.category,\n          dataItem: this.dataItem,\n          value: this.value,\n          series: this.series,\n          percentage: this.percentage,\n          center: new geom.Point(sector.center.x, sector.center.y),\n          radius: sector.radius,\n          innerRadius: sector.innerRadius,\n          startAngle: startAngle,\n          endAngle: startAngle + sector.angle,\n          options: options,\n          sender: this.getSender(),\n          createVisual: function () {\n            var group = new draw.Group();\n            this$1.createSegmentVisual(group);\n            return group;\n          }\n        });\n\n        if (visual) {\n          this.visual.append(visual);\n        }\n      } else {\n        this.createSegmentVisual(this.visual);\n      }\n    }\n  };\n\n  PieSegment.prototype.createSegmentVisual = function createSegmentVisual(group) {\n    var ref = this;\n    var sector = ref.sector;\n    var options = ref.options;\n    var borderOptions = options.border || {};\n    var border = borderOptions.width > 0 ? {\n      stroke: {\n        color: borderOptions.color,\n        width: borderOptions.width,\n        opacity: borderOptions.opacity,\n        dashType: borderOptions.dashType\n      }\n    } : {};\n    var color = options.color;\n    var fill = {\n      color: color,\n      opacity: options.opacity\n    };\n    var visual = this.createSegment(sector, deepExtend({\n      fill: fill,\n      stroke: {\n        opacity: options.opacity\n      },\n      zIndex: options.zIndex\n    }, border));\n    group.append(visual);\n\n    if (hasGradientOverlay(options)) {\n      group.append(this.createGradientOverlay(visual, {\n        baseColor: color,\n        fallbackFill: fill\n      }, deepExtend({\n        center: [sector.center.x, sector.center.y],\n        innerRadius: sector.innerRadius,\n        radius: sector.radius,\n        userSpace: true\n      }, options.overlay)));\n    }\n  };\n\n  PieSegment.prototype.createSegment = function createSegment(sector, options) {\n    if (options.singleSegment) {\n      return new draw.Circle(new geom.Circle(new geom.Point(sector.center.x, sector.center.y), sector.radius), options);\n    }\n\n    return ShapeBuilder.current.createRing(sector, options);\n  };\n\n  PieSegment.prototype.createAnimation = function createAnimation() {\n    var ref = this;\n    var options = ref.options;\n    var center = ref.sector.center;\n    deepExtend(options, {\n      animation: {\n        center: [center.x, center.y],\n        delay: this.animationDelay\n      }\n    });\n    ChartElement.prototype.createAnimation.call(this);\n  };\n\n  PieSegment.prototype.createHighlight = function createHighlight(options) {\n    var highlight = this.options.highlight || {};\n    var border = highlight.border || {};\n    return this.createSegment(this.sector, deepExtend({}, options, {\n      fill: {\n        color: highlight.color,\n        opacity: highlight.opacity\n      },\n      stroke: {\n        opacity: border.opacity,\n        width: border.width,\n        color: border.color\n      }\n    }));\n  };\n\n  PieSegment.prototype.highlightVisual = function highlightVisual() {\n    return this.visual.children[0];\n  };\n\n  PieSegment.prototype.highlightVisualArgs = function highlightVisualArgs() {\n    var sector = this.sector;\n    return {\n      options: this.options,\n      radius: sector.radius,\n      innerRadius: sector.innerRadius,\n      center: new geom.Point(sector.center.x, sector.center.y),\n      startAngle: sector.startAngle,\n      endAngle: sector.angle + sector.startAngle,\n      visual: this.visual\n    };\n  };\n\n  PieSegment.prototype.tooltipAnchor = function tooltipAnchor() {\n    var sector = this.sector.clone().expand(TOOLTIP_OFFSET);\n    var midAndle = sector.middle();\n    var midPoint = sector.point(midAndle);\n    return {\n      point: midPoint,\n      align: tooltipAlignment(midAndle + 180)\n    };\n  };\n\n  PieSegment.prototype.formatValue = function formatValue(format) {\n    return this.owner.formatPointValue(this, format);\n  };\n\n  PieSegment.prototype.pointData = function pointData() {\n    return {\n      dataItem: this.dataItem,\n      category: this.category,\n      value: this.value,\n      series: this.series,\n      percentage: this.percentage\n    };\n  };\n\n  return PieSegment;\n}(ChartElement);\n\nvar RAD_30 = round(rad(30), DEFAULT_PRECISION);\nvar RAD_60 = round(rad(60), DEFAULT_PRECISION);\n\nfunction tooltipAlignment(angle) {\n  var radians = rad(angle);\n  var sine = round(Math.sin(radians), DEFAULT_PRECISION);\n  var cosine = round(Math.cos(radians), DEFAULT_PRECISION);\n  var horizontal;\n\n  if (Math.abs(sine) > RAD_60) {\n    horizontal = CENTER;\n  } else if (cosine < 0) {\n    horizontal = RIGHT;\n  } else {\n    horizontal = LEFT;\n  }\n\n  var vertical;\n\n  if (Math.abs(sine) < RAD_30) {\n    vertical = CENTER;\n  } else if (sine < 0) {\n    vertical = BOTTOM;\n  } else {\n    vertical = TOP;\n  }\n\n  return {\n    horizontal: horizontal,\n    vertical: vertical\n  };\n}\n\nsetDefaultOptions(PieSegment, {\n  color: WHITE,\n  overlay: {\n    gradient: \"roundedBevel\"\n  },\n  border: {\n    width: 0.5\n  },\n  labels: {\n    visible: false,\n    distance: 35,\n    font: DEFAULT_FONT,\n    margin: getSpacing(0.5),\n    align: CIRCLE,\n    zIndex: 1,\n    position: OUTSIDE_END\n  },\n  animation: {\n    type: PIE\n  },\n  highlight: {\n    visible: true,\n    border: {\n      width: 1\n    }\n  },\n  visible: true\n});\ndeepExtend(PieSegment.prototype, PointEventsMixin);\nexport default PieSegment;","map":null,"metadata":{},"sourceType":"module"}