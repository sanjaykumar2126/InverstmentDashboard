{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Animation, compile as templateComplier, Browser } from '@syncfusion/ej2-base';\nimport { merge, extend, isNullOrUndefined, resetBlazorTemplate } from '@syncfusion/ej2-base';\nimport { createElement, remove } from '@syncfusion/ej2-base';\nimport { Index } from '../../common/model/base';\nimport { VisibleLabels } from '../../chart/axis/axis';\nimport { axisLabelRender } from '../model/constants';\nimport { measureText, findDirection, Rect, TextOption, Size, PathOption, SvgRenderer, CanvasRenderer } from '@syncfusion/ej2-svg-base';\n/**\n * Function to sort the dataSource, by default it sort the data in ascending order.\n * @param  {Object} data\n * @param  {string} fields\n * @param  {boolean} isDescending\n * @returns Object\n */\n\nexport function sort(data, fields, isDescending) {\n  var sortData = extend([], data, null);\n  sortData.sort(function (a, b) {\n    var first = 0;\n    var second = 0;\n\n    for (var i = 0; i < fields.length; i++) {\n      first += a[fields[i]];\n      second += b[fields[i]];\n    }\n\n    if (!isDescending && first < second || isDescending && first > second) {\n      return -1;\n    } else if (first === second) {\n      return 0;\n    }\n\n    return 1;\n  });\n  return sortData;\n}\n/** @private */\n\nexport function isBreakLabel(label) {\n  return label.indexOf('<br>') !== -1;\n}\n/** @private */\n\nexport function rotateTextSize(font, text, angle, chart) {\n  var renderer = new SvgRenderer(chart.element.id);\n  var box;\n  var options;\n  var htmlObject;\n  options = {\n    'font-size': font.size,\n    'font-style': font.fontStyle,\n    'font-family': font.fontFamily,\n    'font-weight': font.fontWeight,\n    'transform': 'rotate(' + angle + ', 0, 0)',\n    'text-anchor': 'middle'\n  };\n  htmlObject = renderer.createText(options, text);\n\n  if (!chart.delayRedraw && !chart.redraw) {\n    chart.element.appendChild(chart.svgObject);\n  }\n\n  chart.svgObject.appendChild(htmlObject);\n  box = htmlObject.getBoundingClientRect();\n  remove(htmlObject);\n\n  if (!chart.delayRedraw && !chart.redraw) {\n    remove(chart.svgObject);\n  }\n\n  return new Size(box.right - box.left, box.bottom - box.top);\n}\n/** @private */\n\nexport function removeElement(id) {\n  if (!id) {\n    return null;\n  }\n\n  var element = typeof id === 'string' ? getElement(id) : id;\n\n  if (element) {\n    remove(element);\n  }\n}\n/** @private */\n\nexport function logBase(value, base) {\n  return Math.log(value) / Math.log(base);\n}\n/** @private */\n\nexport function showTooltip(text, x, y, areaWidth, id, element, isTouch) {\n  //let id1: string = 'EJ2_legend_tooltip';\n  var tooltip = document.getElementById(id);\n  var width = measureText(text, {\n    fontFamily: 'Segoe UI',\n    size: '12px',\n    fontStyle: 'Normal',\n    fontWeight: 'Regular'\n  }).width + 5;\n  x = x + width > areaWidth ? x - width : x;\n\n  if (!tooltip) {\n    tooltip = createElement('div', {\n      innerHTML: text,\n      id: id,\n      styles: 'top:' + (y + 15).toString() + 'px;left:' + (x + 15).toString() + 'px;background-color: rgb(255, 255, 255) !important; color:black !important; ' + 'position:absolute;border:1px solid rgb(112, 112, 112); padding-left : 3px; padding-right : 2px;' + 'padding-bottom : 2px; padding-top : 2px; font-size:12px; font-family: \"Segoe UI\"'\n    });\n    element.appendChild(tooltip);\n  } else {\n    tooltip.innerHTML = text;\n    tooltip.style.top = (y + 15).toString() + 'px';\n    tooltip.style.left = (x + 15).toString() + 'px';\n  }\n\n  if (isTouch) {\n    setTimeout(function () {\n      removeElement(id);\n    }, 1500);\n  }\n}\n/** @private */\n\nexport function inside(value, range) {\n  return value < range.max && value > range.min;\n}\n/** @private */\n\nexport function withIn(value, range) {\n  return value <= range.max && value >= range.min;\n}\n/** @private */\n\nexport function logWithIn(value, axis) {\n  if (axis.valueType === 'Logarithmic') {\n    value = logBase(value, axis.logBase);\n  } else {\n    value = value;\n  }\n\n  return value;\n}\n/** @private */\n\nexport function withInRange(previousPoint, currentPoint, nextPoint, series) {\n  var mX2 = logWithIn(currentPoint.xValue, series.xAxis);\n  var mX1 = previousPoint ? logWithIn(previousPoint.xValue, series.xAxis) : mX2;\n  var mX3 = nextPoint ? logWithIn(nextPoint.xValue, series.xAxis) : mX2;\n  var xStart = Math.floor(series.xAxis.visibleRange.min);\n  var xEnd = Math.ceil(series.xAxis.visibleRange.max);\n  return mX1 >= xStart && mX1 <= xEnd || mX2 >= xStart && mX2 <= xEnd || mX3 >= xStart && mX3 <= xEnd || xStart >= mX1 && xStart <= mX3;\n}\n/** @private */\n\nexport function sum(values) {\n  var sum = 0;\n\n  for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n    var value = values_1[_i];\n    sum += value;\n  }\n\n  return sum;\n}\n/** @private */\n\nexport function subArraySum(values, first, last, index, series) {\n  var sum = 0;\n\n  if (index !== null) {\n    for (var i = first + 1; i < last; i++) {\n      if (index.indexOf(i) === -1) {\n        sum += values[i][series.yName];\n      }\n    }\n  } else {\n    for (var i = first + 1; i < last; i++) {\n      if (!isNullOrUndefined(values[i][series.yName])) {\n        sum += values[i][series.yName];\n      }\n    }\n  }\n\n  return sum;\n}\n/** @private */\n\nexport function subtractThickness(rect, thickness) {\n  rect.x += thickness.left;\n  rect.y += thickness.top;\n  rect.width -= thickness.left + thickness.right;\n  rect.height -= thickness.top + thickness.bottom;\n  return rect;\n}\n/** @private */\n\nexport function subtractRect(rect, thickness) {\n  rect.x += thickness.x;\n  rect.y += thickness.y;\n  rect.width -= thickness.x + thickness.width;\n  rect.height -= thickness.y + thickness.height;\n  return rect;\n}\n/** @private */\n\nexport function degreeToLocation(degree, radius, center) {\n  var radian = degree * Math.PI / 180;\n  return new ChartLocation(Math.cos(radian) * radius + center.x, Math.sin(radian) * radius + center.y);\n}\n\nfunction getAccumulationLegend(locX, locY, r, height, width, mode) {\n  var cartesianlarge = degreeToLocation(270, r, new ChartLocation(locX, locY));\n  var cartesiansmall = degreeToLocation(270, r, new ChartLocation(locX + width / 10, locY));\n  return 'M' + ' ' + locX + ' ' + locY + ' ' + 'L' + ' ' + (locX + r) + ' ' + locY + ' ' + 'A' + ' ' + r + ' ' + r + ' ' + 0 + ' ' + 1 + ' ' + 1 + ' ' + cartesianlarge.x + ' ' + cartesianlarge.y + ' ' + 'Z' + ' ' + 'M' + ' ' + (locX + width / 10) + ' ' + (locY - height / 10) + ' ' + 'L' + (locX + r) + ' ' + (locY - height / 10) + ' ' + 'A' + ' ' + r + ' ' + r + ' ' + 0 + ' ' + 0 + ' ' + 0 + ' ' + cartesiansmall.x + ' ' + cartesiansmall.y + ' ' + 'Z';\n}\n/** @private */\n\n\nexport function getAngle(center, point) {\n  var angle = Math.atan2(point.y - center.y, point.x - center.x);\n  angle = angle < 0 ? 6.283 + angle : angle;\n  return angle * (180 / Math.PI);\n}\n/** @private */\n\nexport function subArray(values, index) {\n  var subArray = [];\n\n  for (var i = 0; i <= index - 1; i++) {\n    subArray.push(values[i]);\n  }\n\n  return subArray;\n}\n/** @private */\n\nexport function valueToCoefficient(value, axis) {\n  var range = axis.visibleRange;\n  var result = (value - range.min) / range.delta;\n  return axis.isInversed ? 1 - result : result;\n}\n/** @private */\n\nexport function TransformToVisible(x, y, xAxis, yAxis, isInverted, series) {\n  x = xAxis.valueType === 'Logarithmic' ? logBase(x > 1 ? x : 1, xAxis.logBase) : x;\n  y = yAxis.valueType === 'Logarithmic' ? logBase(y > 1 ? y : 1, yAxis.logBase) : y;\n  x += xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks' && series.type !== 'Radar' ? 0.5 : 0;\n  var radius = series.chart.radius * valueToCoefficient(y, yAxis);\n  var point = CoefficientToVector(valueToPolarCoefficient(x, xAxis), series.chart.primaryXAxis.startAngle);\n  return {\n    x: series.clipRect.width / 2 + series.clipRect.x + radius * point.x,\n    y: series.clipRect.height / 2 + series.clipRect.y + radius * point.y\n  };\n}\n/**\n * method to find series, point index by element id\n * @private\n */\n\nexport function indexFinder(id, isPoint) {\n  if (isPoint === void 0) {\n    isPoint = false;\n  }\n\n  var ids = ['NaN', 'NaN'];\n\n  if (id.indexOf('_Point_') > -1) {\n    ids = id.split('_Series_')[1].split('_Point_');\n  } else if (id.indexOf('_shape_') > -1 && (!isPoint || isPoint && id.indexOf('_legend_') === -1)) {\n    ids = id.split('_shape_');\n    ids[0] = '0';\n  } else if (id.indexOf('_text_') > -1 && (!isPoint || isPoint && id.indexOf('_legend_') === -1)) {\n    ids = id.split('_text_');\n    ids[0] = '0';\n  }\n\n  return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));\n}\n/** @private */\n\nexport function CoefficientToVector(coefficient, startAngle) {\n  startAngle = startAngle < 0 ? startAngle + 360 : startAngle;\n  var angle = Math.PI * (1.5 - 2 * coefficient);\n  angle = angle + startAngle * Math.PI / 180;\n  return {\n    x: Math.cos(angle),\n    y: Math.sin(angle)\n  };\n}\n/** @private */\n\nexport function valueToPolarCoefficient(value, axis) {\n  var range = axis.visibleRange;\n  var delta;\n  var length;\n\n  if (axis.valueType !== 'Category') {\n    delta = range.max - (axis.valueType === 'DateTime' ? axis.dateTimeInterval : range.interval) - range.min;\n    length = axis.visibleLabels.length - 1;\n    delta = delta === 0 ? 1 : delta;\n  } else {\n    delta = range.delta;\n    length = axis.visibleLabels.length;\n  }\n\n  return axis.isInversed ? (value - range.min) / delta * (1 - 1 / length) : 1 - (value - range.min) / delta * (1 - 1 / length);\n}\n/** @private */\n\nvar Mean =\n/** @class */\nfunction () {\n  function Mean(verticalStandardMean, verticalSquareRoot, horizontalStandardMean, horizontalSquareRoot, verticalMean, horizontalMean) {\n    this.verticalStandardMean = verticalStandardMean;\n    this.horizontalStandardMean = horizontalStandardMean;\n    this.verticalSquareRoot = verticalSquareRoot;\n    this.horizontalSquareRoot = horizontalSquareRoot;\n    this.verticalMean = verticalMean;\n    this.horizontalMean = horizontalMean;\n  }\n\n  return Mean;\n}();\n\nexport { Mean };\n/** @private */\n\nvar PolarArc =\n/** @class */\nfunction () {\n  function PolarArc(startAngle, endAngle, innerRadius, radius, currentXPosition) {\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.innerRadius = innerRadius;\n    this.radius = radius;\n    this.currentXPosition = currentXPosition;\n  }\n\n  return PolarArc;\n}();\n\nexport { PolarArc };\n/** @private */\n\nexport function createTooltip(id, text, top, left, fontSize) {\n  var tooltip = getElement(id);\n  var style = 'top:' + top.toString() + 'px;' + 'left:' + left.toString() + 'px;' + 'color:black !important; ' + 'background:#FFFFFF !important; ' + 'position:absolute;border:1px solid #707070;font-size:' + fontSize + ';border-radius:2px; z-index:1';\n\n  if (!tooltip) {\n    tooltip = createElement('div', {\n      id: id,\n      innerHTML: '&nbsp;' + text + '&nbsp;',\n      styles: style\n    });\n    document.body.appendChild(tooltip);\n  } else {\n    tooltip.setAttribute('innerHTML', '&nbsp;' + text + '&nbsp;');\n    tooltip.setAttribute('styles', style);\n  }\n}\n/** @private */\n\nexport function createZoomingLabels(chart, axis, parent, index, isVertical, rect) {\n  var margin = 5;\n  var opposedPosition = axis.opposedPosition;\n  var anchor = isVertical ? 'start' : 'auto';\n  var size;\n  var chartRect = chart.availableSize.width;\n  var x;\n  var y;\n  var rx = 3;\n  var arrowLocation;\n  var direction;\n  var scrollBarHeight = axis.scrollbarSettings.enable || axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject ? axis.scrollBarHeight : 0;\n\n  for (var i = 0; i < 2; i++) {\n    size = measureText(i ? axis.endLabel : axis.startLabel, axis.labelStyle);\n\n    if (isVertical) {\n      arrowLocation = i ? new ChartLocation(rect.x - scrollBarHeight, rect.y + rx) : new ChartLocation(axis.rect.x - scrollBarHeight, rect.y + rect.height - rx);\n      x = rect.x + (opposedPosition ? rect.width + margin + scrollBarHeight : -(size.width + margin + margin + scrollBarHeight));\n      y = rect.y + (i ? 0 : rect.height - size.height - margin);\n      x += x < 0 || chartRect < x + size.width + margin ? opposedPosition ? -(size.width / 2) : size.width / 2 : 0;\n      direction = findDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, false, false, !opposedPosition, arrowLocation.x, arrowLocation.y + (i ? -rx : rx));\n    } else {\n      arrowLocation = i ? new ChartLocation(rect.x + rect.width - rx, rect.y + rect.height + scrollBarHeight) : new ChartLocation(rect.x + rx, rect.y + rect.height + scrollBarHeight);\n      x = rect.x + (i ? rect.width - size.width - margin : 0);\n      y = opposedPosition ? rect.y - size.height - 10 - scrollBarHeight : rect.y + rect.height + margin + scrollBarHeight;\n      direction = findDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, opposedPosition, !opposedPosition, false, arrowLocation.x + (i ? rx : -rx), arrowLocation.y);\n    }\n\n    x = x + margin / 2;\n    y = y + 3 * (size.height / 4) + margin / 2;\n    parent.appendChild(chart.renderer.drawPath(new PathOption(chart.element.id + '_Zoom_' + index + '_AxisLabel_Shape_' + i, chart.themeStyle.crosshairFill, 2, chart.themeStyle.crosshairFill, 1, null, direction)));\n    textElement(chart.renderer, new TextOption(chart.element.id + '_Zoom_' + index + '_AxisLabel_' + i, x, y, anchor, i ? axis.endLabel : axis.startLabel), {\n      color: chart.themeStyle.crosshairLabel,\n      fontFamily: 'Segoe UI',\n      fontWeight: 'Regular',\n      size: '11px'\n    }, chart.themeStyle.crosshairLabel, parent);\n  }\n\n  return parent;\n} //Within bounds\n\n/** @private */\n\nexport function withInBounds(x, y, bounds, width, height) {\n  if (width === void 0) {\n    width = 0;\n  }\n\n  if (height === void 0) {\n    height = 0;\n  }\n\n  return x >= bounds.x - width && x <= bounds.x + bounds.width + width && y >= bounds.y - height && y <= bounds.y + bounds.height + height;\n}\n/** @private */\n\nexport function getValueXByPoint(value, size, axis) {\n  var actualValue = !axis.isInversed ? value / size : 1 - value / size;\n  return actualValue * axis.visibleRange.delta + axis.visibleRange.min;\n}\n/** @private */\n\nexport function getValueYByPoint(value, size, axis) {\n  var actualValue = axis.isInversed ? value / size : 1 - value / size;\n  return actualValue * axis.visibleRange.delta + axis.visibleRange.min;\n}\n/** @private */\n\nexport function findClipRect(series) {\n  var rect = series.clipRect;\n\n  if (series.chart.requireInvertedAxis) {\n    rect.x = series.yAxis.rect.x;\n    rect.y = series.xAxis.rect.y;\n    rect.width = series.yAxis.rect.width;\n    rect.height = series.xAxis.rect.height;\n  } else {\n    rect.x = series.xAxis.rect.x;\n    rect.y = series.yAxis.rect.y;\n    rect.width = series.xAxis.rect.width;\n    rect.height = series.yAxis.rect.height;\n  }\n}\n/** @private */\n\nexport function firstToLowerCase(str) {\n  return str.substr(0, 1).toLowerCase() + str.substr(1);\n}\n/** @private */\n\nexport function getTransform(xAxis, yAxis, invertedAxis) {\n  var x;\n  var y;\n  var width;\n  var height;\n\n  if (invertedAxis) {\n    x = yAxis.rect.x;\n    y = xAxis.rect.y;\n    width = yAxis.rect.width;\n    height = xAxis.rect.height;\n  } else {\n    x = xAxis.rect.x;\n    y = yAxis.rect.y;\n    width = xAxis.rect.width;\n    height = yAxis.rect.height;\n  }\n\n  return new Rect(x, y, width, height);\n}\n/** @private */\n\nexport function getMinPointsDelta(axis, seriesCollection) {\n  var minDelta = Number.MAX_VALUE;\n  var xValues;\n  var minVal;\n  var seriesMin;\n  seriesCollection.forEach(function (series, index) {\n    xValues = [];\n\n    if (series.visible && (axis.name === series.xAxisName || axis.name === 'primaryXAxis' && series.xAxisName === null || axis.name === series.chart.primaryXAxis.name && !series.xAxisName)) {\n      xValues = series.points.map(function (point, index) {\n        return point.xValue;\n      });\n      xValues.sort(function (first, second) {\n        return first - second;\n      });\n\n      if (xValues.length === 1) {\n        seriesMin = axis.valueType === 'DateTime' && series.xMin === series.xMax ? series.xMin - 2592000000 : series.xMin;\n        minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ? seriesMin : axis.visibleRange.min);\n\n        if (minVal !== 0) {\n          minDelta = Math.min(minDelta, minVal);\n        }\n      } else {\n        xValues.forEach(function (value, index, xValues) {\n          if (index > 0 && value) {\n            minVal = value - xValues[index - 1];\n\n            if (minVal !== 0) {\n              minDelta = Math.min(minDelta, minVal);\n            }\n          }\n        });\n      }\n    }\n  });\n\n  if (minDelta === Number.MAX_VALUE) {\n    minDelta = 1;\n  }\n\n  return minDelta;\n}\n/** @private */\n\nexport function getAnimationFunction(effect) {\n  var functionName;\n\n  switch (effect) {\n    case 'Linear':\n      functionName = linear;\n      break;\n  }\n\n  return functionName;\n}\n/**\n * Animation Effect Calculation Started Here\n * @param currentTime\n * @param startValue\n * @param endValue\n * @param duration\n * @private\n */\n\nexport function linear(currentTime, startValue, endValue, duration) {\n  return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;\n}\n/**\n * Animation Effect Calculation End\n * @private\n */\n\nexport function markerAnimate(element, delay, duration, series, pointIndex, point, isLabel) {\n  var centerX = point.x;\n  var centerY = point.y;\n  var height = 0;\n  element.style.visibility = 'hidden';\n  new Animation({}).animate(element, {\n    duration: duration,\n    delay: delay,\n    progress: function (args) {\n      if (args.timeStamp > args.delay) {\n        args.element.style.visibility = 'visible';\n        height = (args.timeStamp - args.delay) / args.duration;\n        element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(' + height + ') translate(' + -centerX + ' ' + -centerY + ')');\n      }\n    },\n    end: function (model) {\n      element.style.visibility = '';\n      element.removeAttribute('transform');\n\n      if ((series.type === 'Scatter' || series.type === 'Bubble') && !isLabel && pointIndex === series.points.length - 1) {\n        series.chart.trigger('animationComplete', {\n          series: series.chart.isBlazor ? {} : series\n        });\n      }\n    }\n  });\n}\n/**\n * Animate the rect element\n */\n\nexport function animateRectElement(element, delay, duration, currentRect, previousRect) {\n  var setStyle = function (rect) {\n    element.setAttribute('x', rect.x + '');\n    element.setAttribute('y', rect.y + '');\n    element.setAttribute('width', rect.width + '');\n    element.setAttribute('height', rect.height + '');\n  };\n\n  new Animation({}).animate(createElement('div'), {\n    duration: duration,\n    delay: delay,\n    name: name,\n    progress: function (args) {\n      setStyle(new Rect(linear(args.timeStamp, previousRect.x, currentRect.x - previousRect.x, args.duration), linear(args.timeStamp, previousRect.y, currentRect.y - previousRect.y, args.duration), linear(args.timeStamp, previousRect.width, currentRect.width - previousRect.width, args.duration), linear(args.timeStamp, previousRect.height, currentRect.height - previousRect.height, args.duration)));\n    },\n    end: function () {\n      setStyle(currentRect);\n    }\n  });\n}\n/**\n * Animation after legend click a path\n * @param element element to be animated\n * @param direction current direction of the path\n * @param previousDirection previous direction of the path\n */\n\nexport function pathAnimation(element, direction, redraw, previousDirection, animateDuration) {\n  if (!redraw || !previousDirection && !element) {\n    return null;\n  }\n\n  var duration = 300;\n\n  if (animateDuration) {\n    duration = animateDuration;\n  }\n\n  var startDirections = previousDirection || element.getAttribute('d');\n  var splitDirections = startDirections.split(/(?=[LMCZAQ])/);\n  var endDirections = direction.split(/(?=[LMCZAQ])/);\n  var currentDireciton;\n  var startPath = [];\n  var endPath = [];\n  var c;\n  var end;\n  element.setAttribute('d', startDirections);\n  new Animation({}).animate(createElement('div'), {\n    duration: duration,\n    progress: function (args) {\n      currentDireciton = '';\n      splitDirections.map(function (directions, index) {\n        startPath = directions.split(' ');\n        endPath = endDirections[index] ? endDirections[index].split(' ') : startPath;\n\n        if (startPath[0] === 'Z') {\n          currentDireciton += 'Z' + ' ';\n        } else {\n          currentDireciton += startPath[0] + ' ' + linear(args.timeStamp, +startPath[1], +endPath[1] - +startPath[1], args.duration) + ' ' + linear(args.timeStamp, +startPath[2], +endPath[2] - +startPath[2], args.duration) + ' ';\n        }\n\n        if (startPath[0] === 'C' || startPath[0] === 'Q') {\n          c = 3;\n          end = startPath[0] === 'Q' ? 4 : 6;\n\n          while (c < end) {\n            currentDireciton += linear(args.timeStamp, +startPath[c], +endPath[c] - +startPath[c], args.duration) + ' ' + linear(args.timeStamp, +startPath[++c], +endPath[c] - +startPath[c], args.duration) + ' ';\n            ++c;\n          }\n        }\n\n        if (startPath[0] === 'A') {\n          currentDireciton += 0 + ' ' + 0 + ' ' + 1 + ' ' + linear(args.timeStamp, +startPath[6], +endPath[6] - +startPath[6], args.duration) + ' ' + linear(args.timeStamp, +startPath[7], +endPath[7] - +startPath[7], args.duration) + ' ';\n        }\n      });\n      element.setAttribute('d', currentDireciton);\n    },\n    end: function () {\n      element.setAttribute('d', direction);\n    }\n  });\n}\n/**\n * To append the clip rect element\n * @param redraw\n * @param options\n * @param renderer\n * @param clipPath\n */\n\nexport function appendClipElement(redraw, options, renderer, clipPath) {\n  if (clipPath === void 0) {\n    clipPath = 'drawClipPath';\n  }\n\n  var clipElement = redrawElement(redraw, options.id, options, renderer);\n\n  if (clipElement) {\n    var def = renderer.createDefs();\n    def.appendChild(clipElement);\n    return def;\n  } else {\n    return renderer[clipPath](options);\n  }\n}\n/**\n * Triggers the event.\n * @return {void}\n * @private\n */\n\nexport function triggerLabelRender(chart, tempInterval, text, labelStyle, axis) {\n  var argsData;\n  argsData = {\n    cancel: false,\n    name: axisLabelRender,\n    axis: axis,\n    text: text,\n    value: tempInterval,\n    labelStyle: labelStyle\n  };\n  chart.trigger(axisLabelRender, argsData);\n\n  if (!argsData.cancel) {\n    var isLineBreakLabels = argsData.text.indexOf('<br>') !== -1;\n    var text_1 = axis.enableTrim ? isLineBreakLabels ? lineBreakLabelTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle) : textTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle) : argsData.text;\n    axis.visibleLabels.push(new VisibleLabels(text_1, argsData.value, argsData.labelStyle, argsData.text));\n  }\n}\n/**\n * The function used to find whether the range is set.\n * @return {boolean}\n * @private\n */\n\nexport function setRange(axis) {\n  return axis.minimum != null && axis.maximum != null;\n}\n/**\n * Calculate desired interval for the axis.\n * @return {void}\n * @private\n */\n\nexport function getActualDesiredIntervalsCount(availableSize, axis) {\n  var size = axis.orientation === 'Horizontal' ? availableSize.width : availableSize.height;\n\n  if (isNullOrUndefined(axis.desiredIntervals)) {\n    var desiredIntervalsCount = (axis.orientation === 'Horizontal' ? 0.533 : 1) * axis.maximumLabels;\n    desiredIntervalsCount = Math.max(size * (desiredIntervalsCount / 100), 1);\n    return desiredIntervalsCount;\n  } else {\n    return axis.desiredIntervals;\n  }\n}\n/**\n * Animation for template\n * @private\n */\n\nexport function templateAnimate(element, delay, duration, name, isRemove) {\n  new Animation({}).animate(element, {\n    duration: duration,\n    delay: delay,\n    name: name,\n    progress: function (args) {\n      args.element.style.visibility = 'visible';\n    },\n    end: function (args) {\n      if (isRemove) {\n        remove(args.element);\n      } else {\n        args.element.style.visibility = 'visible';\n      }\n    }\n  });\n}\n/** @private */\n\nexport function drawSymbol(location, shape, size, url, options, label, renderer, clipRect) {\n  var chartRenderer = renderer ? renderer : new SvgRenderer('');\n  var shapeOption = calculateShapes(location, size, shape, options, url);\n  var drawElement = chartRenderer['draw' + shapeOption.functionName](shapeOption.renderOption, clipRect ? new Int32Array([clipRect.x, clipRect.y]) : null); //drawElement.setAttribute('aria-label', label);\n\n  return drawElement;\n}\n/** @private */\n\nexport function calculateShapes(location, size, shape, options, url) {\n  var dir;\n  var functionName = 'Path';\n  var width = size.width;\n  var height = size.height;\n  var lx = location.x;\n  var ly = location.y;\n  var y = location.y + -height / 2;\n  var x = location.x + -width / 2;\n\n  switch (shape) {\n    case 'Bubble':\n    case 'Circle':\n      functionName = 'Ellipse';\n      merge(options, {\n        'rx': width / 2,\n        'ry': height / 2,\n        'cx': lx,\n        'cy': ly\n      });\n      break;\n\n    case 'Cross':\n      dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly + ' ' + 'M' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2);\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'HorizontalLine':\n      dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly;\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'VerticalLine':\n      dir = 'M' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2);\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Diamond':\n      dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly + ' ' + 'L' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + ly + ' z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Rectangle':\n    case 'Hilo':\n    case 'HiloOpenClose':\n    case 'Candle':\n    case 'Waterfall':\n    case 'BoxAndWhisker':\n    case 'StepArea':\n    case 'Square':\n    case 'Flag':\n      dir = 'M' + ' ' + x + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (ly + -height / 2) + ' z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Pyramid':\n    case 'Triangle':\n      dir = 'M' + ' ' + x + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (ly + height / 2) + ' z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Funnel':\n    case 'InvertedTriangle':\n      dir = 'M' + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx - width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + ' z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Pentagon':\n      var eq = 72;\n      var xVal = void 0;\n      var yVal = void 0;\n\n      for (var i = 0; i <= 5; i++) {\n        xVal = width / 2 * Math.cos(Math.PI / 180 * (i * eq));\n        yVal = height / 2 * Math.sin(Math.PI / 180 * (i * eq));\n\n        if (i === 0) {\n          dir = 'M' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ';\n        } else {\n          dir = dir.concat('L' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ');\n        }\n      }\n\n      dir = dir.concat('Z');\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Image':\n      functionName = 'Image';\n      merge(options, {\n        'href': url,\n        'height': height,\n        'width': width,\n        x: x,\n        y: y\n      });\n      break;\n  }\n\n  options = calculateLegendShapes(location, new Size(width, height), shape, options).renderOption;\n  return {\n    renderOption: options,\n    functionName: functionName\n  };\n}\n/** @private */\n\nexport function getRectLocation(startLocation, endLocation, outerRect) {\n  var x;\n  var y;\n  x = endLocation.x < outerRect.x ? outerRect.x : endLocation.x > outerRect.x + outerRect.width ? outerRect.x + outerRect.width : endLocation.x;\n  y = endLocation.y < outerRect.y ? outerRect.y : endLocation.y > outerRect.y + outerRect.height ? outerRect.y + outerRect.height : endLocation.y;\n  return new Rect(x > startLocation.x ? startLocation.x : x, y > startLocation.y ? startLocation.y : y, Math.abs(x - startLocation.x), Math.abs(y - startLocation.y));\n}\n/** @private */\n\nexport function minMax(value, min, max) {\n  return value > max ? max : value < min ? min : value;\n}\n/** @private */\n\nexport function getElement(id) {\n  return document.getElementById(id);\n}\n/** @private */\n\nexport function getTemplateFunction(template) {\n  var templateFn = null;\n  var e;\n\n  try {\n    if (document.querySelectorAll(template).length) {\n      templateFn = templateComplier(document.querySelector(template).innerHTML.trim());\n    }\n  } catch (e) {\n    templateFn = templateComplier(template);\n  }\n\n  return templateFn;\n}\n/** @private */\n\nexport function createTemplate(childElement, pointIndex, content, chart, point, series) {\n  var templateFn;\n  var templateElement;\n  templateFn = getTemplateFunction(content);\n\n  try {\n    var blazor = 'Blazor';\n    var tempObject = window[blazor] ? {} : {\n      chart: chart,\n      series: series,\n      point: point\n    };\n    var elementData = templateFn ? templateFn(tempObject, null, null, childElement.id.replace(/[^a-zA-Z0-9]/g, '')) : [];\n\n    if (elementData.length) {\n      templateElement = Array.prototype.slice.call(elementData);\n      var len = templateElement.length;\n\n      for (var i = 0; i < len; i++) {\n        childElement.appendChild(templateElement[i]);\n      }\n    }\n  } catch (e) {\n    return childElement;\n  }\n\n  return childElement;\n}\n/** @private */\n\nexport function getFontStyle(font) {\n  var style = '';\n  style = 'font-size:' + font.size + '; font-style:' + font.fontStyle + '; font-weight:' + font.fontWeight + '; font-family:' + font.fontFamily + ';opacity:' + font.opacity + '; color:' + font.color + ';';\n  return style;\n}\n/** @private */\n\nexport function measureElementRect(element, redraw) {\n  if (redraw === void 0) {\n    redraw = false;\n  }\n\n  var bounds;\n  document.body.appendChild(element);\n  bounds = element.getBoundingClientRect();\n\n  if (redraw) {\n    remove(element);\n  } else {\n    removeElement(element.id);\n  }\n\n  return bounds;\n}\n/** @private */\n\nexport function findlElement(elements, id) {\n  var element;\n\n  for (var i = 0, length_1 = elements.length; i < length_1; i++) {\n    if (elements[i].id.indexOf(id) > -1) {\n      element = elements[i];\n      continue;\n    }\n  }\n\n  return element;\n}\n/** @private */\n\nexport function getPoint(x, y, xAxis, yAxis, isInverted, series) {\n  x = xAxis.valueType === 'Logarithmic' ? logBase(x > 0 ? x : 1, xAxis.logBase) : x;\n  y = yAxis.valueType === 'Logarithmic' ? logBase(y > 0 ? y : 1, yAxis.logBase) : y;\n  x = valueToCoefficient(x, xAxis);\n  y = valueToCoefficient(y, yAxis);\n  var xLength = isInverted ? xAxis.rect.height : xAxis.rect.width;\n  var yLength = isInverted ? yAxis.rect.width : yAxis.rect.height;\n  var locationX = isInverted ? y * yLength : x * xLength;\n  var locationY = isInverted ? (1 - x) * xLength : (1 - y) * yLength;\n  return new ChartLocation(locationX, locationY);\n}\n/** @private */\n\nexport function appendElement(child, parent, redraw, animate, x, y) {\n  if (redraw === void 0) {\n    redraw = false;\n  }\n\n  if (animate === void 0) {\n    animate = false;\n  }\n\n  if (x === void 0) {\n    x = 'x';\n  }\n\n  if (y === void 0) {\n    y = 'y';\n  }\n\n  if (child && child.hasChildNodes() && parent) {\n    appendChildElement(false, parent, child, redraw, animate, x, y);\n  } else {\n    return null;\n  }\n}\n/**\n * Method to append child element\n * @param parent\n * @param childElement\n * @param isReplace\n */\n\nexport function appendChildElement(isCanvas, parent, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, previousRect, animateDuration) {\n  if (isAnimate === void 0) {\n    isAnimate = false;\n  }\n\n  if (x === void 0) {\n    x = 'x';\n  }\n\n  if (y === void 0) {\n    y = 'y';\n  }\n\n  if (forceAnimate === void 0) {\n    forceAnimate = false;\n  }\n\n  if (isRect === void 0) {\n    isRect = false;\n  }\n\n  if (previousRect === void 0) {\n    previousRect = null;\n  }\n\n  if (isCanvas) {\n    return null;\n  }\n\n  var existChild = parent.querySelector('#' + childElement.id);\n  var element = existChild || getElement(childElement.id);\n  var child = childElement;\n  var duration = animateDuration ? animateDuration : 300;\n\n  if (redraw && isAnimate && element) {\n    start = start || (element.tagName === 'DIV' ? new ChartLocation(+element.style[x].split('px')[0], +element.style[y].split('px')[0]) : new ChartLocation(+element.getAttribute(x), +element.getAttribute(y)));\n\n    if (direction && direction !== 'undefined') {\n      pathAnimation(childElement, childElement.getAttribute('d'), redraw, direction, duration);\n    } else if (isRect && previousRect) {\n      animateRectElement(child, 0, duration, new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')), previousRect);\n    } else {\n      var end = child.tagName === 'DIV' ? new ChartLocation(+child.style[x].split('px')[0], +child.style[y].split('px')[0]) : new ChartLocation(+child.getAttribute(x), +child.getAttribute(y));\n      animateRedrawElement(child, duration, start, end, x, y);\n    }\n  } else if (redraw && isAnimate && !element && forceAnimate) {\n    templateAnimate(child, 0, 600, 'FadeIn');\n  }\n\n  if (existChild) {\n    parent.replaceChild(child, element);\n  } else {\n    parent.appendChild(child);\n  }\n}\n/** @private */\n\nexport function getDraggedRectLocation(x1, y1, x2, y2, outerRect) {\n  var width = Math.abs(x1 - x2);\n  var height = Math.abs(y1 - y2);\n  var x = Math.max(checkBounds(Math.min(x1, x2), width, outerRect.x, outerRect.width), outerRect.x);\n  var y = Math.max(checkBounds(Math.min(y1, y2), height, outerRect.y, outerRect.height), outerRect.y);\n  return new Rect(x, y, Math.min(width, outerRect.width), Math.min(height, outerRect.height));\n}\n/** @private */\n\nexport function checkBounds(start, size, min, max) {\n  if (start < min) {\n    start = min;\n  } else if (start + size > max + min) {\n    start = max + min - size;\n  }\n\n  return start;\n}\n/** @private */\n\nexport function getLabelText(currentPoint, series, chart) {\n  var labelFormat = series.yAxis.labelFormat;\n  var text = [];\n  var customLabelFormat = labelFormat.match('{value}') !== null;\n\n  switch (series.seriesType) {\n    case 'XY':\n      text.push(currentPoint.text || currentPoint.yValue.toString());\n      break;\n\n    case 'HighLow':\n      text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());\n      text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());\n      break;\n\n    case 'HighLowOpenClose':\n      text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());\n      text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());\n      text.push(currentPoint.text || Math.max(currentPoint.open, currentPoint.close).toString());\n      text.push(currentPoint.text || Math.min(currentPoint.open, currentPoint.close).toString());\n      break;\n\n    case 'BoxPlot':\n      text.push(currentPoint.text || currentPoint.median.toString());\n      text.push(currentPoint.text || currentPoint.maximum.toString());\n      text.push(currentPoint.text || currentPoint.minimum.toString());\n      text.push(currentPoint.text || currentPoint.upperQuartile.toString());\n      text.push(currentPoint.text || currentPoint.lowerQuartile.toString());\n\n      for (var _i = 0, _a = currentPoint.outliers; _i < _a.length; _i++) {\n        var liers = _a[_i];\n        text.push(currentPoint.text || liers.toString());\n      }\n\n      break;\n  }\n\n  if (labelFormat && !currentPoint.text) {\n    for (var i = 0; i < text.length; i++) {\n      text[i] = customLabelFormat ? labelFormat.replace('{value}', series.yAxis.format(parseFloat(text[i]))) : series.yAxis.format(parseFloat(text[i]));\n    }\n  }\n\n  return text;\n}\n/** @private */\n\nexport function stopTimer(timer) {\n  window.clearInterval(timer);\n}\n/** @private */\n\nexport function isCollide(rect, collections, clipRect) {\n  var isCollide;\n  var currentRect = new Rect(rect.x + clipRect.x, rect.y + clipRect.y, rect.width, rect.height);\n  isCollide = collections.some(function (rect) {\n    return currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x && currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y;\n  });\n  return isCollide;\n}\n/** @private */\n\nexport function isOverlap(currentRect, rect) {\n  return currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x && currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y;\n}\n/** @private */\n\nexport function containsRect(currentRect, rect) {\n  return currentRect.x <= rect.x && currentRect.x + currentRect.width >= rect.x + rect.width && currentRect.y <= rect.y && currentRect.height + currentRect.y >= rect.y + rect.height;\n}\n/** @private */\n\nexport function calculateRect(location, textSize, margin) {\n  return new Rect(location.x - textSize.width / 2 - margin.left, location.y - textSize.height / 2 - margin.top, textSize.width + margin.left + margin.right, textSize.height + margin.top + margin.bottom);\n}\n/** @private */\n\nexport function convertToHexCode(value) {\n  return '#' + componentToHex(value.r) + componentToHex(value.g) + componentToHex(value.b);\n}\n/** @private */\n\nexport function componentToHex(value) {\n  var hex = value.toString(16);\n  return hex.length === 1 ? '0' + hex : hex;\n}\n/** @private */\n\nexport function convertHexToColor(hex) {\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? new ColorValue(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) : new ColorValue(255, 255, 255);\n}\n/** @private */\n\nexport function colorNameToHex(color) {\n  var element;\n  color = color === 'transparent' ? 'white' : color;\n  document.body.appendChild(createElement('text', {\n    id: 'chartmeasuretext'\n  }));\n  element = document.getElementById('chartmeasuretext');\n  element.style.color = color;\n  color = window.getComputedStyle(element).color;\n  remove(element);\n  var exp = /^(rgb|hsl)(a?)[(]\\s*([\\d.]+\\s*%?)\\s*,\\s*([\\d.]+\\s*%?)\\s*,\\s*([\\d.]+\\s*%?)\\s*(?:,\\s*([\\d.]+)\\s*)?[)]$/;\n  var isRGBValue = exp.exec(color);\n  return convertToHexCode(new ColorValue(parseInt(isRGBValue[3], 10), parseInt(isRGBValue[4], 10), parseInt(isRGBValue[5], 10)));\n}\n/** @private */\n\nexport function getSaturationColor(color, factor) {\n  color = colorNameToHex(color);\n  color = color.replace(/[^0-9a-f]/gi, '');\n\n  if (color.length < 6) {\n    color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];\n  }\n\n  factor = factor || 0; // convert to decimal and change luminosity\n\n  var rgb = '#';\n  var colorCode;\n\n  for (var i = 0; i < 3; i++) {\n    colorCode = parseInt(color.substr(i * 2, 2), 16);\n    colorCode = Math.round(Math.min(Math.max(0, colorCode + colorCode * factor), 255));\n    rgb += ('00' + colorCode.toString(16)).substr(colorCode.toString(16).length);\n  }\n\n  return rgb;\n}\n/** @private */\n\nexport function getMedian(values) {\n  var half = Math.floor(values.length / 2);\n  return values.length % 2 ? values[half] : (values[half - 1] + values[half]) / 2.0;\n}\n/** @private */\n// tslint:disable-next-line:max-func-body-length\n\nexport function calculateLegendShapes(location, size, shape, options) {\n  var padding = 10;\n  var dir = '';\n  var height = size.height;\n  var width = size.width;\n  var lx = location.x;\n  var ly = location.y;\n\n  switch (shape) {\n    case 'MultiColoredLine':\n    case 'Line':\n    case 'StackingLine':\n    case 'StackingLine100':\n      dir = 'M' + ' ' + (lx + -width / 2) + ' ' + ly + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly;\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'StepLine':\n      options.fill = 'transparent';\n      dir = 'M' + ' ' + (lx + -width / 2 - padding / 4) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + -width / 2 + width / 10) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + -width / 2 + width / 10) + ' ' + ly + ' ' + 'L' + ' ' + (lx + -width / 10) + ' ' + ly + ' ' + 'L' + ' ' + (lx + -width / 10) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + width / 5) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + width / 5) + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + -height / 2) + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + '' + (lx + width / 2 + padding / 4) + ' ' + (ly + height / 2);\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'RightArrow':\n      var space = 2;\n      dir = 'M' + ' ' + (lx + -width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly + ' ' + 'L' + ' ' + (lx + -width / 2) + ' ' + (ly + height / 2) + ' L' + ' ' + (lx + -width / 2) + ' ' + (ly + height / 2 - space) + ' ' + 'L' + ' ' + (lx + width / 2 - 2 * space) + ' ' + ly + ' L' + (lx + -width / 2) + ' ' + (ly - height / 2 + space) + ' Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'LeftArrow':\n      options.fill = options.stroke;\n      options.stroke = 'transparent';\n      space = 2;\n      dir = 'M' + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + (lx + -width / 2) + ' ' + ly + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2 - space) + ' L' + ' ' + (lx + -width / 2 + 2 * space) + ' ' + ly + ' L' + (lx + width / 2) + ' ' + (ly - height / 2 + space) + ' Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Column':\n    case 'Pareto':\n    case 'StackingColumn':\n    case 'StackingColumn100':\n    case 'RangeColumn':\n    case 'Histogram':\n      dir = 'M' + ' ' + (lx - 3 * (width / 5)) + ' ' + (ly - height / 5) + ' ' + 'L' + ' ' + (lx + 3 * (-width / 10)) + ' ' + (ly - height / 5) + ' ' + 'L' + ' ' + (lx + 3 * (-width / 10)) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx - 3 * (width / 5)) + ' ' + (ly + height / 2) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx + -width / 10 - width / 20) + ' ' + (ly - height / 4 - padding / 2) + ' ' + 'L' + ' ' + (lx + width / 10 + width / 20) + ' ' + (ly - height / 4 - padding / 2) + ' ' + 'L' + ' ' + (lx + width / 10 + width / 20) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + -width / 10 - width / 20) + ' ' + (ly + height / 2) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx + 3 * (width / 10)) + ' ' + ly + ' ' + 'L' + ' ' + (lx + 3 * (width / 5)) + ' ' + ly + ' ' + 'L' + ' ' + (lx + 3 * (width / 5)) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly + height / 2) + ' ' + 'Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Bar':\n    case 'StackingBar':\n    case 'StackingBar100':\n      dir = 'M' + ' ' + (lx + -width / 2 + -padding / 4) + ' ' + (ly - 3 * (height / 5)) + ' ' + 'L' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 5)) + ' ' + 'L' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'L' + ' ' + (lx - width / 2 + -padding / 4) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx + -width / 2 + -padding / 4) + ' ' + (ly - height / 5 + padding / 20) + ' ' + 'L' + ' ' + (lx + width / 2 + padding / 4) + ' ' + (ly - height / 5 + padding / 20) + ' ' + 'L' + ' ' + (lx + width / 2 + padding / 4) + ' ' + (ly + height / 10 + padding / 20) + ' ' + 'L' + ' ' + (lx - width / 2 + -padding / 4) + ' ' + (ly + height / 10 + padding / 20) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx - width / 2 + -padding / 4) + ' ' + (ly + height / 5 + padding / 10) + ' ' + 'L' + ' ' + (lx + -width / 4) + ' ' + (ly + height / 5 + padding / 10) + ' ' + 'L' + ' ' + (lx + -width / 4) + ' ' + (ly + height / 2 + padding / 10) + ' ' + 'L' + ' ' + (lx - width / 2 + -padding / 4) + ' ' + (ly + height / 2 + padding / 10) + ' ' + 'Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Spline':\n      options.fill = 'transparent';\n      dir = 'M' + ' ' + (lx - width / 2) + ' ' + (ly + height / 5) + ' ' + 'Q' + ' ' + lx + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + height / 5) + ' ' + 'M' + ' ' + lx + ' ' + (ly + height / 5) + ' ' + 'Q' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + (lx + width / 2) + ' ' + (ly - height / 2);\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Area':\n    case 'MultiColoredArea':\n    case 'RangeArea':\n    case 'StackingArea':\n    case 'StackingArea100':\n      dir = 'M' + ' ' + (lx - width / 2 - padding / 4) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + -width / 4 + -padding / 8) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + height / 4) + ' ' + 'L' + ' ' + (lx + width / 4 + padding / 8) + ' ' + (ly + -height / 2 + height / 4) + ' ' + 'L' + ' ' + (lx + height / 2 + padding / 4) + ' ' + (ly + height / 2) + ' ' + 'Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'SplineArea':\n      dir = 'M' + ' ' + (lx - width / 2) + ' ' + (ly + height / 5) + ' ' + 'Q' + ' ' + lx + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + height / 5) + ' ' + 'Z' + ' ' + 'M' + ' ' + lx + ' ' + (ly + height / 5) + ' ' + 'Q' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + ' ' + ' Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n\n    case 'Pie':\n    case 'Doughnut':\n      options.stroke = 'transparent';\n      var r = Math.min(height, width) / 2;\n      dir = getAccumulationLegend(lx, ly, r, height, width, shape);\n      merge(options, {\n        'd': dir\n      });\n      break;\n  }\n\n  return {\n    renderOption: options\n  };\n}\n/** @private */\n\nexport function textTrim(maxWidth, text, font) {\n  var label = text;\n  var size = measureText(text, font).width;\n\n  if (size > maxWidth) {\n    var textLength = text.length;\n\n    for (var i = textLength - 1; i >= 0; --i) {\n      label = text.substring(0, i) + '...';\n      size = measureText(label, font).width;\n\n      if (size <= maxWidth) {\n        return label;\n      }\n    }\n  }\n\n  return label;\n}\n/**\n * To trim the line break label\n * @param maxWidth\n * @param text\n * @param font\n */\n\nexport function lineBreakLabelTrim(maxWidth, text, font) {\n  var labelCollection = [];\n  var breakLabels = text.split('<br>');\n\n  for (var i = 0; i < breakLabels.length; i++) {\n    text = breakLabels[i];\n    var size = measureText(text, font).width;\n\n    if (size > maxWidth) {\n      var textLength = text.length;\n\n      for (var i_1 = textLength - 1; i_1 >= 0; --i_1) {\n        text = text.substring(0, i_1) + '...';\n        size = measureText(text, font).width;\n\n        if (size <= maxWidth) {\n          labelCollection.push(text);\n          break;\n        }\n      }\n    } else {\n      labelCollection.push(text);\n    }\n  }\n\n  return labelCollection;\n}\n/** @private */\n\nexport function stringToNumber(value, containerSize) {\n  if (value !== null && value !== undefined) {\n    return value.indexOf('%') !== -1 ? containerSize / 100 * parseInt(value, 10) : parseInt(value, 10);\n  }\n\n  return null;\n}\n/** @private */\n\nexport function redrawElement(redraw, id, options, renderer) {\n  if (!redraw) {\n    return null;\n  }\n\n  var element = getElement(id);\n\n  if (element && options) {\n    renderer.setElementAttributes(options, element.tagName === 'clipPath' ? element.childNodes[0] : element);\n  }\n\n  return element;\n}\n/** @private */\n\nexport function animateRedrawElement(element, duration, start, end, x, y) {\n  if (x === void 0) {\n    x = 'x';\n  }\n\n  if (y === void 0) {\n    y = 'y';\n  }\n\n  var isDiv = element.tagName === 'DIV';\n\n  var setStyle = function (xValue, yValue) {\n    if (isDiv) {\n      element.style[x] = xValue + 'px';\n      element.style[y] = yValue + 'px';\n    } else {\n      element.setAttribute(x, xValue + '');\n      element.setAttribute(y, yValue + '');\n    }\n  };\n\n  setStyle(start.x, start.y);\n  new Animation({}).animate(createElement('div'), {\n    duration: duration,\n    progress: function (args) {\n      setStyle(linear(args.timeStamp, start.x, end.x - start.x, args.duration), linear(args.timeStamp, start.y, end.y - start.y, args.duration));\n    },\n    end: function () {\n      setStyle(end.x, end.y);\n    }\n  });\n}\n/** @private */\n\nexport function textElement(renderer, option, font, color, parent, isMinus, redraw, isAnimate, forceAnimate, animateDuration, seriesClipRect) {\n  if (isMinus === void 0) {\n    isMinus = false;\n  }\n\n  if (forceAnimate === void 0) {\n    forceAnimate = false;\n  }\n\n  var renderOptions = {};\n  var htmlObject;\n  var tspanElement; //let renderer: SvgRenderer = new SvgRenderer('');\n\n  var text;\n  var height;\n  renderOptions = {\n    'id': option.id,\n    'x': option.x,\n    'y': option.y,\n    'fill': color ? color : 'black',\n    'font-size': font.size,\n    'font-style': font.fontStyle,\n    'font-family': font.fontFamily,\n    'font-weight': font.fontWeight,\n    'text-anchor': option.anchor,\n    'labelRotation': option.labelRotation,\n    'transform': option.transform,\n    'opacity': font.opacity,\n    'dominant-baseline': option.baseLine\n  };\n  text = typeof option.text === 'string' ? option.text : isMinus ? option.text[option.text.length - 1] : option.text[0];\n  htmlObject = renderer.createText(renderOptions, text, seriesClipRect ? seriesClipRect.x : 0, seriesClipRect ? seriesClipRect.y : 0);\n\n  if (typeof option.text !== 'string' && option.text.length > 1) {\n    for (var i = 1, len = option.text.length; i < len; i++) {\n      height = measureText(option.text[i], font).height;\n      tspanElement = renderer.createTSpan({\n        'x': option.x,\n        'id': option.id,\n        'y': option.y + (isMinus ? -(i * height) : i * height)\n      }, isMinus ? option.text[option.text.length - (i + 1)] : option.text[i]);\n      htmlObject.appendChild(tspanElement);\n    }\n  }\n\n  appendChildElement(renderer instanceof CanvasRenderer, parent, htmlObject, redraw, isAnimate, 'x', 'y', null, null, forceAnimate, false, null, animateDuration);\n  return htmlObject;\n}\n/**\n * Method to calculate the width and height of the chart\n */\n\nexport function calculateSize(chart) {\n  // fix for Chart rendered with default width in IE issue\n  var containerWidth = chart.element.clientWidth || chart.element.offsetWidth;\n  var containerHeight = chart.element.clientHeight;\n\n  if (chart.stockChart) {\n    containerWidth = chart.stockChart.element.clientWidth;\n  }\n\n  var height = 450;\n  var marginHeight;\n\n  if (chart.getModuleName() === 'rangeNavigator') {\n    var range = chart;\n    var tooltipSpace = range.tooltip.enable ? 35 : 0;\n    var periodHeight = range.periodSelectorSettings.periods.length ? range.periodSelectorSettings.height : 0;\n    marginHeight = range.margin.top + range.margin.bottom + tooltipSpace;\n    var labelSize = measureText('tempString', range.labelStyle).height;\n    var labelPadding = 15;\n    height = (chart.series.length ? Browser.isDevice ? 80 : 120 : (range.enableGrouping ? 40 + labelPadding + labelSize : 40) + marginHeight) + periodHeight;\n\n    if (range.disableRangeSelector) {\n      height = periodHeight;\n    }\n  }\n\n  chart.availableSize = new Size(stringToNumber(chart.width, containerWidth) || containerWidth || 600, stringToNumber(chart.height, containerHeight) || containerHeight || height);\n}\nexport function createSvg(chart) {\n  chart.canvasRender = new CanvasRenderer(chart.element.id);\n  chart.renderer = chart.enableCanvas ? chart.canvasRender : new SvgRenderer(chart.element.id);\n  calculateSize(chart);\n\n  if (chart.stockChart && chart.getModuleName() === 'chart') {\n    chart.svgObject = chart.stockChart.chartObject;\n  } else if (chart.stockChart && chart.getModuleName() === 'rangeNavigator') {\n    chart.svgObject = chart.stockChart.selectorObject;\n  } else {\n    if (chart.enableCanvas) {\n      chart.svgObject = chart.renderer.createCanvas({\n        id: chart.element.id + '_canvas',\n        width: chart.availableSize.width,\n        height: chart.availableSize.height\n      });\n    } else {\n      chart.svgObject = chart.renderer.createSvg({\n        id: chart.element.id + '_svg',\n        width: chart.availableSize.width,\n        height: chart.availableSize.height\n      });\n    }\n  }\n}\n/**\n * To calculate chart title and height\n * @param title\n * @param style\n * @param width\n */\n\nexport function getTitle(title, style, width) {\n  var titleCollection = [];\n\n  switch (style.textOverflow) {\n    case 'Wrap':\n      titleCollection = textWrap(title, width, style);\n      break;\n\n    case 'Trim':\n      titleCollection.push(textTrim(width, title, style));\n      break;\n\n    default:\n      titleCollection.push(title);\n      break;\n  }\n\n  return titleCollection;\n}\n/**\n * Method to calculate x position of title\n */\n\nexport function titlePositionX(rect, titleStyle) {\n  var positionX;\n\n  if (titleStyle.textAlignment === 'Near') {\n    positionX = rect.x;\n  } else if (titleStyle.textAlignment === 'Center') {\n    positionX = rect.x + rect.width / 2;\n  } else {\n    positionX = rect.x + rect.width;\n  }\n\n  return positionX;\n}\n/**\n * Method to find new text and element size based on textOverflow\n */\n\nexport function textWrap(currentLabel, maximumWidth, font) {\n  var textCollection = currentLabel.split(' ');\n  var label = '';\n  var labelCollection = [];\n  var text;\n\n  for (var i = 0, len = textCollection.length; i < len; i++) {\n    text = textCollection[i];\n\n    if (measureText(label.concat(text), font).width < maximumWidth) {\n      label = label.concat((label === '' ? '' : ' ') + text);\n    } else {\n      if (label !== '') {\n        labelCollection.push(textTrim(maximumWidth, label, font));\n        label = text;\n      } else {\n        labelCollection.push(textTrim(maximumWidth, text, font));\n        text = '';\n      }\n    }\n\n    if (label && i === len - 1) {\n      labelCollection.push(textTrim(maximumWidth, label, font));\n    }\n  }\n\n  return labelCollection;\n}\n/**\n * Method to reset the blazor templates\n */\n\nexport function blazorTemplatesReset(control) {\n  for (var i = 0; i < control.annotations.length; i++) {\n    resetBlazorTemplate((control.element.id + '_Annotation_' + i).replace(/[^a-zA-Z0-9]/g, ''), 'ContentTemplate');\n  }\n}\n/** @private */\n\nvar CustomizeOption =\n/** @class */\nfunction () {\n  function CustomizeOption(id) {\n    this.id = id;\n  }\n\n  return CustomizeOption;\n}();\n\nexport { CustomizeOption };\n/** @private */\n\nvar StackValues =\n/** @class */\nfunction () {\n  function StackValues(startValue, endValue) {\n    this.startValues = startValue;\n    this.endValues = endValue;\n  }\n\n  return StackValues;\n}();\n\nexport { StackValues };\n/** @private */\n\nvar RectOption =\n/** @class */\nfunction (_super) {\n  __extends(RectOption, _super);\n\n  function RectOption(id, fill, border, opacity, rect, rx, ry, transform, dashArray) {\n    var _this = _super.call(this, id, fill, border.width, border.color, opacity, dashArray) || this;\n\n    _this.y = rect.y;\n    _this.x = rect.x;\n    _this.height = rect.height;\n    _this.width = rect.width;\n    _this.rx = rx ? rx : 0;\n    _this.ry = ry ? ry : 0;\n    _this.transform = transform ? transform : '';\n    _this.stroke = border.width !== 0 && _this.stroke !== '' ? border.color : 'transparent';\n    return _this;\n  }\n\n  return RectOption;\n}(PathOption);\n\nexport { RectOption };\n/** @private */\n\nvar CircleOption =\n/** @class */\nfunction (_super) {\n  __extends(CircleOption, _super);\n\n  function CircleOption(id, fill, border, opacity, cx, cy, r) {\n    var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;\n\n    _this.cy = cy;\n    _this.cx = cx;\n    _this.r = r;\n    return _this;\n  }\n\n  return CircleOption;\n}(PathOption);\n\nexport { CircleOption };\n/** @private */\n\nvar PolygonOption =\n/** @class */\nfunction () {\n  function PolygonOption(id, points, fill) {\n    this.id = id;\n    this.points = points;\n    this.fill = fill;\n  }\n\n  return PolygonOption;\n}();\n\nexport { PolygonOption };\n/** @private */\n\nvar ChartLocation =\n/** @class */\nfunction () {\n  function ChartLocation(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  return ChartLocation;\n}();\n\nexport { ChartLocation };\n/** @private */\n\nvar Thickness =\n/** @class */\nfunction () {\n  function Thickness(left, right, top, bottom) {\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n  }\n\n  return Thickness;\n}();\n\nexport { Thickness };\n/** @private */\n\nvar ColorValue =\n/** @class */\nfunction () {\n  function ColorValue(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n\n  return ColorValue;\n}();\n\nexport { ColorValue };\n/** @private */\n\nvar PointData =\n/** @class */\nfunction () {\n  function PointData(point, series, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    this.point = point;\n    this.series = series;\n    this.lierIndex = index;\n  }\n\n  return PointData;\n}();\n\nexport { PointData };\n/** @private */\n\nvar AccPointData =\n/** @class */\nfunction () {\n  function AccPointData(point, series, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    this.point = point;\n    this.series = series;\n  }\n\n  return AccPointData;\n}();\n\nexport { AccPointData };\n/** @private */\n\nvar ControlPoints =\n/** @class */\nfunction () {\n  function ControlPoints(controlPoint1, controlPoint2) {\n    this.controlPoint1 = controlPoint1;\n    this.controlPoint2 = controlPoint2;\n  }\n\n  return ControlPoints;\n}();\n\nexport { ControlPoints };","map":null,"metadata":{},"sourceType":"module"}