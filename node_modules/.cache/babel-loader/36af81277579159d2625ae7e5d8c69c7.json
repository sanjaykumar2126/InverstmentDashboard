{"ast":null,"code":"import { withInRange, getPoint, drawSymbol } from '../../common/utils/helper';\nimport { Size, PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { markerAnimate, appendChildElement, animateRedrawElement } from '../../common/utils/helper';\nimport { pointRender } from '../../common/model/constants';\n/**\n * `BubbleSeries` module is used to render the bubble series.\n */\n\nvar BubbleSeries =\n/** @class */\nfunction () {\n  function BubbleSeries() {}\n  /**\n   * Render the Bubble series.\n   * @return {void}\n   * @private\n   */\n\n\n  BubbleSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n    var marker = series.marker;\n    var visiblePoints = series.points;\n    var shapeOption;\n    var argsData; //let bubbleMode: RadiusMode = bubbleOptions.radiusMode;\n\n    var segmentRadius;\n    var radius;\n    var value = Math.max(series.chart.initialClipRect.height, series.chart.initialClipRect.width);\n    var percentChange = value / 100;\n    var maxRadius = series.maxRadius * percentChange;\n    var minRadius = series.minRadius * percentChange;\n    var maximumSize = null;\n    var maxValue = null;\n    var element;\n    var startLocation;\n    var redraw = series.chart.redraw;\n\n    if (series.maxRadius === null || series.minRadius === null) {\n      for (var _i = 0, _a = series.chart.visibleSeries; _i < _a.length; _i++) {\n        var value_1 = _a[_i];\n\n        if (value_1.type === 'Bubble' && value_1.visible === true && (value_1.maxRadius === null || value_1.minRadius === null)) {\n          maximumSize = value_1.sizeMax > maximumSize ? value_1.sizeMax : maximumSize;\n        }\n      }\n\n      maxValue = value / 5 / 2;\n      minRadius = maxRadius = 1;\n      radius = maxValue * maxRadius;\n    } else {\n      maximumSize = series.sizeMax;\n      radius = maxRadius - minRadius;\n    }\n\n    for (var _b = 0, visiblePoints_1 = visiblePoints; _b < visiblePoints_1.length; _b++) {\n      var bubblePoint = visiblePoints_1[_b];\n      startLocation = redraw ? bubblePoint.symbolLocations[0] : null;\n      bubblePoint.symbolLocations = [];\n      bubblePoint.regions = [];\n\n      if (bubblePoint.visible && withInRange(visiblePoints[bubblePoint.index - 1], bubblePoint, visiblePoints[bubblePoint.index + 1], series)) {\n        if (series.maxRadius === null || series.minRadius === null) {\n          segmentRadius = radius * Math.abs(+bubblePoint.size / maximumSize);\n        } else {\n          segmentRadius = minRadius + radius * Math.abs(+bubblePoint.size / maximumSize);\n        }\n\n        segmentRadius = segmentRadius || minRadius;\n        argsData = {\n          cancel: false,\n          name: pointRender,\n          series: series,\n          point: bubblePoint,\n          fill: series.setPointColor(bubblePoint, series.interior),\n          border: series.setBorderColor(bubblePoint, {\n            width: series.border.width,\n            color: series.border.color\n          }),\n          height: 2 * segmentRadius,\n          width: 2 * segmentRadius\n        };\n        series.chart.trigger(pointRender, argsData);\n\n        if (!argsData.cancel) {\n          bubblePoint.symbolLocations.push(getPoint(bubblePoint.xValue, bubblePoint.yValue, xAxis, yAxis, isInverted));\n          bubblePoint.color = argsData.fill;\n          shapeOption = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + bubblePoint.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, null);\n          element = drawSymbol(bubblePoint.symbolLocations[0], 'Circle', new Size(argsData.width, argsData.height), marker.imageUrl, shapeOption, bubblePoint.x.toString() + ':' + bubblePoint.yValue.toString(), series.chart.svgRenderer, series.clipRect);\n          appendChildElement(false, series.seriesElement, element, redraw);\n          bubblePoint.regions.push(new Rect(bubblePoint.symbolLocations[0].x - segmentRadius, bubblePoint.symbolLocations[0].y - segmentRadius, 2 * segmentRadius, 2 * segmentRadius));\n          bubblePoint.marker = {\n            border: argsData.border,\n            fill: argsData.fill,\n            height: argsData.height,\n            visible: true,\n            shape: 'Circle',\n            width: argsData.width\n          };\n\n          if (redraw) {\n            animateRedrawElement(element, 300, startLocation, bubblePoint.symbolLocations[0], 'cx', 'cy');\n          }\n        } else {\n          bubblePoint.marker = {\n            visible: false\n          };\n        }\n      }\n    }\n  };\n  /**\n   * To destroy the Bubble.\n   * @return {void}\n   * @private\n   */\n\n\n  BubbleSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroy method calling here\n     */\n  };\n  /**\n   * Get module name.\n   */\n\n\n  BubbleSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'BubbleSeries';\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  BubbleSeries.prototype.doAnimation = function (series) {\n    var duration = series.animation.duration;\n    var delay = series.animation.delay;\n    var rectElements = series.seriesElement.childNodes;\n    var count = 1;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var bubblePoint = _a[_i];\n\n      if (!bubblePoint.symbolLocations.length) {\n        continue;\n      }\n\n      markerAnimate(rectElements[count], delay, duration, series, bubblePoint.index, bubblePoint.symbolLocations[0], false);\n      count++;\n    }\n  };\n\n  return BubbleSeries;\n}();\n\nexport { BubbleSeries };","map":null,"metadata":{},"sourceType":"module"}