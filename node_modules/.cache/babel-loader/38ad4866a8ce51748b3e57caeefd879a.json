{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { getPoint, appendClipElement, pathAnimation } from '../../common/utils/helper';\nimport { LineBase } from './line-base';\nimport { RectOption, getElement } from '../../common/utils/helper';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * Base class for multi colored series\n */\n\nvar MultiColoredSeries =\n/** @class */\nfunction (_super) {\n  __extends(MultiColoredSeries, _super);\n\n  function MultiColoredSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * To Generate the area path direction\n   * @param xValue\n   * @param yValue\n   * @param series\n   * @param isInverted\n   * @param getPointLocation\n   * @param startPoint\n   * @param startPath\n   */\n\n\n  MultiColoredSeries.prototype.getAreaPathDirection = function (xValue, yValue, series, isInverted, getPointLocation, startPoint, startPath) {\n    var direction = '';\n    var firstPoint;\n\n    if (startPoint === null) {\n      firstPoint = getPointLocation(xValue, yValue, series.xAxis, series.yAxis, isInverted, series);\n      direction += startPath + ' ' + firstPoint.x + ' ' + firstPoint.y + ' ';\n    }\n\n    return direction;\n  };\n  /**\n   * To Generate the empty point direction\n   * @param firstPoint\n   * @param secondPoint\n   * @param series\n   * @param isInverted\n   * @param getPointLocation\n   */\n\n\n  MultiColoredSeries.prototype.getAreaEmptyDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation) {\n    var direction = '';\n    direction += this.getAreaPathDirection(firstPoint.x, firstPoint.y, series, isInverted, getPointLocation, null, 'L');\n    direction += this.getAreaPathDirection(secondPoint.x, secondPoint.y, series, isInverted, getPointLocation, null, 'L');\n    return direction;\n  };\n  /**\n   * To set point color\n   * @param points\n   */\n\n\n  MultiColoredSeries.prototype.setPointColor = function (currentPoint, previous, series, isXSegment, segments) {\n    if (series.pointColorMapping === '') {\n      var segment = void 0;\n      var value = void 0;\n\n      for (var i = 0; i < segments.length; i++) {\n        segment = segments[i];\n        value = isXSegment ? currentPoint.xValue : currentPoint.yValue;\n\n        if (value <= this.getAxisValue(segment.value, isXSegment ? series.xAxis : series.yAxis, series.chart) || !segment.value) {\n          currentPoint.interior = segment.color;\n          break;\n        }\n      }\n\n      if (currentPoint.interior == null) {\n        currentPoint.interior = series.interior;\n      }\n\n      return false;\n    } else {\n      if (previous) {\n        return series.setPointColor(currentPoint, series.interior) !== series.setPointColor(previous, series.interior);\n      } else {\n        return false;\n      }\n    }\n  };\n\n  MultiColoredSeries.prototype.sortSegments = function (series, chartSegments) {\n    var axis = series.segmentAxis === 'X' ? series.xAxis : series.yAxis;\n    var segments = [].concat(chartSegments);\n    var access = this;\n    return segments.sort(function (a, b) {\n      return access.getAxisValue(a.value, axis, series.chart) - access.getAxisValue(b.value, axis, series.chart);\n    });\n  };\n  /**\n   * Segment calculation performed here\n   * @param series\n   * @param options\n   * @param chartSegments\n   */\n\n\n  MultiColoredSeries.prototype.applySegmentAxis = function (series, options, segments) {\n    var _this = this;\n\n    if (series.pointColorMapping !== '') {\n      options.map(function (option) {\n        _this.appendLinePath(option, series, '');\n      });\n      return null;\n    }\n\n    var isXSegment = series.segmentAxis === 'X';\n    var axis = isXSegment ? series.xAxis : series.yAxis;\n    var chart = series.chart;\n    var segment;\n    this.includeSegment(segments, axis, series, segments.length);\n    var length = segments.length;\n    var value;\n    var clipPath;\n    var attributeOptions;\n\n    var _loop_1 = function (index) {\n      segment = segments[index];\n      value = this_1.getAxisValue(segment.value, axis, series.chart);\n      clipPath = this_1.createClipRect(index ? this_1.getAxisValue(segments[index - 1].value, axis, series.chart) : axis.visibleRange.min, value, series, index, isXSegment);\n\n      if (clipPath) {\n        options.map(function (option) {\n          attributeOptions = {\n            'clip-path': clipPath,\n            'stroke-dasharray': segment.dashArray,\n            'opacity': option.opacity,\n            'stroke': series.type.indexOf('Line') > -1 ? segment.color || series.interior : series.border.color,\n            'stroke-width': option['stroke-width'],\n            'fill': series.type.indexOf('Line') > -1 ? 'none' : segment.color || series.interior,\n            'id': option.id + '_Segment_' + index,\n            'd': option.d\n          };\n          pathAnimation(getElement(attributeOptions.id), attributeOptions.d, chart.redraw);\n          series.seriesElement.appendChild(chart.renderer.drawPath(attributeOptions));\n        });\n      }\n    };\n\n    var this_1 = this;\n\n    for (var index = 0; index < length; index++) {\n      _loop_1(index);\n    }\n  };\n\n  MultiColoredSeries.prototype.includeSegment = function (segments, axis, series, length) {\n    if (length <= 0) {\n      segments.push({\n        value: axis.visibleRange.max,\n        color: series.interior\n      });\n      return null;\n    }\n\n    if (this.getAxisValue(segments[length - 1].value, axis, series.chart) < axis.visibleRange.max) {\n      segments.push({\n        value: axis.visibleRange.max,\n        color: series.interior\n      });\n    }\n  };\n  /**\n   * To create clip rect for segment axis\n   * @param startValue\n   * @param endValue\n   * @param series\n   * @param index\n   * @param isX\n   * @param chart\n   */\n\n\n  MultiColoredSeries.prototype.createClipRect = function (startValue, endValue, series, index, isX) {\n    var isRequired = series.chart.requireInvertedAxis;\n    var startPointLocation = getPoint(isX ? startValue : series.xAxis.visibleRange.min, isX ? series.yAxis.visibleRange.max : endValue, series.xAxis, series.yAxis, isRequired);\n    var endPointLocation = getPoint(isX ? endValue : series.xAxis.visibleRange.max, isX ? series.yAxis.visibleRange.min : startValue, series.xAxis, series.yAxis, isRequired);\n    endPointLocation = isRequired ? [startPointLocation, startPointLocation = endPointLocation][0] : endPointLocation;\n    var options;\n\n    if (endPointLocation.x - startPointLocation.x > 0 && endPointLocation.y - startPointLocation.y > 0) {\n      options = new RectOption(series.chart.element.id + '_ChartSegmentClipRect_' + index, 'transparent', {\n        width: 1,\n        color: 'Gray'\n      }, 1, {\n        x: startPointLocation.x,\n        y: startPointLocation.y,\n        width: endPointLocation.x - startPointLocation.x,\n        height: endPointLocation.y - startPointLocation.y\n      });\n      series.seriesElement.appendChild(appendClipElement(series.chart.redraw, options, series.chart.renderer));\n      return 'url(#' + series.chart.element.id + '_ChartSegmentClipRect_' + index + ')';\n    }\n\n    return null;\n  };\n  /**\n   * To get exact value from segment value\n   * @param segmentValue\n   * @param axis\n   * @param chart\n   */\n\n\n  MultiColoredSeries.prototype.getAxisValue = function (segmentValue, axis, chart) {\n    if (segmentValue === null) {\n      segmentValue = axis.visibleRange.max;\n    }\n\n    if (axis.valueType === 'DateTime') {\n      var option = {\n        skeleton: 'full',\n        type: 'dateTime'\n      };\n      return Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({\n        val: segmentValue\n      }).val))));\n    } else if (axis.valueType.indexOf('Category') > -1) {\n      var xValue = axis.valueType === 'DateTimeCategory' ? segmentValue.getTime().toString() : segmentValue;\n      return axis.labels.indexOf(xValue) < 0 ? +segmentValue : axis.labels.indexOf(xValue);\n    } else {\n      return +segmentValue;\n    }\n  };\n\n  return MultiColoredSeries;\n}(LineBase);\n\nexport { MultiColoredSeries };","map":null,"metadata":{},"sourceType":"module"}