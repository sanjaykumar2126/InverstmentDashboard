{"ast":null,"code":"import { ClosestPoint, SmithchartRect } from '../../smithchart/utils/utils';\nimport { Tooltip } from '@syncfusion/ej2-svg-base';\nimport { isNullOrUndefined, createElement, updateBlazorTemplate } from '@syncfusion/ej2-base';\n/**\n * To render tooltip\n */\n\nvar TooltipRender =\n/** @class */\nfunction () {\n  function TooltipRender() {}\n\n  TooltipRender.prototype.smithchartMouseMove = function (smithchart, e) {\n    var touchArg;\n    var pageX;\n    var pageY;\n\n    if (e.type === 'touchend' || e.type === 'touchmove') {\n      touchArg = e;\n      pageX = touchArg.changedTouches[0].clientX;\n      pageY = touchArg.changedTouches[0].clientY;\n      this.tooltipElement = undefined;\n    } else {\n      pageY = e.clientY;\n      pageX = e.clientX;\n    }\n\n    this.setMouseXY(smithchart, pageX, pageY);\n\n    for (var i = 0; i < smithchart.series.length; i++) {\n      var series = smithchart.series[i];\n      var seriesIndex = i;\n      var closestPoint = new ClosestPoint();\n      closestPoint = this.closestPointXY(smithchart, this.mouseX, this.mouseY, series, seriesIndex);\n\n      if (closestPoint.location && series.tooltip.visible && series.visibility === 'visible') {\n        this.createTooltip(smithchart, e, closestPoint.index, seriesIndex, series);\n        break;\n      } else if (this.tooltipElement && this.tooltipElement.enable && !series.tooltip.template) {\n        this.tooltipElement.fadeOut();\n        this.tooltipElement.enable = false;\n      } else if (series.tooltip.template) {\n        this.tooltipElement.fadeOut();\n      }\n    }\n\n    return this.tooltipElement;\n  };\n\n  TooltipRender.prototype.setMouseXY = function (smithchart, pageX, pageY) {\n    var rect = smithchart.element.getBoundingClientRect();\n    var svgRect = document.getElementById(smithchart.element.id + '_svg').getBoundingClientRect();\n    this.mouseX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);\n    this.mouseY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);\n  };\n\n  TooltipRender.prototype.createTooltip = function (smithchart, e, pointindex, seriesindex, series) {\n    var pointX = series.points[pointindex].resistance;\n    var pointY = series.points[pointindex].reactance;\n    var tooltipText = [pointX + ' ' + ':' + ' ' + '<b>' + pointY + '</b>'];\n    var markerHeight = smithchart.series[seriesindex].marker.height / 2;\n    var div = document.getElementById(smithchart.element.id + '_smithchart_tooltip_div');\n\n    if (isNullOrUndefined(div)) {\n      div = createElement('div', {\n        id: smithchart.element.id + '_smithchart_tooltip_div',\n        styles: 'pointer-events: none; position: absolute;z-index:1;'\n      });\n      document.getElementById(smithchart.element.id + '_Secondary_Element').appendChild(div);\n    }\n\n    this.tooltipElement = new Tooltip({\n      enable: true,\n      header: '<b>' + series.name + '</b>',\n      content: tooltipText,\n      border: series.tooltip.border,\n      fill: smithchart.themeStyle.tooltipFill,\n      data: {\n        reactance: pointY\n      },\n      template: series.tooltip.template,\n      location: {\n        x: this.locationX + smithchart.element.offsetLeft,\n        y: this.locationY - markerHeight + smithchart.element.offsetTop\n      },\n      shared: false,\n      areaBounds: new SmithchartRect(smithchart.bounds.x, smithchart.bounds.y, smithchart.bounds.width, smithchart.bounds.height),\n      palette: [series.fill || smithchart.seriesColors[seriesindex % smithchart.seriesColors.length]],\n      shapes: ['Circle'],\n      availableSize: smithchart.availableSize,\n      theme: smithchart.theme\n    });\n    this.tooltipElement.opacity = smithchart.themeStyle.tooltipFillOpacity || this.tooltipElement.opacity;\n    this.tooltipElement.textStyle.fontFamily = smithchart.themeStyle.fontFamily || 'Roboto, Segoe UI, Noto, Sans-serif';\n    this.tooltipElement.textStyle.opacity = smithchart.themeStyle.tooltipTextOpacity || this.tooltipElement.textStyle.opacity;\n    this.tooltipElement.appendTo(div);\n    updateBlazorTemplate(div.id + 'Template', 'Template');\n  };\n\n  TooltipRender.prototype.closestPointXY = function (smithchart, x, y, series, seriesindex) {\n    var pointIndex;\n    var chartPoint;\n    var closePoint;\n\n    for (var j = 0; j < series.points.length; j++) {\n      chartPoint = smithchart.seriesrender.getLocation(seriesindex, j);\n      this.locationX = chartPoint.x;\n      this.locationY = chartPoint.y;\n      pointIndex = j;\n      var a = x - chartPoint.x;\n      var b = y - chartPoint.y;\n      var distance = Math.abs(Math.sqrt(a * a + b * b));\n\n      if (distance < series.marker.width) {\n        closePoint = chartPoint;\n        pointIndex = j;\n        break;\n      }\n    }\n\n    return {\n      location: closePoint,\n      index: pointIndex\n    };\n  };\n  /**\n   * Get module name.\n   */\n\n\n  TooltipRender.prototype.getModuleName = function () {\n    return 'TooltipRender';\n  };\n  /**\n   * To destroy the legend.\n   * @return {void}\n   * @private\n   */\n\n\n  TooltipRender.prototype.destroy = function (smithchart) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return TooltipRender;\n}();\n\nexport { TooltipRender };","map":null,"metadata":{},"sourceType":"module"}