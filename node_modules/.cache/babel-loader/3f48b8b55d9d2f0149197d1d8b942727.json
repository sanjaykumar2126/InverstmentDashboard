{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { withInRange, sum } from '../../common/utils/helper';\nimport { getSaturationColor, getPoint } from '../../common/utils/helper';\nimport { Size, PathOption } from '@syncfusion/ej2-svg-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { ColumnBase } from './column-base';\nimport { getMedian } from '../../common/utils/helper';\n/**\n * `BoxAndWhiskerSeries` module is used to render the box and whisker series.\n */\n\nvar BoxAndWhiskerSeries =\n/** @class */\nfunction (_super) {\n  __extends(BoxAndWhiskerSeries, _super);\n\n  function BoxAndWhiskerSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Render BoxAndWhisker series.\n   * @return {void}\n   * @private\n   */\n\n\n  BoxAndWhiskerSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n    var sideBySideInfo = this.getSideBySideInfo(series);\n    var argsData;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n      point.symbolLocations = [];\n      point.regions = [];\n      var centerRegion = void 0;\n\n      if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {\n        this.findBoxPlotValues(point.y, point, series.boxPlotMode); //region to cover the top and bottom ticks\n\n        this.updateTipRegion(series, point, sideBySideInfo); //get middle rect\n\n        centerRegion = this.getRectangle(point.xValue + sideBySideInfo.start, point.upperQuartile, point.xValue + sideBySideInfo.end, point.lowerQuartile, series);\n        point.regions.push(centerRegion);\n        argsData = this.triggerEvent(series, point, series.interior, {\n          color: !isNullOrUndefined(series.border.color) && series.border.color !== 'transparent' ? series.border.color : getSaturationColor(series.interior, -0.6),\n          width: series.border.width ? series.border.width : 1\n        });\n\n        if (!argsData.cancel) {\n          this.renderBoxAndWhisker(series, point, centerRegion, argsData, this.getPathString(point, series, getPoint(point.xValue, point.median, xAxis, yAxis, isInverted), getPoint(point.xValue + sideBySideInfo.median, point.average, xAxis, yAxis, isInverted)), sideBySideInfo.median);\n        }\n      }\n    }\n\n    if (series.marker.visible) {\n      series.chart.markerRender.render(series);\n    }\n  };\n  /**\n   * update the tip region fo box plot\n   * @param series\n   * @param point\n   * @param sideBySideInfo\n   */\n\n\n  BoxAndWhiskerSeries.prototype.updateTipRegion = function (series, point, sideBySideInfo) {\n    var tipRegion = this.getRectangle(point.xValue + sideBySideInfo.median, point.maximum, point.xValue + sideBySideInfo.median, point.minimum, series);\n    this.updateTipSize(series, point, tipRegion, series.chart.requireInvertedAxis);\n  };\n  /**\n   * Update tip size to tip regions\n   * @param series\n   * @param point\n   * @param region\n   * @param isInverted\n   */\n\n\n  BoxAndWhiskerSeries.prototype.updateTipSize = function (series, point, region, isInverted) {\n    var borderWidth = series.border.width || 1;\n\n    if (!isInverted) {\n      region.x -= borderWidth / 2;\n      region.width = region.width || borderWidth;\n    } else {\n      region.y -= borderWidth / 2;\n      region.height = region.height || borderWidth;\n    }\n\n    point.regions.push(region);\n  };\n  /**\n   * Calculation for path direction performed here\n   * @param point\n   * @param series\n   * @param median\n   * @param average\n   */\n\n\n  BoxAndWhiskerSeries.prototype.getPathString = function (point, series, median, average) {\n    var topRect = point.regions[0];\n    var midRect = point.regions[1];\n    var direction = '';\n    var width = series.chart.requireInvertedAxis ? topRect.height : topRect.width;\n    var center = series.chart.requireInvertedAxis ? topRect.y + topRect.height / 2 : topRect.x + topRect.width / 2;\n    var midWidth = midRect.x + midRect.width;\n    var midHeight = midRect.y + midRect.height;\n    var topWidth = topRect.x + topRect.width;\n    var topHeight = topRect.y + topRect.height;\n\n    if (!series.chart.requireInvertedAxis) {\n      this.updateTipSize(series, point, {\n        x: midRect.x,\n        y: topRect.y,\n        width: midWidth - midRect.x,\n        height: 0\n      }, true);\n      this.updateTipSize(series, point, {\n        x: midRect.x,\n        y: topHeight,\n        width: midWidth - midRect.x,\n        height: 0\n      }, true);\n      direction += 'M ' + midRect.x + ' ' + topRect.y + ' ' + ' L ' + midWidth + ' ' + topRect.y;\n      direction += ' M ' + center + ' ' + topRect.y + ' ' + ' L ' + center + ' ' + midRect.y;\n      direction += ' M ' + midRect.x + ' ' + midRect.y + ' ' + ' L ' + midWidth + ' ' + midRect.y + ' L ' + midWidth + ' ' + midHeight + ' L ' + midRect.x + ' ' + midHeight + ' Z';\n      direction += ' M ' + center + ' ' + midHeight + ' L ' + center + ' ' + topHeight;\n      direction += ' M ' + midRect.x + ' ' + topHeight + ' L ' + midWidth + ' ' + topHeight;\n      direction += ' M ' + midRect.x + ' ' + median.y + ' L ' + midWidth + ' ' + median.y;\n      direction += series.showMean ? ' M ' + (average.x - 5) + ' ' + (average.y - 5) + ' L ' + (average.x + 5) + ' ' + (average.y + 5) + ' M ' + (average.x + 5) + ' ' + (average.y - 5) + ' L ' + (average.x - 5) + ' ' + (average.y + 5) : '';\n    } else {\n      this.updateTipSize(series, point, {\n        x: topRect.x,\n        y: midRect.y,\n        width: 0,\n        height: midHeight - midRect.y\n      }, false);\n      this.updateTipSize(series, point, {\n        x: topWidth,\n        y: midRect.y,\n        width: 0,\n        height: midHeight - midRect.y\n      }, true);\n      direction += 'M ' + topRect.x + ' ' + midRect.y + ' L ' + topRect.x + ' ' + midHeight;\n      direction += 'M ' + topRect.x + ' ' + center + ' ' + ' L ' + midRect.x + ' ' + center;\n      direction += ' M ' + midRect.x + ' ' + midRect.y + ' ' + ' L ' + midWidth + ' ' + midRect.y + ' L ' + midWidth + ' ' + midHeight + ' L ' + midRect.x + ' ' + midHeight + ' Z';\n      direction += ' M ' + midWidth + ' ' + center + ' L ' + topWidth + ' ' + center;\n      direction += ' M ' + topWidth + ' ' + midRect.y + ' L ' + topWidth + ' ' + midHeight;\n      direction += ' M ' + median.x + ' ' + midRect.y + ' ' + ' L ' + median.x + ' ' + midHeight;\n      direction += series.showMean ? 'M ' + (average.x + 5) + ' ' + (average.y - 5) + ' L ' + (average.x - 5) + ' ' + (average.y + 5) + 'M ' + (average.x - 5) + ' ' + (average.y - 5) + ' L ' + (average.x + 5) + ' ' + (average.y + 5) : '';\n    }\n\n    return direction;\n  };\n  /**\n   * Rendering for box and whisker append here.\n   * @param series\n   * @param point\n   * @param rect\n   * @param argsData\n   * @param direction\n   */\n\n\n  BoxAndWhiskerSeries.prototype.renderBoxAndWhisker = function (series, point, rect, argsData, direction, median) {\n    var location;\n    var size;\n    var symbolId = series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index;\n    var element = series.chart.renderer.drawPath(new PathOption(symbolId + '_BoxPath', argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction));\n    element.setAttribute('aria-label', point.x.toString() + ':' + point.maximum.toString() + ':' + point.minimum.toString() + ':' + point.lowerQuartile.toString() + ':' + point.upperQuartile.toString());\n    var parentElement = series.chart.renderer.createGroup({\n      'id': symbolId\n    });\n    parentElement.appendChild(element);\n\n    for (var i = 0; i < point.outliers.length; i++) {\n      location = getPoint(point.xValue + median, point.outliers[i], series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n      size = new Size(series.marker.width, series.marker.height);\n      point.symbolLocations.push(location);\n      this.updateTipSize(series, point, {\n        x: location.x - size.width / 2,\n        y: location.y - size.height / 2,\n        width: size.width,\n        height: size.height\n      }, true);\n    }\n\n    series.seriesElement.appendChild(parentElement);\n  };\n  /**\n   * To find the box plot values\n   * @param yValues\n   * @param point\n   * @param mode\n   */\n\n\n  BoxAndWhiskerSeries.prototype.findBoxPlotValues = function (yValues, point, mode) {\n    var yCount = yValues.length;\n    var quartile = {\n      average: sum(yValues) / yCount,\n      lowerQuartile: 0,\n      upperQuartile: 0,\n      maximum: 0,\n      minimum: 0,\n      median: 0,\n      outliers: []\n    };\n\n    if (mode === 'Exclusive') {\n      quartile.lowerQuartile = this.getExclusiveQuartileValue(yValues, yCount, 0.25);\n      quartile.upperQuartile = this.getExclusiveQuartileValue(yValues, yCount, 0.75);\n      quartile.median = this.getExclusiveQuartileValue(yValues, yCount, 0.5);\n    } else if (mode === 'Inclusive') {\n      quartile.lowerQuartile = this.getInclusiveQuartileValue(yValues, yCount, 0.25);\n      quartile.upperQuartile = this.getInclusiveQuartileValue(yValues, yCount, 0.75);\n      quartile.median = this.getInclusiveQuartileValue(yValues, yCount, 0.5);\n    } else {\n      quartile.median = getMedian(yValues);\n      this.getQuartileValues(yValues, yCount, quartile);\n    }\n\n    this.getMinMaxOutlier(yValues, yCount, quartile);\n    point.minimum = quartile.minimum;\n    point.maximum = quartile.maximum;\n    point.lowerQuartile = quartile.lowerQuartile;\n    point.upperQuartile = quartile.upperQuartile;\n    point.median = quartile.median;\n    point.outliers = quartile.outliers;\n    point.average = quartile.average;\n  };\n  /**\n   * to find the exclusive quartile values\n   * @param yValues\n   * @param count\n   * @param percentile\n   */\n\n\n  BoxAndWhiskerSeries.prototype.getExclusiveQuartileValue = function (yValues, count, percentile) {\n    if (count === 0) {\n      return 0;\n    } else if (count === 1) {\n      return yValues[0];\n    }\n\n    var value = 0;\n    var rank = percentile * (count + 1);\n    var integerRank = Math.floor(Math.abs(rank));\n    var fractionRank = rank - integerRank;\n\n    if (integerRank === 0) {\n      value = yValues[0];\n    } else if (integerRank > count - 1) {\n      value = yValues[count - 1];\n    } else {\n      value = fractionRank * (yValues[integerRank] - yValues[integerRank - 1]) + yValues[integerRank - 1];\n    }\n\n    return value;\n  };\n  /**\n   * to find the inclusive quartile values\n   * @param yValues\n   * @param count\n   * @param percentile\n   */\n\n\n  BoxAndWhiskerSeries.prototype.getInclusiveQuartileValue = function (yValues, count, percentile) {\n    if (count === 0) {\n      return 0;\n    } else if (count === 1) {\n      return yValues[0];\n    }\n\n    var value = 0;\n    var rank = percentile * (count - 1);\n    var integerRank = Math.floor(Math.abs(rank));\n    var fractionRank = rank - integerRank;\n    value = fractionRank * (yValues[integerRank + 1] - yValues[integerRank]) + yValues[integerRank];\n    return value;\n  };\n  /**\n   * To find the quartile values\n   * @param yValues\n   * @param count\n   * @param lowerQuartile\n   * @param upperQuartile\n   */\n\n\n  BoxAndWhiskerSeries.prototype.getQuartileValues = function (yValues, count, quartile) {\n    if (count === 1) {\n      quartile.lowerQuartile = yValues[0];\n      quartile.upperQuartile = yValues[0];\n      return null;\n    }\n\n    var isEvenList = count % 2 === 0;\n    var halfLength = count / 2;\n    var lowerQuartileArray = yValues.slice(0, halfLength);\n    var upperQuartileArray = yValues.slice(isEvenList ? halfLength : halfLength + 1, count);\n    quartile.lowerQuartile = getMedian(lowerQuartileArray);\n    quartile.upperQuartile = getMedian(upperQuartileArray);\n  };\n  /**\n   * To find the min, max and outlier values\n   * @param yValues\n   * @param lowerQuartile\n   * @param upperQuartile\n   * @param minimum\n   * @param maximum\n   * @param outliers\n   */\n\n\n  BoxAndWhiskerSeries.prototype.getMinMaxOutlier = function (yValues, count, quartile) {\n    var interquartile = quartile.upperQuartile - quartile.lowerQuartile;\n    var rangeIQR = 1.5 * interquartile;\n\n    for (var i = 0; i < count; i++) {\n      if (yValues[i] < quartile.lowerQuartile - rangeIQR) {\n        quartile.outliers.push(yValues[i]);\n      } else {\n        quartile.minimum = yValues[i];\n        break;\n      }\n    }\n\n    for (var i = count - 1; i >= 0; i--) {\n      if (yValues[i] > quartile.upperQuartile + rangeIQR) {\n        quartile.outliers.push(yValues[i]);\n      } else {\n        quartile.maximum = yValues[i];\n        break;\n      }\n    }\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  BoxAndWhiskerSeries.prototype.doAnimation = function (series) {\n    this.animate(series);\n  };\n  /**\n   * Get module name.\n   */\n\n\n  BoxAndWhiskerSeries.prototype.getModuleName = function () {\n    return 'BoxAndWhiskerSeries';\n    /**\n     * return the module name\n     */\n  };\n  /**\n   * To destroy the candle series.\n   * @return {void}\n   * @private\n   */\n\n\n  BoxAndWhiskerSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroys the candle series.\n     */\n  };\n\n  return BoxAndWhiskerSeries;\n}(ColumnBase);\n\nexport { BoxAndWhiskerSeries };","map":null,"metadata":{},"sourceType":"module"}