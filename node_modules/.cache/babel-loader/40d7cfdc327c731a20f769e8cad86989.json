{"ast":null,"code":"import Axis from './axis';\nimport NumericAxis from './numeric-axis';\nimport AxisLabel from './axis-label';\nimport { DateLabelFormats } from './constants';\nimport { BLACK, DATE, COORD_PRECISION, DEFAULT_PRECISION, X, Y } from '../common/constants';\nimport { setDefaultOptions, deepExtend, limitValue, round } from '../common';\nimport autoMajorUnit from './utils/auto-major-unit';\nimport ceil from './utils/ceil';\nimport { toDate, toTime, floorDate, ceilDate, duration, addDuration, addTicks, dateDiff, absoluteDateDiff, dateComparer, parseDate, parseDates } from '../date-utils';\nimport { HOURS, DAYS, WEEKS, MONTHS, YEARS, TIME_PER_DAY, TIME_PER_WEEK, TIME_PER_MONTH, TIME_PER_YEAR, TIME_PER_UNIT } from '../date-utils/constants';\n\nvar DateValueAxis = function (Axis) {\n  function DateValueAxis(seriesMin, seriesMax, axisOptions, chartService) {\n    var min = toDate(seriesMin);\n    var max = toDate(seriesMax);\n    var intlService = chartService.intl;\n    var options = axisOptions || {};\n    options = deepExtend(options || {}, {\n      min: parseDate(intlService, options.min),\n      max: parseDate(intlService, options.max),\n      axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue)\n    });\n    options = applyDefaults(min, max, options);\n    Axis.call(this, options, chartService);\n    this.intlService = intlService;\n    this.seriesMin = min;\n    this.seriesMax = max;\n    this.totalMin = toTime(floorDate(toTime(min) - 1, options.baseUnit));\n    this.totalMax = toTime(ceilDate(toTime(max) + 1, options.baseUnit));\n  }\n\n  if (Axis) DateValueAxis.__proto__ = Axis;\n  DateValueAxis.prototype = Object.create(Axis && Axis.prototype);\n  DateValueAxis.prototype.constructor = DateValueAxis;\n\n  DateValueAxis.prototype.clone = function clone() {\n    return new DateValueAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);\n  };\n\n  DateValueAxis.prototype.range = function range() {\n    var options = this.options;\n    return {\n      min: options.min,\n      max: options.max\n    };\n  };\n\n  DateValueAxis.prototype.getDivisions = function getDivisions(stepValue) {\n    var options = this.options;\n    return Math.floor(duration(options.min, options.max, options.baseUnit) / stepValue + 1);\n  };\n\n  DateValueAxis.prototype.getTickPositions = function getTickPositions(step) {\n    var options = this.options;\n    var vertical = options.vertical;\n    var lineBox = this.lineBox();\n    var dir = (vertical ? -1 : 1) * (options.reverse ? -1 : 1);\n    var startEdge = dir === 1 ? 1 : 2;\n    var start = lineBox[(vertical ? Y : X) + startEdge];\n    var divisions = this.getDivisions(step);\n    var timeRange = dateDiff(options.max, options.min);\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var scale = lineSize / timeRange;\n    var positions = [start];\n\n    for (var i = 1; i < divisions; i++) {\n      var date = addDuration(options.min, i * step, options.baseUnit);\n      var pos = start + dateDiff(date, options.min) * scale * dir;\n      positions.push(round(pos, COORD_PRECISION));\n    }\n\n    return positions;\n  };\n\n  DateValueAxis.prototype.getMajorTickPositions = function getMajorTickPositions() {\n    return this.getTickPositions(this.options.majorUnit);\n  };\n\n  DateValueAxis.prototype.getMinorTickPositions = function getMinorTickPositions() {\n    return this.getTickPositions(this.options.minorUnit);\n  };\n\n  DateValueAxis.prototype.getSlot = function getSlot(a, b, limit) {\n    return NumericAxis.prototype.getSlot.call(this, parseDate(this.intlService, a), parseDate(this.intlService, b), limit);\n  };\n\n  DateValueAxis.prototype.getValue = function getValue(point) {\n    var value = NumericAxis.prototype.getValue.call(this, point);\n    return value !== null ? toDate(value) : null;\n  };\n\n  DateValueAxis.prototype.labelsCount = function labelsCount() {\n    return this.getDivisions(this.options.majorUnit);\n  };\n\n  DateValueAxis.prototype.createAxisLabel = function createAxisLabel(index, labelOptions) {\n    var options = this.options;\n    var offset = index * options.majorUnit;\n    var date = options.min;\n\n    if (offset > 0) {\n      date = addDuration(date, offset, options.baseUnit);\n    }\n\n    var unitFormat = labelOptions.dateFormats[options.baseUnit];\n    labelOptions.format = labelOptions.format || unitFormat;\n    var text = this.axisLabelText(date, null, labelOptions);\n    return new AxisLabel(date, text, index, null, labelOptions);\n  };\n\n  DateValueAxis.prototype.translateRange = function translateRange(delta, exact) {\n    var options = this.options;\n    var baseUnit = options.baseUnit;\n    var weekStartDay = options.weekStartDay;\n    var lineBox = this.lineBox();\n    var size = options.vertical ? lineBox.height() : lineBox.width();\n    var range = this.range();\n    var scale = size / dateDiff(range.max, range.min);\n    var offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n    var from = addTicks(options.min, offset);\n    var to = addTicks(options.max, offset);\n\n    if (!exact) {\n      from = addDuration(from, 0, baseUnit, weekStartDay);\n      to = addDuration(to, 0, baseUnit, weekStartDay);\n    }\n\n    return {\n      min: from,\n      max: to,\n      offset: offset\n    };\n  };\n\n  DateValueAxis.prototype.scaleRange = function scaleRange(delta) {\n    var ref = this.options;\n    var from = ref.min;\n    var to = ref.max;\n    var rounds = Math.abs(delta);\n\n    while (rounds--) {\n      var range = dateDiff(from, to);\n      var step = Math.round(range * 0.1);\n\n      if (delta < 0) {\n        from = addTicks(from, step);\n        to = addTicks(to, -step);\n      } else {\n        from = addTicks(from, -step);\n        to = addTicks(to, step);\n      }\n    }\n\n    return {\n      min: from,\n      max: to\n    };\n  };\n\n  DateValueAxis.prototype.shouldRenderNote = function shouldRenderNote(value) {\n    var range = this.range();\n    return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0;\n  };\n\n  DateValueAxis.prototype.pan = function pan(delta) {\n    var range = this.translateRange(delta, true);\n    var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);\n\n    if (limittedRange) {\n      return {\n        min: toDate(limittedRange.min),\n        max: toDate(limittedRange.max)\n      };\n    }\n  };\n\n  DateValueAxis.prototype.pointsRange = function pointsRange(start, end) {\n    var startValue = this.getValue(start);\n    var endValue = this.getValue(end);\n    var min = Math.min(startValue, endValue);\n    var max = Math.max(startValue, endValue);\n    return {\n      min: toDate(min),\n      max: toDate(max)\n    };\n  };\n\n  DateValueAxis.prototype.zoomRange = function zoomRange(delta) {\n    var range = this.scaleRange(delta);\n    var min = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));\n    var max = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  return DateValueAxis;\n}(Axis);\n\nfunction timeUnits(delta) {\n  var unit = HOURS;\n\n  if (delta >= TIME_PER_YEAR) {\n    unit = YEARS;\n  } else if (delta >= TIME_PER_MONTH) {\n    unit = MONTHS;\n  } else if (delta >= TIME_PER_WEEK) {\n    unit = WEEKS;\n  } else if (delta >= TIME_PER_DAY) {\n    unit = DAYS;\n  }\n\n  return unit;\n}\n\nfunction applyDefaults(seriesMin, seriesMax, options) {\n  var min = options.min || seriesMin;\n  var max = options.max || seriesMax;\n  var baseUnit = options.baseUnit || (max && min ? timeUnits(absoluteDateDiff(max, min)) : HOURS);\n  var baseUnitTime = TIME_PER_UNIT[baseUnit];\n  var autoMin = floorDate(toTime(min) - 1, baseUnit) || toDate(max);\n  var autoMax = ceilDate(toTime(max) + 1, baseUnit);\n  var userMajorUnit = options.majorUnit ? options.majorUnit : undefined;\n  var majorUnit = userMajorUnit || ceil(autoMajorUnit(autoMin.getTime(), autoMax.getTime()), baseUnitTime) / baseUnitTime;\n  var actualUnits = duration(autoMin, autoMax, baseUnit);\n  var totalUnits = ceil(actualUnits, majorUnit);\n  var unitsToAdd = totalUnits - actualUnits;\n  var head = Math.floor(unitsToAdd / 2);\n  var tail = unitsToAdd - head;\n\n  if (!options.baseUnit) {\n    delete options.baseUnit;\n  }\n\n  options.baseUnit = options.baseUnit || baseUnit;\n  options.min = options.min || addDuration(autoMin, -head, baseUnit);\n  options.max = options.max || addDuration(autoMax, tail, baseUnit);\n  options.minorUnit = options.minorUnit || majorUnit / 5;\n  options.majorUnit = majorUnit;\n  return options;\n}\n\nsetDefaultOptions(DateValueAxis, {\n  type: DATE,\n  majorGridLines: {\n    visible: true,\n    width: 1,\n    color: BLACK\n  },\n  labels: {\n    dateFormats: DateLabelFormats\n  }\n});\nexport default DateValueAxis;","map":null,"metadata":{},"sourceType":"module"}