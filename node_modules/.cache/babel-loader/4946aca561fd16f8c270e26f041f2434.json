{"ast":null,"code":"/**\n * Defines the common functionalities of accumulation series\n */\nimport { isNullOrUndefined, Animation, createElement } from '@syncfusion/ej2-base';\nimport { degreeToLocation, getElement, indexFinder, linear } from '../../common/utils/helper';\nimport { pointByIndex } from '../model/acc-base';\n/**\n * Accumulation Base used to do some base calculation for accumulation chart.\n */\n\nvar AccumulationBase =\n/** @class */\nfunction () {\n  /** @private */\n  function AccumulationBase(accumulation) {\n    this.accumulation = accumulation;\n  }\n\n  Object.defineProperty(AccumulationBase.prototype, \"center\", {\n    /**\n     * Gets the center of the pie\n     * @private\n     */\n    get: function () {\n      return this.pieCenter || (this.accumulation.visibleSeries[0].type === 'Pie' ? this.accumulation.pieSeriesModule.center : null);\n    },\n\n    /**\n     * Sets the center of the pie\n     * @private\n     */\n    set: function (value) {\n      this.pieCenter = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AccumulationBase.prototype, \"radius\", {\n    /**\n     * Gets the radius of the pie\n     * @private\n     */\n    get: function () {\n      return this.pieRadius !== undefined ? this.pieRadius : this.accumulation.pieSeriesModule.radius;\n    },\n\n    /**\n     * Sets the radius of the pie\n     * @private\n     */\n    set: function (value) {\n      this.pieRadius = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AccumulationBase.prototype, \"labelRadius\", {\n    /**\n     * Gets the label radius of the pie\n     * @private\n     */\n    get: function () {\n      return this.pieLabelRadius !== undefined ? this.pieLabelRadius : this.accumulation.pieSeriesModule.labelRadius;\n    },\n\n    /**\n     * Sets the label radius of the pie\n     * @private\n     */\n    set: function (value) {\n      this.pieLabelRadius = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Checks whether the series is circular or not\n   * @private\n   */\n\n  AccumulationBase.prototype.isCircular = function () {\n    return this.accumulation.type === 'Pie';\n  };\n  /**\n   * To check various radius pie\n   * @private\n   */\n\n\n  AccumulationBase.prototype.isVariousRadius = function () {\n    return this.accumulation.pieSeriesModule.isRadiusMapped;\n  };\n  /**\n   * To process the explode on accumulation chart loading\n   * @private\n   */\n\n\n  AccumulationBase.prototype.processExplode = function (event) {\n    if (event.target.id.indexOf('_Series_') > -1 || event.target.id.indexOf('_datalabel_') > -1) {\n      var pointIndex = indexFinder(event.target.id).point;\n\n      if (isNaN(pointIndex) || event.target.id.indexOf('_datalabel_') > -1 && this.accumulation.visibleSeries[0].points[pointIndex].labelPosition === 'Outside') {\n        return null;\n      }\n\n      this.explodePoints(pointIndex, this.accumulation);\n      this.deExplodeAll(pointIndex, this.accumulation.enableAnimation ? 300 : 0);\n    }\n  };\n  /**\n   * To invoke the explode on accumulation chart loading\n   * @private\n   */\n\n\n  AccumulationBase.prototype.invokeExplode = function () {\n    var series = this.accumulation.visibleSeries[0];\n    var duration = this.accumulation.enableAnimation ? 300 : 0;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      if (point.isExplode) {\n        this.pointExplode(point.index, point, duration);\n      }\n    }\n\n    if (this.accumulation.accumulationSelectionModule && this.accumulation.selectionMode !== 'None' && this.accumulation.accumulationSelectionModule.selectedDataIndexes.length) {\n      for (var _b = 0, _c = this.accumulation.accumulationSelectionModule.selectedDataIndexes; _b < _c.length; _b++) {\n        var index = _c[_b];\n        this.explodePoints(index.point, this.accumulation, true);\n        this.deExplodeAll(index.point, duration);\n      }\n    }\n  };\n  /**\n   * To deExplode all points in the series\n   * @private\n   */\n\n\n  AccumulationBase.prototype.deExplodeAll = function (index, animationDuration) {\n    var pointId = this.accumulation.element.id + '_Series_0_Point_';\n    var points = this.accumulation.visibleSeries[0].points;\n\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var currentPoint = points_1[_i];\n\n      if (index !== currentPoint.index && !currentPoint.isSliced || currentPoint.isClubbed) {\n        currentPoint.isExplode = false;\n        this.deExplodeSlice(currentPoint.index, pointId, animationDuration);\n      }\n    }\n  };\n  /**\n   * To explode point by index\n   * @private\n   */\n\n\n  AccumulationBase.prototype.explodePoints = function (index, chart, explode) {\n    if (explode === void 0) {\n      explode = false;\n    }\n\n    var series = chart.visibleSeries[0];\n    var points = series.points;\n    var point = pointByIndex(index, points);\n    var explodePoints = true;\n    var duration = this.accumulation.enableAnimation ? 300 : 0;\n\n    if (isNullOrUndefined(point)) {\n      return null;\n    }\n\n    var clubPointsExploded = !explode && (point.isSliced || series.clubbedPoints.length && points[points.length - 1].index === series.clubbedPoints[series.clubbedPoints.length - 1].index);\n\n    if (series.type === 'Pie' && (clubPointsExploded || point.isClubbed)) {\n      explodePoints = this.clubPointExplode(index, point, series, points, chart, duration, explode, clubPointsExploded);\n    }\n\n    if (explodePoints) {\n      this.pointExplode(index, point, duration, explode);\n    }\n  };\n\n  AccumulationBase.prototype.getSum = function (points) {\n    var total = 0;\n    points.map(function (point) {\n      total += point.visible ? point.y : 0;\n    });\n    return total;\n  };\n\n  ;\n\n  AccumulationBase.prototype.clubPointExplode = function (index, point, series, points, chart, duration, explode, clubPointsExploded) {\n    if (explode === void 0) {\n      explode = false;\n    }\n\n    if (clubPointsExploded === void 0) {\n      clubPointsExploded = false;\n    }\n\n    if (point.isClubbed) {\n      chart.animateSeries = false;\n      points.splice(points.length - 1, 1);\n      series.clubbedPoints.map(function (point) {\n        point.visible = true;\n        point.isExplode = true;\n      });\n      chart.visibleSeries[0].points = points.concat(series.clubbedPoints);\n      this.deExplodeAll(index, duration);\n      series.sumOfPoints = this.getSum(chart.visibleSeries[0].points);\n      chart.refreshChart();\n      return false;\n    } else if (clubPointsExploded || point.isSliced) {\n      chart.animateSeries = false;\n      points.splice(points.length - series.clubbedPoints.length, series.clubbedPoints.length);\n      var clubPoint = series.generateClubPoint();\n      clubPoint.index = points.length;\n      clubPoint.color = series.clubbedPoints[0].color;\n      points.push(clubPoint);\n      series.sumOfPoints = this.getSum(points);\n      this.deExplodeAll(index, duration);\n      clubPoint.isExplode = false;\n      chart.visibleSeries[0].points = points;\n      chart.refreshChart();\n      this.pointExplode(clubPoint.index, points[clubPoint.index], 0, true);\n      clubPoint.isExplode = false;\n      this.deExplodeSlice(clubPoint.index, chart.element.id + '_Series_0_Point_', duration);\n\n      if (point.isSliced) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * To Explode points\n   * @param index\n   * @param point\n   * @param explode\n   */\n\n\n  AccumulationBase.prototype.pointExplode = function (index, point, duration, explode) {\n    var translate;\n    var pointId = this.accumulation.element.id + '_Series_0_Point_';\n    var chart = this.accumulation;\n\n    if (!this.isCircular()) {\n      translate = {\n        x: point.labelRegion && point.labelRegion.x < point.region.x ? -chart.explodeDistance : chart.explodeDistance,\n        y: 0\n      };\n    } else {\n      translate = degreeToLocation(point.midAngle, chart.explodeDistance, this.center);\n    }\n\n    if (this.isExplode(pointId + index) || explode) {\n      point.isExplode = true;\n      this.explodeSlice(index, translate, pointId, this.center || {\n        x: 0,\n        y: 0\n      }, duration);\n    } else {\n      point.isExplode = false;\n      this.deExplodeSlice(index, pointId, duration);\n    }\n  };\n  /**\n   * To check point is exploded by id\n   */\n\n\n  AccumulationBase.prototype.isExplode = function (id) {\n    var element = getElement(id);\n    var transform = element ? element.getAttribute('transform') : null;\n    return element && (transform === 'translate(0, 0)' || transform === null || transform === 'translate(0)');\n  };\n  /**\n   * To deExplode the point by index\n   */\n\n\n  AccumulationBase.prototype.deExplodeSlice = function (index, sliceId, animationDuration) {\n    var element = getElement(sliceId + index);\n    var transform = element ? element.getAttribute('transform') : null;\n\n    if (this.accumulation.enableAnimation && element && transform && transform !== 'translate(0, 0)' && transform !== 'translate(0)') {\n      var result = /translate\\((-?\\d+\\.?\\d*),?\\s*(-?\\d+[.]?\\d*)?\\)/.exec(transform);\n      this.performAnimation(index, sliceId, 0, 0, +result[1], +result[2] || 0, animationDuration, true);\n    } else {\n      this.performAnimation(index, sliceId, 0, 0, 0, 0, animationDuration, true);\n    }\n  };\n  /**\n   * To translate the point elements by index and position\n   */\n\n\n  AccumulationBase.prototype.setTranslate = function (index, sliceId, position) {\n    this.setElementTransform(sliceId + index, position);\n\n    if (this.accumulation.visibleSeries[0].dataLabel.visible) {\n      sliceId = this.accumulation.element.id + '_datalabel_Series_0_';\n      this.setElementTransform(sliceId + 'shape_' + index, position);\n      this.setElementTransform(sliceId + 'text_' + index, position);\n      this.setElementTransform(sliceId + 'connector_' + index, position);\n    }\n  };\n  /**\n   * To translate the point element by id and position\n   */\n\n\n  AccumulationBase.prototype.setElementTransform = function (id, position) {\n    var element = getElement(id);\n\n    if (element) {\n      element.setAttribute('transform', position);\n    }\n  };\n  /**\n   * To translate the point elements by index position\n   */\n\n\n  AccumulationBase.prototype.explodeSlice = function (index, translate, sliceId, center, animationDuration) {\n    this.performAnimation(index, sliceId, 0, 0, translate.x - center.x, translate.y - center.y, animationDuration);\n  };\n  /**\n   * To Perform animation point explode\n   * @param index\n   * @param sliceId\n   * @param start\n   * @param endX\n   * @param endY\n   */\n\n\n  AccumulationBase.prototype.performAnimation = function (index, sliceId, startX, startY, endX, endY, duration, isReverse) {\n    var _this = this;\n\n    if (duration <= 0) {\n      this.setTranslate(index, sliceId, 'translate(' + endX + ', ' + endY + ')');\n      return null;\n    }\n\n    var xValue;\n    var yValue;\n    new Animation({}).animate(createElement('div'), {\n      duration: duration,\n      progress: function (args) {\n        xValue = linear(args.timeStamp, startX, endX, args.duration);\n        yValue = linear(args.timeStamp, startY, endY, args.duration);\n\n        _this.setTranslate(index, sliceId, 'translate(' + (isReverse ? endX - xValue : xValue) + ', ' + (isReverse ? endY - yValue : yValue) + ')');\n      },\n      end: function (model) {\n        _this.setTranslate(index, sliceId, 'translate(' + (isReverse ? startX : endX) + ', ' + (isReverse ? startX : endY) + ')');\n      }\n    });\n  };\n\n  return AccumulationBase;\n}();\n\nexport { AccumulationBase };","map":null,"metadata":{},"sourceType":"module"}