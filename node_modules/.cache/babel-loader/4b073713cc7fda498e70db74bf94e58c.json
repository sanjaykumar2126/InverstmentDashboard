{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { setDefaultOptions, deepExtend, defined, round } from '../../common';\nimport { BLACK, COORD_PRECISION } from '../../common/constants';\nimport { autoMajorUnit, Box, NumericAxis } from '../../core';\nimport { buildLabelElement, getRange } from '../utils';\nimport { DEGREE, DEFAULT_LINE_WIDTH, INSIDE, OUTSIDE } from '../constants';\nvar GEO_ARC_ADJUST_ANGLE = 180;\nvar Arc = drawing.Arc;\nvar Path = drawing.Path;\nvar Group = drawing.Group;\n\nfunction drawTicks(arc, tickAngles, unit, tickOptions) {\n  var ticks = new Group();\n  var center = arc.center;\n  var radius = arc.getRadiusX();\n\n  if (tickOptions.visible) {\n    for (var i = 0; i < tickAngles.length; i++) {\n      var tickStart = arc.pointAt(tickAngles[i]);\n      var tickEnd = new geo.Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n      ticks.append(new Path({\n        stroke: {\n          color: tickOptions.color,\n          width: tickOptions.width\n        }\n      }).moveTo(tickStart).lineTo(tickEnd));\n    }\n  }\n\n  return ticks;\n}\n\nfunction rangeSegment(from, to, color, opacity) {\n  return {\n    from: from,\n    to: to,\n    color: color,\n    opacity: opacity\n  };\n}\n\nvar RadialScale = function (NumericAxis) {\n  function RadialScale(options, service) {\n    NumericAxis.call(this, 0, 1, options, service);\n  }\n\n  if (NumericAxis) RadialScale.__proto__ = NumericAxis;\n  RadialScale.prototype = Object.create(NumericAxis && NumericAxis.prototype);\n  RadialScale.prototype.constructor = RadialScale;\n\n  RadialScale.prototype.initUserOptions = function initUserOptions(options) {\n    var scaleOptions = deepExtend({}, this.options, options);\n    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);\n    scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n    return scaleOptions;\n  };\n\n  RadialScale.prototype.initFields = function initFields() {};\n\n  RadialScale.prototype.render = function render(center, radius) {\n    var arc = this.renderArc(center, radius);\n    this.bbox = arc.bbox();\n    this.labelElements = this.renderLabels();\n    this.ticks = this.renderTicks();\n    this.ranges = this.renderRanges();\n  };\n\n  RadialScale.prototype.reflow = function reflow(bbox) {\n    var center = bbox.center();\n    var radius = Math.min(bbox.height(), bbox.width()) / 2;\n\n    if (defined(this.bbox)) {\n      this.bbox = this.arc.bbox();\n      this.radius(this.arc.getRadiusX());\n      this.repositionRanges();\n      this.renderLabels();\n    } else {\n      return this.render(center, radius);\n    }\n  };\n\n  RadialScale.prototype.slotAngle = function slotAngle(value) {\n    var ref = this.options;\n    var min = ref.min;\n    var max = ref.max;\n    var reverse = ref.reverse;\n    var startAngle = ref.startAngle;\n    var endAngle = ref.endAngle;\n    var angle = endAngle - startAngle;\n    var result;\n\n    if (reverse) {\n      result = endAngle - (value - min) / (max - min) * angle;\n    } else {\n      result = (value - min) / (max - min) * angle + startAngle;\n    }\n\n    return result + GEO_ARC_ADJUST_ANGLE;\n  };\n\n  RadialScale.prototype.hasRanges = function hasRanges() {\n    var ranges = this.options.ranges;\n    return ranges && ranges.length;\n  };\n\n  RadialScale.prototype.ticksSize = function ticksSize() {\n    var ref = this.options;\n    var majorTicks = ref.majorTicks;\n    var minorTicks = ref.minorTicks;\n    var size = 0;\n\n    if (majorTicks.visible) {\n      size = majorTicks.size;\n    }\n\n    if (minorTicks.visible) {\n      size = Math.max(minorTicks.size, size);\n    }\n\n    return size;\n  };\n\n  RadialScale.prototype.renderLabels = function renderLabels() {\n    var this$1 = this;\n    var options = this.options;\n    var arc = this.arc.clone();\n    var radius = arc.getRadiusX();\n    var tickAngles = this.tickAngles(arc, options.majorUnit);\n    var rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n    var labelsGroup = new Group();\n    var rangeDistance = radius * 0.05;\n\n    if (defined(options.rangeDistance)) {\n      rangeDistance = options.rangeDistance;\n    } else {\n      options.rangeDistance = rangeDistance;\n    }\n\n    var labelsOptions = options.labels;\n    var isInside = labelsOptions.position === INSIDE;\n    var hasLabelElements = defined(this.labelElements);\n\n    if (isInside) {\n      radius -= this.ticksSize();\n\n      if (this.hasRanges() && !hasLabelElements) {\n        radius -= rangeSize + rangeDistance;\n      }\n\n      arc.setRadiusX(radius).setRadiusY(radius);\n    }\n\n    var labels = this.labels;\n    var count = labels.length;\n    var padding = labelsOptions.padding;\n\n    for (var i = 0; i < count; i++) {\n      var label = labels[i];\n      var halfWidth = label.box.width() / 2;\n      var halfHeight = label.box.height() / 2;\n      var angle = tickAngles[i];\n      var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n      var lp = arc.pointAt(angle);\n      var cx = lp.x + Math.cos(labelAngle) * (halfWidth + padding) * (isInside ? 1 : -1);\n      var cy = lp.y + Math.sin(labelAngle) * (halfHeight + padding) * (isInside ? 1 : -1);\n      label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n      var labelPos = new geo.Point(label.box.x1, label.box.y1);\n      var labelElement = void 0;\n\n      if (!hasLabelElements) {\n        labelElement = buildLabelElement(label, options.labels);\n        labelsGroup.append(labelElement);\n      } else {\n        labelElement = this$1.labelElements.children[i];\n        var prevLabelPos = labelElement.bbox().origin;\n        var labelTransform = labelElement.transform() || geo.transform();\n        labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n        labelElement.transform(labelTransform);\n      }\n\n      this$1.bbox = geo.Rect.union(this$1.bbox, labelElement.bbox());\n    }\n\n    return labelsGroup;\n  };\n\n  RadialScale.prototype.repositionRanges = function repositionRanges() {\n    var ranges = this.ranges.children;\n\n    if (ranges.length > 0) {\n      var ref = this.options;\n      var rangeDistance = ref.rangeDistance;\n      var rangeSize = ref.rangeSize;\n      var rangeRadius = this.getRangeRadius();\n\n      if (this.options.labels.position === INSIDE) {\n        rangeRadius += rangeSize + rangeDistance;\n      }\n\n      var newRadius = rangeRadius + rangeSize / 2;\n\n      for (var i = 0; i < ranges.length; i++) {\n        ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n      }\n\n      this.bbox = geo.Rect.union(this.bbox, this.ranges.bbox());\n    }\n  };\n\n  RadialScale.prototype.renderRanges = function renderRanges() {\n    var this$1 = this;\n    var segments = this.rangeSegments();\n    var segmentsCount = segments.length;\n    var result = new Group();\n\n    if (segmentsCount) {\n      var ref = this.options;\n      var rangeSize = ref.rangeSize;\n      var reverse = ref.reverse;\n      var rangeDistance = ref.rangeDistance;\n      var rangeRadius = this.getRangeRadius(); // move the ticks with a range distance and a range size\n\n      this.radius(this.radius() - rangeSize - rangeDistance);\n\n      for (var i = 0; i < segmentsCount; i++) {\n        var segment = segments[i];\n        var from = this$1.slotAngle(segment[reverse ? \"to\" : \"from\"]);\n        var to = this$1.slotAngle(segment[!reverse ? \"to\" : \"from\"]);\n\n        if (to - from !== 0) {\n          result.append(this$1.createRange(from, to, rangeRadius, segment));\n        }\n      }\n    }\n\n    return result;\n  };\n\n  RadialScale.prototype.createRange = function createRange(startAngle, endAngle, rangeRadius, options) {\n    var rangeSize = this.options.rangeSize;\n    var rangeGeom = new geo.Arc(this.arc.center, {\n      radiusX: rangeRadius + rangeSize / 2,\n      radiusY: rangeRadius + rangeSize / 2,\n      startAngle: startAngle,\n      endAngle: endAngle\n    });\n    return new Arc(rangeGeom, {\n      stroke: {\n        width: rangeSize,\n        color: options.color,\n        opacity: options.opacity,\n        lineCap: options.lineCap\n      }\n    });\n  };\n\n  RadialScale.prototype.rangeSegments = function rangeSegments() {\n    var options = this.options;\n    var ranges = options.ranges || [];\n    var count = ranges.length;\n    var segments = [];\n\n    if (count) {\n      var min = options.min;\n      var max = options.max;\n      var defaultColor = options.rangePlaceholderColor;\n      segments.push(rangeSegment(min, max, defaultColor));\n\n      for (var i = 0; i < count; i++) {\n        var range = getRange(ranges[i], min, max);\n        var segmentsCount = segments.length;\n\n        for (var j = 0; j < segmentsCount; j++) {\n          var segment = segments[j];\n\n          if (segment.from <= range.from && range.from <= segment.to) {\n            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n\n            if (segment.from <= range.to && range.to <= segment.to) {\n              segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n            }\n\n            segment.to = range.from;\n            break;\n          }\n        }\n      }\n    }\n\n    return segments;\n  };\n\n  RadialScale.prototype.getRangeRadius = function getRangeRadius() {\n    var ref = this;\n    var arc = ref.arc;\n    var options = ref.options;\n    var rangeSize = options.rangeSize;\n    var rangeDistance = options.rangeDistance;\n    var majorTickSize = options.majorTicks.size;\n    var radius;\n\n    if (options.labels.position === OUTSIDE) {\n      radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n    } else {\n      radius = arc.getRadiusX() - rangeSize;\n    }\n\n    return radius;\n  };\n\n  RadialScale.prototype.renderArc = function renderArc(center, radius) {\n    var options = this.options;\n    var arc = this.arc = new geo.Arc(center, {\n      radiusX: radius,\n      radiusY: radius,\n      startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n      endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n    });\n    return arc;\n  };\n\n  RadialScale.prototype.renderTicks = function renderTicks() {\n    var ref = this;\n    var arc = ref.arc;\n    var options = ref.options;\n    var tickArc = arc.clone();\n    this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n    this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n    var allTicks = new Group();\n    allTicks.append(this.majorTicks);\n    var majorTickSize = options.majorTicks.size;\n    var minorTickSize = options.minorTicks.size;\n    this._tickDifference = majorTickSize - minorTickSize;\n\n    if (options.labels.position === OUTSIDE) {\n      var radius = tickArc.getRadiusX();\n      tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);\n    }\n\n    this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n    this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n    allTicks.append(this.minorTicks);\n    return allTicks;\n  };\n\n  RadialScale.prototype.normalizeTickAngles = function normalizeTickAngles(angles) {\n    var options = this.options;\n    var skip = options.majorUnit / options.minorUnit;\n\n    for (var i = angles.length - 1; i >= 0; i--) {\n      if (i % skip === 0) {\n        angles.splice(i, 1);\n      }\n    }\n\n    return angles;\n  };\n\n  RadialScale.prototype.tickAngles = function tickAngles(ring, stepValue) {\n    var options = this.options;\n    var reverse = options.reverse;\n    var range = options.max - options.min;\n    var angle = ring.endAngle - ring.startAngle;\n    var tickCount = range / stepValue;\n    var pos = ring.startAngle;\n    var step = angle / tickCount;\n\n    if (reverse) {\n      pos += angle;\n      step = -step;\n    }\n\n    var positions = [];\n\n    for (var i = 0; i < tickCount; i++) {\n      positions.push(round(pos, COORD_PRECISION));\n      pos += step;\n    }\n\n    if (round(pos) <= ring.endAngle) {\n      positions.push(pos);\n    }\n\n    return positions;\n  };\n\n  RadialScale.prototype.radius = function radius(value) {\n    if (value) {\n      this.arc.setRadiusX(value).setRadiusY(value);\n      this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n      this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n    } else {\n      return this.arc.getRadiusX();\n    }\n  };\n\n  RadialScale.prototype.repositionTicks = function repositionTicks(ticks, tickAngles, minor) {\n    var diff = minor ? this._tickDifference || 0 : 0;\n    var tickArc = this.arc;\n    var radius = tickArc.getRadiusX();\n\n    if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {\n      tickArc = this.arc.clone();\n      tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n    }\n\n    for (var i = 0; i < ticks.length; i++) {\n      var newPoint = tickArc.pointAt(tickAngles[i]);\n      var segments = ticks[i].segments;\n      var xDiff = newPoint.x - segments[0].anchor().x;\n      var yDiff = newPoint.y - segments[0].anchor().y;\n      ticks[i].transform(new geo.transform().translate(xDiff, yDiff));\n    }\n  };\n\n  return RadialScale;\n}(NumericAxis);\n\nsetDefaultOptions(RadialScale, {\n  min: 0,\n  max: 100,\n  majorTicks: {\n    size: 15,\n    align: INSIDE,\n    color: BLACK,\n    width: DEFAULT_LINE_WIDTH,\n    visible: true\n  },\n  minorTicks: {\n    size: 10,\n    align: INSIDE,\n    color: BLACK,\n    width: DEFAULT_LINE_WIDTH,\n    visible: true\n  },\n  startAngle: -30,\n  endAngle: 210,\n  labels: {\n    position: INSIDE,\n    padding: 2\n  }\n});\nexport default RadialScale;","map":null,"metadata":{},"sourceType":"module"}