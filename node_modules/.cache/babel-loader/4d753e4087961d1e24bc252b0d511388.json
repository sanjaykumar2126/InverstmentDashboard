{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport { X, Y } from '../common/constants';\nimport { Class, last, round } from '../common';\nvar WEIGHT = 0.333;\nvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\n\nvar CurveProcessor = function (Class) {\n  function CurveProcessor(closed) {\n    Class.call(this);\n    this.closed = closed;\n  }\n\n  if (Class) CurveProcessor.__proto__ = Class;\n  CurveProcessor.prototype = Object.create(Class && Class.prototype);\n  CurveProcessor.prototype.constructor = CurveProcessor;\n\n  CurveProcessor.prototype.process = function process(dataPoints) {\n    var this$1 = this;\n    var points = dataPoints.slice(0);\n    var segments = [];\n    var closed = this.closed;\n    var length = points.length;\n\n    if (length > 2) {\n      this.removeDuplicates(0, points);\n      length = points.length;\n    }\n\n    if (length < 2 || length === 2 && points[0].equals(points[1])) {\n      return segments;\n    }\n\n    var p0 = points[0];\n    var p1 = points[1];\n    var p2 = points[2];\n    segments.push(new geom.Segment(p0));\n\n    while (p0.equals(points[length - 1])) {\n      closed = true;\n      points.pop();\n      length--;\n    }\n\n    if (length === 2) {\n      var tangent = this.tangent(p0, p1, X, Y);\n      last(segments).controlOut(this.firstControlPoint(tangent, p0, p1, X, Y));\n      segments.push(new geom.Segment(p1, this.secondControlPoint(tangent, p0, p1, X, Y)));\n      return segments;\n    }\n\n    var initialControlPoint, lastControlPoint;\n\n    if (closed) {\n      p0 = points[length - 1];\n      p1 = points[0];\n      p2 = points[1];\n      var controlPoints = this.controlPoints(p0, p1, p2);\n      initialControlPoint = controlPoints[1];\n      lastControlPoint = controlPoints[0];\n    } else {\n      var tangent$1 = this.tangent(p0, p1, X, Y);\n      initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\n    }\n\n    var cp0 = initialControlPoint;\n\n    for (var idx = 0; idx <= length - 3; idx++) {\n      this$1.removeDuplicates(idx, points);\n      length = points.length;\n\n      if (idx + 3 <= length) {\n        p0 = points[idx];\n        p1 = points[idx + 1];\n        p2 = points[idx + 2];\n        var controlPoints$1 = this$1.controlPoints(p0, p1, p2);\n        last(segments).controlOut(cp0);\n        cp0 = controlPoints$1[1];\n        var cp1 = controlPoints$1[0];\n        segments.push(new geom.Segment(p1, cp1));\n      }\n    }\n\n    if (closed) {\n      p0 = points[length - 2];\n      p1 = points[length - 1];\n      p2 = points[0];\n      var controlPoints$2 = this.controlPoints(p0, p1, p2);\n      last(segments).controlOut(cp0);\n      segments.push(new geom.Segment(p1, controlPoints$2[0]));\n      last(segments).controlOut(controlPoints$2[1]);\n      segments.push(new geom.Segment(p2, lastControlPoint));\n    } else {\n      var tangent$2 = this.tangent(p1, p2, X, Y);\n      last(segments).controlOut(cp0);\n      segments.push(new geom.Segment(p2, this.secondControlPoint(tangent$2, p1, p2, X, Y)));\n    }\n\n    return segments;\n  };\n\n  CurveProcessor.prototype.removeDuplicates = function removeDuplicates(idx, points) {\n    while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n      points.splice(idx + 1, 1);\n    }\n  };\n\n  CurveProcessor.prototype.invertAxis = function invertAxis(p0, p1, p2) {\n    var invertAxis = false;\n\n    if (p0.x === p1.x) {\n      invertAxis = true;\n    } else if (p1.x === p2.x) {\n      if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {\n        invertAxis = true;\n      }\n    } else {\n      var fn = this.lineFunction(p0, p1);\n      var y2 = this.calculateFunction(fn, p2.x);\n\n      if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {\n        invertAxis = true;\n      }\n    }\n\n    return invertAxis;\n  };\n\n  CurveProcessor.prototype.isLine = function isLine(p0, p1, p2) {\n    var fn = this.lineFunction(p0, p1);\n    var y2 = this.calculateFunction(fn, p2.x);\n    return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);\n  };\n\n  CurveProcessor.prototype.lineFunction = function lineFunction(p1, p2) {\n    var a = (p2.y - p1.y) / (p2.x - p1.x);\n    var b = p1.y - a * p1.x;\n    return [b, a];\n  };\n\n  CurveProcessor.prototype.controlPoints = function controlPoints(p0, p1, p2) {\n    var xField = X;\n    var yField = Y;\n    var restrict = false;\n    var switchOrientation = false;\n    var tangent;\n\n    if (this.isLine(p0, p1, p2)) {\n      tangent = this.tangent(p0, p1, X, Y);\n    } else {\n      var monotonic = {\n        x: this.isMonotonicByField(p0, p1, p2, X),\n        y: this.isMonotonicByField(p0, p1, p2, Y)\n      };\n\n      if (monotonic.x && monotonic.y) {\n        tangent = this.tangent(p0, p2, X, Y);\n        restrict = true;\n      } else {\n        if (this.invertAxis(p0, p1, p2)) {\n          xField = Y;\n          yField = X;\n        }\n\n        if (monotonic[xField]) {\n          tangent = 0;\n        } else {\n          var sign;\n\n          if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {\n            sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n          } else {\n            sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n          }\n\n          tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n          switchOrientation = true;\n        }\n      }\n    }\n\n    var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n    if (switchOrientation) {\n      var oldXField = xField;\n      xField = yField;\n      yField = oldXField;\n    }\n\n    var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n    if (restrict) {\n      this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n      this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n    }\n\n    return [secondControlPoint, firstControlPoint];\n  };\n\n  CurveProcessor.prototype.restrictControlPoint = function restrictControlPoint(p1, p2, cp, tangent) {\n    if (p1.y < p2.y) {\n      if (p2.y < cp.y) {\n        cp.x = p1.x + (p2.y - p1.y) / tangent;\n        cp.y = p2.y;\n      } else if (cp.y < p1.y) {\n        cp.x = p2.x - (p2.y - p1.y) / tangent;\n        cp.y = p1.y;\n      }\n    } else {\n      if (cp.y < p2.y) {\n        cp.x = p1.x - (p1.y - p2.y) / tangent;\n        cp.y = p2.y;\n      } else if (p1.y < cp.y) {\n        cp.x = p2.x + (p1.y - p2.y) / tangent;\n        cp.y = p1.y;\n      }\n    }\n  };\n\n  CurveProcessor.prototype.tangent = function tangent(p0, p1, xField, yField) {\n    var x = p1[xField] - p0[xField];\n    var y = p1[yField] - p0[yField];\n    var tangent;\n\n    if (x === 0) {\n      tangent = 0;\n    } else {\n      tangent = y / x;\n    }\n\n    return tangent;\n  };\n\n  CurveProcessor.prototype.isMonotonicByField = function isMonotonicByField(p0, p1, p2, field) {\n    return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];\n  };\n\n  CurveProcessor.prototype.firstControlPoint = function firstControlPoint(tangent, p0, p3, xField, yField) {\n    var t1 = p0[xField];\n    var t2 = p3[xField];\n    var distance = (t2 - t1) * WEIGHT;\n    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n  };\n\n  CurveProcessor.prototype.secondControlPoint = function secondControlPoint(tangent, p0, p3, xField, yField) {\n    var t1 = p0[xField];\n    var t2 = p3[xField];\n    var distance = (t2 - t1) * WEIGHT;\n    return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n  };\n\n  CurveProcessor.prototype.point = function point(xValue, yValue, xField, yField) {\n    var controlPoint = new geom.Point();\n    controlPoint[xField] = xValue;\n    controlPoint[yField] = yValue;\n    return controlPoint;\n  };\n\n  CurveProcessor.prototype.calculateFunction = function calculateFunction(fn, x) {\n    var length = fn.length;\n    var result = 0;\n\n    for (var i = 0; i < length; i++) {\n      result += Math.pow(x, i) * fn[i];\n    }\n\n    return result;\n  };\n\n  return CurveProcessor;\n}(Class);\n\nfunction numberSign(value) {\n  return value <= 0 ? -1 : 1;\n}\n\nexport default CurveProcessor;","map":null,"metadata":{},"sourceType":"module"}