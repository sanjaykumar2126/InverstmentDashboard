{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport Bar from './bar';\nimport CategoricalChart from '../categorical-chart';\nimport ClusterLayout from '../layout/cluster-layout';\nimport StackWrap from '../layout/stack-wrap';\nimport { BAR, OUTSIDE_END, INSIDE_END } from '../constants';\nimport anyHasZIndex from '../utils/any-has-z-index';\nimport { STRING, X, Y } from '../../common/constants';\nimport { defined, isFunction, setDefaultOptions } from '../../common';\n\nvar BarChart = function (CategoricalChart) {\n  function BarChart() {\n    CategoricalChart.apply(this, arguments);\n  }\n\n  if (CategoricalChart) BarChart.__proto__ = CategoricalChart;\n  BarChart.prototype = Object.create(CategoricalChart && CategoricalChart.prototype);\n  BarChart.prototype.constructor = BarChart;\n\n  BarChart.prototype.render = function render() {\n    CategoricalChart.prototype.render.call(this);\n    this.updateStackRange();\n  };\n\n  BarChart.prototype.pointType = function pointType() {\n    return Bar;\n  };\n\n  BarChart.prototype.clusterType = function clusterType() {\n    return ClusterLayout;\n  };\n\n  BarChart.prototype.stackType = function stackType() {\n    return StackWrap;\n  };\n\n  BarChart.prototype.stackLimits = function stackLimits(axisName, stackName) {\n    var limits = CategoricalChart.prototype.stackLimits.call(this, axisName, stackName);\n    return limits;\n  };\n\n  BarChart.prototype.createPoint = function createPoint(data, fields) {\n    var categoryIx = fields.categoryIx;\n    var category = fields.category;\n    var series = fields.series;\n    var seriesIx = fields.seriesIx;\n    var ref = this;\n    var options = ref.options;\n    var children = ref.children;\n    var isStacked = options.isStacked;\n    var value = this.pointValue(data);\n    var pointOptions = this.pointOptions(series, seriesIx);\n    var labelOptions = pointOptions.labels;\n\n    if (isStacked) {\n      if (labelOptions.position === OUTSIDE_END) {\n        labelOptions.position = INSIDE_END;\n      }\n    }\n\n    pointOptions.isStacked = isStacked;\n    var color = data.fields.color || series.color;\n\n    if (value < 0 && pointOptions.negativeColor) {\n      color = pointOptions.negativeColor;\n    }\n\n    pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    }\n\n    var pointType = this.pointType();\n    var point = new pointType(value, pointOptions);\n    point.color = color;\n    var cluster = children[categoryIx];\n\n    if (!cluster) {\n      var clusterType = this.clusterType();\n      cluster = new clusterType({\n        vertical: options.invertAxes,\n        gap: options.gap,\n        spacing: options.spacing,\n        rtl: !options.invertAxes && (this.chartService || {}).rtl\n      });\n      this.append(cluster);\n    }\n\n    if (isStacked) {\n      var stackWrap = this.getStackWrap(series, cluster);\n      stackWrap.append(point);\n    } else {\n      cluster.append(point);\n    }\n\n    return point;\n  };\n\n  BarChart.prototype.getStackWrap = function getStackWrap(series, cluster) {\n    var stack = series.stack;\n    var stackGroup = stack ? stack.group || stack : stack;\n    var wraps = cluster.children;\n    var stackWrap;\n\n    if (typeof stackGroup === STRING) {\n      for (var i = 0; i < wraps.length; i++) {\n        if (wraps[i]._stackGroup === stackGroup) {\n          stackWrap = wraps[i];\n          break;\n        }\n      }\n    } else {\n      stackWrap = wraps[0];\n    }\n\n    if (!stackWrap) {\n      var stackType = this.stackType();\n      stackWrap = new stackType({\n        vertical: !this.options.invertAxes\n      });\n      stackWrap._stackGroup = stackGroup;\n      cluster.append(stackWrap);\n    }\n\n    return stackWrap;\n  };\n\n  BarChart.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx, valueAxis) {\n    var options = this.options;\n    var categorySlot = categoryAxis.getSlot(categoryIx);\n    var startValue = valueAxis.startValue();\n\n    if (options.isStacked) {\n      var zeroSlot = valueAxis.getSlot(startValue, startValue, true);\n      var stackAxis = options.invertAxes ? X : Y;\n      categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];\n    }\n\n    return categorySlot;\n  };\n\n  BarChart.prototype.reflowCategories = function reflowCategories(categorySlots) {\n    var children = this.children;\n    var childrenLength = children.length;\n\n    for (var i = 0; i < childrenLength; i++) {\n      children[i].reflow(categorySlots[i]);\n    }\n  };\n\n  BarChart.prototype.createAnimation = function createAnimation() {\n    this._setAnimationOptions();\n\n    CategoricalChart.prototype.createAnimation.call(this);\n\n    if (anyHasZIndex(this.options.series)) {\n      this._setChildrenAnimation();\n    }\n  };\n\n  BarChart.prototype._setChildrenAnimation = function _setChildrenAnimation() {\n    var this$1 = this;\n    var points = this.points;\n\n    for (var idx = 0; idx < points.length; idx++) {\n      var point = points[idx];\n      var pointVisual = point.visual;\n\n      if (pointVisual && defined(pointVisual.options.zIndex)) {\n        point.options.animation = this$1.options.animation;\n        point.createAnimation();\n      }\n    }\n  };\n\n  BarChart.prototype._setAnimationOptions = function _setAnimationOptions() {\n    var options = this.options;\n    var animation = options.animation || {};\n    var origin;\n\n    if (options.isStacked) {\n      var valueAxis = this.seriesValueAxis(options.series[0]);\n      origin = valueAxis.getSlot(valueAxis.startValue());\n    } else {\n      origin = this.categoryAxis.getSlot(0);\n    }\n\n    animation.origin = new geom.Point(origin.x1, origin.y1);\n    animation.vertical = !options.invertAxes;\n  };\n\n  return BarChart;\n}(CategoricalChart);\n\nsetDefaultOptions(BarChart, {\n  animation: {\n    type: BAR\n  }\n});\nexport default BarChart;","map":null,"metadata":{},"sourceType":"module"}