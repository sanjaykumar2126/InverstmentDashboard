{"ast":null,"code":"import CategoricalChart from '../categorical-chart';\nimport LineChartMixin from '../mixins/line-chart-mixin';\nimport ClipAnimationMixin from '../mixins/clip-animation-mixin';\nimport RangeAreaPoint from './range-area-point';\nimport RangeAreaSegment from './range-area-segment';\nimport SplineRangeAreaSegment from './spline-range-area-segment';\nimport StepRangeAreaSegment from './step-range-area-segment';\nimport { Box } from '../../core';\nimport { ZERO } from '../constants';\nimport { MIN_VALUE, MAX_VALUE } from '../../common/constants';\nimport { isNumber } from '../../common';\nimport { deepExtend, isFunction } from '../../common';\nimport { hasValue } from '../utils';\n\nvar RangeAreaChart = function (CategoricalChart) {\n  function RangeAreaChart() {\n    CategoricalChart.apply(this, arguments);\n  }\n\n  if (CategoricalChart) RangeAreaChart.__proto__ = CategoricalChart;\n  RangeAreaChart.prototype = Object.create(CategoricalChart && CategoricalChart.prototype);\n  RangeAreaChart.prototype.constructor = RangeAreaChart;\n\n  RangeAreaChart.prototype.render = function render() {\n    CategoricalChart.prototype.render.call(this);\n    this.renderSegments();\n  };\n\n  RangeAreaChart.prototype.pointType = function pointType() {\n    return RangeAreaPoint;\n  };\n\n  RangeAreaChart.prototype.createPoint = function createPoint(data, fields) {\n    var categoryIx = fields.categoryIx;\n    var category = fields.category;\n    var series = fields.series;\n    var seriesIx = fields.seriesIx;\n    var value = data.valueFields;\n\n    if (!hasValue(value.from) && !hasValue(value.to)) {\n      if (this.seriesMissingValues(series) === ZERO) {\n        value = {\n          from: 0,\n          to: 0\n        };\n      } else {\n        return null;\n      }\n    }\n\n    var pointOptions = this.pointOptions(series, seriesIx);\n    pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n    var color = data.fields.color || series.color;\n\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    }\n\n    var point = new RangeAreaPoint(value, pointOptions);\n    point.color = color;\n    this.append(point);\n    return point;\n  };\n\n  RangeAreaChart.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {\n    var style = (currentSeries.line || {}).style;\n    var segmentType;\n\n    if (style === \"smooth\") {\n      segmentType = SplineRangeAreaSegment;\n    } else if (style === \"step\") {\n      segmentType = StepRangeAreaSegment;\n    } else {\n      segmentType = RangeAreaSegment;\n    }\n\n    return new segmentType(linePoints, currentSeries, seriesIx);\n  };\n\n  RangeAreaChart.prototype.plotRange = function plotRange(point, startValue) {\n    if (!point) {\n      return [startValue, startValue];\n    }\n\n    return [point.value.from, point.value.to];\n  };\n\n  RangeAreaChart.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {\n    var fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);\n    var toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);\n\n    if (fromSlot && toSlot) {\n      return {\n        from: fromSlot,\n        to: toSlot\n      };\n    }\n  };\n\n  RangeAreaChart.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {\n    var from = valueSlot.from;\n    var to = valueSlot.to;\n    var fromSlot, toSlot;\n\n    if (this.options.invertAxes) {\n      fromSlot = new Box(from.x1, categorySlot.y1, from.x2, categorySlot.y2);\n      toSlot = new Box(to.x1, categorySlot.y1, to.x2, categorySlot.y2);\n    } else {\n      fromSlot = new Box(categorySlot.x1, from.y1, categorySlot.x2, from.y2);\n      toSlot = new Box(categorySlot.x1, to.y1, categorySlot.x2, to.y2);\n    }\n\n    return {\n      from: fromSlot,\n      to: toSlot\n    };\n  };\n\n  RangeAreaChart.prototype.addValue = function addValue(data, fields) {\n    var valueFields = data.valueFields;\n\n    if (!isNumber(valueFields.from)) {\n      valueFields.from = valueFields.to;\n    }\n\n    if (!isNumber(valueFields.to)) {\n      valueFields.to = valueFields.from;\n    }\n\n    CategoricalChart.prototype.addValue.call(this, data, fields);\n  };\n\n  RangeAreaChart.prototype.updateRange = function updateRange(value, fields) {\n    if (value !== null && isNumber(value.from) && isNumber(value.to)) {\n      var axisName = fields.series.axis;\n      var axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n      var from = value.from;\n      var to = value.to;\n      axisRange.min = Math.min(axisRange.min, from, to);\n      axisRange.max = Math.max(axisRange.max, from, to);\n    }\n  };\n\n  RangeAreaChart.prototype.formatPointValue = function formatPointValue(point, format) {\n    var value = point.value;\n    return this.chartService.format.auto(format, value.from, value.to);\n  };\n\n  RangeAreaChart.prototype.animationPoints = function animationPoints() {\n    var points = this.points;\n    var result = [];\n\n    for (var idx = 0; idx < points.length; idx++) {\n      var point = points[idx];\n\n      if (point) {\n        result.push((point.fromPoint || {}).marker);\n        result.push((point.toPoint || {}).marker);\n      }\n    }\n\n    return result.concat(this._segments);\n  };\n\n  return RangeAreaChart;\n}(CategoricalChart);\n\ndeepExtend(RangeAreaChart.prototype, LineChartMixin, ClipAnimationMixin);\nexport default RangeAreaChart;","map":null,"metadata":{},"sourceType":"module"}