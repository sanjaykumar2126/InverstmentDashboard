{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { getPoint, withInRange, TransformToVisible } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { SplineBase } from './spline-base';\n/**\n * `SplineAreaSeries` module used to render the spline area series.\n */\n\nvar SplineAreaSeries =\n/** @class */\nfunction (_super) {\n  __extends(SplineAreaSeries, _super);\n\n  function SplineAreaSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Render the splineArea series.\n   * @return {void}\n   * @private\n   */\n\n\n  SplineAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n    var firstPoint = null;\n    var direction = '';\n    var startPoint = null;\n    var startPoint1 = null;\n    var pt1;\n    var pt2;\n    var bpt1;\n    var bpt2;\n    var controlPt1;\n    var controlPt2;\n    var points = this.filterEmptyPoints(series);\n    var pointsLength = series.points.length;\n    var point;\n    var previous;\n    var getCoordinate = series.chart.chartAreaType === 'PolarRadar' ? TransformToVisible : getPoint;\n    var origin = series.chart.chartAreaType === 'PolarRadar' ? series.points[0].yValue : Math.max(series.yAxis.visibleRange.min, 0);\n\n    for (var i = 0; i < pointsLength; i++) {\n      point = series.points[i];\n      point.symbolLocations = [];\n      point.regions = [];\n      previous = this.getPreviousIndex(points, point.index - 1, series);\n\n      if (point.visible && withInRange(points[previous], point, points[this.getNextIndex(points, point.index - 1, series)], series)) {\n        if (firstPoint) {\n          controlPt1 = series.drawPoints[previous].controlPoint1;\n          controlPt2 = series.drawPoints[previous].controlPoint2;\n          pt1 = getCoordinate(firstPoint.xValue, firstPoint.yValue, xAxis, yAxis, isInverted, series);\n          pt2 = getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);\n          bpt1 = getCoordinate(controlPt1.x, controlPt1.y, xAxis, yAxis, isInverted, series);\n          bpt2 = getCoordinate(controlPt2.x, controlPt2.y, xAxis, yAxis, isInverted, series);\n          direction = direction.concat('C ' + bpt1.x + ' ' + bpt1.y + ' ' + bpt2.x + ' ' + bpt2.y + ' ' + pt2.x + ' ' + pt2.y + ' ');\n        } else {\n          // Start point for the current path\n          startPoint = getCoordinate(point.xValue, origin, xAxis, yAxis, isInverted, series);\n          direction += 'M ' + startPoint.x + ' ' + startPoint.y + ' '; // First Point to draw the area path\n\n          startPoint1 = getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);\n          direction += 'L ' + startPoint1.x + ' ' + startPoint1.y + ' ';\n        }\n\n        this.storePointLocation(point, series, isInverted, getCoordinate);\n        firstPoint = point;\n      } else {\n        firstPoint = null;\n        point.symbolLocations = [];\n      }\n\n      if ((i + 1 < pointsLength && !series.points[i + 1].visible || i === pointsLength - 1) && pt2 && startPoint) {\n        startPoint = getCoordinate(point.xValue, origin, xAxis, yAxis, isInverted, series);\n        direction = direction.concat('L ' + startPoint.x + ' ' + startPoint.y);\n      }\n    }\n\n    this.appendLinePath(new PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, series.border.width, series.border.color, series.opacity, series.dashArray, direction), series, '');\n    this.renderMarker(series);\n  };\n  /**\n   * Get module name.\n   */\n\n\n  SplineAreaSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'SplineAreaSeries';\n  };\n  /**\n   * To destroy the spline.\n   * @return {void}\n   * @private\n   */\n\n\n  SplineAreaSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroy method calling here\n     */\n  };\n\n  return SplineAreaSeries;\n}(SplineBase);\n\nexport { SplineAreaSeries };","map":null,"metadata":{},"sourceType":"module"}