{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { registerForIntl, provideIntlService } from '@progress/kendo-react-intl';\nimport { DomEventsBuilder as ChartDomEventsBuilder, InstanceObserver } from '@progress/kendo-charts';\nimport { isServerRendering } from '@progress/kendo-react-common';\nimport { hasParent } from './utils/main';\nimport { DomEventsBuilder } from './events/dom-events-builder';\nimport { create as createEvent } from './events/chart-event-builder';\nimport { toDomEvent } from './events/dom-event';\nimport { loadTheme } from './theming/theme-service';\nimport createStore from './store/store';\nimport { optionsReducer, themeReducer, observersReducer } from './store/reducer';\nimport { toggle } from './utils/main';\nimport './defaults';\nimport { SeriesTooltip } from './tooltip/Series';\nimport { CrosshairTooltipContainer } from './tooltip/CrosshairContainer';\n/**\n * @hidden\n */\n\nvar BaseChart =\n/** @class */\nfunction (_super) {\n  __extends(BaseChart, _super);\n\n  function BaseChart(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * @hidden\n     */\n\n\n    _this.chartInstance = null;\n    _this._element = null;\n    _this.optionsStore = {};\n    _this.optionsUnsubscriber = Function.prototype;\n    _this.themeStore = {};\n    _this.themeUnsubscriber = Function.prototype;\n    _this.observersStore = {};\n    /* Chart handlers */\n\n    /**\n     * @hidden\n     */\n\n    _this.onRender = function (e) {\n      if (_this.chartInstance !== null) {\n        _this.surface = e.sender.surface;\n\n        _this.trigger('render', e);\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onLegendItemClick = function (e) {\n      if (_this.chartInstance !== null) {\n        /**\n         * In \"controlled\" state the user should toggle the series data visibility\n         */\n        if (_this.props.onLegendItemClick) {\n          _this.trigger('legendItemClick', e);\n        } else {\n          var series = _this.optionsStore.getState().series;\n\n          if (!series) {\n            return;\n          }\n\n          var payload = {};\n          var seriesIndex = e.seriesIndex,\n              pointIndex = e.pointIndex;\n          var seriesByIndex = series[seriesIndex];\n\n          if (pointIndex === undefined) {\n            payload = Object.assign({}, seriesByIndex, {\n              visible: toggle(seriesByIndex.visible)\n            });\n          } else {\n            var pv = seriesByIndex.pointVisibility = seriesByIndex.pointVisibility || [];\n            pv[pointIndex] = toggle(pv[pointIndex]);\n            payload = Object.assign({}, seriesByIndex);\n          }\n\n          _this.optionsStore.dispatch({\n            chartCollectionIdxKey: \"series_\" + seriesIndex,\n            payload: payload\n          });\n        }\n      }\n    };\n    /* Dom event handlers */\n\n    /**\n     * @hidden\n     */\n\n\n    _this.onWindowResize = function () {\n      if (_this.chartInstance !== null) {\n        _this.chartInstance.resize();\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onChartMouseLeave = function (e) {\n      var domEvent = toDomEvent(_this, e);\n\n      var isDefaultPrevented = _this.triggerDomEvent('onMouseLeave', domEvent);\n\n      if (isDefaultPrevented) {\n        e.preventDefault();\n      } else if (_this.chartInstance !== null) {\n        _this.chartInstance.hideElements();\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onChildMouseLeave = function (e) {\n      var syntheticEvent = e.syntheticEvent;\n\n      if (_this.chartInstance && !hasParent(syntheticEvent.relatedTarget, _this.element)) {\n        _this.chartInstance.hideElements();\n      }\n\n      return false;\n    };\n\n    _this.optionsStore = createStore(optionsReducer);\n    _this.themeStore = createStore(themeReducer);\n    _this.observersStore = createStore(observersReducer);\n    _this.chartObserver = new InstanceObserver(_this, {\n      render: 'onRender',\n      legendItemClick: 'onLegendItemClick'\n    });\n    _this.childrenObserver = new InstanceObserver(_this, {\n      onMouseLeave: 'onChildMouseLeave'\n    });\n    return _this;\n  }\n\n  Object.defineProperty(BaseChart.prototype, \"element\", {\n    /**\n     * @hidden\n     */\n    get: function () {\n      return this._element;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @hidden\n   */\n\n  BaseChart.prototype.componentDidMount = function () {\n    loadTheme(this.themeStore, this.instantiateCoreChart.bind(this));\n    this.optionsUnsubscriber = this.optionsStore.subscribe(this.refresh.bind(this));\n    this.themeUnsubscriber = this.themeStore.subscribe(this.refresh.bind(this));\n    window.addEventListener('resize', this.onWindowResize);\n  };\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.componentWillUnmount = function () {\n    this.optionsUnsubscriber();\n    this.themeUnsubscriber();\n\n    if (this.chartInstance !== null) {\n      this.chartInstance.destroy();\n      this.chartInstance = null;\n    }\n\n    window.removeEventListener('resize', this.onWindowResize);\n  };\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.componentDidUpdate = function (prevProps) {\n    var _a = this.props,\n        dir = _a.dir,\n        children = _a.children,\n        spreadProps = __rest(_a, [\"dir\", \"children\"]);\n\n    if (this.chartInstance !== null) {\n      var currentIntlService = provideIntlService(this);\n      var chartService = this.chartInstance.chartService;\n      var localeChanged = currentIntlService.locale !== chartService._intlService.locale;\n      var shouldUpdate = Object.entries(prevProps).filter(function (keyValue) {\n        return keyValue[0] !== 'dir' && keyValue[0] !== 'children';\n      }).some(function (keyValue) {\n        var key = keyValue[0],\n            value = keyValue[1];\n        return !(spreadProps.hasOwnProperty(key) && spreadProps[key] === value);\n      });\n\n      if (localeChanged) {\n        this.chartInstance.chartService._intlService = currentIntlService;\n        this.chartInstance.chartService.format._intlService = currentIntlService;\n\n        if (!shouldUpdate) {\n          this.chartInstance.noTransitionsRedraw();\n        }\n      }\n\n      if (shouldUpdate) {\n        this.refresh();\n      }\n\n      if (prevProps.dir !== dir) {\n        this.chartInstance.setDirection(this.getDirection(dir));\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        _b = _a.style,\n        style = _b === void 0 ? {} : _b,\n        wrapperClassName = _a.wrapperClassName,\n        wrapper = _a.wrapper,\n        children = _a.children;\n    var chartStyles = Object.assign({}, style, {\n      position: 'relative'\n    });\n    var content = React.createElement(wrapper, {\n      className: wrapperClassName,\n      style: chartStyles,\n      key: 'chartElement'\n    }, React.createElement(\"div\", {\n      onMouseLeave: this.onChartMouseLeave,\n      ref: function (el) {\n        return _this._element = el;\n      },\n      className: \"k-chart-surface\"\n    }, children));\n    return [React.createElement(SeriesTooltip, {\n      key: \"seriesTooltip\"\n    }), React.createElement(CrosshairTooltipContainer, {\n      key: \"crosshairTooltips\"\n    }), content];\n  };\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.getChildContext = function () {\n    return {\n      optionsStore: this.optionsStore,\n      observersStore: this.observersStore,\n      childrenObserver: this.childrenObserver\n    };\n  };\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.getDirection = function (dir) {\n    var _this = this;\n\n    var directionFromWindow = function () {\n      return !isServerRendering() && window.getComputedStyle(_this.element).direction;\n    };\n\n    var direction = dir !== undefined ? dir : directionFromWindow() || 'ltr';\n    return direction === 'rtl';\n  };\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.getChartOptions = function () {\n    var _a = this.props,\n        renderAs = _a.renderAs,\n        pannable = _a.pannable,\n        zoomable = _a.zoomable,\n        transitions = _a.transitions,\n        seriesColors = _a.seriesColors,\n        deriveOptionsFromParent = _a.deriveOptionsFromParent;\n    var chartOptions = Object.assign({\n      renderAs: renderAs,\n      pannable: pannable,\n      zoomable: zoomable,\n      transitions: transitions,\n      seriesColors: seriesColors\n    }, this.optionsStore.getState());\n\n    if (deriveOptionsFromParent) {\n      chartOptions = deriveOptionsFromParent(chartOptions);\n    }\n\n    return chartOptions;\n  };\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.refresh = function () {\n    if (this.chartInstance !== null) {\n      var themeOptions = this.themeStore.getState();\n      var chartOptions = this.getChartOptions();\n\n      if (this.props.onRefresh) {\n        this.props.onRefresh.call(undefined, chartOptions, themeOptions, this.chartInstance);\n      } else {\n        this.chartInstance.setOptions(chartOptions, themeOptions);\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.instantiateCoreChart = function () {\n    var _a = this.props,\n        dir = _a.dir,\n        chartConstructor = _a.chartConstructor;\n    var chartOptions = this.getChartOptions();\n    this.chartInstance = new chartConstructor(this.element, chartOptions, this.themeStore.getState(), {\n      rtl: this.getDirection(dir),\n      intlService: provideIntlService(this),\n      observer: this.chartObserver,\n      sender: this\n    });\n  };\n  /* Triggers public dom event handlers */\n\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.trigger = function (name, e) {\n    var target = this.props.getTarget();\n    var eventObject = createEvent(name, e, target);\n    var handler = 'on' + name.charAt(0).toUpperCase() + name.slice(1);\n    var observers = this.observersStore.getState();\n    var isDefaultPrevented = false;\n\n    for (var idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].trigger(name, e)) {\n        isDefaultPrevented = true;\n      }\n    }\n    /* We have not prevented the event internally, now pass it to the user */\n\n\n    if (isDefaultPrevented === false && eventObject && this.props.hasOwnProperty(handler)) {\n      this.props[handler].call(undefined, eventObject);\n      return eventObject.isDefaultPrevented && eventObject.isDefaultPrevented();\n    }\n\n    return isDefaultPrevented;\n  };\n  /* Used by (event)InstanceObserver to check the wrapper for supported events */\n\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.requiresHandlers = function (names) {\n    for (var idx = 0; idx < names.length; idx++) {\n      var name_1 = names[idx];\n      var handler = 'on' + name_1.charAt(0).toUpperCase() + name_1.slice(1);\n\n      if (this.props.hasOwnProperty(handler)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /* Triggers private dom event handlers */\n\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.prototype.triggerDomEvent = function (name, e) {\n    var observers = this.observersStore.getState();\n    var isDefaultPrevented = false;\n\n    for (var idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].trigger(name, e)) {\n        isDefaultPrevented = true;\n      }\n    }\n\n    return isDefaultPrevented;\n  };\n  /**\n   * @hidden\n   */\n\n\n  BaseChart.childContextTypes = {\n    optionsStore: PropTypes.object,\n    observersStore: PropTypes.object,\n    childrenObserver: PropTypes.object\n  };\n  /**\n   * @hidden\n   */\n\n  BaseChart.propTypes = {\n    dir: PropTypes.string,\n    renderAs: PropTypes.oneOf(['svg', 'canvas'])\n  };\n  /**\n   * @hidden\n   */\n\n  BaseChart.defaultProps = {\n    renderAs: 'svg'\n  };\n  return BaseChart;\n}(React.Component);\n\nexport { BaseChart };\nregisterForIntl(BaseChart);\nChartDomEventsBuilder.register(DomEventsBuilder);","map":null,"metadata":{},"sourceType":"module"}