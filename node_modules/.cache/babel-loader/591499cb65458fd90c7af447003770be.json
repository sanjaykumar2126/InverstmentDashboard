{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * Chart legend\n */\n\n\nimport { remove, Browser } from '@syncfusion/ej2-base';\nimport { extend } from '@syncfusion/ej2-base';\nimport { LegendOptions, BaseLegend } from '../../common/legend/legend';\nimport { textTrim, removeElement, getElement, RectOption, withInBounds } from '../../common/utils/helper';\nimport { measureText, Rect } from '@syncfusion/ej2-svg-base';\nimport { legendRender, legendClick } from '../../common/model/constants';\n/**\n * `Legend` module is used to render legend for the chart.\n */\n\nvar Legend =\n/** @class */\nfunction (_super) {\n  __extends(Legend, _super);\n\n  function Legend(chart) {\n    var _this = _super.call(this, chart) || this;\n\n    _this.library = _this;\n\n    _this.addEventListener();\n\n    return _this;\n  }\n  /**\n   * Binding events for legend module.\n   */\n\n\n  Legend.prototype.addEventListener = function () {\n    if (this.chart.isDestroyed) {\n      return;\n    }\n\n    this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);\n    this.chart.on('click', this.click, this);\n    this.chart.on(Browser.touchEndEvent, this.mouseEnd, this);\n  };\n  /**\n   * UnBinding events for legend module.\n   */\n\n\n  Legend.prototype.removeEventListener = function () {\n    if (this.chart.isDestroyed) {\n      return;\n    }\n\n    this.chart.off(Browser.touchMoveEvent, this.mouseMove);\n    this.chart.off('click', this.click);\n    this.chart.off(Browser.touchEndEvent, this.mouseEnd);\n  };\n  /**\n   * To handle mosue move for legend module\n   */\n\n\n  Legend.prototype.mouseMove = function (e) {\n    if (this.chart.legendSettings.visible && !this.chart.isTouch) {\n      this.move(e);\n    }\n  };\n  /**\n   * To handle mosue end for legend module\n   */\n\n\n  Legend.prototype.mouseEnd = function (e) {\n    if (this.chart.legendSettings.visible && this.chart.isTouch) {\n      this.move(e);\n    }\n  };\n  /**\n   * Get the legend options.\n   * @return {void}\n   * @private\n   */\n\n\n  Legend.prototype.getLegendOptions = function (visibleSeriesCollection, chart) {\n    this.legendCollections = [];\n    var seriesType;\n\n    for (var _i = 0, visibleSeriesCollection_1 = visibleSeriesCollection; _i < visibleSeriesCollection_1.length; _i++) {\n      var series = visibleSeriesCollection_1[_i];\n\n      if (series.category !== 'Indicator') {\n        seriesType = chart.chartAreaType === 'PolarRadar' ? series.drawType : series.type;\n        this.legendCollections.push(new LegendOptions(series.name, series.interior, series.legendShape, series.visible, seriesType, series.marker.shape, series.marker.visible));\n      }\n    }\n  };\n  /** @private */\n\n\n  Legend.prototype.getLegendBounds = function (availableSize, legendBounds, legend) {\n    var padding = legend.padding;\n    var extraHeight = 0;\n    var extraWidth = 0;\n\n    if (!this.isVertical) {\n      extraHeight = !legend.height ? availableSize.height / 100 * 5 : 0;\n    } else {\n      extraWidth = !legend.width ? availableSize.width / 100 * 5 : 0;\n    }\n\n    legendBounds.height += extraHeight;\n    legendBounds.width += extraWidth;\n    var shapeHeight = legend.shapeHeight;\n    var shapeWidth = legend.shapeWidth;\n    var shapePadding = legend.shapePadding;\n    var maximumWidth = 0;\n    var rowWidth = 0;\n    var legendWidth = 0;\n    var columnHeight = 0;\n    var rowCount = 0;\n    var legendEventArgs;\n    this.maxItemHeight = Math.max(measureText('MeasureText', legend.textStyle).height, legend.shapeHeight);\n    var render = false;\n\n    for (var _i = 0, _a = this.legendCollections; _i < _a.length; _i++) {\n      var legendOption = _a[_i];\n      legendEventArgs = {\n        fill: legendOption.fill,\n        text: legendOption.text,\n        shape: legendOption.shape,\n        markerShape: legendOption.markerShape,\n        name: legendRender,\n        cancel: false\n      };\n      this.chart.trigger(legendRender, legendEventArgs);\n      legendOption.render = !legendEventArgs.cancel;\n      legendOption.text = legendEventArgs.text;\n      legendOption.fill = legendEventArgs.fill;\n      legendOption.shape = legendEventArgs.shape;\n      legendOption.markerShape = legendEventArgs.markerShape;\n      legendOption.textSize = measureText(legendOption.text, legend.textStyle);\n\n      if (legendOption.render && legendOption.text !== '') {\n        render = true;\n        legendWidth = shapeWidth + shapePadding + legendOption.textSize.width + padding;\n        rowWidth = rowWidth + legendWidth;\n\n        if (legendBounds.width < padding + rowWidth || this.isVertical) {\n          maximumWidth = Math.max(maximumWidth, rowWidth + padding - (this.isVertical ? 0 : legendWidth));\n\n          if (rowCount === 0 && legendWidth !== rowWidth) {\n            rowCount = 1;\n          }\n\n          rowWidth = this.isVertical ? 0 : legendWidth;\n          rowCount++;\n          columnHeight = rowCount * (this.maxItemHeight + padding) + padding;\n        }\n      }\n    }\n\n    columnHeight = Math.max(columnHeight, this.maxItemHeight + padding + padding);\n    this.isPaging = legendBounds.height < columnHeight;\n    this.totalPages = rowCount;\n\n    if (render) {\n      this.setBounds(Math.max(rowWidth + padding, maximumWidth), columnHeight, legend, legendBounds);\n    } else {\n      this.setBounds(0, 0, legend, legendBounds);\n    }\n  };\n  /** @private */\n\n\n  Legend.prototype.getRenderPoint = function (legendOption, start, textPadding, prevLegend, rect, count, firstLegend) {\n    var padding = this.legend.padding;\n    var previousBound = prevLegend.location.x + textPadding + prevLegend.textSize.width;\n\n    if (previousBound + (legendOption.textSize.width + textPadding) > rect.x + rect.width + this.legend.shapeWidth / 2 || this.isVertical) {\n      legendOption.location.x = start.x;\n      legendOption.location.y = count === firstLegend ? prevLegend.location.y : prevLegend.location.y + this.maxItemHeight + padding;\n    } else {\n      legendOption.location.x = count === firstLegend ? prevLegend.location.x : previousBound;\n      legendOption.location.y = prevLegend.location.y;\n    }\n\n    var availwidth = this.legendBounds.x + this.legendBounds.width - (legendOption.location.x + textPadding - this.legend.shapeWidth / 2);\n    legendOption.text = textTrim(+availwidth.toFixed(4), legendOption.text, this.legend.textStyle);\n  };\n  /** @private */\n\n\n  Legend.prototype.LegendClick = function (seriesIndex) {\n    var chart = this.chart;\n    var series = chart.visibleSeries[seriesIndex];\n    var legend = this.legendCollections[seriesIndex];\n    var legendClickArgs = {\n      legendText: legend.text,\n      legendShape: legend.shape,\n      chart: chart,\n      series: series,\n      name: legendClick,\n      cancel: false\n    };\n    this.chart.trigger(legendClick, legendClickArgs);\n    series.legendShape = legendClickArgs.legendShape;\n\n    if (series.fill !== null) {\n      chart.visibleSeries[seriesIndex].interior = series.fill;\n    }\n\n    var selectedDataIndexes = [];\n\n    if (chart.selectionModule) {\n      selectedDataIndexes = extend([], chart.selectionModule.selectedDataIndexes, null, true);\n    }\n\n    if (chart.legendSettings.toggleVisibility) {\n      if (!series.visible) {\n        series.visible = true;\n      } else {\n        series.visible = false;\n      }\n\n      legend.visible = series.visible;\n\n      if (chart.svgObject.childNodes.length > 0 && !chart.enableAnimation && !chart.enableCanvas) {\n        while (chart.svgObject.lastChild) {\n          chart.svgObject.removeChild(chart.svgObject.lastChild);\n        }\n\n        remove(chart.svgObject);\n      }\n\n      chart.animateSeries = false;\n      chart.redraw = chart.enableAnimation;\n      removeElement(getElement(chart.element.id + '_Secondary_Element').querySelectorAll('.ejSVGTooltip')[0]);\n      this.redrawSeriesElements(series, chart);\n      chart.removeSvg();\n      chart.refreshAxis();\n      series.refreshAxisLabel();\n      this.refreshSeries(chart.visibleSeries);\n      chart.refreshBound();\n      chart.trigger('loaded', {\n        chart: chart\n      });\n\n      if (selectedDataIndexes.length > 0) {\n        chart.selectionModule.selectedDataIndexes = selectedDataIndexes;\n        chart.selectionModule.redrawSelection(chart, chart.selectionMode);\n      }\n\n      chart.redraw = false;\n    } else if (chart.selectionModule) {\n      chart.selectionModule.legendSelection(chart, seriesIndex);\n    }\n  };\n\n  Legend.prototype.redrawSeriesElements = function (series, chart) {\n    if (!chart.redraw) {\n      return null;\n    }\n\n    removeElement(chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections');\n  };\n\n  Legend.prototype.refreshSeries = function (seriesCollection) {\n    for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {\n      var series = seriesCollection_1[_i];\n      series.position = undefined;\n    }\n  };\n  /**\n   * To show the tooltip for the trimmed text in legend.\n   * @return {void}\n   */\n\n\n  Legend.prototype.click = function (event) {\n    var _this = this;\n\n    if (!this.chart.legendSettings.visible) {\n      return;\n    }\n\n    var pageX = event.pageX;\n    var pageY = event.pageY;\n    var legendRegion = [];\n    var targetId = event.target.id;\n    var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_', this.legendID + '_shape_'];\n    var seriesIndex;\n\n    for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {\n      var id = legendItemsId_1[_i];\n\n      if (targetId.indexOf(id) > -1) {\n        seriesIndex = parseInt(targetId.split(id)[1], 10);\n        this.LegendClick(seriesIndex);\n        break;\n      }\n    }\n\n    if (targetId.indexOf(this.legendID + '_pageup') > -1) {\n      this.changePage(event, true);\n    } else if (targetId.indexOf(this.legendID + '_pagedown') > -1) {\n      this.changePage(event, false);\n    }\n\n    if (this.chart.enableCanvas && this.pagingRegions.length) {\n      this.checkWithinBounds(pageX, pageY);\n    }\n\n    legendRegion = this.legendRegions.filter(function (region) {\n      return withInBounds(pageX, pageY + (_this.isPaging ? (_this.currentPageNumber - 1) * _this.translatePage(null, 1, 2) : 0), region.rect);\n    });\n\n    if (legendRegion.length && this.chart.enableCanvas) {\n      this.LegendClick(legendRegion[0].index);\n    }\n  };\n  /**\n   * To check click position is within legend bounds\n   */\n\n\n  Legend.prototype.checkWithinBounds = function (pageX, pageY) {\n    var cRender = this.chart.renderer;\n    var bounds = this.legendBounds;\n    var borderWidth = this.chart.legendSettings.border.width;\n    var canvasRect = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);\n    canvasRect.x = canvasRect.x - borderWidth / 2;\n    canvasRect.y = canvasRect.y - borderWidth / 2;\n    canvasRect.width = canvasRect.width + borderWidth;\n    canvasRect.height = canvasRect.height + borderWidth;\n\n    if (withInBounds(pageX, pageY, this.pagingRegions[0])) {\n      // pagedown calculations are performing here\n      if (--this.currentPageNumber > 0) {\n        this.legendRegions = [];\n        cRender.clearRect(canvasRect);\n        cRender.canvasClip(new RectOption('legendClipPath', 'transparent', {\n          width: 0,\n          color: ''\n        }, null, canvasRect));\n        this.renderLegend(this.chart, this.legend, bounds);\n        cRender.canvasRestore();\n      } else {\n        ++this.currentPageNumber;\n      }\n\n      return null;\n    }\n\n    if (withInBounds(pageX, pageY, this.pagingRegions[1])) {\n      // pageUp calculations are performing here\n      if (++this.currentPageNumber > 0 && this.currentPageNumber <= this.totalNoOfPages) {\n        this.legendRegions = [];\n        cRender.clearRect(canvasRect);\n        cRender.canvasClip(new RectOption('legendClipPath', 'transpaent', {\n          width: 0,\n          color: ''\n        }, null, canvasRect));\n        this.renderLegend(this.chart, this.legend, bounds);\n        cRender.canvasRestore();\n      } else {\n        --this.currentPageNumber;\n      }\n\n      return null;\n    }\n  };\n  /**\n   * Get module name\n   */\n\n\n  Legend.prototype.getModuleName = function () {\n    return 'Legend';\n  };\n  /**\n   * To destroy the Legend.\n   * @return {void}\n   * @private\n   */\n\n\n  Legend.prototype.destroy = function (chart) {\n    this.removeEventListener();\n  };\n\n  return Legend;\n}(BaseLegend);\n\nexport { Legend };","map":null,"metadata":{},"sourceType":"module"}