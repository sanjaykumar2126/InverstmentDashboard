{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Category } from '../axis/category-axis';\nimport { triggerLabelRender } from '../../common/utils/helper';\nimport { withIn, firstToLowerCase } from '../../common/utils/helper';\nimport { extend, getValue } from '@syncfusion/ej2-base';\n/**\n * Category module is used to render category axis.\n */\n\nvar DateTimeCategory =\n/** @class */\nfunction (_super) {\n  __extends(DateTimeCategory, _super);\n  /**\n   * Constructor for the category module.\n   * @private\n   */\n\n\n  function DateTimeCategory(chart) {\n    return _super.call(this, chart) || this;\n  }\n  /**\n   * The function to calculate the range and labels for the axis.\n   * @return {void}\n   * @private\n   */\n\n\n  DateTimeCategory.prototype.calculateRangeAndInterval = function (size, axis) {\n    this.axisSize = size;\n    this.calculateRange(axis, size);\n    this.getActualRange(axis, size);\n    this.applyRangePadding(axis, size);\n    this.calculateVisibleLabels(axis);\n  };\n  /**\n   * Calculate label for the axis.\n   * @private\n   */\n\n\n  DateTimeCategory.prototype.calculateVisibleLabels = function (axis) {\n    /*! Generate axis labels */\n    axis.visibleLabels = [];\n    var labelStyle;\n    var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n\n    if (axis.intervalType === 'Auto') {\n      this.calculateDateTimeNiceInterval(axis, this.axisSize, parseInt(axis.labels[0], 10), parseInt(axis.labels[axis.labels.length - 1], 10));\n    } else {\n      axis.actualIntervalType = axis.intervalType;\n    }\n\n    axis.format = this.chart.intl.getDateFormat({\n      format: axis.labelFormat,\n      type: firstToLowerCase(axis.skeletonType),\n      skeleton: this.getSkeleton(axis, null, null)\n    });\n\n    for (var i = 0; i < axis.labels.length; i++) {\n      labelStyle = extend({}, getValue('properties', axis.labelStyle), null, true);\n\n      if (!this.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - 1], axis.actualIntervalType, i) || axis.isIndexed) {\n        if (withIn(i - padding, axis.visibleRange)) {\n          triggerLabelRender(this.chart, i, axis.isIndexed ? this.getIndexedAxisLabel(axis.labels[i], axis.format) : axis.format(new Date(axis.labels.map(Number)[i])), labelStyle, axis);\n        }\n      }\n    }\n\n    if (axis.getMaxLabelWidth) {\n      axis.getMaxLabelWidth(this.chart);\n    }\n  };\n  /**\n   * To get the Indexed axis label text with axis format for DateTimeCategory axis\n   * @param value\n   * @param format\n   */\n\n\n  DateTimeCategory.prototype.getIndexedAxisLabel = function (value, format) {\n    var texts = value.split(',');\n\n    for (var i = 0; i < texts.length; i++) {\n      texts[i] = format(new Date(parseInt(texts[i], 10)));\n    }\n\n    return texts.join(', ');\n  };\n  /**\n   * get same interval\n   */\n\n\n  DateTimeCategory.prototype.sameInterval = function (currentDate, previousDate, type, index) {\n    var sameValue;\n\n    if (index === 0) {\n      sameValue = false;\n    } else {\n      switch (type) {\n        case 'Years':\n          sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear();\n          break;\n\n        case 'Months':\n          sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear() && new Date(currentDate).getMonth() === new Date(previousDate).getMonth();\n          break;\n\n        case 'Days':\n          sameValue = Math.abs(currentDate - previousDate) < 24 * 60 * 60 * 1000 && new Date(currentDate).getDay() === new Date(previousDate).getDay();\n          break;\n\n        case 'Hours':\n          sameValue = Math.abs(currentDate - previousDate) < 60 * 60 * 1000 && new Date(currentDate).getDay() === new Date(previousDate).getDay();\n          break;\n\n        case 'Minutes':\n          sameValue = Math.abs(currentDate - previousDate) < 60 * 1000 && new Date(currentDate).getMinutes() === new Date(previousDate).getMinutes();\n          break;\n\n        case 'Seconds':\n          sameValue = Math.abs(currentDate - previousDate) < 1000 && new Date(currentDate).getDay() === new Date(previousDate).getDay();\n          break;\n      }\n    }\n\n    return sameValue;\n  };\n  /**\n   * Get module name\n   */\n\n\n  DateTimeCategory.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'DateTimeCategory';\n  };\n  /**\n   * To destroy the category axis.\n   * @return {void}\n   * @private\n   */\n\n\n  DateTimeCategory.prototype.destroy = function (chart) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return DateTimeCategory;\n}(Category);\n\nexport { DateTimeCategory };","map":null,"metadata":{},"sourceType":"module"}