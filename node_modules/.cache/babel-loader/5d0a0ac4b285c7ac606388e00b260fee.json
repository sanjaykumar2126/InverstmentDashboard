{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport limitCoordinate from './utils/limit-coordinate';\nimport { DEFAULT_PRECISION, BLACK, X, Y } from '../common/constants';\nimport { deepExtend, defined, inArray, limitValue, round, setDefaultOptions } from '../common';\nvar DEFAULT_MAJOR_UNIT = 10;\n\nvar LogarithmicAxis = function (Axis) {\n  function LogarithmicAxis(seriesMin, seriesMax, options, chartService) {\n    var axisOptions = deepExtend({\n      majorUnit: DEFAULT_MAJOR_UNIT,\n      min: seriesMin,\n      max: seriesMax\n    }, options);\n    var base = axisOptions.majorUnit;\n    var autoMax = autoAxisMax(seriesMax, base);\n    var autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions);\n    var range = initRange(autoMin, autoMax, axisOptions, options);\n    axisOptions.max = range.max;\n    axisOptions.min = range.min;\n    axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n    Axis.call(this, axisOptions, chartService);\n    this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n    this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n    this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n    this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n    this.seriesMin = seriesMin;\n    this.seriesMax = seriesMax;\n    this.createLabels();\n  }\n\n  if (Axis) LogarithmicAxis.__proto__ = Axis;\n  LogarithmicAxis.prototype = Object.create(Axis && Axis.prototype);\n  LogarithmicAxis.prototype.constructor = LogarithmicAxis;\n\n  LogarithmicAxis.prototype.clone = function clone() {\n    return new LogarithmicAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);\n  };\n\n  LogarithmicAxis.prototype.startValue = function startValue() {\n    return this.options.min;\n  };\n\n  LogarithmicAxis.prototype.getSlot = function getSlot(a, b, limit) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var reverse = options.reverse;\n    var vertical = options.vertical;\n    var base = options.majorUnit;\n    var valueAxis = vertical ? Y : X;\n    var lineBox = this.lineBox();\n    var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var dir = reverse ? -1 : 1;\n    var step = dir * (lineSize / (logMax - logMin));\n    var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n    var start = a;\n    var end = b;\n\n    if (!defined(start)) {\n      start = end || 1;\n    }\n\n    if (!defined(end)) {\n      end = start || 1;\n    }\n\n    if (start <= 0 || end <= 0) {\n      return null;\n    }\n\n    if (limit) {\n      start = Math.max(Math.min(start, options.max), options.min);\n      end = Math.max(Math.min(end, options.max), options.min);\n    }\n\n    start = log(start, base);\n    end = log(end, base);\n    var p1, p2;\n\n    if (vertical) {\n      p1 = logMax - Math.max(start, end);\n      p2 = logMax - Math.min(start, end);\n    } else {\n      p1 = Math.min(start, end) - logMin;\n      p2 = Math.max(start, end) - logMin;\n    }\n\n    slotBox[valueAxis + 1] = limitCoordinate(lineStart + step * (reverse ? p2 : p1));\n    slotBox[valueAxis + 2] = limitCoordinate(lineStart + step * (reverse ? p1 : p2));\n    return slotBox;\n  };\n\n  LogarithmicAxis.prototype.getValue = function getValue(point) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var reverse = options.reverse;\n    var vertical = options.vertical;\n    var base = options.majorUnit;\n    var lineBox = this.lineBox();\n    var dir = vertical === reverse ? 1 : -1;\n    var startEdge = dir === 1 ? 1 : 2;\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var step = (logMax - logMin) / lineSize;\n    var valueAxis = vertical ? Y : X;\n    var lineStart = lineBox[valueAxis + startEdge];\n    var offset = dir * (point[valueAxis] - lineStart);\n    var valueOffset = offset * step;\n\n    if (offset < 0 || offset > lineSize) {\n      return null;\n    }\n\n    var value = logMin + valueOffset;\n    return round(Math.pow(base, value), DEFAULT_PRECISION);\n  };\n\n  LogarithmicAxis.prototype.range = function range() {\n    var options = this.options;\n    return {\n      min: options.min,\n      max: options.max\n    };\n  };\n\n  LogarithmicAxis.prototype.scaleRange = function scaleRange(delta) {\n    var base = this.options.majorUnit;\n    var offset = -delta;\n    return {\n      min: Math.pow(base, this.logMin - offset),\n      max: Math.pow(base, this.logMax + offset)\n    };\n  };\n\n  LogarithmicAxis.prototype.translateRange = function translateRange(delta) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var reverse = options.reverse;\n    var vertical = options.vertical;\n    var base = options.majorUnit;\n    var lineBox = this.lineBox();\n    var size = vertical ? lineBox.height() : lineBox.width();\n    var scale = size / (logMax - logMin);\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n\n    if ((vertical || reverse) && !(vertical && reverse)) {\n      offset = -offset;\n    }\n\n    return {\n      min: Math.pow(base, logMin + offset),\n      max: Math.pow(base, logMax + offset),\n      offset: offset\n    };\n  };\n\n  LogarithmicAxis.prototype.labelsCount = function labelsCount() {\n    var floorMax = Math.floor(this.logMax);\n    var count = Math.floor(floorMax - this.logMin) + 1;\n    return count;\n  };\n\n  LogarithmicAxis.prototype.getMajorTickPositions = function getMajorTickPositions() {\n    var ticks = [];\n    this.traverseMajorTicksPositions(function (position) {\n      ticks.push(position);\n    }, {\n      step: 1,\n      skip: 0\n    });\n    return ticks;\n  };\n\n  LogarithmicAxis.prototype.createTicks = function createTicks(lineGroup) {\n    var options = this.options;\n    var majorTicks = options.majorTicks;\n    var minorTicks = options.minorTicks;\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var lineBox = this.lineBox();\n    var ticks = [];\n    var tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: vertical\n    };\n\n    function render(tickPosition, tickOptions) {\n      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n      tickLineOptions.position = tickPosition;\n      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n    }\n\n    if (majorTicks.visible) {\n      this.traverseMajorTicksPositions(render, majorTicks);\n    }\n\n    if (minorTicks.visible) {\n      this.traverseMinorTicksPositions(render, minorTicks);\n    }\n\n    return ticks;\n  };\n\n  LogarithmicAxis.prototype.createGridLines = function createGridLines(altAxis) {\n    var options = this.options;\n    var minorGridLines = options.minorGridLines;\n    var majorGridLines = options.majorGridLines;\n    var vertical = options.vertical;\n    var lineBox = altAxis.lineBox();\n    var lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    var majorTicks = [];\n    var container = this.gridLinesVisual();\n\n    function render(tickPosition, gridLine) {\n      if (!inArray(tickPosition, majorTicks)) {\n        lineOptions.position = tickPosition;\n        container.append(createAxisGridLine(lineOptions, gridLine));\n        majorTicks.push(tickPosition);\n      }\n    }\n\n    if (majorGridLines.visible) {\n      this.traverseMajorTicksPositions(render, majorGridLines);\n    }\n\n    if (minorGridLines.visible) {\n      this.traverseMinorTicksPositions(render, minorGridLines);\n    }\n\n    return container.children;\n  };\n\n  LogarithmicAxis.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions(callback, tickOptions) {\n    var ref = this._lineOptions();\n\n    var lineStart = ref.lineStart;\n    var step = ref.step;\n    var ref$1 = this;\n    var logMin = ref$1.logMin;\n    var logMax = ref$1.logMax;\n\n    for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n      var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n      callback(position, tickOptions);\n    }\n  };\n\n  LogarithmicAxis.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions(callback, tickOptions) {\n    var this$1 = this;\n    var ref = this.options;\n    var min = ref.min;\n    var max = ref.max;\n    var minorUnit = ref.minorUnit;\n    var base = ref.majorUnit;\n\n    var ref$1 = this._lineOptions();\n\n    var lineStart = ref$1.lineStart;\n    var step = ref$1.step;\n    var ref$2 = this;\n    var logMin = ref$2.logMin;\n    var logMax = ref$2.logMax;\n    var start = Math.floor(logMin);\n\n    for (var power = start; power < logMax; power++) {\n      var minorOptions = this$1._minorIntervalOptions(power);\n\n      for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n        var value = minorOptions.value + idx * minorOptions.minorStep;\n\n        if (value > max) {\n          break;\n        }\n\n        if (value >= min) {\n          var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n          callback(position, tickOptions);\n        }\n      }\n    }\n  };\n\n  LogarithmicAxis.prototype.createAxisLabel = function createAxisLabel(index, labelOptions) {\n    var power = Math.ceil(this.logMin + index);\n    var value = Math.pow(this.options.majorUnit, power);\n    var text = this.axisLabelText(value, null, labelOptions);\n    return new AxisLabel(value, text, index, null, labelOptions);\n  };\n\n  LogarithmicAxis.prototype.shouldRenderNote = function shouldRenderNote(value) {\n    var range = this.range();\n    return range.min <= value && value <= range.max;\n  };\n\n  LogarithmicAxis.prototype.pan = function pan(delta) {\n    var range = this.translateRange(delta);\n    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n  };\n\n  LogarithmicAxis.prototype.pointsRange = function pointsRange(start, end) {\n    var startValue = this.getValue(start);\n    var endValue = this.getValue(end);\n    var min = Math.min(startValue, endValue);\n    var max = Math.max(startValue, endValue);\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  LogarithmicAxis.prototype.zoomRange = function zoomRange(delta) {\n    var ref = this;\n    var options = ref.options;\n    var totalMin = ref.totalMin;\n    var totalMax = ref.totalMax;\n    var newRange = this.scaleRange(delta);\n    var min = limitValue(newRange.min, totalMin, totalMax);\n    var max = limitValue(newRange.max, totalMin, totalMax);\n    var base = options.majorUnit;\n    var acceptOptionsRange = max > min && options.min && options.max && round(log(options.max, base) - log(options.min, base), DEFAULT_PRECISION) < 1;\n    var acceptNewRange = !(options.min === totalMin && options.max === totalMax) && round(log(max, base) - log(min, base), DEFAULT_PRECISION) >= 1;\n\n    if (acceptOptionsRange || acceptNewRange) {\n      return {\n        min: min,\n        max: max\n      };\n    }\n  };\n\n  LogarithmicAxis.prototype._minorIntervalOptions = function _minorIntervalOptions(power) {\n    var ref = this.options;\n    var minorUnit = ref.minorUnit;\n    var base = ref.majorUnit;\n    var value = Math.pow(base, power);\n    var nextValue = Math.pow(base, power + 1);\n    var difference = nextValue - value;\n    var minorStep = difference / minorUnit;\n    return {\n      value: value,\n      minorStep: minorStep\n    };\n  };\n\n  LogarithmicAxis.prototype._lineOptions = function _lineOptions() {\n    var ref = this.options;\n    var reverse = ref.reverse;\n    var vertical = ref.vertical;\n    var valueAxis = vertical ? Y : X;\n    var lineBox = this.lineBox();\n    var dir = vertical === reverse ? 1 : -1;\n    var startEdge = dir === 1 ? 1 : 2;\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var step = dir * (lineSize / (this.logMax - this.logMin));\n    var lineStart = lineBox[valueAxis + startEdge];\n    return {\n      step: step,\n      lineStart: lineStart,\n      lineBox: lineBox\n    };\n  };\n\n  return LogarithmicAxis;\n}(Axis);\n\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n  var min = axisOptions.min;\n  var max = axisOptions.max;\n\n  if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n    throwNegativeValuesError();\n  }\n\n  if (!defined(options.max)) {\n    max = autoMax;\n  } else if (options.max <= 0) {\n    throwNegativeValuesError();\n  }\n\n  if (!defined(options.min)) {\n    min = autoMin;\n  } else if (options.min <= 0) {\n    throwNegativeValuesError();\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction autoAxisMin(min, max, options) {\n  var base = options.majorUnit;\n  var autoMin = min;\n\n  if (min <= 0) {\n    autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n  } else if (!options.narrowRange) {\n    autoMin = Math.pow(base, Math.floor(log(min, base)));\n  }\n\n  return autoMin;\n}\n\nfunction autoAxisMax(max, base) {\n  var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n  var autoMax;\n\n  if (max <= 0) {\n    autoMax = base;\n  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n    autoMax = Math.pow(base, log(max, base) + 0.2);\n  } else {\n    autoMax = Math.pow(base, Math.ceil(log(max, base)));\n  }\n\n  return autoMax;\n}\n\nfunction throwNegativeValuesError() {\n  throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\n\nfunction log(y, x) {\n  return Math.log(y) / Math.log(x);\n}\n\nsetDefaultOptions(LogarithmicAxis, {\n  type: \"log\",\n  majorUnit: DEFAULT_MAJOR_UNIT,\n  minorUnit: 1,\n  axisCrossingValue: 1,\n  vertical: true,\n  majorGridLines: {\n    visible: true,\n    width: 1,\n    color: BLACK\n  },\n  zIndex: 1,\n  _deferLabels: true\n});\nexport default LogarithmicAxis;","map":null,"metadata":{},"sourceType":"module"}