{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\nimport { BLACK, DEFAULT_PRECISION, COORD_PRECISION, X, Y } from '../common/constants';\nimport { deepExtend, defined, limitValue, round, setDefaultOptions } from '../common';\nimport autoMajorUnit from './utils/auto-major-unit';\nimport autoAxisMin from './utils/auto-axis-min';\nimport autoAxisMax from './utils/auto-axis-max';\nimport floor from './utils/floor';\nimport ceil from './utils/ceil';\nimport limitCoordinate from './utils/limit-coordinate';\nvar MIN_VALUE_RANGE = Math.pow(10, -DEFAULT_PRECISION + 1);\n\nvar NumericAxis = function (Axis) {\n  function NumericAxis(seriesMin, seriesMax, options, chartService) {\n    Axis.call(this, Object.assign({}, options, {\n      seriesMin: seriesMin,\n      seriesMax: seriesMax\n    }), chartService);\n  }\n\n  if (Axis) NumericAxis.__proto__ = Axis;\n  NumericAxis.prototype = Object.create(Axis && Axis.prototype);\n  NumericAxis.prototype.constructor = NumericAxis;\n\n  NumericAxis.prototype.initUserOptions = function initUserOptions(options) {\n    var autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);\n    this.totalOptions = totalAxisOptions(autoOptions, options);\n    return axisOptions(autoOptions, options);\n  };\n\n  NumericAxis.prototype.initFields = function initFields() {\n    this.totalMin = this.totalOptions.min;\n    this.totalMax = this.totalOptions.max;\n    this.totalMajorUnit = this.totalOptions.majorUnit;\n    this.seriesMin = this.options.seriesMin;\n    this.seriesMax = this.options.seriesMax;\n  };\n\n  NumericAxis.prototype.clone = function clone() {\n    return new NumericAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);\n  };\n\n  NumericAxis.prototype.startValue = function startValue() {\n    return 0;\n  };\n\n  NumericAxis.prototype.range = function range() {\n    var options = this.options;\n    return {\n      min: options.min,\n      max: options.max\n    };\n  };\n\n  NumericAxis.prototype.getDivisions = function getDivisions(stepValue) {\n    if (stepValue === 0) {\n      return 1;\n    }\n\n    var options = this.options;\n    var range = options.max - options.min;\n    return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;\n  };\n\n  NumericAxis.prototype.getTickPositions = function getTickPositions(unit, skipUnit) {\n    var options = this.options;\n    var vertical = options.vertical;\n    var reverse = options.reverse;\n    var lineBox = this.lineBox();\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var range = options.max - options.min;\n    var scale = lineSize / range;\n    var step = unit * scale;\n    var divisions = this.getDivisions(unit);\n    var dir = (vertical ? -1 : 1) * (reverse ? -1 : 1);\n    var startEdge = dir === 1 ? 1 : 2;\n    var positions = [];\n    var pos = lineBox[(vertical ? Y : X) + startEdge];\n    var skipStep = 0;\n\n    if (skipUnit) {\n      skipStep = skipUnit / unit;\n    }\n\n    for (var idx = 0; idx < divisions; idx++) {\n      if (idx % skipStep !== 0) {\n        positions.push(round(pos, COORD_PRECISION));\n      }\n\n      pos = pos + step * dir;\n    }\n\n    return positions;\n  };\n\n  NumericAxis.prototype.getMajorTickPositions = function getMajorTickPositions() {\n    return this.getTickPositions(this.options.majorUnit);\n  };\n\n  NumericAxis.prototype.getMinorTickPositions = function getMinorTickPositions() {\n    return this.getTickPositions(this.options.minorUnit);\n  };\n\n  NumericAxis.prototype.getSlot = function getSlot(a, b, limit) {\n    if (limit === void 0) limit = false;\n    var options = this.options;\n    var vertical = options.vertical;\n    var reverse = options.reverse;\n    var valueAxis = vertical ? Y : X;\n    var lineBox = this.lineBox();\n    var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var dir = reverse ? -1 : 1;\n    var step = dir * (lineSize / (options.max - options.min));\n    var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n    var start = a;\n    var end = b;\n\n    if (!defined(start)) {\n      start = end || 0;\n    }\n\n    if (!defined(end)) {\n      end = start || 0;\n    }\n\n    if (limit) {\n      start = Math.max(Math.min(start, options.max), options.min);\n      end = Math.max(Math.min(end, options.max), options.min);\n    }\n\n    var p1, p2;\n\n    if (vertical) {\n      p1 = options.max - Math.max(start, end);\n      p2 = options.max - Math.min(start, end);\n    } else {\n      p1 = Math.min(start, end) - options.min;\n      p2 = Math.max(start, end) - options.min;\n    }\n\n    slotBox[valueAxis + 1] = limitCoordinate(lineStart + step * (reverse ? p2 : p1));\n    slotBox[valueAxis + 2] = limitCoordinate(lineStart + step * (reverse ? p1 : p2));\n    return slotBox;\n  };\n\n  NumericAxis.prototype.getValue = function getValue(point) {\n    var options = this.options;\n    var vertical = options.vertical;\n    var reverse = options.reverse;\n    var max = Number(options.max);\n    var min = Number(options.min);\n    var valueAxis = vertical ? Y : X;\n    var lineBox = this.lineBox();\n    var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var dir = reverse ? -1 : 1;\n    var offset = dir * (point[valueAxis] - lineStart);\n    var step = (max - min) / lineSize;\n    var valueOffset = offset * step;\n\n    if (offset < 0 || offset > lineSize) {\n      return null;\n    }\n\n    var value = vertical ? max - valueOffset : min + valueOffset;\n    return round(value, DEFAULT_PRECISION);\n  };\n\n  NumericAxis.prototype.translateRange = function translateRange(delta) {\n    var options = this.options;\n    var vertical = options.vertical;\n    var reverse = options.reverse;\n    var max = options.max;\n    var min = options.min;\n    var lineBox = this.lineBox();\n    var size = vertical ? lineBox.height() : lineBox.width();\n    var range = max - min;\n    var scale = size / range;\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n\n    if ((vertical || reverse) && !(vertical && reverse)) {\n      offset = -offset;\n    }\n\n    return {\n      min: min + offset,\n      max: max + offset,\n      offset: offset\n    };\n  };\n\n  NumericAxis.prototype.scaleRange = function scaleRange(delta) {\n    var options = this.options;\n    var offset = -delta * options.majorUnit;\n    return {\n      min: options.min - offset,\n      max: options.max + offset\n    };\n  };\n\n  NumericAxis.prototype.labelsCount = function labelsCount() {\n    return this.getDivisions(this.options.majorUnit);\n  };\n\n  NumericAxis.prototype.createAxisLabel = function createAxisLabel(index, labelOptions) {\n    var options = this.options;\n    var value = round(options.min + index * options.majorUnit, DEFAULT_PRECISION);\n    var text = this.axisLabelText(value, null, labelOptions);\n    return new AxisLabel(value, text, index, null, labelOptions);\n  };\n\n  NumericAxis.prototype.shouldRenderNote = function shouldRenderNote(value) {\n    var range = this.range();\n    return range.min <= value && value <= range.max;\n  };\n\n  NumericAxis.prototype.pan = function pan(delta) {\n    var range = this.translateRange(delta);\n    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n  };\n\n  NumericAxis.prototype.pointsRange = function pointsRange(start, end) {\n    var startValue = this.getValue(start);\n    var endValue = this.getValue(end);\n    var min = Math.min(startValue, endValue);\n    var max = Math.max(startValue, endValue);\n\n    if (this.isValidRange(min, max)) {\n      return {\n        min: min,\n        max: max\n      };\n    }\n  };\n\n  NumericAxis.prototype.zoomRange = function zoomRange(delta) {\n    var ref = this;\n    var totalMin = ref.totalMin;\n    var totalMax = ref.totalMax;\n    var newRange = this.scaleRange(delta);\n    var min = limitValue(newRange.min, totalMin, totalMax);\n    var max = limitValue(newRange.max, totalMin, totalMax);\n\n    if (this.isValidRange(min, max)) {\n      return {\n        min: min,\n        max: max\n      };\n    }\n  };\n\n  NumericAxis.prototype.isValidRange = function isValidRange(min, max) {\n    return max - min > MIN_VALUE_RANGE;\n  };\n\n  return NumericAxis;\n}(Axis);\n\nfunction autoAxisOptions(seriesMin, seriesMax, options) {\n  var narrowRange = options.narrowRange;\n  var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);\n  var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);\n  var majorUnit = autoMajorUnit(autoMin, autoMax);\n  var autoOptions = {\n    majorUnit: majorUnit\n  };\n\n  if (options.roundToMajorUnit !== false) {\n    if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {\n      autoMin -= majorUnit;\n    }\n\n    if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {\n      autoMax += majorUnit;\n    }\n  }\n\n  autoOptions.min = floor(autoMin, majorUnit);\n  autoOptions.max = ceil(autoMax, majorUnit);\n  return autoOptions;\n}\n\nfunction totalAxisOptions(autoOptions, options) {\n  return {\n    min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,\n    max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,\n    majorUnit: autoOptions.majorUnit\n  };\n}\n\nfunction clearNullValues(options, fields) {\n  for (var idx = 0; idx < fields.length; idx++) {\n    var field = fields[idx];\n\n    if (options[field] === null) {\n      options[field] = undefined;\n    }\n  }\n}\n\nfunction axisOptions(autoOptions, userOptions) {\n  var options = userOptions;\n  var userSetMin, userSetMax;\n\n  if (userOptions) {\n    clearNullValues(userOptions, ['min', 'max']);\n    userSetMin = defined(userOptions.min);\n    userSetMax = defined(userOptions.max);\n    var userSetLimits = userSetMin || userSetMax;\n\n    if (userSetLimits) {\n      if (userOptions.min === userOptions.max) {\n        if (userOptions.min > 0) {\n          userOptions.min = 0;\n        } else {\n          userOptions.max = 1;\n        }\n      }\n    }\n\n    if (userOptions.majorUnit) {\n      autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);\n      autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);\n    } else if (userSetLimits) {\n      options = deepExtend(autoOptions, userOptions); // Determine an auto major unit after min/max have been set\n\n      autoOptions.majorUnit = autoMajorUnit(options.min, options.max);\n    }\n  }\n\n  autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;\n  var result = deepExtend(autoOptions, options);\n\n  if (result.min >= result.max) {\n    if (userSetMin && !userSetMax) {\n      result.max = result.min + result.majorUnit;\n    } else if (!userSetMin && userSetMax) {\n      result.min = result.max - result.majorUnit;\n    }\n  }\n\n  return result;\n}\n\nfunction remainderClose(value, divisor, ratio) {\n  var remainder = round(Math.abs(value % divisor), DEFAULT_PRECISION);\n  var threshold = divisor * (1 - ratio);\n  return remainder === 0 || remainder > threshold;\n}\n\nsetDefaultOptions(NumericAxis, {\n  type: \"numeric\",\n  min: 0,\n  max: 1,\n  vertical: true,\n  majorGridLines: {\n    visible: true,\n    width: 1,\n    color: BLACK\n  },\n  labels: {\n    format: \"#.####################\"\n  },\n  zIndex: 1\n});\nexport default NumericAxis;","map":null,"metadata":{},"sourceType":"module"}