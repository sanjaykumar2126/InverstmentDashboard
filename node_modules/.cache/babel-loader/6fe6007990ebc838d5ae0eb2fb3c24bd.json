{"ast":null,"code":"import { setDefaultOptions, deepExtend, isNumber } from '../../common';\nimport { ANGULAR_SPEED, RADIAL_RANGE_POINTER } from '../constants';\nimport Pointer from '../pointer';\nimport RangePointerAnimation from './range-pointer-animation';\n\nvar RangePointer = function (Pointer) {\n  function RangePointer() {\n    Pointer.apply(this, arguments);\n  }\n\n  if (Pointer) RangePointer.__proto__ = Pointer;\n  RangePointer.prototype = Object.create(Pointer && Pointer.prototype);\n  RangePointer.prototype.constructor = RangePointer;\n\n  RangePointer.prototype.repaint = function repaint() {\n    var ref = this;\n    var scale = ref.scale;\n    var options = ref.options;\n    var oldAngle = scale.slotAngle(options._oldValue);\n    var newAngle = scale.slotAngle(options.value);\n\n    if (this.animation) {\n      this.animation.abort();\n    }\n\n    if (options.animation.transitions === false) {\n      this.angle(newAngle);\n      this.stroke(this.currentColor());\n    } else {\n      this.animation = new RangePointerAnimation(this, deepExtend(options.animation, {\n        oldAngle: oldAngle,\n        newAngle: newAngle\n      }));\n      this.animation.play();\n    }\n  };\n\n  RangePointer.prototype.angle = function angle(value) {\n    var geometry = this.elements.geometry();\n\n    if (this.scale.options.reverse) {\n      geometry.setStartAngle(value);\n    } else {\n      geometry.setEndAngle(value);\n    }\n\n    this.scale.placeholderRangeAngle(value);\n  };\n\n  RangePointer.prototype.stroke = function stroke(value) {\n    this.elements.stroke(value);\n  };\n\n  RangePointer.prototype.render = function render() {\n    if (this.elements) {\n      return;\n    }\n\n    var ref = this;\n    var scale = ref.scale;\n    var options = ref.options;\n\n    if (options.animation !== false) {\n      deepExtend(options.animation, {\n        startAngle: 0,\n        center: scale.arc.center,\n        reverse: scale.options.reverse\n      });\n    }\n\n    this.elements = scale.addRange(scale.options.min, this.options.value, {\n      color: this.currentColor(),\n      opacity: options.opacity,\n      lineCap: scale.options.rangeLineCap\n    });\n  };\n\n  RangePointer.prototype.currentColor = function currentColor() {\n    var ref = this.scale.options;\n    var min = ref.min;\n    var max = ref.max;\n    var ref$1 = this.options;\n    var colors = ref$1.colors;\n    var color = ref$1.color;\n    var value = ref$1.value;\n    var currentValue = isNumber(value) ? value : min;\n\n    if (colors) {\n      for (var idx = 0; idx < colors.length; idx++) {\n        var ref$2 = colors[idx];\n        var rangeColor = ref$2.color;\n        var from = ref$2.from;\n        if (from === void 0) from = min;\n        var to = ref$2.to;\n        if (to === void 0) to = max;\n\n        if (from <= currentValue && currentValue <= to) {\n          return rangeColor;\n        }\n      }\n    }\n\n    return color;\n  };\n\n  RangePointer.prototype.reflow = function reflow() {\n    this.render();\n    this.bbox = this.elements.bbox();\n  };\n\n  return RangePointer;\n}(Pointer);\n\nsetDefaultOptions(RangePointer, {\n  animation: {\n    type: RADIAL_RANGE_POINTER,\n    duration: ANGULAR_SPEED\n  }\n});\nexport default RangePointer;","map":null,"metadata":{},"sourceType":"module"}