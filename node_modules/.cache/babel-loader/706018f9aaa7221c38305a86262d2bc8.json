{"ast":null,"code":"/**\n * StripLine src\n */\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { valueToCoefficient, textElement, RectOption, appendChildElement, appendClipElement, withIn, getElement } from '../../common/utils/helper';\nimport { measureText, TextOption, PathOption, Rect } from '@syncfusion/ej2-svg-base';\n/**\n * `StripLine` module is used to render the stripLine in chart.\n */\n\nvar StripLine =\n/** @class */\nfunction () {\n  function StripLine() {}\n  /**\n   * Finding x, y, width and height of the strip line\n   * @param axis\n   * @param strip line\n   * @param seriesClipRect\n   * @param startValue\n   * @param segmentAxis\n   */\n\n\n  StripLine.prototype.measureStripLine = function (axis, stripline, seriesClipRect, startValue, segmentAxis) {\n    var actualStart;\n    var actualEnd;\n    var orientation = axis.orientation;\n\n    if (stripline.isRepeat && stripline.size !== null) {\n      actualStart = startValue;\n      actualEnd = null;\n    } else {\n      if (axis.valueType === 'DateTimeCategory') {\n        var start = stripline.start;\n        var end = stripline.end;\n        actualStart = start != null && typeof start !== 'number' ? axis.labels.indexOf(start.getTime().toString()) : start;\n        actualEnd = end != null && typeof end !== 'number' ? axis.labels.indexOf(end.getTime().toString()) : end;\n      } else {\n        actualStart = stripline.start === null ? null : +stripline.start;\n        actualEnd = stripline.end === null ? null : +stripline.end;\n      }\n    }\n\n    var rect = this.getFromTovalue(actualStart, actualEnd, stripline.size, stripline.startFromAxis, axis, stripline);\n    var height = orientation === 'Vertical' ? (rect.to - rect.from) * axis.rect.height : seriesClipRect.height;\n    var width = orientation === 'Horizontal' ? (rect.to - rect.from) * axis.rect.width : seriesClipRect.width;\n    var x = orientation === 'Vertical' ? seriesClipRect.x : rect.from * axis.rect.width + axis.rect.x;\n    var y = orientation === 'Horizontal' ? seriesClipRect.y : axis.rect.y + axis.rect.height - (stripline.sizeType === 'Pixel' ? rect.from : rect.to) * axis.rect.height;\n\n    if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\n      var segRect = this.getFromTovalue(+stripline.segmentStart, +stripline.segmentEnd, null, null, segmentAxis, stripline);\n\n      if (segmentAxis.orientation === 'Vertical') {\n        y = segmentAxis.rect.y + segmentAxis.rect.height - segRect.to * segmentAxis.rect.height;\n        height = (segRect.to - segRect.from) * segmentAxis.rect.height;\n      } else {\n        x = segRect.from * segmentAxis.rect.width + segmentAxis.rect.x;\n        width = (segRect.to - segRect.from) * segmentAxis.rect.width;\n      }\n    }\n\n    if (height !== 0 && width !== 0 || stripline.sizeType === 'Pixel' && (stripline.start !== null || stripline.startFromAxis)) {\n      return new Rect(x, y, width, height);\n    }\n\n    return new Rect(0, 0, 0, 0);\n  };\n  /**\n   * To get from to value from start, end, size, start from axis\n   * @param start\n   * @param end\n   * @param size\n   * @param startFromAxis\n   * @param axis\n   * @param strip line\n   */\n\n\n  StripLine.prototype.getFromTovalue = function (start, end, size, startFromAxis, axis, stripline) {\n    var from = !stripline.isRepeat && startFromAxis ? axis.visibleRange.min : start;\n    var to = this.getToValue(Math.max(start, isNullOrUndefined(end) ? start : end), from, size, axis, end, stripline);\n    from = this.findValue(from, axis);\n    to = this.findValue(to, axis);\n    return {\n      from: valueToCoefficient(axis.isInversed ? to : from, axis),\n      to: valueToCoefficient(axis.isInversed ? from : to, axis)\n    };\n  };\n  /**\n   * Finding end value of the strip line\n   * @param to\n   * @param from\n   * @param size\n   * @param axis\n   * @param end\n   * @param strip line\n   */\n\n\n  StripLine.prototype.getToValue = function (to, from, size, axis, end, stripline) {\n    var sizeType = stripline.sizeType;\n    var isEnd = end === null;\n\n    if (axis.valueType === 'DateTime') {\n      var fromValue = new Date(from);\n\n      if (sizeType === 'Auto') {\n        sizeType = axis.actualIntervalType;\n        size *= axis.visibleRange.interval;\n      }\n\n      switch (sizeType) {\n        case 'Years':\n          return isEnd ? new Date(fromValue.setFullYear(fromValue.getFullYear() + size)) : to;\n\n        case 'Months':\n          return isEnd ? new Date(fromValue.setMonth(fromValue.getMonth() + size)) : to;\n\n        case 'Days':\n          return isEnd ? new Date(fromValue.setDate(fromValue.getDate() + size)) : to;\n\n        case 'Hours':\n          return isEnd ? new Date(fromValue.setHours(fromValue.getHours() + size)) : to;\n\n        case 'Minutes':\n          return isEnd ? new Date(fromValue.setMinutes(fromValue.getMinutes() + size)) : to;\n\n        case 'Seconds':\n          return isEnd ? new Date(fromValue.setSeconds(fromValue.getSeconds() + size)) : to;\n\n        default:\n          return from;\n      }\n    } else {\n      return stripline.sizeType === 'Pixel' ? from : isEnd ? from + size : to;\n    }\n  };\n  /**\n   * To check the strip line values within range\n   * @param value\n   * @param axis\n   */\n\n\n  StripLine.prototype.findValue = function (value, axis) {\n    if (value < axis.visibleRange.min) {\n      value = axis.visibleRange.min;\n    } else if (value > axis.visibleRange.max) {\n      value = axis.visibleRange.max;\n    }\n\n    return value;\n  };\n  /**\n   * To render strip lines based start and end.\n   * @private\n   * @param chart\n   * @param position\n   * @param axes\n   */\n\n\n  StripLine.prototype.renderStripLine = function (chart, position, axes) {\n    var id = chart.element.id + '_stripline_' + position + '_';\n    var seriesClipRect = chart.chartAxisLayoutPanel.seriesClipRect;\n    var end = 0;\n    var limit = 0;\n    var startValue = 0;\n    var segmentAxis = null;\n    var range;\n    var options = new RectOption(id + 'ClipRect', 'transparent', {\n      width: 1,\n      color: 'Gray'\n    }, 1, {\n      x: chart.initialClipRect.x,\n      y: chart.initialClipRect.y,\n      width: chart.initialClipRect.width,\n      height: chart.initialClipRect.height\n    });\n    var striplineGroup = chart.renderer.createGroup({\n      id: id + 'collections',\n      'clip-path': 'url(#' + id + 'ClipRect' + ')'\n    });\n    striplineGroup.appendChild(appendClipElement(chart.redraw, options, chart.renderer));\n\n    for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {\n      var axis = axes_1[_i];\n      var count = 0;\n\n      for (var _a = 0, _b = axis.stripLines; _a < _b.length; _a++) {\n        var stripline = _b[_a];\n\n        if (stripline.visible && stripline.zIndex === position) {\n          if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\n            segmentAxis = this.getSegmentAxis(axes, axis, stripline);\n          }\n\n          if (stripline.isRepeat && stripline.repeatEvery != null && stripline.size !== null && stripline.sizeType !== 'Pixel') {\n            limit = stripline.repeatUntil != null ? axis.valueType === 'DateTime' ? stripline.repeatUntil.getTime() : +stripline.repeatUntil : axis.actualRange.max;\n            startValue = stripline.start;\n\n            if (stripline.startFromAxis && axis.valueType === 'DateTime' && stripline.sizeType === 'Auto' || stripline.start < axis.visibleRange.min) {\n              startValue = axis.visibleLabels[0].value === axis.visibleRange.min ? axis.visibleRange.min : axis.visibleLabels[0].value - (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n            }\n\n            startValue = stripline.startFromAxis && axis.valueType !== 'DateTime' ? axis.visibleRange.min : startValue;\n\n            while (startValue < limit) {\n              end = startValue + (axis.valueType === 'DateTime' ? axis.dateTimeInterval * +stripline.size : stripline.size);\n              range = withIn(end, axis.visibleRange);\n\n              if (startValue >= axis.visibleRange.min && startValue < axis.visibleRange.max || range) {\n                this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count);\n              }\n\n              count++;\n              startValue = this.getStartValue(axis, stripline, startValue);\n            }\n          } else {\n            this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, null, segmentAxis, count);\n            count++;\n          }\n        }\n      }\n    }\n\n    appendChildElement(chart.enableCanvas, chart.svgObject, striplineGroup, chart.redraw);\n  };\n  /**\n   * To draw the single line strip line\n   * @param strip line\n   * @param rect\n   * @param id\n   * @param parent\n   * @param chart\n   * @param axis\n   */\n\n\n  StripLine.prototype.renderPath = function (stripline, rect, id, parent, chart, axis) {\n    var element = getElement(id);\n    var direction = element ? element.getAttribute('d') : '';\n    var d = axis.orientation === 'Vertical' ? 'M' + rect.x + ' ' + rect.y + ' ' + 'L' + (rect.x + rect.width) + ' ' + rect.y : 'M' + rect.x + ' ' + rect.y + ' ' + 'L' + rect.x + ' ' + (rect.y + rect.height);\n    appendChildElement(chart.enableCanvas, parent, chart.renderer.drawPath(new PathOption(id, '', stripline.size, stripline.color, stripline.opacity, stripline.dashArray, d)), chart.redraw, true, 'x', 'y', null, direction, true);\n  };\n\n  ;\n  /**\n   * To draw the rectangle\n   * @param strip line\n   * @param rect\n   * @param id\n   * @param parent\n   * @param chart\n   */\n\n  StripLine.prototype.renderRectangle = function (stripline, rect, id, parent, chart) {\n    var element = getElement(id);\n    var previousRect = element ? new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;\n    appendChildElement(chart.enableCanvas, parent, chart.renderer.drawRectangle(new RectOption(id, stripline.color, stripline.border, stripline.opacity, rect, 0, 0, '', stripline.dashArray)), chart.redraw, true, 'x', 'y', null, null, true, true, previousRect);\n  };\n  /**\n   * To create the text on strip line\n   * @param strip line\n   * @param rect\n   * @param id\n   * @param parent\n   * @param chart\n   * @param axis\n   */\n\n\n  StripLine.prototype.renderText = function (stripline, rect, id, parent, chart, axis) {\n    var textSize = measureText(stripline.text, stripline.textStyle);\n    var textMid = 3 * (textSize.height / 8);\n    var ty = rect.y + rect.height / 2 + textMid;\n    var rotation = stripline.rotation === null ? axis.orientation === 'Vertical' ? 0 : -90 : stripline.rotation;\n    var tx = rect.x + rect.width / 2;\n    var anchor;\n    var padding = 5;\n\n    if (axis.orientation === 'Horizontal') {\n      tx = this.getTextStart(tx + textMid * this.factor(stripline.horizontalAlignment), rect.width, stripline.horizontalAlignment);\n      ty = this.getTextStart(ty - textMid, rect.height, stripline.verticalAlignment);\n      anchor = this.invertAlignment(stripline.verticalAlignment);\n    } else {\n      tx = this.getTextStart(tx, rect.width, stripline.horizontalAlignment);\n      ty = this.getTextStart(ty + textMid * this.factor(stripline.verticalAlignment) - padding, rect.height, stripline.verticalAlignment);\n      anchor = stripline.horizontalAlignment;\n    }\n\n    textElement(chart.renderer, new TextOption(id, tx, ty, anchor, stripline.text, 'rotate(' + rotation + ' ' + tx + ',' + ty + ')', 'middle'), stripline.textStyle, stripline.textStyle.color, parent);\n  };\n\n  StripLine.prototype.invertAlignment = function (anchor) {\n    switch (anchor) {\n      case 'Start':\n        anchor = 'End';\n        break;\n\n      case 'End':\n        anchor = 'Start';\n        break;\n    }\n\n    return anchor;\n  };\n  /**\n   * To find the next value of the recurrence strip line\n   * @param axis\n   * @param stripline\n   * @param startValue\n   */\n\n\n  StripLine.prototype.getStartValue = function (axis, stripline, startValue) {\n    if (axis.valueType === 'DateTime') {\n      return this.getToValue(null, startValue, +stripline.repeatEvery, axis, null, stripline);\n    } else {\n      return startValue + +stripline.repeatEvery;\n    }\n  };\n  /**\n   * Finding segment axis for segmented strip line\n   * @param axes\n   * @param axis\n   * @param strip line\n   */\n\n\n  StripLine.prototype.getSegmentAxis = function (axes, axis, stripline) {\n    var segment;\n\n    if (stripline.segmentAxisName == null) {\n      return axis.orientation === 'Horizontal' ? axes[1] : axes[0];\n    } else {\n      for (var i = 0; i < axes.length; i++) {\n        if (stripline.segmentAxisName === axes[i].name) {\n          segment = axes[i];\n        }\n      }\n\n      return segment;\n    }\n  };\n  /**\n   * To render strip line on chart\n   * @param axis\n   * @param stripline\n   * @param seriesClipRect\n   * @param id\n   * @param striplineGroup\n   * @param chart\n   * @param startValue\n   * @param segmentAxis\n   * @param count\n   */\n\n\n  StripLine.prototype.renderStripLineElement = function (axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count) {\n    var rect = this.measureStripLine(axis, stripline, seriesClipRect, startValue, segmentAxis);\n\n    if (stripline.sizeType === 'Pixel') {\n      this.renderPath(stripline, rect, id + 'path_' + axis.name + '_' + count, striplineGroup, chart, axis);\n    } else {\n      if (rect.height !== 0 && rect.width !== 0) {\n        this.renderRectangle(stripline, rect, id + 'rect_' + axis.name + '_' + count, striplineGroup, chart);\n      }\n    }\n\n    if (stripline.text !== '') {\n      this.renderText(stripline, rect, id + 'text_' + axis.name + '_' + count, striplineGroup, chart, axis);\n    }\n  };\n  /**\n   * To find the factor of the text\n   * @param anchor\n   */\n\n\n  StripLine.prototype.factor = function (anchor) {\n    var factor = 0;\n\n    switch (anchor) {\n      case 'Start':\n        factor = 1;\n        break;\n\n      case 'End':\n        factor = -1;\n        break;\n    }\n\n    return factor;\n  };\n  /**\n   * To find the start value of the text\n   * @param xy\n   * @param size\n   * @param textAlignment\n   */\n\n\n  StripLine.prototype.getTextStart = function (xy, size, textAlignment) {\n    var padding = 5;\n\n    switch (textAlignment) {\n      case 'Start':\n        xy = xy - size / 2 + padding;\n        break;\n\n      case 'End':\n        xy = xy + size / 2 - padding;\n        break;\n    }\n\n    return xy;\n  };\n  /**\n   * To get the module name for `StripLine`.\n   * @private\n   */\n\n\n  StripLine.prototype.getModuleName = function () {\n    return 'StripLine';\n  };\n  /**\n   * To destroy the `StripLine` module.\n   * @private\n   */\n\n\n  StripLine.prototype.destroy = function () {// destroy peform here\n  };\n\n  return StripLine;\n}();\n\nexport { StripLine };","map":null,"metadata":{},"sourceType":"module"}