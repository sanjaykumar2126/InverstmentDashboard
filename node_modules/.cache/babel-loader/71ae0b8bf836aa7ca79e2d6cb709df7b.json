{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Component, Property, NotifyPropertyChanges, Internationalization } from '@syncfusion/ej2-base';\nimport { L10n, setValue, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { ChildProperty } from '@syncfusion/ej2-base';\nimport { remove, extend } from '@syncfusion/ej2-base';\nimport { Browser, Touch } from '@syncfusion/ej2-base';\nimport { Event, EventHandler, Complex, Collection } from '@syncfusion/ej2-base';\nimport { findClipRect, showTooltip, removeElement, appendChildElement, blazorTemplatesReset } from '../common/utils/helper';\nimport { textElement, RectOption, createSvg, firstToLowerCase, titlePositionX, redrawElement } from '../common/utils/helper';\nimport { appendClipElement } from '../common/utils/helper';\nimport { getSeriesColor, Theme, getThemeColor } from '../common/model/theme';\nimport { Margin, Border, ChartArea, Font, Indexes, TooltipSettings } from '../common/model/base';\nimport { Row, Column, Axis } from './axis/axis';\nimport { CartesianAxisLayoutPanel } from './axis/cartesian-panel';\nimport { Rect, measureText, TextOption, Size, SvgRenderer } from '@syncfusion/ej2-svg-base';\nimport { ChartData } from './utils/get-data';\nimport { Series } from './series/chart-series';\nimport { Data } from '../common/model/data';\nimport { Marker } from './series/marker';\nimport { LegendSettings } from '../common/legend/legend';\nimport { TechnicalIndicator } from './technical-indicators/technical-indicator';\nimport { chartMouseClick, pointClick, pointMove, chartMouseLeave, resized } from '../common/model/constants';\nimport { chartMouseDown, chartMouseMove, chartMouseUp, load } from '../common/model/constants';\nimport { ChartAnnotationSettings } from './model/chart-base';\nimport { getElement, getTitle } from '../common/utils/helper';\nimport { ExportUtils } from '../common/utils/export';\n/**\n * Configures the crosshair in the chart.\n */\n\nvar CrosshairSettings =\n/** @class */\nfunction (_super) {\n  __extends(CrosshairSettings, _super);\n\n  function CrosshairSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(false)], CrosshairSettings.prototype, \"enable\", void 0);\n\n  __decorate([Property('')], CrosshairSettings.prototype, \"dashArray\", void 0);\n\n  __decorate([Complex({\n    color: null,\n    width: 1\n  }, Border)], CrosshairSettings.prototype, \"line\", void 0);\n\n  __decorate([Property('Both')], CrosshairSettings.prototype, \"lineType\", void 0);\n\n  return CrosshairSettings;\n}(ChildProperty);\n\nexport { CrosshairSettings };\n/**\n * Configures the zooming behavior for the chart.\n */\n\nvar ZoomSettings =\n/** @class */\nfunction (_super) {\n  __extends(ZoomSettings, _super);\n\n  function ZoomSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(false)], ZoomSettings.prototype, \"enableSelectionZooming\", void 0);\n\n  __decorate([Property(false)], ZoomSettings.prototype, \"enablePinchZooming\", void 0);\n\n  __decorate([Property(false)], ZoomSettings.prototype, \"enableMouseWheelZooming\", void 0);\n\n  __decorate([Property(true)], ZoomSettings.prototype, \"enableDeferredZooming\", void 0);\n\n  __decorate([Property('XY')], ZoomSettings.prototype, \"mode\", void 0);\n\n  __decorate([Property(['Zoom', 'ZoomIn', 'ZoomOut', 'Pan', 'Reset'])], ZoomSettings.prototype, \"toolbarItems\", void 0);\n\n  __decorate([Property(false)], ZoomSettings.prototype, \"enablePan\", void 0);\n\n  __decorate([Property(false)], ZoomSettings.prototype, \"enableScrollbar\", void 0);\n\n  return ZoomSettings;\n}(ChildProperty);\n\nexport { ZoomSettings };\n/**\n * Represents the Chart control.\n * ```html\n * <div id=\"chart\"/>\n * <script>\n *   var chartObj = new Chart({ isResponsive : true });\n *   chartObj.appendTo(\"#chart\");\n * </script>\n * ```\n * @public\n */\n\nvar Chart =\n/** @class */\nfunction (_super) {\n  __extends(Chart, _super);\n  /**\n   * Constructor for creating the widget\n   * @hidden\n   */\n\n\n  function Chart(options, element) {\n    var _this = _super.call(this, options, element) || this;\n    /** @public */\n\n\n    _this.animated = false;\n    /** @private */\n\n    _this.isPointMouseDown = false;\n    /** @private */\n\n    _this.isScrolling = false;\n    /** @private */\n\n    _this.chartAreaType = 'Cartesian';\n    _this.chartid = 57723;\n    setValue('mergePersistData', _this.mergePersistChartData, _this);\n    return _this;\n  }\n  /**\n   * To manage persist chart data\n   */\n\n\n  Chart.prototype.mergePersistChartData = function () {\n    var data = window.localStorage.getItem(this.getModuleName() + this.element.id);\n\n    if (!(isNullOrUndefined(data) || data === '')) {\n      var dataObj = JSON.parse(data);\n      var keys = Object.keys(dataObj);\n      this.isProtectedOnChange = true;\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n\n        if (typeof this[key] === 'object' && !isNullOrUndefined(this[key])) {\n          extend(this[key], dataObj[key]);\n        } else {\n          this[key] = dataObj[key];\n        }\n      }\n\n      this.isProtectedOnChange = false;\n    }\n  };\n  /**\n   * Initialize the event handler.\n   */\n\n\n  Chart.prototype.preRender = function () {\n    // It is used for checking blazor framework or not.\n    var blazor = 'Blazor';\n    this.isBlazor = window[blazor];\n    this.unWireEvents();\n    this.initPrivateVariable();\n    this.setCulture();\n    this.wireEvents();\n  };\n\n  Chart.prototype.initPrivateVariable = function () {\n    this.animateSeries = true;\n    this.delayRedraw = false;\n    this.horizontalAxes = [];\n    this.verticalAxes = [];\n    this.refreshAxis();\n    this.refreshDefinition(this.rows);\n    this.refreshDefinition(this.columns);\n\n    if (this.tooltipModule) {\n      this.tooltipModule.previousPoints = [];\n    }\n\n    if (this.element.id === '') {\n      var collection = document.getElementsByClassName('e-chart').length;\n      this.element.id = 'chart_' + this.chartid + '_' + collection;\n    } //seperate ID to differentiate chart and stock chart\n\n\n    this.svgId = this.stockChart ? this.stockChart.element.id + '_stockChart_chart' : this.element.id + (this.enableCanvas ? '_canvas' : '_svg');\n  };\n  /**\n   * To Initialize the control rendering.\n   */\n\n\n  Chart.prototype.render = function () {\n    this.svgRenderer = new SvgRenderer(this.element.id);\n    this.trigger(load, {\n      chart: this\n    });\n    this.createChartSvg();\n    this.setTheme();\n    this.markerRender = new Marker(this);\n    this.calculateAreaType();\n    this.calculateVisibleSeries();\n    this.initTechnicalIndicators();\n    this.initTrendLines();\n    this.calculateVisibleAxis();\n    this.processData();\n    this.renderComplete();\n  };\n  /**\n   * Gets the localized label by locale keyword.\n   * @param  {string} key\n   * @return {string}\n   */\n\n\n  Chart.prototype.getLocalizedLabel = function (key) {\n    return this.localeObject.getConstant(key);\n  };\n  /**\n   * Animate the series bounds.\n   * @private\n   */\n\n\n  Chart.prototype.animate = function (duration) {\n    this.redraw = true;\n    this.animated = true; //used to set duration as 1000 for animation at default 300\n\n    this.duration = duration ? duration : 1000;\n  };\n  /**\n   * Refresh the chart bounds.\n   * @private\n   */\n\n\n  Chart.prototype.refreshBound = function () {\n    if (this.legendModule && this.legendSettings.visible) {\n      this.legendModule.getLegendOptions(this.visibleSeries, this);\n    }\n\n    this.calculateStackValues();\n    this.calculateBounds(); //this prevents the initial rendering of stock chart\n\n    if (this.stockChart && !this.stockChart.rangeFound) {\n      if (this.stockChart.enablePeriodSelector || this.stockChart.enableSelector) {\n        return null;\n      }\n    }\n\n    this.renderElements();\n    removeElement('chartmeasuretext');\n  };\n  /**\n   * To calcualte the stack values\n   */\n\n\n  Chart.prototype.calculateStackValues = function () {\n    var series;\n    var isCalculateStacking = false;\n\n    for (var i = 0, len = this.visibleSeries.length; i < len; i++) {\n      series = this.visibleSeries[i];\n      series.position = series.rectCount = undefined;\n\n      if ((series.type.indexOf('Stacking') !== -1 || series.drawType.indexOf('Stacking') !== -1 && this.chartAreaType === 'PolarRadar') && !isCalculateStacking) {\n        series.calculateStackedValue(series.type.indexOf('100') > -1, this);\n        isCalculateStacking = true;\n      }\n    }\n  };\n\n  Chart.prototype.renderElements = function () {\n    this.renderBorder();\n    this.renderTitle();\n    this.renderAreaBorder();\n    this.renderSeriesElements(this.renderAxes());\n    this.renderLegend();\n    this.applyZoomkit();\n    this.performSelection();\n    this.setSecondaryElementPosition();\n    this.renderAnnotation();\n  };\n  /**\n   * To render the legend\n   * @private\n   */\n\n\n  Chart.prototype.renderAxes = function () {\n    this.yAxisElements = this.renderer.createGroup({\n      id: this.element.id + 'yAxisCollection'\n    });\n    var axisElement;\n\n    if (this.rows.length > 0 && this.columns.length > 0) {\n      axisElement = this.chartAxisLayoutPanel.renderAxes();\n    }\n\n    if (this.stripLineModule) {\n      this.stripLineModule.renderStripLine(this, 'Behind', this.axisCollections);\n    }\n\n    return axisElement;\n  };\n  /**\n   * To render the legend\n   */\n\n\n  Chart.prototype.renderLegend = function () {\n    if (this.legendModule && this.legendModule.legendCollections.length) {\n      this.legendModule.calTotalPage = true;\n      var borderWidth = this.legendSettings.border.width;\n      var bounds = this.legendModule.legendBounds;\n      var rect = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);\n\n      if (this.enableCanvas) {\n        rect = new Rect(rect.x - borderWidth / 2, rect.y - borderWidth / 2, rect.width + borderWidth, rect.height + borderWidth);\n        this.renderer.canvasClip(rect);\n      }\n\n      this.legendModule.renderLegend(this, this.legendSettings, bounds);\n\n      if (this.enableCanvas) {\n        this.renderer.canvasRestore();\n      }\n    }\n\n    if (!this.redraw) {\n      if (!this.stockChart) {\n        this.element.appendChild(this.svgObject);\n      } else {\n        if (!getElement(this.stockChart.chartObject.id)) {\n          this.stockChart.mainObject.appendChild(this.svgObject);\n        }\n      }\n    }\n  };\n  /**\n   * To set the left and top position for data label template for center aligned chart\n   */\n\n\n  Chart.prototype.setSecondaryElementPosition = function () {\n    var element = getElement(this.element.id + '_Secondary_Element');\n\n    if (!element) {\n      return;\n    }\n\n    var rect = this.element.getBoundingClientRect();\n    var svgRect = getElement(this.svgId).getBoundingClientRect();\n    element.style.left = Math.max(svgRect.left - rect.left, 0) + 'px';\n    element.style.top = Math.max(svgRect.top - rect.top, 0) + 'px';\n  };\n\n  Chart.prototype.initializeModuleElements = function () {\n    this.dataLabelCollections = [];\n    var elementId = this.element.id;\n\n    if (this.series.length) {\n      this.seriesElements = this.series[0].type === 'Scatter' || this.series[0].type === 'Bubble' ? this.svgRenderer.createGroup({\n        id: elementId + 'SeriesCollection'\n      }) : this.renderer.createGroup({\n        id: elementId + 'SeriesCollection'\n      });\n    }\n\n    if (this.indicators.length) {\n      this.indicatorElements = this.renderer.createGroup({\n        id: elementId + 'IndicatorCollection'\n      });\n    }\n\n    if (this.hasTrendlines()) {\n      this.trendLineElements = this.renderer.createGroup({\n        id: elementId + 'TrendLineCollection'\n      });\n    }\n\n    this.dataLabelElements = this.renderer.createGroup({\n      id: elementId + 'DataLabelCollection'\n    });\n  };\n\n  Chart.prototype.hasTrendlines = function () {\n    var isTrendline;\n\n    for (var _i = 0, _a = this.series; _i < _a.length; _i++) {\n      var series = _a[_i];\n      isTrendline = series.trendlines.length ? true : false;\n\n      if (isTrendline) {\n        break;\n      }\n    }\n\n    return isTrendline;\n  };\n\n  Chart.prototype.renderSeriesElements = function (axisElement) {\n    // Initialize the series elements values\n    this.initializeModuleElements();\n    var elementId = this.element.id;\n\n    if (this.element.tagName !== 'g') {\n      var tooltipDiv = redrawElement(this.redraw, elementId + '_Secondary_Element') || this.createElement('div');\n      tooltipDiv.id = elementId + '_Secondary_Element';\n      tooltipDiv.setAttribute('style', 'position: relative');\n      appendChildElement(false, this.element, tooltipDiv, this.redraw);\n    } // For canvas\n\n\n    if (this.enableCanvas) {\n      var tooltipdiv = document.getElementById(elementId + '_Secondary_Element');\n      tooltipdiv = !tooltipdiv ? this.createElement('div', {\n        id: elementId + '_Secondary_Element',\n        attrs: {\n          'style': 'position: relative; left:0px; top:0px'\n        }\n      }) : tooltipdiv;\n      var svg = this.svgRenderer.createSvg({\n        id: elementId + '_tooltip_svg',\n        width: this.availableSize.width,\n        height: this.availableSize.height\n      });\n      svg.setAttribute('style', 'position: absolute; pointer-events: none');\n      tooltipdiv.appendChild(svg);\n    } // For userInteraction\n\n\n    if (this.tooltip.enable) {\n      appendChildElement(this.enableCanvas, this.svgObject, this.renderer.createGroup({\n        id: elementId + '_UserInteraction',\n        style: 'pointer-events:none;'\n      }), this.redraw);\n    }\n\n    if (this.rows.length > 0 && this.columns.length > 0) {\n      this.initializeIndicator();\n      this.initializeTrendLine();\n      this.renderSeries();\n      this.appendElementsAfterSeries(axisElement);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  Chart.prototype.renderSeries = function () {\n    for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (item.visible) {\n        findClipRect(item);\n\n        if (this.enableCanvas) {\n          // To render scatter and bubble series in canvas\n          this.renderCanvasSeries(item); // To clip the series rect for canvas\n\n          this.renderer.canvasClip(this.chartAxisLayoutPanel.seriesClipRect);\n        }\n\n        item.renderSeries(this);\n\n        if (this.enableCanvas) {\n          this.renderer.canvasRestore();\n        }\n      }\n    }\n\n    var options = {\n      'id': this.element.id + '_ChartAreaClipRect_',\n      'x': this.chartAxisLayoutPanel.seriesClipRect.x,\n      'y': this.chartAxisLayoutPanel.seriesClipRect.y,\n      'width': this.chartAxisLayoutPanel.seriesClipRect.width,\n      'height': this.chartAxisLayoutPanel.seriesClipRect.height,\n      'fill': 'transparent',\n      'stroke-width': 1,\n      'stroke': 'Gray'\n    };\n\n    if (!this.enableCanvas) {\n      this.seriesElements.appendChild(appendClipElement(this.redraw, options, this.renderer));\n    }\n\n    var seriesSvg = document.getElementById(this.element.id + '_series_svg');\n    seriesSvg ? appendChildElement(false, seriesSvg, this.seriesElements, this.redraw) : appendChildElement(this.enableCanvas, this.svgObject, this.seriesElements, this.redraw);\n  };\n\n  Chart.prototype.renderCanvasSeries = function (item) {\n    var svgElement;\n    var divElement;\n    var canvas;\n\n    if (item.type === 'Bubble' || item.type === 'Scatter') {\n      svgElement = !svgElement ? this.svgRenderer.createSvg({\n        id: this.element.id + '_series_svg',\n        width: this.availableSize.width,\n        height: this.availableSize.height\n      }) : svgElement;\n      divElement = !divElement ? this.createElement('div', {\n        id: this.element.id + '_series'\n      }) : divElement;\n      divElement.setAttribute('style', 'position: absolute');\n      var mainElement = document.getElementById(this.element.id + '_Secondary_Element');\n      divElement.appendChild(svgElement);\n      mainElement.appendChild(divElement);\n    }\n\n    svgElement = this.enableCanvas && (item.type === 'Bubble' || item.type === 'Scatter') ? svgElement : this.svgObject;\n    canvas = this.enableCanvas && (item.type === 'Bubble' || item.type === 'Scatter') ? false : this.enableCanvas;\n  };\n\n  Chart.prototype.initializeIndicator = function () {\n    for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {\n      var indicator = _a[_i];\n\n      if (this[firstToLowerCase(indicator.type) + 'IndicatorModule']) {\n        this[firstToLowerCase(indicator.type) + 'IndicatorModule'].createIndicatorElements(this, indicator, indicator.index);\n      }\n    }\n\n    if (this.indicatorElements) {\n      appendChildElement(this.enableCanvas, this.svgObject, this.indicatorElements, this.redraw);\n    }\n  };\n\n  Chart.prototype.initializeTrendLine = function () {\n    for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {\n      var series = _a[_i];\n\n      if (series.trendlines.length) {\n        this.trendLineModule.getTrendLineElements(series, this);\n      }\n    }\n\n    if (this.trendLineElements) {\n      appendChildElement(this.enableCanvas, this.svgObject, this.trendLineElements, this.redraw);\n    }\n  };\n\n  Chart.prototype.appendElementsAfterSeries = function (axisElement) {\n    if (this.chartAreaType === 'PolarRadar') {\n      appendChildElement(this.enableCanvas, this.svgObject, this.yAxisElements, this.redraw);\n    }\n\n    appendChildElement(this.enableCanvas, this.svgObject, axisElement, this.redraw);\n\n    if (this.zoomModule && this.zoomSettings.enableScrollbar && this.scrollElement.childElementCount || this.scrollElement && this.scrollElement.childElementCount) {\n      appendChildElement(false, getElement(this.element.id + '_Secondary_Element'), this.scrollElement, this.redraw);\n    }\n\n    if (this.stripLineModule) {\n      this.stripLineModule.renderStripLine(this, 'Over', this.axisCollections);\n    }\n\n    if (!this.tooltip.enable) {\n      appendChildElement(this.enableCanvas, this.svgObject, this.renderer.createGroup({\n        id: this.element.id + '_UserInteraction',\n        style: 'pointer-events:none;'\n      }), this.redraw);\n    }\n\n    if (this.stockChart) {\n      this.stockChart.calculateStockEvents();\n    }\n  };\n\n  Chart.prototype.applyZoomkit = function () {\n    /**\n     * Issue: Zoomkit not visible after performing refresh()\n     * Fix: this method called without checking `zoomModule.isZoomed`\n     */\n    if (!this.redraw && this.zoomModule && (!this.zoomSettings.enablePan || this.zoomModule.performedUI)) {\n      this.zoomModule.applyZoomToolkit(this, this.axisCollections);\n    }\n  };\n  /**\n   * Render annotation perform here\n   * @param redraw\n   * @private\n   */\n\n\n  Chart.prototype.renderAnnotation = function () {\n    if (this.annotationModule) {\n      this.annotationModule.renderAnnotations(getElement(this.element.id + '_Secondary_Element'));\n    }\n  };\n\n  Chart.prototype.performSelection = function () {\n    var selectedDataIndexes = [];\n\n    if (this.selectionModule) {\n      selectedDataIndexes = extend([], this.selectionModule.selectedDataIndexes, null, true);\n      this.selectionModule.invokeSelection(this);\n    }\n\n    if (selectedDataIndexes.length > 0) {\n      this.selectionModule.selectedDataIndexes = selectedDataIndexes;\n      this.selectionModule.redrawSelection(this, this.selectionMode);\n    }\n  };\n\n  Chart.prototype.processData = function (render) {\n    if (render === void 0) {\n      render = true;\n    }\n\n    this.visibleSeriesCount = 0;\n    var check = true;\n\n    for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {\n      var series = _a[_i];\n\n      if (!series.visible && !this.legendSettings.visible) {\n        this.visibleSeriesCount++;\n        continue;\n      }\n\n      if (series.category !== 'Indicator' && series.category !== 'TrendLine') {\n        this.initializeDataModule(series);\n      }\n    }\n\n    for (var _b = 0, _c = this.indicators; _b < _c.length; _b++) {\n      var indicator = _c[_b];\n\n      if (indicator.dataSource) {\n        var techIndicator = indicator;\n        this.initializeDataModule(techIndicator);\n        check = false;\n      }\n    }\n\n    if (render && (!this.visibleSeries.length || this.visibleSeriesCount === this.visibleSeries.length && check)) {\n      this.refreshBound();\n      this.trigger('loaded', {\n        chart: this.isBlazor ? {} : this\n      });\n    }\n  };\n\n  Chart.prototype.initializeDataModule = function (series) {\n    series.xData = [];\n    series.yData = [];\n    series.dataModule = new Data(series.dataSource || this.dataSource, series.query);\n    series.points = [];\n    series.refreshDataManager(this);\n  };\n\n  Chart.prototype.calculateBounds = function () {\n    var margin = this.margin; // Title Height;\n\n    var titleHeight = 0;\n    var subTitleHeight = 0;\n    var titleWidth = 0;\n    var padding = 15;\n    var left = margin.left;\n    var width = this.availableSize.width - left - margin.right - this.border.width;\n    this.titleCollection = [];\n    this.subTitleCollection = [];\n\n    if (this.title) {\n      this.titleCollection = getTitle(this.title, this.titleStyle, width);\n      titleHeight = measureText(this.title, this.titleStyle).height * this.titleCollection.length + padding;\n\n      if (this.subTitle) {\n        var maxWidth = 0;\n\n        for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {\n          var titleText = _a[_i];\n          titleWidth = measureText(titleText, this.titleStyle).width;\n          maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;\n        }\n\n        this.subTitleCollection = getTitle(this.subTitle, this.subTitleStyle, maxWidth);\n        subTitleHeight = measureText(this.subTitle, this.subTitleStyle).height * this.subTitleCollection.length + padding;\n      }\n    }\n\n    var top = margin.top + subTitleHeight + titleHeight + this.chartArea.border.width * 0.5;\n    var height = this.availableSize.height - top - this.border.width - margin.bottom;\n    this.initialClipRect = new Rect(left, top, width, height);\n\n    if (this.legendModule) {\n      this.legendModule.calculateLegendBounds(this.initialClipRect, this.availableSize);\n    }\n\n    this.chartAxisLayoutPanel.measureAxis(this.initialClipRect);\n  };\n  /**\n   * Handles the print method for chart control.\n   */\n\n\n  Chart.prototype.print = function (id) {\n    var exportChart = new ExportUtils(this);\n    exportChart.print(id);\n  };\n  /**\n   * Defines the trendline initialization\n   */\n\n\n  Chart.prototype.initTrendLines = function () {\n    for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {\n      var series = _a[_i];\n      var trendIndex = 0;\n\n      for (var _b = 0, _c = series.trendlines; _b < _c.length; _b++) {\n        var trendline = _c[_b];\n        var trendLine = trendline;\n        var type = firstToLowerCase(trendLine.type);\n\n        if (this.trendLineModule) {\n          trendLine.index = trendIndex;\n          trendLine.sourceIndex = series.index;\n          this.trendLineModule.initSeriesCollection(trendLine, this);\n\n          if (trendLine.targetSeries) {\n            trendLine.targetSeries.xAxisName = series.xAxisName;\n            trendLine.targetSeries.yAxisName = series.yAxisName;\n            this.visibleSeries.push(trendLine.targetSeries);\n          }\n        }\n\n        trendIndex++;\n      }\n    }\n  };\n\n  Chart.prototype.calculateAreaType = function () {\n    var series = this.series[0];\n    this.chartArea.border.width = this.stockChart ? 0 : this.chartArea.border.width;\n\n    if (series) {\n      this.requireInvertedAxis = series.type.indexOf('Bar') !== -1 && !this.isTransposed || series.type.indexOf('Bar') === -1 && this.isTransposed && this.chartAreaType !== 'PolarRadar';\n    }\n\n    this.chartAxisLayoutPanel = this.chartAreaType === 'PolarRadar' ? this.polarSeriesModule || this.radarSeriesModule : new CartesianAxisLayoutPanel(this);\n  };\n  /**\n   * Calculate the visible axis\n   * @private\n   */\n\n\n  Chart.prototype.calculateVisibleAxis = function () {\n    var axis;\n    var series;\n    var axes = [this.primaryXAxis, this.primaryYAxis];\n    axes = this.chartAreaType === 'Cartesian' ? axes.concat(this.axes) : axes;\n\n    if (this.paretoSeriesModule && this.series[0].type === 'Pareto') {\n      axes = axes.concat(this.paretoSeriesModule.paretoAxes);\n    }\n\n    this.axisCollections = [];\n\n    if (this.zoomModule) {\n      this.zoomModule.isPanning = this.zoomModule.isAxisZoomed(axes) && this.zoomSettings.enablePan;\n      this.svgObject.setAttribute('cursor', this.zoomModule.isPanning ? 'pointer' : 'auto');\n\n      if (this.scrollBarModule) {\n        this.scrollBarModule.axes = axes;\n      }\n    }\n\n    if (this.scrollSettingEnabled) {\n      if (this.scrollBarModule) {\n        this.scrollBarModule.axes = axes;\n      }\n    }\n\n    for (var i = 0, len = axes.length; i < len; i++) {\n      axis = axes[i];\n      axis.series = [];\n      axis.labels = [];\n\n      for (var _i = 0, _a = this.visibleSeries; _i < _a.length; _i++) {\n        var series_1 = _a[_i];\n        this.initAxis(series_1, axis, true);\n      }\n\n      for (var _b = 0, _c = this.indicators; _b < _c.length; _b++) {\n        var indicator = _c[_b];\n        this.initAxis(indicator, axis, false);\n      }\n\n      if (this.scrollBarModule && !axis.zoomingScrollBar) {\n        this.scrollBarModule.injectTo(axis, this);\n      }\n\n      if (axis.orientation != null) {\n        this.axisCollections.push(axis);\n      }\n    }\n\n    if (this.rows.length > 0 && this.columns.length > 0) {\n      this.chartAxisLayoutPanel.measure();\n    }\n  };\n\n  Chart.prototype.initAxis = function (series, axis, isSeries) {\n    if (series.xAxisName === axis.name || series.xAxisName == null && axis.name === 'primaryXAxis') {\n      axis.orientation = this.requireInvertedAxis ? 'Vertical' : 'Horizontal';\n      series.xAxis = axis;\n\n      if (isSeries) {\n        axis.series.push(series);\n      }\n    } else if (series.yAxisName === axis.name || series.yAxisName == null && axis.name === 'primaryYAxis') {\n      axis.orientation = this.requireInvertedAxis ? 'Horizontal' : 'Vertical';\n      series.yAxis = axis;\n\n      if (isSeries) {\n        axis.series.push(series);\n      }\n    }\n  };\n\n  Chart.prototype.initTechnicalIndicators = function () {\n    var i = 0;\n\n    for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {\n      var indicator = _a[_i];\n      var techIndicator = indicator;\n      var type = firstToLowerCase(techIndicator.type);\n\n      if (this[type + 'IndicatorModule']) {\n        techIndicator.index = i;\n        this[type + 'IndicatorModule'].initSeriesCollection(techIndicator, this);\n\n        for (var _b = 0, _c = techIndicator.targetSeries; _b < _c.length; _b++) {\n          var targetSeries = _c[_b];\n\n          if (indicator.seriesName || indicator.dataSource) {\n            this.visibleSeries.push(targetSeries);\n          }\n        }\n      }\n\n      i++;\n    }\n  };\n  /** @private */\n\n\n  Chart.prototype.refreshTechnicalIndicator = function (series) {\n    if (this.indicators.length) {\n      var targetIndicator = null;\n\n      if (series instanceof Series && series.category !== 'Indicator') {\n        for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {\n          var indicator = _a[_i];\n\n          if (indicator.seriesName === series.name && !indicator.dataSource) {\n            targetIndicator = indicator;\n            targetIndicator.setDataSource(series, this);\n          }\n        }\n      } else if (series instanceof TechnicalIndicator) {\n        targetIndicator = series;\n        targetIndicator.setDataSource(series instanceof Series ? series : null, this);\n      }\n    }\n  };\n\n  Chart.prototype.calculateVisibleSeries = function () {\n    var series;\n    var seriesCollection;\n    this.visibleSeries = [];\n    var colors = this.palettes.length ? this.palettes : getSeriesColor(this.theme);\n    var count = colors.length;\n    seriesCollection = this.series.sort(function (a, b) {\n      return a.zOrder - b.zOrder;\n    });\n\n    for (var i = 0, len = seriesCollection.length; i < len; i++) {\n      series = seriesCollection[i]; // for y axis label issue during chart navigation\n\n      series.category = seriesCollection[0].type === 'Pareto' ? 'Pareto' : 'Series';\n      series.index = i;\n      series.interior = series.fill || colors[i % count];\n\n      switch (series.type) {\n        case 'Bar':\n        case 'StackingBar':\n        case 'StackingBar100':\n          if (seriesCollection[0].type.indexOf('Bar') === -1) {\n            continue;\n          }\n\n          break;\n\n        case 'Polar':\n        case 'Radar':\n          if (this.chartAreaType !== 'PolarRadar') {\n            continue;\n          }\n\n          if (this.chartAreaType === 'PolarRadar' && (series.xAxisName === null && series.yAxisName !== null || series.xAxisName !== null && series.yAxisName === null || series.xAxisName !== null && series.yAxisName !== null)) {\n            continue;\n          }\n\n          break;\n\n        case 'Pareto':\n          this.visibleSeries.push(series);\n          this.paretoSeriesModule.initSeries(series, this);\n          continue;\n\n        default:\n          if (this.chartAreaType === 'PolarRadar' || seriesCollection[0].type.indexOf('Bar') > -1) {\n            continue;\n          }\n\n          break;\n      }\n\n      this.visibleSeries.push(series);\n      seriesCollection[i] = series;\n    }\n  };\n\n  Chart.prototype.renderTitle = function () {\n    var rect;\n    var margin = this.margin;\n\n    if (this.title) {\n      var alignment = this.titleStyle.textAlignment;\n      var getAnchor = alignment === 'Near' ? 'start' : alignment === 'Far' ? 'end' : 'middle';\n      var elementSize = measureText(this.title, this.titleStyle);\n      rect = new Rect(margin.left, 0, this.availableSize.width - margin.left - margin.right, 0);\n      var options = new TextOption(this.element.id + '_ChartTitle', titlePositionX(rect, this.titleStyle), this.margin.top + elementSize.height * 3 / 4, getAnchor, this.titleCollection, '', 'auto');\n      var element = redrawElement(this.redraw, this.element.id + '_ChartTitle', options, this.renderer) || textElement(this.renderer, options, this.titleStyle, this.titleStyle.color || this.themeStyle.chartTitle, this.svgObject);\n\n      if (element) {\n        element.setAttribute('aria-label', this.description || this.title);\n        element.setAttribute('tabindex', this.tabIndex.toString());\n      }\n\n      if (this.subTitle) {\n        this.renderSubTitle(options);\n      }\n    }\n  };\n\n  Chart.prototype.renderSubTitle = function (options) {\n    var maxWidth = 0;\n    var titleWidth = 0;\n    var padding = 10;\n    var rect;\n\n    var anchor = function (alignment) {\n      return alignment === 'Near' ? 'start' : alignment === 'Far' ? 'end' : 'middle';\n    };\n\n    var alignment = this.titleStyle.textAlignment;\n\n    for (var _i = 0, _a = this.titleCollection; _i < _a.length; _i++) {\n      var titleText = _a[_i];\n      titleWidth = measureText(titleText, this.titleStyle).width;\n      maxWidth = titleWidth > maxWidth ? titleWidth : maxWidth;\n    }\n\n    var subTitleElementSize = measureText(this.subTitle, this.subTitleStyle);\n    rect = new Rect(alignment === 'Center' ? options.x - maxWidth * 0.5 : alignment === 'Far' ? options.x - maxWidth : options.x, 0, maxWidth, 0);\n    var subTitleOptions = new TextOption(this.element.id + '_ChartSubTitle', titlePositionX(rect, this.subTitleStyle), options.y * options.text.length + subTitleElementSize.height * 3 / 4 + padding, anchor(this.subTitleStyle.textAlignment), this.subTitleCollection, '', 'auto');\n    var element = redrawElement(this.redraw, this.element.id + '_ChartSubTitle', subTitleOptions, this.renderer) || textElement(this.renderer, subTitleOptions, this.subTitleStyle, this.subTitleStyle.color || this.themeStyle.chartTitle, this.svgObject);\n\n    if (element) {\n      element.setAttribute('aria-label', this.description || this.subTitle);\n      element.setAttribute('tabindex', this.tabIndex.toString());\n    }\n  };\n\n  Chart.prototype.renderBorder = function () {\n    var width = this.border.width;\n    var rect = new RectOption(this.element.id + '_ChartBorder', this.background || this.themeStyle.background, this.border, 1, new Rect(width * 0.5, width * 0.5, this.availableSize.width - width, this.availableSize.height - width));\n    this.htmlObject = redrawElement(this.redraw, this.element.id + '_ChartBorder', rect, this.renderer) || this.renderer.drawRectangle(rect);\n    appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw);\n  };\n  /**\n   * @private\n   */\n\n\n  Chart.prototype.renderAreaBorder = function () {\n    if (this.chartAreaType === 'PolarRadar') {\n      return null;\n    } else {\n      var element = getElement(this.element.id + '_ChartAreaBorder');\n      var previousRect = element ? new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;\n      var rect = new RectOption(this.element.id + '_ChartAreaBorder', this.chartArea.background, {\n        width: this.chartArea.border.width,\n        color: this.chartArea.border.color || this.themeStyle.areaBorder\n      }, this.chartArea.opacity, this.chartAxisLayoutPanel.seriesClipRect);\n      this.htmlObject = this.renderer.drawRectangle(rect);\n      appendChildElement(this.enableCanvas, this.svgObject, this.htmlObject, this.redraw, true, 'x', 'y', null, null, true, true, previousRect);\n      this.htmlObject = null;\n    }\n  };\n  /**\n   * To add series for the chart\n   * @param {SeriesModel[]} seriesCollection - Defines the series collection to be added in chart.\n   * @return {void}.\n   */\n\n\n  Chart.prototype.addSeries = function (seriesCollection) {\n    for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {\n      var series = seriesCollection_1[_i];\n      series = new Series(this, 'series', series);\n      this.series.push(series);\n    }\n\n    this.refresh();\n  };\n  /**\n   * To Remove series for the chart\n   * @param index - Defines the series index to be remove in chart series\n   * @return {void}\n   */\n\n\n  Chart.prototype.removeSeries = function (index) {\n    this.series.splice(index, 1);\n    this.refresh();\n  };\n  /**\n   * To destroy the widget\n   * @method destroy\n   * @return {void}.\n   * @member of Chart\n   */\n\n\n  Chart.prototype.destroy = function () {\n    if (this.scrollBarModule) {\n      this.scrollBarModule.destroy();\n    }\n\n    if (this.markerRender) {\n      this.markerRender.removeEventListener();\n      this.markerRender = null;\n    }\n\n    this.unWireEvents();\n\n    _super.prototype.destroy.call(this);\n\n    if (!this.enableCanvas) {\n      this.removeSvg();\n      this.svgObject = null;\n    }\n\n    this.horizontalAxes = [];\n    this.verticalAxes = [];\n    this.visibleSeries = [];\n    this.axisCollections = [];\n    this.chartAxisLayoutPanel = null;\n    this.dataLabelCollections = null;\n    this.dataLabelElements = null;\n    this.yAxisElements = null;\n  };\n  /**\n   * Get component name\n   */\n\n\n  Chart.prototype.getModuleName = function () {\n    return 'chart';\n  };\n  /**\n   * Get the properties to be maintained in the persisted state.\n   * @private\n   */\n\n\n  Chart.prototype.getPersistData = function () {\n    var keyEntity = ['loaded', 'animationComplete', 'primaryXAxis', 'primaryYAxis'];\n    return this.addOnPersist(keyEntity);\n  };\n  /**\n   * Method to create SVG element.\n   */\n\n\n  Chart.prototype.createChartSvg = function () {\n    this.removeSvg();\n    createSvg(this);\n  };\n  /**\n   * Method to bind events for chart\n   */\n\n\n  Chart.prototype.unWireEvents = function () {\n    /*! Find the Events type */\n    var startEvent = Browser.touchStartEvent;\n    var moveEvent = Browser.touchMoveEvent;\n    var stopEvent = Browser.touchEndEvent;\n    var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';\n    /*! UnBind the Event handler */\n\n    EventHandler.remove(this.element, startEvent, this.chartOnMouseDown);\n    EventHandler.remove(this.element, moveEvent, this.mouseMove);\n    EventHandler.remove(this.element, stopEvent, this.mouseEnd);\n    EventHandler.remove(this.element, 'click', this.chartOnMouseClick);\n    EventHandler.remove(this.element, 'contextmenu', this.chartRightClick);\n    EventHandler.remove(this.element, cancelEvent, this.mouseLeave);\n    window.removeEventListener(Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.resizeBound);\n    /**\n     * To fix memory issue\n     */\n\n    if (this.touchObject) {\n      this.touchObject.destroy();\n      this.touchObject = null;\n    }\n  };\n\n  Chart.prototype.wireEvents = function () {\n    /*! Find the Events type */\n    var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';\n    /*! Bind the Event handler */\n\n    EventHandler.add(this.element, Browser.touchStartEvent, this.chartOnMouseDown, this);\n    EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);\n    EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);\n    EventHandler.add(this.element, 'click', this.chartOnMouseClick, this);\n    EventHandler.add(this.element, 'contextmenu', this.chartRightClick, this);\n    EventHandler.add(this.element, cancelEvent, this.mouseLeave, this);\n    this.resizeBound = this.chartResize.bind(this);\n    window.addEventListener(Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.resizeBound);\n    this.longPressBound = this.longPress.bind(this);\n    this.touchObject = new Touch(this.element, {\n      tapHold: this.longPressBound,\n      tapHoldThreshold: 500\n    });\n    /*! Apply the style for chart */\n\n    this.setStyle(this.element);\n  };\n\n  Chart.prototype.chartRightClick = function (event) {\n    if (this.crosshair.enable && this.crosshairModule && (event.buttons === 2 || event.which === 0 || event.pointerType === 'touch')) {\n      event.preventDefault();\n      event.stopPropagation();\n      return false;\n    }\n\n    return true;\n  };\n\n  Chart.prototype.setStyle = function (element) {\n    var zooming = this.zoomSettings;\n    var disableScroll = zooming.enableSelectionZooming || zooming.enablePinchZooming || this.selectionMode !== 'None' || this.crosshair.enable;\n    element.style.touchAction = disableScroll ? 'none' : 'element';\n    element.style.msTouchAction = disableScroll ? 'none' : 'element';\n    element.style.msContentZooming = 'none';\n    element.style.msUserSelect = 'none';\n    element.style.webkitUserSelect = 'none';\n    element.style.position = 'relative';\n    element.style.display = 'block'; // To fix angular and react tooltip div scrollbar issue\n\n    element.style.overflow = 'hidden';\n  };\n  /**\n   * Finds the orientation.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.isOrientation = function () {\n    return 'orientation' in window && 'onorientationchange' in window;\n  };\n  /**\n   * Handles the long press on chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.longPress = function (e) {\n    this.mouseX = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientX : 0;\n    this.mouseY = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientY : 0;\n    this.startMove = true;\n    this.setMouseXY(this.mouseX, this.mouseY);\n    this.notify('tapHold', e);\n    return false;\n  };\n  /**\n   * To find mouse x, y for aligned chart element svg position\n   */\n\n\n  Chart.prototype.setMouseXY = function (pageX, pageY) {\n    var svgRect = getElement(this.svgId).getBoundingClientRect();\n    var rect = this.element.getBoundingClientRect();\n    this.mouseY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);\n    this.mouseX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);\n  };\n  /**\n   * Export method for the chart.\n   */\n\n\n  Chart.prototype.export = function (type, fileName) {\n    if (this.exportModule) {\n      this.exportModule.export(type, fileName);\n    }\n  };\n  /**\n   * Handles the chart resize.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.chartResize = function (e) {\n    var _this = this;\n\n    this.animateSeries = false;\n    var arg = {\n      chart: this.isBlazor ? {} : this,\n      name: resized,\n      currentSize: new Size(0, 0),\n      previousSize: new Size(this.availableSize.width, this.availableSize.height)\n    };\n\n    if (this.resizeTo) {\n      clearTimeout(this.resizeTo);\n    }\n\n    this.resizeTo = setTimeout(function () {\n      if (_this.isDestroyed || _this.stockChart) {\n        clearTimeout(_this.resizeTo);\n        return;\n      }\n\n      _this.createChartSvg();\n\n      arg.currentSize = _this.availableSize;\n\n      _this.trigger(resized, arg);\n\n      _this.refreshAxis();\n\n      _this.refreshBound();\n\n      _this.trigger('loaded', {\n        chart: _this.isBlazor ? {} : _this\n      });\n    }, 500);\n    return false;\n  };\n  /**\n   * Handles the mouse move.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.mouseMove = function (e) {\n    var pageX;\n    var pageY;\n    var touchArg;\n\n    if (e.type === 'touchmove') {\n      this.isTouch = true;\n      touchArg = e;\n      pageX = touchArg.changedTouches[0].clientX;\n      pageY = touchArg.changedTouches[0].clientY;\n    } else {\n      this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;\n      pageX = e.clientX;\n      pageY = e.clientY;\n    }\n\n    this.setMouseXY(pageX, pageY);\n    this.chartOnMouseMove(e);\n    return false;\n  };\n  /**\n   * Handles the mouse leave.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.mouseLeave = function (e) {\n    var pageX;\n    var pageY;\n    var touchArg;\n\n    if (e.type === 'touchleave') {\n      this.isTouch = true;\n      touchArg = e;\n      pageX = touchArg.changedTouches[0].clientX;\n      pageY = touchArg.changedTouches[0].clientY;\n    } else {\n      this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';\n      pageX = e.clientX;\n      pageY = e.clientY;\n    }\n\n    this.setMouseXY(pageX, pageY);\n    this.chartOnMouseLeave(e);\n    return false;\n  };\n  /**\n   * Handles the mouse leave on chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.chartOnMouseLeave = function (e) {\n    var element = e.target;\n    var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';\n    this.trigger(chartMouseLeave, {\n      target: element.id,\n      x: this.mouseX,\n      y: this.mouseY\n    });\n    this.isChartDrag = this.isPointMouseDown = false;\n    this.notify(cancelEvent, e);\n    return false;\n  };\n  /**\n   * Handles the mouse click on chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.chartOnMouseClick = function (e) {\n    var element = e.target;\n    this.trigger(chartMouseClick, {\n      target: element.id,\n      x: this.mouseX,\n      y: this.mouseY\n    });\n\n    if (this.pointClick) {\n      this.triggerPointEvent(pointClick);\n    }\n\n    this.notify('click', e);\n    return false;\n  };\n\n  Chart.prototype.triggerPointEvent = function (event) {\n    var data = new ChartData(this);\n    var pointData = data.getData();\n\n    if (pointData.series && pointData.point) {\n      this.trigger(event, {\n        series: this.isBlazor ? {} : pointData.series,\n        point: pointData.point,\n        seriesIndex: pointData.series.index,\n        pointIndex: pointData.point.index,\n        x: this.mouseX,\n        y: this.mouseY\n      });\n    }\n  };\n  /**\n   * Handles the mouse move on chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.chartOnMouseMove = function (e) {\n    var element = e.target;\n    this.trigger(chartMouseMove, {\n      target: element.id,\n      x: this.mouseX,\n      y: this.mouseY\n    });\n\n    if (this.pointMove) {\n      this.triggerPointEvent(pointMove);\n    } // Tooltip for chart series.\n\n\n    if (!this.isTouch) {\n      this.titleTooltip(e, this.mouseX, this.mouseY);\n      this.axisTooltip(e, this.mouseX, this.mouseY);\n    }\n\n    if (this.dataEditingModule) {\n      this.dataEditingModule.pointMouseMove(e);\n    }\n\n    this.notify(Browser.touchMoveEvent, e);\n    this.isTouch = false;\n    return false;\n  };\n\n  Chart.prototype.titleTooltip = function (event, x, y, isTouch) {\n    var targetId = event.target.id;\n    var id = targetId === this.element.id + '_ChartTitle' || targetId === this.element.id + '_ChartSubTitle';\n\n    if (id && event.target.textContent.indexOf('...') > -1) {\n      var title = targetId === this.element.id + '_ChartTitle' ? this.title : this.subTitle;\n      showTooltip(title, x, y, this.element.offsetWidth, this.element.id + '_EJ2_Title_Tooltip', getElement(this.element.id + '_Secondary_Element'), isTouch);\n    } else {\n      removeElement(this.element.id + '_EJ2_Title_Tooltip');\n    }\n  };\n\n  Chart.prototype.axisTooltip = function (event, x, y, isTouch) {\n    var targetId = event.target.id;\n\n    if ((targetId.indexOf('AxisLabel') > -1 || targetId.indexOf('Axis_MultiLevelLabel') > -1) && event.target.textContent.indexOf('...') > -1) {\n      showTooltip(this.findAxisLabel(targetId), x, y, this.element.offsetWidth, this.element.id + '_EJ2_AxisLabel_Tooltip', getElement(this.element.id + '_Secondary_Element'), isTouch);\n    } else {\n      removeElement(this.element.id + '_EJ2_AxisLabel_Tooltip');\n    }\n  };\n\n  Chart.prototype.findAxisLabel = function (text) {\n    var texts;\n\n    if (text.indexOf('AxisLabel') > -1) {\n      texts = text.replace(this.element.id, '').replace('AxisLabel_', '').split('_');\n      return this.axisCollections[parseInt(texts[0], 10)].visibleLabels[parseInt(texts[1], 10)].originalText;\n    } else {\n      texts = text.replace(this.element.id, '').replace('Axis_MultiLevelLabel_Level_', '').replace('Text_', '').split('_');\n      return this.axisCollections[parseInt(texts[0], 10)].multiLevelLabels[parseInt(texts[1], 10)].categories[parseInt(texts[2], 10)].text;\n    }\n  };\n  /**\n   * Handles the mouse down on chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.chartOnMouseDown = function (e) {\n    var pageX;\n    var pageY;\n    var target;\n    var touchArg;\n    var offset = Browser.isDevice ? 20 : 30;\n    var rect = this.element.getBoundingClientRect();\n    var element = e.target;\n    this.trigger(chartMouseDown, {\n      target: element.id,\n      x: this.mouseX,\n      y: this.mouseY\n    });\n\n    if (e.type === 'touchstart') {\n      this.isTouch = true;\n      touchArg = e;\n      pageX = touchArg.changedTouches[0].clientX;\n      pageY = touchArg.changedTouches[0].clientY;\n      target = touchArg.target;\n    } else {\n      this.isTouch = e.pointerType === 'touch';\n      pageX = e.clientX;\n      pageY = e.clientY;\n      target = e.target;\n    }\n\n    var svgRect = getElement(this.svgId).getBoundingClientRect();\n    this.mouseDownX = this.previousMouseMoveX = pageX - rect.left - Math.max(svgRect.left - rect.left, 0);\n    this.mouseDownY = this.previousMouseMoveY = pageY - rect.top - Math.max(svgRect.top - rect.top, 0);\n\n    if (this.isTouch) {\n      this.isDoubleTap = new Date().getTime() < this.threshold && target.id.indexOf(this.element.id + '_Zooming_') === -1 && (this.mouseDownX - offset >= this.mouseX || this.mouseDownX + offset >= this.mouseX) && (this.mouseDownY - offset >= this.mouseY || this.mouseDownY + offset >= this.mouseY) && (this.mouseX - offset >= this.mouseDownX || this.mouseX + offset >= this.mouseDownX) && (this.mouseY - offset >= this.mouseDownY || this.mouseY + offset >= this.mouseDownY);\n    }\n\n    if (this.dataEditingModule) {\n      this.dataEditingModule.pointMouseDown();\n    }\n\n    this.notify(Browser.touchStartEvent, e);\n    return false;\n  };\n  /**\n   * Handles the mouse up.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.mouseEnd = function (e) {\n    var pageY;\n    var pageX;\n    var touchArg;\n\n    if (e.type === 'touchend') {\n      touchArg = e;\n      pageX = touchArg.changedTouches[0].clientX;\n      this.isTouch = true;\n      pageY = touchArg.changedTouches[0].clientY;\n    } else {\n      pageY = e.clientY;\n      pageX = e.clientX;\n      this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';\n    }\n\n    this.setMouseXY(pageX, pageY);\n    this.chartOnMouseUp(e);\n    return false;\n  };\n  /**\n   * Handles the mouse up.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.chartOnMouseUp = function (e) {\n    var element = e.target;\n    this.trigger(chartMouseUp, {\n      target: element.id,\n      x: this.mouseX,\n      y: this.mouseY\n    });\n    this.isChartDrag = false;\n\n    if (this.isTouch) {\n      this.titleTooltip(e, this.mouseX, this.mouseY, this.isTouch);\n      this.axisTooltip(e, this.mouseX, this.mouseY, this.isTouch);\n      this.threshold = new Date().getTime() + 300;\n    }\n\n    if (this.dataEditingModule) {\n      this.dataEditingModule.pointMouseUp();\n    }\n\n    if (!this.enableCanvas) {\n      this.seriesElements.removeAttribute('clip-path');\n    }\n\n    this.notify(Browser.touchEndEvent, e);\n    return false;\n  };\n  /**\n   * Method to set culture for chart\n   */\n\n\n  Chart.prototype.setCulture = function () {\n    this.intl = new Internationalization();\n    this.setLocaleConstants();\n    this.localeObject = new L10n(this.getModuleName(), this.defaultLocalConstants, this.locale);\n  };\n  /**\n   * Method to set the annotation content dynamically for chart.\n   */\n\n\n  Chart.prototype.setAnnotationValue = function (annotationIndex, content) {\n    var parentNode = getElement(this.element.id + '_Annotation_Collections');\n    var annotation = this.annotations[annotationIndex];\n    var element;\n\n    if (content !== null) {\n      annotation.content = content;\n\n      if (parentNode) {\n        removeElement(this.element.id + '_Annotation_' + annotationIndex);\n        element = this.createElement('div');\n        this.annotationModule.processAnnotation(annotation, annotationIndex, element);\n        parentNode.appendChild(element.children[0]);\n      } else {\n        this.annotationModule.renderAnnotations(getElement(this.element.id + '_Secondary_Element'));\n      }\n    }\n  };\n  /**\n   * Method to set locale constants\n   */\n\n\n  Chart.prototype.setLocaleConstants = function () {\n    this.defaultLocalConstants = {\n      ZoomIn: 'ZoomIn',\n      Zoom: 'Zoom',\n      ZoomOut: 'ZoomOut',\n      Pan: 'Pan',\n      Reset: 'Reset',\n      ResetZoom: 'Reset Zoom'\n    };\n  };\n  /**\n   * Theming for chart\n   */\n\n\n  Chart.prototype.setTheme = function () {\n    /*! Set theme */\n    this.themeStyle = getThemeColor(this.theme);\n  };\n  /**\n   * To provide the array of modules needed for control rendering\n   * @return {ModuleDeclaration[]}\n   * @private\n   */\n  //tslint:disable:max-func-body-length\n\n\n  Chart.prototype.requiredModules = function () {\n    var _this = this;\n\n    var modules = [];\n    var series = this.series;\n    var enableAnnotation = false;\n    var moduleName;\n    var errorBarVisible = false;\n    var isPointDrag = false;\n    var dataLabelEnable = false;\n    var zooming = this.zoomSettings;\n    this.chartAreaType = series.length > 0 && (series[0].type === 'Polar' || series[0].type === 'Radar') ? 'PolarRadar' : 'Cartesian';\n\n    if (this.tooltip.enable) {\n      modules.push({\n        member: 'Tooltip',\n        args: [this]\n      });\n    }\n\n    series.map(function (value) {\n      _this.isLegend = _this.legendSettings.visible && (value.name !== '' || !!_this.isLegend);\n      moduleName = value.type.indexOf('100') !== -1 ? value.type.replace('100', '') + 'Series' : value.type + 'Series';\n      errorBarVisible = value.errorBar.visible || errorBarVisible;\n      dataLabelEnable = value.marker.dataLabel.visible || dataLabelEnable;\n      isPointDrag = value.dragSettings.enable || isPointDrag;\n\n      if (!modules.some(function (currentModule) {\n        return currentModule.member === moduleName;\n      })) {\n        modules.push({\n          member: moduleName,\n          args: [_this, series]\n        });\n      }\n\n      if (_this.chartAreaType === 'PolarRadar') {\n        modules.push({\n          member: value.drawType + 'Series',\n          args: [_this, series]\n        });\n      }\n\n      if (value.type === 'Pareto') {\n        modules.push({\n          member: 'ColumnSeries',\n          args: [_this, series]\n        });\n        modules.push({\n          member: 'LineSeries',\n          args: [_this, series]\n        });\n      }\n    });\n    this.findIndicatorModules(modules);\n    this.findTrendLineModules(modules);\n    modules = this.findAxisModule(modules);\n    enableAnnotation = this.annotations.some(function (value) {\n      return value.content !== null;\n    });\n\n    if (errorBarVisible) {\n      modules.push({\n        member: 'ErrorBar',\n        args: [this, series]\n      });\n    }\n\n    if (this.isLegend) {\n      modules.push({\n        member: 'Legend',\n        args: [this]\n      });\n    }\n\n    if (this.enableExport) {\n      modules.push({\n        member: 'Export',\n        args: [this]\n      });\n    }\n\n    if (this.chartAreaType !== 'PolarRadar' && !this.scrollSettingEnabled && (zooming.enableSelectionZooming || zooming.enableMouseWheelZooming || zooming.enablePinchZooming || zooming.enablePan)) {\n      modules.push({\n        member: 'Zoom',\n        args: [this, this.zoomSettings]\n      });\n\n      if (zooming.enableScrollbar) {\n        modules.push({\n          member: 'ScrollBar',\n          args: [this]\n        });\n      }\n    }\n\n    if (this.selectionMode !== 'None' && !(this.chartAreaType === 'PolarRadar' && this.selectionMode.indexOf('Drag') > -1)) {\n      modules.push({\n        member: 'Selection',\n        args: [this]\n      });\n    }\n\n    if (dataLabelEnable) {\n      modules.push({\n        member: 'DataLabel',\n        args: [this, series]\n      });\n    }\n\n    if (isPointDrag) {\n      modules.push({\n        member: 'DataEditing',\n        args: [this]\n      });\n    }\n\n    if (enableAnnotation) {\n      modules.push({\n        member: 'Annotation',\n        args: [this]\n      });\n    }\n\n    if (this.chartAreaType !== 'PolarRadar' && this.crosshair.enable) {\n      modules.push({\n        member: 'Crosshair',\n        args: [this]\n      });\n    }\n\n    return modules;\n  };\n\n  Chart.prototype.findAxisModule = function (modules) {\n    var axisCollections = [];\n    axisCollections.push(this.primaryXAxis);\n    axisCollections.push(this.primaryYAxis);\n    axisCollections = axisCollections.concat(this.axes);\n    var datetimeEnabled = false;\n    var categoryEnabled = false;\n    var logarithmicEnabled = false;\n    var striplineEnabled = false;\n    var dateTimeCategoryEnabled = false;\n    var multiLevelEnabled = false;\n\n    for (var _i = 0, axisCollections_1 = axisCollections; _i < axisCollections_1.length; _i++) {\n      var axis = axisCollections_1[_i];\n      datetimeEnabled = axis.valueType === 'DateTime' || datetimeEnabled;\n      categoryEnabled = axis.valueType === 'Category' || categoryEnabled;\n      logarithmicEnabled = axis.valueType === 'Logarithmic' || logarithmicEnabled;\n      dateTimeCategoryEnabled = axis.valueType === 'DateTimeCategory' || dateTimeCategoryEnabled;\n      striplineEnabled = this.findStriplineVisibility(axis.stripLines) || striplineEnabled;\n      multiLevelEnabled = axis.multiLevelLabels.length > 0 || multiLevelEnabled;\n      this.scrollSettingEnabled = axis.scrollbarSettings.enable ? true : this.scrollSettingEnabled;\n    }\n\n    if (datetimeEnabled) {\n      modules.push({\n        member: 'DateTime',\n        args: [this]\n      });\n    }\n\n    if (categoryEnabled) {\n      modules.push({\n        member: 'Category',\n        args: [this]\n      });\n    }\n\n    if (logarithmicEnabled) {\n      modules.push({\n        member: 'Logarithmic',\n        args: [this]\n      });\n    }\n\n    if (striplineEnabled) {\n      modules.push({\n        member: 'StripLine',\n        args: [this]\n      });\n    }\n\n    if (multiLevelEnabled) {\n      modules.push({\n        member: 'MultiLevelLabel',\n        args: [this]\n      });\n    }\n\n    if (dateTimeCategoryEnabled) {\n      modules.push({\n        member: 'DateTimeCategory',\n        args: [this]\n      });\n    }\n\n    if (this.scrollSettingEnabled) {\n      modules.push({\n        member: 'ScrollBar',\n        args: [this]\n      });\n    }\n\n    return modules;\n  };\n\n  Chart.prototype.findIndicatorModules = function (modules) {\n    var macdEnable;\n    var bandEnable;\n    var indicators = this.indicators;\n\n    if (this.indicators.length) {\n      modules.push({\n        member: 'LineSeries',\n        args: [this]\n      });\n      indicators.map(function (indicator) {\n        macdEnable = macdEnable || indicator.type === 'Macd';\n        bandEnable = bandEnable || indicator.type === 'BollingerBands';\n      });\n\n      if (macdEnable) {\n        modules.push({\n          member: 'ColumnSeries',\n          args: [this]\n        });\n      }\n\n      if (bandEnable) {\n        modules.push({\n          member: 'RangeAreaSeries',\n          args: [this]\n        });\n      }\n\n      for (var _i = 0, _a = this.indicators; _i < _a.length; _i++) {\n        var indicator = _a[_i];\n        modules.push({\n          member: indicator.type + 'Indicator',\n          args: [this]\n        });\n      }\n    }\n  };\n\n  Chart.prototype.findTrendLineModules = function (modules) {\n    var isLine;\n    var isSpline;\n\n    var _loop_1 = function (series) {\n      var markerEnable;\n      series.trendlines.map(function (trendline) {\n        markerEnable = markerEnable || trendline.marker.visible;\n        isLine = isLine || trendline.type === 'Linear' || trendline.type === 'MovingAverage' ? true : false;\n        isSpline = isSpline || !isLine ? true : false;\n      });\n\n      if (markerEnable) {\n        modules.push({\n          member: 'Marker',\n          args: [this_1, series]\n        });\n      }\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, _a = this.series; _i < _a.length; _i++) {\n      var series = _a[_i];\n\n      _loop_1(series);\n    }\n\n    if (isLine || isSpline) {\n      modules.push({\n        member: 'TrendLine',\n        args: [this]\n      });\n    }\n\n    if (isLine) {\n      modules.push({\n        member: 'LineSeries',\n        args: [this]\n      });\n    }\n\n    if (isSpline) {\n      modules.push({\n        member: 'SplineSeries',\n        args: [this]\n      });\n    }\n  };\n\n  Chart.prototype.findStriplineVisibility = function (striplines) {\n    var visible = false;\n\n    for (var _i = 0, striplines_1 = striplines; _i < striplines_1.length; _i++) {\n      var stripline = striplines_1[_i];\n\n      if (stripline.visible) {\n        visible = true;\n        break;\n      }\n    }\n\n    return visible;\n  };\n  /**\n   * To Remove the SVG.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.removeSvg = function () {\n    if (this.redraw) {\n      return null;\n    }\n\n    blazorTemplatesReset(this);\n\n    if (this.enableCanvas && this.svgObject && this.svgObject.tagName === 'CANVAS') {\n      this.renderer.clearRect(new Rect(0, 0, this.availableSize.width, this.availableSize.height));\n      remove(this.svgObject);\n      return null;\n    }\n\n    removeElement(this.element.id + '_Secondary_Element');\n    var removeLength = 0;\n\n    if (this.zoomModule && this.zoomModule.pinchTarget) {\n      this.zoomModule.pinchTarget.id = '';\n      this.zoomModule.pinchTarget.setAttribute('opacity', '0');\n      this.svgObject.appendChild(this.zoomModule.pinchTarget);\n      removeLength = 1;\n    }\n\n    if (this.svgObject) {\n      while (this.svgObject.childNodes.length > removeLength) {\n        this.svgObject.removeChild(this.svgObject.firstChild);\n      }\n\n      if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode && !this.stockChart) {\n        remove(this.svgObject);\n      }\n    }\n  };\n\n  Chart.prototype.refreshDefinition = function (definitions) {\n    for (var _i = 0, definitions_1 = definitions; _i < definitions_1.length; _i++) {\n      var item = definitions_1[_i];\n      item.axes = [];\n    }\n  };\n  /**\n   * Refresh the axis default value.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Chart.prototype.refreshAxis = function () {\n    var axis = this.primaryXAxis;\n    axis.rect = new Rect(undefined, undefined, 0, 0);\n    axis = this.primaryYAxis;\n    axis.isStack100 = false;\n    axis.rect = new Rect(undefined, undefined, 0, 0);\n\n    for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {\n      var item = _a[_i];\n      axis = item;\n      axis.rect = new Rect(undefined, undefined, 0, 0);\n      axis.isStack100 = false;\n    }\n\n    if (this.paretoSeriesModule && this.series[0].type === 'Pareto') {\n      for (var _b = 0, _c = this.paretoSeriesModule.paretoAxes; _b < _c.length; _b++) {\n        var item = _c[_b];\n        axis = item;\n        axis.rect = new Rect(undefined, undefined, 0, 0);\n        axis.isStack100 = false;\n      }\n    }\n  };\n\n  Chart.prototype.axisChange = function (axis) {\n    if (!axis.name && !axis.valueType) {\n      return false;\n    }\n\n    this.refreshDefinition(this.columns);\n    this.refreshDefinition(this.rows);\n    this.calculateVisibleAxis();\n    this.processData();\n    return true;\n  };\n  /**\n   * Get visible series by index\n   */\n\n\n  Chart.prototype.getVisibleSeries = function (visibleSeries, index) {\n    for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {\n      var series = visibleSeries_1[_i];\n\n      if (index === series.index) {\n        return series;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Clear visible Axis labels\n   */\n\n\n  Chart.prototype.clearVisibleAxisLabels = function () {\n    var axes = [this.primaryXAxis, this.primaryYAxis];\n    axes = this.chartAreaType === 'Cartesian' ? axes.concat(this.axes) : axes;\n\n    for (var i = 0, len = axes.length; i < len; i++) {\n      axes[i].labels = [];\n    }\n  };\n  /**\n   * Called internally if any of the property value changed.\n   * @private\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  Chart.prototype.onPropertyChanged = function (newProp, oldProp) {\n    var renderer = false;\n    var refreshBounds = false;\n\n    if (Object.keys(newProp).length === 1 && Object.keys(newProp)[0] === 'indicators') {\n      //add valid check,it should happen only when property change is triggered for target series\n      return;\n    }\n\n    this.animateSeries = false;\n\n    if (!this.delayRedraw) {\n      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n        var prop = _a[_i];\n\n        switch (prop) {\n          case 'primaryXAxis':\n            refreshBounds = this.axisChange(newProp.primaryXAxis);\n\n            if (newProp.primaryXAxis.edgeLabelPlacement) {\n              renderer = true;\n            }\n\n            if (!newProp.primaryXAxis.crosshairTooltip) {\n              refreshBounds = true;\n            }\n\n            break;\n\n          case 'primaryYAxis':\n            refreshBounds = this.axisChange(newProp.primaryYAxis);\n\n            if (newProp.primaryYAxis.edgeLabelPlacement) {\n              renderer = true;\n            }\n\n            if (!newProp.primaryYAxis.crosshairTooltip) {\n              refreshBounds = true;\n            }\n\n            break;\n\n          case 'axes':\n            for (var _b = 0, _c = Object.keys(newProp.axes); _b < _c.length; _b++) {\n              var index = _c[_b];\n              refreshBounds = refreshBounds || this.axisChange(newProp.axes[index]);\n\n              if (!newProp.axes[index].crosshairTooltip) {\n                refreshBounds = true;\n              }\n            }\n\n            break;\n\n          case 'height':\n          case 'width':\n            this.createChartSvg();\n            refreshBounds = true;\n            break;\n\n          case 'subTitle':\n          case 'title':\n            refreshBounds = true;\n            break;\n\n          case 'titleStyle':\n            if (newProp.titleStyle && (newProp.titleStyle.size || newProp.titleStyle.textOverflow)) {\n              refreshBounds = true;\n            } else {\n              renderer = true;\n            }\n\n            break;\n\n          case 'subTitleStyle':\n            if (newProp.subTitleStyle && (newProp.subTitleStyle.size || newProp.subTitleStyle.textOverflow)) {\n              refreshBounds = true;\n            } else {\n              renderer = true;\n            }\n\n            break;\n\n          case 'border':\n            renderer = true;\n            break;\n\n          case 'dataSource':\n            this.processData(false);\n            refreshBounds = true;\n            break;\n\n          case 'series':\n            var len = this.series.length;\n            var seriesRefresh = false;\n            var series = void 0;\n\n            for (var i = 0; i < len; i++) {\n              series = newProp.series[i];\n\n              if (series && (series.dataSource || series.xName || series.yName || series.size || series.high || series.low || series.open || series.close || series.fill || series.name)) {\n                extend(this.getVisibleSeries(this.visibleSeries, i), series, null, true);\n                seriesRefresh = true;\n              }\n            }\n\n            if (seriesRefresh) {\n              this.calculateVisibleSeries();\n              this.initTechnicalIndicators();\n              this.initTrendLines();\n              this.refreshDefinition(this.columns);\n              this.refreshDefinition(this.rows);\n              this.calculateVisibleAxis();\n              this.processData(false);\n              refreshBounds = true;\n            }\n\n            break;\n\n          case 'zoomSettings':\n            if (newProp.zoomSettings.enableScrollbar || oldProp.zoomSettings.enableScrollbar) {\n              refreshBounds = true;\n            }\n\n            renderer = true;\n            break;\n\n          case 'background':\n            renderer = true;\n            break;\n\n          case 'chartArea':\n            if (newProp.chartArea.border && newProp.chartArea.border.width) {\n              refreshBounds = true;\n            }\n\n            renderer = true;\n            break;\n\n          case 'legendSettings':\n            if (!newProp.legendSettings.background || !newProp.legendSettings.opacity) {\n              refreshBounds = true;\n            }\n\n            renderer = true;\n            break;\n\n          case 'palettes':\n            this.calculateVisibleSeries();\n            renderer = true;\n            break;\n\n          case 'selectedDataIndexes':\n          case 'selectionMode':\n            if (this.selectionModule && newProp.selectionMode && newProp.selectionMode.indexOf('Drag') === -1) {\n              this.selectionModule.redrawSelection(this, oldProp.selectionMode);\n            }\n\n            break;\n\n          case 'isMultiSelect':\n            if (this.selectionModule && !newProp.isMultiSelect && this.selectionModule.selectedDataIndexes.length > 1) {\n              this.selectionModule.redrawSelection(this, oldProp.selectionMode);\n            }\n\n            break;\n\n          case 'theme':\n            this.animateSeries = true;\n            break;\n\n          case 'locale':\n          case 'currencyCode':\n            _super.prototype.refresh.call(this);\n\n            break;\n\n          case 'tooltip':\n            this.tooltipModule.previousPoints = [];\n            break;\n        }\n      }\n\n      if (!refreshBounds && renderer) {\n        this.removeSvg();\n        this.renderElements();\n        this.trigger('loaded', {\n          chart: this.isBlazor ? {} : this\n        });\n      }\n\n      if (refreshBounds) {\n        this.enableCanvas ? this.createChartSvg() : this.removeSvg();\n        this.refreshAxis();\n        this.refreshBound();\n        this.trigger('loaded', {\n          chart: this.isBlazor ? {} : this\n        });\n        this.redraw = false;\n        this.animated = false;\n      }\n    }\n  };\n\n  __decorate([Property(null)], Chart.prototype, \"width\", void 0);\n\n  __decorate([Property(null)], Chart.prototype, \"height\", void 0);\n\n  __decorate([Property('')], Chart.prototype, \"title\", void 0);\n\n  __decorate([Property('')], Chart.prototype, \"dataSource\", void 0);\n\n  __decorate([Complex(Theme.chartTitleFont, Font)], Chart.prototype, \"titleStyle\", void 0);\n\n  __decorate([Property('')], Chart.prototype, \"subTitle\", void 0);\n\n  __decorate([Complex(Theme.chartSubTitleFont, Font)], Chart.prototype, \"subTitleStyle\", void 0);\n\n  __decorate([Complex({}, Margin)], Chart.prototype, \"margin\", void 0);\n\n  __decorate([Complex({\n    color: '#DDDDDD',\n    width: 0\n  }, Border)], Chart.prototype, \"border\", void 0);\n\n  __decorate([Property(null)], Chart.prototype, \"background\", void 0);\n\n  __decorate([Complex({\n    border: {\n      color: null,\n      width: 0.5\n    },\n    background: 'transparent'\n  }, ChartArea)], Chart.prototype, \"chartArea\", void 0);\n\n  __decorate([Complex({\n    name: 'primaryXAxis'\n  }, Axis)], Chart.prototype, \"primaryXAxis\", void 0);\n\n  __decorate([Complex({\n    name: 'primaryYAxis'\n  }, Axis)], Chart.prototype, \"primaryYAxis\", void 0);\n\n  __decorate([Collection([{}], Row)], Chart.prototype, \"rows\", void 0);\n\n  __decorate([Collection([{}], Column)], Chart.prototype, \"columns\", void 0);\n\n  __decorate([Collection([{}], Axis)], Chart.prototype, \"axes\", void 0);\n\n  __decorate([Collection([{}], Series)], Chart.prototype, \"series\", void 0);\n\n  __decorate([Collection([{}], ChartAnnotationSettings)], Chart.prototype, \"annotations\", void 0);\n\n  __decorate([Property([])], Chart.prototype, \"palettes\", void 0);\n\n  __decorate([Property('Material')], Chart.prototype, \"theme\", void 0);\n\n  __decorate([Complex({}, TooltipSettings)], Chart.prototype, \"tooltip\", void 0);\n\n  __decorate([Complex({}, CrosshairSettings)], Chart.prototype, \"crosshair\", void 0);\n\n  __decorate([Complex({}, LegendSettings)], Chart.prototype, \"legendSettings\", void 0);\n\n  __decorate([Complex({}, ZoomSettings)], Chart.prototype, \"zoomSettings\", void 0);\n\n  __decorate([Property('None')], Chart.prototype, \"selectionMode\", void 0);\n\n  __decorate([Property(false)], Chart.prototype, \"isMultiSelect\", void 0);\n\n  __decorate([Property(true)], Chart.prototype, \"enableExport\", void 0);\n\n  __decorate([Collection([], Indexes)], Chart.prototype, \"selectedDataIndexes\", void 0);\n\n  __decorate([Property(false)], Chart.prototype, \"useGroupingSeparator\", void 0);\n\n  __decorate([Property(false)], Chart.prototype, \"isTransposed\", void 0);\n\n  __decorate([Property(false)], Chart.prototype, \"enableCanvas\", void 0);\n\n  __decorate([Collection([], TechnicalIndicator)], Chart.prototype, \"indicators\", void 0);\n\n  __decorate([Property(true)], Chart.prototype, \"enableAnimation\", void 0);\n\n  __decorate([Property(null)], Chart.prototype, \"description\", void 0);\n\n  __decorate([Property(1)], Chart.prototype, \"tabIndex\", void 0);\n\n  __decorate([Property(true)], Chart.prototype, \"enableSideBySidePlacement\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"resized\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"annotationRender\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"beforePrint\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"loaded\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"load\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"animationComplete\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"legendRender\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"textRender\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"pointRender\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"seriesRender\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"axisLabelRender\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"axisRangeCalculated\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"axisMultiLabelRender\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"legendClick\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"multiLevelLabelClick\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"tooltipRender\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"chartMouseMove\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"chartMouseClick\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"pointClick\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"pointMove\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"chartMouseLeave\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"chartMouseDown\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"chartMouseUp\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"dragComplete\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"zoomComplete\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"scrollStart\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"scrollEnd\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"scrollChanged\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"dragStart\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"drag\", void 0);\n\n  __decorate([Event()], Chart.prototype, \"dragEnd\", void 0);\n\n  __decorate([Property('USD')], Chart.prototype, \"currencyCode\", void 0);\n\n  Chart = __decorate([NotifyPropertyChanges], Chart);\n  return Chart;\n}(Component);\n\nexport { Chart };","map":null,"metadata":{},"sourceType":"module"}