{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport Point from './point';\nimport { X, Y, TOP, BOTTOM, LEFT, RIGHT, CENTER, WIDTH, HEIGHT } from '../common/constants';\nimport { Class, defined, getSpacing, inArray, isArray, rad } from '../common';\n\nvar Box = function (Class) {\n  function Box(x1, y1, x2, y2) {\n    Class.call(this);\n    this.x1 = x1 || 0;\n    this.y1 = y1 || 0;\n    this.x2 = x2 || 0;\n    this.y2 = y2 || 0;\n  }\n\n  if (Class) Box.__proto__ = Class;\n  Box.prototype = Object.create(Class && Class.prototype);\n  Box.prototype.constructor = Box;\n\n  Box.prototype.equals = function equals(box) {\n    return this.x1 === box.x1 && this.x2 === box.x2 && this.y1 === box.y1 && this.y2 === box.y2;\n  };\n\n  Box.prototype.width = function width() {\n    return this.x2 - this.x1;\n  };\n\n  Box.prototype.height = function height() {\n    return this.y2 - this.y1;\n  };\n\n  Box.prototype.translate = function translate(dx, dy) {\n    this.x1 += dx;\n    this.x2 += dx;\n    this.y1 += dy;\n    this.y2 += dy;\n    return this;\n  };\n\n  Box.prototype.move = function move(x, y) {\n    var height = this.height();\n    var width = this.width();\n\n    if (defined(x)) {\n      this.x1 = x;\n      this.x2 = this.x1 + width;\n    }\n\n    if (defined(y)) {\n      this.y1 = y;\n      this.y2 = this.y1 + height;\n    }\n\n    return this;\n  };\n\n  Box.prototype.wrap = function wrap(targetBox) {\n    this.x1 = Math.min(this.x1, targetBox.x1);\n    this.y1 = Math.min(this.y1, targetBox.y1);\n    this.x2 = Math.max(this.x2, targetBox.x2);\n    this.y2 = Math.max(this.y2, targetBox.y2);\n    return this;\n  };\n\n  Box.prototype.wrapPoint = function wrapPoint(point) {\n    var arrayPoint = isArray(point);\n    var x = arrayPoint ? point[0] : point.x;\n    var y = arrayPoint ? point[1] : point.y;\n    this.wrap(new Box(x, y, x, y));\n    return this;\n  };\n\n  Box.prototype.snapTo = function snapTo(targetBox, axis) {\n    if (axis === X || !axis) {\n      this.x1 = targetBox.x1;\n      this.x2 = targetBox.x2;\n    }\n\n    if (axis === Y || !axis) {\n      this.y1 = targetBox.y1;\n      this.y2 = targetBox.y2;\n    }\n\n    return this;\n  };\n\n  Box.prototype.alignTo = function alignTo(targetBox, anchor) {\n    var height = this.height();\n    var width = this.width();\n    var axis = anchor === TOP || anchor === BOTTOM ? Y : X;\n    var offset = axis === Y ? height : width;\n\n    if (anchor === CENTER) {\n      var targetCenter = targetBox.center();\n      var center = this.center();\n      this.x1 += targetCenter.x - center.x;\n      this.y1 += targetCenter.y - center.y;\n    } else if (anchor === TOP || anchor === LEFT) {\n      this[axis + 1] = targetBox[axis + 1] - offset;\n    } else {\n      this[axis + 1] = targetBox[axis + 2];\n    }\n\n    this.x2 = this.x1 + width;\n    this.y2 = this.y1 + height;\n    return this;\n  };\n\n  Box.prototype.shrink = function shrink(dw, dh) {\n    this.x2 -= dw;\n    this.y2 -= dh;\n    return this;\n  };\n\n  Box.prototype.expand = function expand(dw, dh) {\n    this.shrink(-dw, -dh);\n    return this;\n  };\n\n  Box.prototype.pad = function pad(padding) {\n    var spacing = getSpacing(padding);\n    this.x1 -= spacing.left;\n    this.x2 += spacing.right;\n    this.y1 -= spacing.top;\n    this.y2 += spacing.bottom;\n    return this;\n  };\n\n  Box.prototype.unpad = function unpad(padding) {\n    var spacing = getSpacing(padding);\n    spacing.left = -spacing.left;\n    spacing.top = -spacing.top;\n    spacing.right = -spacing.right;\n    spacing.bottom = -spacing.bottom;\n    return this.pad(spacing);\n  };\n\n  Box.prototype.clone = function clone() {\n    return new Box(this.x1, this.y1, this.x2, this.y2);\n  };\n\n  Box.prototype.center = function center() {\n    return new Point(this.x1 + this.width() / 2, this.y1 + this.height() / 2);\n  };\n\n  Box.prototype.containsPoint = function containsPoint(point) {\n    return point.x >= this.x1 && point.x <= this.x2 && point.y >= this.y1 && point.y <= this.y2;\n  };\n\n  Box.prototype.points = function points() {\n    return [new Point(this.x1, this.y1), new Point(this.x2, this.y1), new Point(this.x2, this.y2), new Point(this.x1, this.y2)];\n  };\n\n  Box.prototype.getHash = function getHash() {\n    return [this.x1, this.y1, this.x2, this.y2].join(\",\");\n  };\n\n  Box.prototype.overlaps = function overlaps(box) {\n    return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);\n  };\n\n  Box.prototype.rotate = function rotate(rotation) {\n    var width = this.width();\n    var height = this.height();\n    var ref = this.center();\n    var cx = ref.x;\n    var cy = ref.y;\n    var r1 = rotatePoint(0, 0, cx, cy, rotation);\n    var r2 = rotatePoint(width, 0, cx, cy, rotation);\n    var r3 = rotatePoint(width, height, cx, cy, rotation);\n    var r4 = rotatePoint(0, height, cx, cy, rotation);\n    width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);\n    height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);\n    this.x2 = this.x1 + width;\n    this.y2 = this.y1 + height;\n    return this;\n  };\n\n  Box.prototype.toRect = function toRect() {\n    return new geom.Rect([this.x1, this.y1], [this.width(), this.height()]);\n  };\n\n  Box.prototype.hasSize = function hasSize() {\n    return this.width() !== 0 && this.height() !== 0;\n  };\n\n  Box.prototype.align = function align(targetBox, axis, alignment) {\n    var c1 = axis + 1;\n    var c2 = axis + 2;\n    var sizeFunc = axis === X ? WIDTH : HEIGHT;\n    var size = this[sizeFunc]();\n\n    if (inArray(alignment, [LEFT, TOP])) {\n      this[c1] = targetBox[c1];\n      this[c2] = this[c1] + size;\n    } else if (inArray(alignment, [RIGHT, BOTTOM])) {\n      this[c2] = targetBox[c2];\n      this[c1] = this[c2] - size;\n    } else if (alignment === CENTER) {\n      this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;\n      this[c2] = this[c1] + size;\n    }\n  };\n\n  return Box;\n}(Class);\n\nfunction rotatePoint(x, y, cx, cy, angle) {\n  var theta = rad(angle);\n  return new Point(cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta), cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta));\n}\n\nexport default Box;","map":null,"metadata":{},"sourceType":"module"}