{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport LineSegment from '../line-chart/line-segment';\nimport { append, deepExtend, isFunction, last } from '../../common';\n\nvar AreaSegment = function (LineSegment) {\n  function AreaSegment(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {\n    LineSegment.call(this, linePoints, currentSeries, seriesIx);\n    this.prevSegment = prevSegment;\n    this.stackPoints = stackPoints;\n  }\n\n  if (LineSegment) AreaSegment.__proto__ = LineSegment;\n  AreaSegment.prototype = Object.create(LineSegment && LineSegment.prototype);\n  AreaSegment.prototype.constructor = AreaSegment;\n\n  AreaSegment.prototype.createVisual = function createVisual() {\n    var series = this.series;\n    var defaults = series._defaults;\n    var lineOptions = series.line || {};\n    var color = series.color;\n\n    if (isFunction(color) && defaults) {\n      color = defaults.color;\n    }\n\n    this.visual = new draw.Group({\n      zIndex: series.zIndex\n    });\n    this.createFill({\n      fill: {\n        color: color,\n        opacity: series.opacity\n      },\n      stroke: null\n    });\n\n    if (lineOptions.width > 0 && lineOptions.visible !== false) {\n      this.createStroke({\n        stroke: deepExtend({\n          color: color,\n          opacity: series.opacity,\n          lineCap: \"butt\"\n        }, lineOptions)\n      });\n    }\n  };\n\n  AreaSegment.prototype.strokeSegments = function strokeSegments() {\n    var segments = this._strokeSegments;\n\n    if (!segments) {\n      segments = this._strokeSegments = this.createStrokeSegments();\n    }\n\n    return segments;\n  };\n\n  AreaSegment.prototype.createStrokeSegments = function createStrokeSegments() {\n    return this.segmentsFromPoints(this.points());\n  };\n\n  AreaSegment.prototype.stackSegments = function stackSegments() {\n    if (this.prevSegment) {\n      return this.prevSegment.createStackSegments(this.stackPoints);\n    }\n\n    return this.createStackSegments(this.stackPoints);\n  };\n\n  AreaSegment.prototype.createStackSegments = function createStackSegments(stackPoints) {\n    return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();\n  };\n\n  AreaSegment.prototype.segmentsFromPoints = function segmentsFromPoints(points) {\n    return points.map(function (point) {\n      return new geom.Segment(point);\n    });\n  };\n\n  AreaSegment.prototype.createStroke = function createStroke(style) {\n    var stroke = new draw.Path(style);\n    stroke.segments.push.apply(stroke.segments, this.strokeSegments());\n    this.visual.append(stroke);\n  };\n\n  AreaSegment.prototype.hasStackSegment = function hasStackSegment() {\n    return this.prevSegment || this.stackPoints && this.stackPoints.length;\n  };\n\n  AreaSegment.prototype.createFill = function createFill(style) {\n    var strokeSegments = this.strokeSegments();\n    var fillSegments = strokeSegments.slice(0);\n    var hasStackSegments = this.hasStackSegment();\n\n    if (hasStackSegments) {\n      var stackSegments = this.stackSegments();\n      append(fillSegments, stackSegments);\n    }\n\n    var fill = new draw.Path(style);\n    fill.segments.push.apply(fill.segments, fillSegments);\n\n    if (!hasStackSegments && strokeSegments.length > 1) {\n      this.fillToAxes(fill);\n    }\n\n    this.visual.append(fill);\n  };\n\n  AreaSegment.prototype.fillToAxes = function fillToAxes(fillPath) {\n    var chart = this.parent;\n    var invertAxes = chart.options.invertAxes;\n    var valueAxis = chart.seriesValueAxis(this.series);\n    var crossingValue = chart.categoryAxisCrossingValue(valueAxis);\n    var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);\n    var segments = this.strokeSegments();\n    var firstPoint = segments[0].anchor();\n    var lastPoint = last(segments).anchor();\n    var end = invertAxes ? endSlot.x1 : endSlot.y1;\n\n    if (invertAxes) {\n      fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);\n    } else {\n      fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);\n    }\n  };\n\n  return AreaSegment;\n}(LineSegment);\n\nexport default AreaSegment;","map":null,"metadata":{},"sourceType":"module"}