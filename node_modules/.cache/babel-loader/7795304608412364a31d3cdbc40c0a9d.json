{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Property, ChildProperty, Complex, Collection, getValue } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined, extend } from '@syncfusion/ej2-base';\nimport { StackValues, RectOption, appendChildElement, appendClipElement } from '../../common/utils/helper';\nimport { firstToLowerCase, CircleOption } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { Border, Font, Margin, Animation, EmptyPointSettings, CornerRadius, Connector, DragSettings } from '../../common/model/base';\nimport { DataManager, DataUtil } from '@syncfusion/ej2-data';\nimport { seriesRender } from '../../common/model/constants';\nimport { sort } from '../../common/utils/helper';\nimport { Browser } from '@syncfusion/ej2-base';\n/**\n * Configures the data label in the series.\n */\n\nvar DataLabelSettings =\n/** @class */\nfunction (_super) {\n  __extends(DataLabelSettings, _super);\n\n  function DataLabelSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(false)], DataLabelSettings.prototype, \"visible\", void 0);\n\n  __decorate([Property(null)], DataLabelSettings.prototype, \"name\", void 0);\n\n  __decorate([Property('transparent')], DataLabelSettings.prototype, \"fill\", void 0);\n\n  __decorate([Property(1)], DataLabelSettings.prototype, \"opacity\", void 0);\n\n  __decorate([Property('Auto')], DataLabelSettings.prototype, \"position\", void 0);\n\n  __decorate([Property(5)], DataLabelSettings.prototype, \"rx\", void 0);\n\n  __decorate([Property(5)], DataLabelSettings.prototype, \"ry\", void 0);\n\n  __decorate([Property('Center')], DataLabelSettings.prototype, \"alignment\", void 0);\n\n  __decorate([Complex({\n    width: null,\n    color: null\n  }, Border)], DataLabelSettings.prototype, \"border\", void 0);\n\n  __decorate([Complex({\n    left: 5,\n    right: 5,\n    top: 5,\n    bottom: 5\n  }, Margin)], DataLabelSettings.prototype, \"margin\", void 0);\n\n  __decorate([Complex({\n    size: '11px',\n    color: '',\n    fontStyle: 'Normal',\n    fontWeight: 'Normal',\n    fontFamily: 'Segoe UI'\n  }, Font)], DataLabelSettings.prototype, \"font\", void 0);\n\n  __decorate([Property(null)], DataLabelSettings.prototype, \"template\", void 0);\n\n  return DataLabelSettings;\n}(ChildProperty);\n\nexport { DataLabelSettings };\n/**\n *  Configures the marker in the series.\n */\n\nvar MarkerSettings =\n/** @class */\nfunction (_super) {\n  __extends(MarkerSettings, _super);\n\n  function MarkerSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(false)], MarkerSettings.prototype, \"visible\", void 0);\n\n  __decorate([Property('Circle')], MarkerSettings.prototype, \"shape\", void 0);\n\n  __decorate([Property('')], MarkerSettings.prototype, \"imageUrl\", void 0);\n\n  __decorate([Property(5)], MarkerSettings.prototype, \"height\", void 0);\n\n  __decorate([Property(5)], MarkerSettings.prototype, \"width\", void 0);\n\n  __decorate([Complex({\n    width: 2,\n    color: null\n  }, Border)], MarkerSettings.prototype, \"border\", void 0);\n\n  __decorate([Property(null)], MarkerSettings.prototype, \"fill\", void 0);\n\n  __decorate([Property(1)], MarkerSettings.prototype, \"opacity\", void 0);\n\n  __decorate([Complex({}, DataLabelSettings)], MarkerSettings.prototype, \"dataLabel\", void 0);\n\n  return MarkerSettings;\n}(ChildProperty);\n\nexport { MarkerSettings };\n/**\n * Points model for the series.\n * @public\n */\n\nvar Points =\n/** @class */\nfunction () {\n  function Points() {\n    /** point symbol location */\n    this.symbolLocations = null;\n    /** point region */\n\n    this.regions = null;\n    /** point percentage value */\n\n    this.percentage = null;\n    /** point region data */\n\n    this.regionData = null;\n    /** point marker */\n\n    this.marker = {\n      visible: false\n    };\n  }\n\n  return Points;\n}();\n\nexport { Points };\n/**\n * Defines the behavior of the Trendlines\n */\n\nvar Trendline =\n/** @class */\nfunction (_super) {\n  __extends(Trendline, _super);\n\n  function Trendline() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** @private */\n\n\n    _this.clipRect = new Rect(0, 0, 0, 0);\n    return _this;\n  }\n  /** @private */\n\n\n  Trendline.prototype.setDataSource = function (series, chart) {\n    if (series) {\n      this.points = series.points;\n    }\n\n    var type = firstToLowerCase(this.type);\n    chart.trendLineModule.initDataSource(this, chart);\n    chart.visibleSeriesCount++;\n  };\n\n  __decorate([Property('')], Trendline.prototype, \"name\", void 0);\n\n  __decorate([Property('Linear')], Trendline.prototype, \"type\", void 0);\n\n  __decorate([Property(2)], Trendline.prototype, \"period\", void 0);\n\n  __decorate([Property(2)], Trendline.prototype, \"polynomialOrder\", void 0);\n\n  __decorate([Property(0)], Trendline.prototype, \"backwardForecast\", void 0);\n\n  __decorate([Property(0)], Trendline.prototype, \"forwardForecast\", void 0);\n\n  __decorate([Complex({}, Animation)], Trendline.prototype, \"animation\", void 0);\n\n  __decorate([Complex({}, MarkerSettings)], Trendline.prototype, \"marker\", void 0);\n\n  __decorate([Property(true)], Trendline.prototype, \"enableTooltip\", void 0);\n\n  __decorate([Property(null)], Trendline.prototype, \"intercept\", void 0);\n\n  __decorate([Property('')], Trendline.prototype, \"fill\", void 0);\n\n  __decorate([Property(1)], Trendline.prototype, \"width\", void 0);\n\n  __decorate([Property('SeriesType')], Trendline.prototype, \"legendShape\", void 0);\n\n  return Trendline;\n}(ChildProperty);\n\nexport { Trendline };\n/**\n * Configures Error bar in series.\n */\n\nvar ErrorBarCapSettings =\n/** @class */\nfunction (_super) {\n  __extends(ErrorBarCapSettings, _super);\n\n  function ErrorBarCapSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(1)], ErrorBarCapSettings.prototype, \"width\", void 0);\n\n  __decorate([Property(10)], ErrorBarCapSettings.prototype, \"length\", void 0);\n\n  __decorate([Property(null)], ErrorBarCapSettings.prototype, \"color\", void 0);\n\n  __decorate([Property(1)], ErrorBarCapSettings.prototype, \"opacity\", void 0);\n\n  return ErrorBarCapSettings;\n}(ChildProperty);\n\nexport { ErrorBarCapSettings };\n\nvar ChartSegment =\n/** @class */\nfunction (_super) {\n  __extends(ChartSegment, _super);\n\n  function ChartSegment() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(null)], ChartSegment.prototype, \"value\", void 0);\n\n  __decorate([Property(null)], ChartSegment.prototype, \"color\", void 0);\n\n  __decorate([Property('0')], ChartSegment.prototype, \"dashArray\", void 0);\n\n  return ChartSegment;\n}(ChildProperty);\n\nexport { ChartSegment };\n/**\n * Error bar settings\n * @public\n */\n\nvar ErrorBarSettings =\n/** @class */\nfunction (_super) {\n  __extends(ErrorBarSettings, _super);\n\n  function ErrorBarSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(false)], ErrorBarSettings.prototype, \"visible\", void 0);\n\n  __decorate([Property('Fixed')], ErrorBarSettings.prototype, \"type\", void 0);\n\n  __decorate([Property('Both')], ErrorBarSettings.prototype, \"direction\", void 0);\n\n  __decorate([Property('Vertical')], ErrorBarSettings.prototype, \"mode\", void 0);\n\n  __decorate([Property(null)], ErrorBarSettings.prototype, \"color\", void 0);\n\n  __decorate([Property(1)], ErrorBarSettings.prototype, \"verticalError\", void 0);\n\n  __decorate([Property(1)], ErrorBarSettings.prototype, \"width\", void 0);\n\n  __decorate([Property(1)], ErrorBarSettings.prototype, \"horizontalError\", void 0);\n\n  __decorate([Property(3)], ErrorBarSettings.prototype, \"verticalPositiveError\", void 0);\n\n  __decorate([Property(3)], ErrorBarSettings.prototype, \"verticalNegativeError\", void 0);\n\n  __decorate([Property(1)], ErrorBarSettings.prototype, \"horizontalPositiveError\", void 0);\n\n  __decorate([Property(1)], ErrorBarSettings.prototype, \"horizontalNegativeError\", void 0);\n\n  __decorate([Complex(null, ErrorBarCapSettings)], ErrorBarSettings.prototype, \"errorBarCap\", void 0);\n\n  return ErrorBarSettings;\n}(ChildProperty);\n\nexport { ErrorBarSettings };\n/**\n * Defines the common behavior of Series and Technical Indicators\n */\n\nvar SeriesBase =\n/** @class */\nfunction (_super) {\n  __extends(SeriesBase, _super);\n\n  function SeriesBase() {\n    /**\n     * The DataSource field that contains the x value.\n     * It is applicable for series and technical indicators\n     * @default ''\n     */\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** @private */\n\n\n    _this.currentViewData = [];\n    /** @private */\n\n    _this.clipRect = new Rect(0, 0, 0, 0);\n    /** @private */\n\n    _this.seriesType = 'XY';\n    return _this;\n  }\n  /**\n   * Process data for the series.\n   * @hidden\n   */\n\n\n  SeriesBase.prototype.processJsonData = function () {\n    var i = 0;\n    var point = new Points();\n    var xName = this instanceof Series && this.type === 'Histogram' ? 'x' : this.xName;\n    var textMappingName = this instanceof Series && this.marker.dataLabel.name ? this.marker.dataLabel.name : '';\n\n    if (this instanceof Series) {\n      if (this.type === 'Waterfall' || this.type === 'Histogram') {\n        this.currentViewData = this.chart[firstToLowerCase(this.type) + 'SeriesModule'].processInternalData(extend([], this.currentViewData, null, true), this);\n      }\n\n      if (this.category === 'Pareto') {\n        this.currentViewData = sort(extend([], this.currentViewData, null, true), [this.yName], true);\n\n        if (this.type === 'Line') {\n          this.currentViewData = this.chart.paretoSeriesModule.performCumulativeCalculation(this.currentViewData, this);\n        }\n      }\n    }\n\n    var len = Object.keys(this.currentViewData).length;\n    this.points = [];\n    this.xMin = Infinity;\n    this.xMax = -Infinity;\n    this.yMin = Infinity;\n    this.yMax = -Infinity;\n    this.sizeMax = -Infinity;\n    this.getSeriesType();\n\n    if (this.xAxis.valueType === 'Category') {\n      while (i < len) {\n        point = this.dataPoint(i, textMappingName, xName);\n        this.pushCategoryData(point, i, point.x);\n        this.pushData(point, i);\n        this.setEmptyPoint(point, i);\n        i++;\n      }\n    } else if (this.xAxis.valueType.indexOf('DateTime') > -1) {\n      var option = {\n        skeleton: 'full',\n        type: 'dateTime'\n      };\n      var dateParser = this.chart.intl.getDateParser(option);\n      var dateFormatter = this.chart.intl.getDateFormat(option);\n\n      while (i < len) {\n        point = this.dataPoint(i, textMappingName, xName);\n        point.x = new Date(DataUtil.parse.parseJson({\n          val: point.x\n        }).val);\n\n        if (this.xAxis.valueType === 'DateTime') {\n          point.xValue = Date.parse(dateParser(dateFormatter(point.x)));\n        } else {\n          this.pushCategoryData(point, i, Date.parse(dateParser(dateFormatter(point.x))).toString());\n        }\n\n        this.pushData(point, i);\n        this.setEmptyPoint(point, i);\n        i++;\n      }\n    } else {\n      while (i < len) {\n        point = this.dataPoint(i, textMappingName, xName);\n        point.xValue = point.x;\n        this.pushData(point, i);\n        this.setEmptyPoint(point, i);\n        i++;\n      }\n    }\n\n    if (this instanceof Series) {\n      if (this.type.indexOf('Spline') > -1 || this.drawType.indexOf('Spline') > -1 && this.chart.chartAreaType === 'PolarRadar') {\n        var isArea = this.type.indexOf('Area') > -1 || this.drawType === 'Area';\n        this.chart['spline' + (isArea ? 'Area' : '') + 'SeriesModule'].findSplinePoint(this);\n      }\n    }\n  };\n\n  SeriesBase.prototype.pushData = function (point, i) {\n    point.index = i;\n    point.yValue = point.y; // To find the min, max for the axis range.\n\n    this.xMin = Math.min(this.xMin, point.xValue);\n    this.xMax = Math.max(this.xMax, point.xValue);\n    this.xData.push(point.xValue);\n  };\n  /** @private */\n\n\n  SeriesBase.prototype.dataPoint = function (i, textMappingName, xName) {\n    var point;\n    this.points[i] = new Points();\n    point = this.points[i];\n    var currentViewData = this.currentViewData;\n    var getObjectValueByMappingString = this.enableComplexProperty ? getValue : this.getObjectValue;\n    point.x = getObjectValueByMappingString(xName, currentViewData[i]);\n    point.high = getObjectValueByMappingString(this.high, currentViewData[i]);\n    point.low = getObjectValueByMappingString(this.low, currentViewData[i]);\n    point.open = getObjectValueByMappingString(this.open, currentViewData[i]);\n    point.close = getObjectValueByMappingString(this.close, currentViewData[i]);\n    point.volume = getObjectValueByMappingString(this.volume, currentViewData[i]);\n    point.interior = getObjectValueByMappingString(this.pointColorMapping, currentViewData[i]);\n\n    if (this instanceof Series) {\n      point.y = getObjectValueByMappingString(this.yName, currentViewData[i]);\n      point.size = getObjectValueByMappingString(this.size, currentViewData[i]);\n      point.text = getObjectValueByMappingString(textMappingName, currentViewData[i]);\n      point.tooltip = getObjectValueByMappingString(this.tooltipMappingName, currentViewData[i]);\n    }\n\n    return point;\n  };\n\n  SeriesBase.prototype.getObjectValue = function (mappingName, data) {\n    return data[mappingName];\n  };\n  /**\n   * To set empty point value based on empty point mode\n   * @private\n   */\n\n\n  SeriesBase.prototype.setEmptyPoint = function (point, i) {\n    if (!this.findVisibility(point)) {\n      point.visible = true;\n      return null;\n    }\n\n    point.isEmpty = true;\n    var mode = this instanceof Series ? this.emptyPointSettings.mode : 'Drop';\n\n    switch (mode) {\n      case 'Zero':\n        point.visible = true;\n\n        if (this instanceof Series && this.seriesType.indexOf('HighLow') > -1) {\n          point.high = point.low = 0;\n\n          if (this.seriesType.indexOf('HighLowOpenClose') > -1) {\n            point.open = point.close = 0;\n          }\n        } else {\n          point.y = point.yValue = this.yData[i] = 0;\n        }\n\n        break;\n\n      case 'Average':\n        if (this instanceof Series) {\n          if (this.seriesType.indexOf('HighLow') > -1) {\n            point.high = isNullOrUndefined(point.high) || isNaN(+point.high) ? this.getAverage(this.high, i) : point.high;\n            point.low = isNullOrUndefined(point.low) || isNaN(+point.low) ? this.getAverage(this.low, i) : point.low;\n\n            if (this.seriesType.indexOf('HighLowOpenClose') > -1) {\n              point.open = isNullOrUndefined(point.open) || isNaN(+point.open) ? this.getAverage(this.open, i) : point.open;\n              point.close = isNullOrUndefined(point.close) || isNaN(+point.close) ? this.getAverage(this.close, i) : point.close;\n            }\n          } else {\n            point.y = point.yValue = this.yData[i] = this.getAverage(this.yName, i);\n          }\n        }\n\n        point.visible = true;\n        break;\n\n      case 'Drop':\n      case 'Gap':\n        this.yData[i] = null;\n        point.visible = false;\n        break;\n    }\n  };\n\n  SeriesBase.prototype.findVisibility = function (point) {\n    var type = this instanceof Series ? this.seriesType : 'HighLowOpenClose';\n    var yValues;\n\n    switch (type) {\n      case 'XY':\n        this.setXYMinMax(point.yValue);\n        this.yData.push(point.yValue);\n\n        if (this instanceof Series && this.type === 'Bubble') {\n          this.sizeMax = Math.max(this.sizeMax, isNullOrUndefined(point.size) || isNaN(+point.size) ? this.sizeMax : point.size);\n        }\n\n        return isNullOrUndefined(point.x) || isNullOrUndefined(point.y) || isNaN(+point.y);\n\n      case 'HighLow':\n        this.setHiloMinMax(point.high, point.low);\n        return isNullOrUndefined(point.x) || isNullOrUndefined(point.low) || isNaN(+point.low) || isNullOrUndefined(point.high) || isNaN(+point.high);\n\n      case 'HighLowOpenClose':\n        this.setHiloMinMax(point.high, point.low);\n        return isNullOrUndefined(point.x) || isNullOrUndefined(point.low) || isNaN(+point.low) || isNullOrUndefined(point.open) || isNaN(+point.open) || isNullOrUndefined(point.close) || isNaN(+point.close) || isNullOrUndefined(point.high) || isNaN(+point.high);\n\n      case 'BoxPlot':\n        yValues = (point.y || [null]).filter(function (value) {\n          return !isNullOrUndefined(value) && !isNaN(value);\n        }).sort(function (a, b) {\n          return a - b;\n        });\n        point.y = yValues;\n        this.yMin = Math.min(this.yMin, Math.min.apply(Math, yValues));\n        this.yMax = Math.max(this.yMax, Math.max.apply(Math, yValues));\n        return !yValues.length;\n    }\n  };\n  /**\n   * To get Y min max for the provided point seriesType XY\n   */\n\n\n  SeriesBase.prototype.setXYMinMax = function (yValue) {\n    this.yMin = Math.min(this.yMin, isNullOrUndefined(yValue) || isNaN(yValue) ? this.yMin : yValue);\n    this.yMax = Math.max(this.yMax, isNullOrUndefined(yValue) || isNaN(yValue) ? this.yMax : yValue);\n  };\n  /**\n   * To get Y min max for the provided point seriesType XY\n   */\n\n\n  SeriesBase.prototype.setHiloMinMax = function (high, low) {\n    this.yMin = Math.min(this.yMin, Math.min(isNullOrUndefined(low) || isNaN(low) ? this.yMin : low, isNullOrUndefined(high) || isNaN(high) ? this.yMin : high));\n    this.yMax = Math.max(this.yMax, Math.max(isNullOrUndefined(low) || isNaN(low) ? this.yMax : low, isNullOrUndefined(high) || isNaN(high) ? this.yMax : high));\n  };\n  /**\n   * Finds the type of the series\n   * @private\n   */\n\n\n  SeriesBase.prototype.getSeriesType = function () {\n    var type;\n\n    if (this instanceof Series) {\n      var seriesType = this.chart.chartAreaType === 'PolarRadar' ? this.drawType : this.type;\n\n      if (seriesType) {\n        switch (seriesType) {\n          case 'RangeColumn':\n          case 'RangeArea':\n          case 'Hilo':\n            type = 'HighLow';\n            break;\n\n          case 'HiloOpenClose':\n          case 'Candle':\n            type = 'HighLowOpenClose';\n            break;\n\n          case 'BoxAndWhisker':\n            type = 'BoxPlot';\n            break;\n\n          default:\n            type = 'XY';\n        }\n      }\n    }\n\n    this.seriesType = type;\n  };\n  /** @private */\n\n\n  SeriesBase.prototype.pushCategoryData = function (point, index, pointX) {\n    if (!this.xAxis.isIndexed) {\n      if (this.xAxis.labels.indexOf(pointX) < 0) {\n        this.xAxis.labels.push(pointX);\n      }\n\n      point.xValue = this.xAxis.labels.indexOf(pointX);\n    } else {\n      this.xAxis.labels[index] ? this.xAxis.labels[index] += ', ' + pointX : this.xAxis.labels.push(pointX);\n      point.xValue = index;\n    }\n  };\n  /**\n   * To find average of given property\n   */\n\n\n  SeriesBase.prototype.getAverage = function (member, i, data) {\n    if (data === void 0) {\n      data = this.currentViewData;\n    }\n\n    var previous = data[i - 1] ? data[i - 1][member] || 0 : 0;\n    var next = data[i + 1] ? data[i + 1][member] || 0 : 0;\n    return (previous + next) / 2;\n  };\n  /**\n   * To find the control points for spline.\n   * @return {void}\n   * @private\n   */\n\n\n  SeriesBase.prototype.refreshDataManager = function (chart) {\n    var _this = this;\n\n    this.chart = chart;\n    var dateSource = this.dataSource || chart.dataSource;\n\n    if (!(dateSource instanceof DataManager) && isNullOrUndefined(this.query)) {\n      this.dataManagerSuccess({\n        result: dateSource,\n        count: dateSource.length\n      }, false);\n      return;\n    }\n\n    var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());\n    dataManager.then(function (e) {\n      return _this.dataManagerSuccess(e);\n    });\n  };\n\n  SeriesBase.prototype.dataManagerSuccess = function (e, isRemoteData) {\n    if (isRemoteData === void 0) {\n      isRemoteData = true;\n    }\n\n    this.currentViewData = e.count ? e.result : [];\n\n    if (this instanceof Series) {\n      if (this.chart.stockChart) {\n        this.chart.stockChart.series[this.index].localData = this.currentViewData;\n      }\n\n      var argsData = {\n        name: seriesRender,\n        series: this,\n        data: this.currentViewData,\n        fill: this.interior\n      };\n      this.chart.trigger(seriesRender, argsData);\n      this.interior = argsData.fill;\n      this.currentViewData = argsData.data;\n    }\n\n    if (this.chart.stockChart && !(this instanceof Series)) {\n      this.currentViewData = this.chart.stockChart.findCurrentData(this.chart.stockChart.series[0].localData, this.chart.stockChart.series[0].xName);\n    }\n\n    this.processJsonData();\n    this.recordsCount = e.count;\n    this.refreshChart(isRemoteData);\n    this.currentViewData = null;\n  };\n\n  SeriesBase.prototype.refreshChart = function (isRemoteData) {\n    var chart = this.chart;\n\n    if (this instanceof Series) {\n      chart.visibleSeriesCount += isRemoteData ? 1 : 0;\n    }\n\n    chart.refreshTechnicalIndicator(this);\n\n    if (this instanceof Series && this.category !== 'TrendLine') {\n      for (var _i = 0, _a = this.trendlines; _i < _a.length; _i++) {\n        var trendline = _a[_i];\n        trendline.setDataSource(this, chart);\n      }\n    } //if (chart.visibleSeries.length === (chart.visibleSeriesCount - chart.indicators.length)) {\n\n\n    if (chart.visibleSeries.length === chart.visibleSeriesCount) {\n      chart.refreshBound();\n      chart.trigger('loaded', {\n        chart: chart.isBlazor ? {} : chart\n      });\n\n      if (this.chart.stockChart && this.chart.stockChart.initialRender) {\n        this.chart.stockChart.stockChartDataManagerSuccess();\n        this.chart.stockChart.initialRender = false;\n      }\n    }\n\n    if (this instanceof Series) {\n      chart.visibleSeriesCount += isRemoteData ? 0 : 1;\n    }\n  };\n\n  __decorate([Property('')], SeriesBase.prototype, \"xName\", void 0);\n\n  __decorate([Property('')], SeriesBase.prototype, \"high\", void 0);\n\n  __decorate([Property('')], SeriesBase.prototype, \"low\", void 0);\n\n  __decorate([Property('')], SeriesBase.prototype, \"open\", void 0);\n\n  __decorate([Property('')], SeriesBase.prototype, \"close\", void 0);\n\n  __decorate([Property('')], SeriesBase.prototype, \"volume\", void 0);\n\n  __decorate([Property('')], SeriesBase.prototype, \"pointColorMapping\", void 0);\n\n  __decorate([Property(null)], SeriesBase.prototype, \"xAxisName\", void 0);\n\n  __decorate([Property(null)], SeriesBase.prototype, \"yAxisName\", void 0);\n\n  __decorate([Complex(null, Animation)], SeriesBase.prototype, \"animation\", void 0);\n\n  __decorate([Property(null)], SeriesBase.prototype, \"fill\", void 0);\n\n  __decorate([Property(1)], SeriesBase.prototype, \"width\", void 0);\n\n  __decorate([Property('0')], SeriesBase.prototype, \"dashArray\", void 0);\n\n  __decorate([Property('')], SeriesBase.prototype, \"dataSource\", void 0);\n\n  __decorate([Property()], SeriesBase.prototype, \"query\", void 0);\n\n  __decorate([Collection([], ChartSegment)], SeriesBase.prototype, \"segments\", void 0);\n\n  __decorate([Property('X')], SeriesBase.prototype, \"segmentAxis\", void 0);\n\n  __decorate([Property(false)], SeriesBase.prototype, \"enableComplexProperty\", void 0);\n\n  return SeriesBase;\n}(ChildProperty);\n\nexport { SeriesBase };\n/**\n * Configures the series in charts.\n * @public\n */\n\nvar Series =\n/** @class */\nfunction (_super) {\n  __extends(Series, _super); // tslint:disable-next-line:no-any\n\n\n  function Series(parent, propName, defaultValue, isArray) {\n    var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;\n\n    _this.visibleSeriesCount = 0;\n    /** @private */\n\n    _this.category = 'Series';\n    /** @private */\n\n    _this.isRectSeries = false;\n    /** @private */\n\n    _this.drawPoints = [];\n    /** @private */\n\n    _this.delayedAnimation = false;\n    return _this;\n  }\n  /**\n   * Refresh the axis label.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Series.prototype.refreshAxisLabel = function () {\n    if (this.xAxis.valueType !== 'Category') {\n      return null;\n    }\n\n    this.xAxis.labels = [];\n\n    for (var _i = 0, _a = this.xAxis.series; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (item.visible) {\n        item.xMin = Infinity;\n        item.xMax = -Infinity;\n\n        for (var _b = 0, _c = item.points; _b < _c.length; _b++) {\n          var point = _c[_b];\n          item.pushCategoryData(point, point.index, point.x);\n          item.xMin = Math.min(item.xMin, point.xValue);\n          item.xMax = Math.max(item.xMax, point.xValue);\n        }\n      }\n    }\n  };\n  /**\n   * To get the series collection.\n   * @return {void}\n   * @private\n   */\n\n\n  Series.prototype.findSeriesCollection = function (column, row, isStack) {\n    var seriesCollection = [];\n\n    for (var _i = 0, _a = row.axes; _i < _a.length; _i++) {\n      var rowAxis = _a[_i];\n\n      for (var _b = 0, _c = rowAxis.series; _b < _c.length; _b++) {\n        var rowSeries = _c[_b];\n\n        for (var _d = 0, _e = column.axes; _d < _e.length; _d++) {\n          var axis = _e[_d];\n\n          for (var _f = 0, _g = axis.series; _f < _g.length; _f++) {\n            var series = _g[_f];\n\n            if (series === rowSeries && series.visible && this.rectSeriesInChart(series, isStack)) {\n              seriesCollection.push(series);\n            }\n          }\n        }\n      }\n    }\n\n    return seriesCollection;\n  };\n  /**\n   * To get the column type series.\n   * @return {void}\n   * @private\n   */\n\n\n  Series.prototype.rectSeriesInChart = function (series, isStack) {\n    var type = series.type.toLowerCase();\n    return type.indexOf('column') !== -1 || type.indexOf('bar') !== -1 || type.indexOf('histogram') !== -1 || type.indexOf('hiloopenclose') !== -1 || type.indexOf('candle') !== -1 || type.indexOf('pareto') !== -1 || type.indexOf('hilo') !== -1 || series.drawType.indexOf('Column') !== -1 || type.indexOf('waterfall') !== -1 || type.indexOf('boxandwhisker') !== -1 || isStack;\n  };\n  /**\n   * To calculate the stacked values.\n   * @return {void}\n   * @private\n   */\n\n\n  Series.prototype.calculateStackedValue = function (isStacking100, chart) {\n    var axisSeries;\n\n    for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n      var columnItem = _a[_i];\n\n      for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {\n        var item = _c[_b];\n        this.calculateStackingValues(this.findSeriesCollection(columnItem, item, true), isStacking100);\n      }\n    }\n  };\n\n  Series.prototype.calculateStackingValues = function (seriesCollection, isStacking100) {\n    var startValues;\n    var endValues;\n    var yValues = [];\n    var lastPositive = [];\n    var lastNegative = [];\n    var stackingGroup;\n    var lastValue;\n    var value;\n    var frequencies = [];\n\n    if (isStacking100) {\n      frequencies = this.findFrequencies(seriesCollection);\n    }\n\n    var stackingSeies = [];\n    var stackedValues = [];\n\n    for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {\n      var series = seriesCollection_1[_i];\n\n      if (series.type.indexOf('Stacking') !== -1 || series.drawType.indexOf('Stacking') !== -1 && series.chart.chartAreaType === 'PolarRadar') {\n        stackingGroup = series.type.indexOf('StackingArea') !== -1 ? 'StackingArea100' : series.stackingGroup;\n\n        if (!lastPositive[stackingGroup]) {\n          lastPositive[stackingGroup] = [];\n          lastNegative[stackingGroup] = [];\n        }\n\n        yValues = series.yData;\n        startValues = [];\n        endValues = [];\n        stackingSeies.push(series);\n\n        for (var j = 0, pointsLength = series.points.length; j < pointsLength; j++) {\n          lastValue = 0;\n          value = +yValues[j]; // Fix for chart not rendering while y value is given as string issue\n\n          if (lastPositive[stackingGroup][series.points[j].xValue] === undefined) {\n            lastPositive[stackingGroup][series.points[j].xValue] = 0;\n          }\n\n          if (lastNegative[stackingGroup][series.points[j].xValue] === undefined) {\n            lastNegative[stackingGroup][series.points[j].xValue] = 0;\n          }\n\n          if (isStacking100) {\n            value = value / frequencies[stackingGroup][series.points[j].xValue] * 100;\n            value = !isNaN(value) ? value : 0;\n            series.points[j].percentage = +value.toFixed(2);\n          } else {\n            stackedValues[j] = stackedValues[j] ? stackedValues[j] + Math.abs(value) : Math.abs(value);\n          }\n\n          if (value >= 0) {\n            lastValue = lastPositive[stackingGroup][series.points[j].xValue];\n            lastPositive[stackingGroup][series.points[j].xValue] += value;\n          } else {\n            lastValue = lastNegative[stackingGroup][series.points[j].xValue];\n            lastNegative[stackingGroup][series.points[j].xValue] += value;\n          }\n\n          startValues.push(lastValue);\n          endValues.push(value + lastValue);\n\n          if (isStacking100 && endValues[j] > 100) {\n            endValues[j] = 100;\n          }\n        }\n\n        series.stackedValues = new StackValues(startValues, endValues);\n        series.yMin = Math.min.apply(0, startValues);\n        series.yMax = Math.max.apply(0, endValues);\n\n        if (series.yMin > Math.min.apply(0, endValues)) {\n          series.yMin = isStacking100 ? -100 : Math.min.apply(0, endValues);\n        }\n\n        if (series.yMax < Math.max.apply(0, startValues)) {\n          series.yMax = 0;\n        }\n      }\n    }\n\n    this.findPercentageOfStacking(stackingSeies, stackedValues, isStacking100);\n  };\n\n  Series.prototype.findPercentageOfStacking = function (stackingSeies, values, isStacking100) {\n    for (var _i = 0, stackingSeies_1 = stackingSeies; _i < stackingSeies_1.length; _i++) {\n      var item = stackingSeies_1[_i];\n\n      if (isStacking100) {\n        return null;\n      }\n\n      for (var _a = 0, _b = item.points; _a < _b.length; _a++) {\n        var point = _b[_a];\n        point.percentage = Math.abs(+(point.y / values[point.index] * 100).toFixed(2));\n      }\n    }\n  };\n\n  Series.prototype.findFrequencies = function (seriesCollection) {\n    var frequencies = [];\n    var stackingGroup;\n\n    for (var _i = 0, seriesCollection_2 = seriesCollection; _i < seriesCollection_2.length; _i++) {\n      var series = seriesCollection_2[_i];\n      series.yAxis.isStack100 = series.type.indexOf('100') !== -1 ? true : false;\n\n      if (series.type.indexOf('Stacking') !== -1) {\n        stackingGroup = series.type.indexOf('StackingArea') !== -1 ? 'StackingArea100' : series.stackingGroup;\n\n        if (!frequencies[stackingGroup]) {\n          frequencies[stackingGroup] = [];\n        }\n\n        for (var j = 0, pointsLength = series.points.length; j < pointsLength; j++) {\n          if (frequencies[stackingGroup][series.points[j].xValue] === undefined) {\n            frequencies[stackingGroup][series.points[j].xValue] = 0;\n          }\n\n          if (series.yData[j] > 0) {\n            frequencies[stackingGroup][series.points[j].xValue] += series.yData[j];\n          } else {\n            frequencies[stackingGroup][series.points[j].xValue] -= series.yData[j];\n          }\n        }\n      }\n    }\n\n    return frequencies;\n  };\n  /* private dataManagerFailure(e: { result: Object[] }): void {\n       this.currentViewData = [];\n       this.refreshChart();\n   }*/\n\n  /** @private */\n\n\n  Series.prototype.renderSeries = function (chart) {\n    var seriesType = firstToLowerCase(this.type);\n    seriesType = seriesType.replace('100', '');\n\n    if (chart[seriesType + 'SeriesModule']) {\n      if (this.category !== 'Indicator' && this.category !== 'TrendLine') {\n        this.createSeriesElements(chart);\n      }\n\n      chart[seriesType + 'SeriesModule'].render(this, this.xAxis, this.yAxis, chart.requireInvertedAxis);\n\n      if (this.category !== 'Indicator') {\n        if (this.errorBar.visible) {\n          this.chart.errorBarModule.render(this);\n        }\n\n        if (this.marker.dataLabel.visible) {\n          chart.dataLabelModule.render(this, this.chart, this.marker.dataLabel);\n        }\n\n        this.appendSeriesElement(chart.seriesElements, chart);\n      }\n\n      if (!this.chart.enableCanvas) {\n        this.performAnimation(chart, seriesType, this.errorBar, this.marker, this.marker.dataLabel);\n      }\n    }\n  };\n  /**\n   * To create seris element.\n   * @return {void}\n   * @private\n   */\n\n\n  Series.prototype.createSeriesElements = function (chart) {\n    if (this.category !== 'Indicator') {\n      var elementId = chart.element.id; // 8 for extend border value 5 for extend size value\n\n      var explodeValue = this.marker.border.width + 8 + 5;\n      var render = this.type === 'Scatter' || this.type === 'Bubble' ? chart.svgRenderer : chart.renderer;\n      var index = this.index === undefined ? this.category : this.index;\n      var markerHeight = this.type === 'Scatter' ? (this.marker.height + explodeValue) / 2 : 0;\n      var markerWidth = this.type === 'Scatter' ? (this.marker.width + explodeValue) / 2 : 0;\n      var options = void 0;\n\n      if (chart.chartAreaType === 'PolarRadar') {\n        var markerMaxValue = this.drawType === 'Scatter' ? Math.max(this.marker.width, this.marker.height) : 0;\n        options = new CircleOption(elementId + '_ChartSeriesClipRect_' + index, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, this.clipRect.width / 2 + this.clipRect.x, this.clipRect.height / 2 + this.clipRect.y, chart.radius + markerMaxValue);\n        this.clipRectElement = appendClipElement(chart.redraw, options, render, 'drawCircularClipPath');\n      } else {\n        options = new RectOption(elementId + '_ChartSeriesClipRect_' + index, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, {\n          x: -markerWidth,\n          y: -markerHeight,\n          width: this.clipRect.width + markerWidth * 2,\n          height: this.clipRect.height + markerHeight * 2\n        });\n        this.clipRectElement = appendClipElement(chart.redraw, options, render);\n      }\n\n      var transform = void 0;\n      transform = chart.chartAreaType === 'Cartesian' ? 'translate(' + this.clipRect.x + ',' + this.clipRect.y + ')' : '';\n      this.symbolElement = null;\n      this.seriesElement = render.createGroup({\n        'id': elementId + 'SeriesGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + elementId + '_ChartSeriesClipRect_' + index + ')'\n      });\n\n      if (!this.chart.enableCanvas || this.type === 'Scatter' || this.type === 'Bubble') {\n        this.seriesElement.appendChild(this.clipRectElement);\n      }\n    }\n  };\n  /**\n   * To append the series.\n   * @return {void}\n   * @private\n   */\n\n\n  Series.prototype.appendSeriesElement = function (element, chart) {\n    var marker = this.marker;\n    var dataLabel = marker.dataLabel;\n    var redraw = chart.redraw;\n\n    if (this.category !== 'TrendLine') {\n      appendChildElement(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);\n      var errorBar = this.errorBar;\n\n      if (errorBar.visible) {\n        if (chart.chartAreaType === 'PolarRadar') {\n          appendChildElement(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);\n        } else {\n          appendChildElement(chart.enableCanvas, chart.seriesElements, this.errorBarElement, redraw);\n        }\n      }\n\n      if (this.type === 'Scatter' || this.type === 'Bubble') {\n        appendChildElement(false, chart.seriesElements, this.seriesElement, redraw);\n      }\n    }\n\n    if (marker.visible && (chart.chartAreaType === 'Cartesian' || this.drawType !== 'Scatter' && chart.chartAreaType === 'PolarRadar') && this.type !== 'Scatter' && this.type !== 'Bubble' && this.type !== 'Candle' && this.type !== 'Hilo' && this.type !== 'HiloOpenClose') {\n      appendChildElement(chart.enableCanvas, chart.seriesElements, this.symbolElement, redraw);\n    }\n\n    if (dataLabel.visible) {\n      appendChildElement(chart.enableCanvas, chart.dataLabelElements, this.shapeElement, redraw);\n      appendChildElement(chart.enableCanvas, chart.dataLabelElements, this.textElement, redraw);\n    }\n\n    if (!chart.enableCanvas && chart.dataLabelElements.hasChildNodes()) {\n      chart.seriesElements.appendChild(chart.dataLabelElements);\n    }\n  };\n  /**\n   * To perform animation for chart series.\n   * @return {void}\n   * @private\n   */\n\n\n  Series.prototype.performAnimation = function (chart, type, errorBar, marker, dataLabel) {\n    if (this.animation.enable && chart.animateSeries) {\n      chart[type + 'SeriesModule'].doAnimation(this);\n\n      if (errorBar.visible) {\n        chart.errorBarModule.doErrorBarAnimation(this);\n      }\n\n      if (marker.visible) {\n        chart.markerRender.doMarkerAnimation(this);\n      } //to datalabel animation disabled for edge and IE\n\n\n      if (dataLabel.visible && Browser.info.name !== 'edge' && !Browser.isIE) {\n        chart.dataLabelModule.doDataLabelAnimation(this);\n      }\n    }\n  };\n  /**\n   * To set border color for empty point\n   * @private\n   */\n\n\n  Series.prototype.setPointColor = function (point, color) {\n    color = point.interior || color;\n    return point.isEmpty ? this.emptyPointSettings.fill || color : color;\n  };\n  /**\n   * To set border color for empty point\n   * @private\n   */\n\n\n  Series.prototype.setBorderColor = function (point, border) {\n    border.width = point.isEmpty ? this.emptyPointSettings.border.width || border.width : border.width;\n    border.color = point.isEmpty ? this.emptyPointSettings.border.color || border.color : border.color;\n    return border;\n  };\n\n  __decorate([Property('')], Series.prototype, \"name\", void 0);\n\n  __decorate([Property('')], Series.prototype, \"yName\", void 0);\n\n  __decorate([Property('Line')], Series.prototype, \"drawType\", void 0);\n\n  __decorate([Property(true)], Series.prototype, \"isClosed\", void 0);\n\n  __decorate([Property('#2ecd71')], Series.prototype, \"bearFillColor\", void 0);\n\n  __decorate([Property('#e74c3d')], Series.prototype, \"bullFillColor\", void 0);\n\n  __decorate([Property(false)], Series.prototype, \"enableSolidCandles\", void 0);\n\n  __decorate([Property('')], Series.prototype, \"size\", void 0);\n\n  __decorate([Property(null)], Series.prototype, \"binInterval\", void 0);\n\n  __decorate([Property(false)], Series.prototype, \"showNormalDistribution\", void 0);\n\n  __decorate([Property('')], Series.prototype, \"stackingGroup\", void 0);\n\n  __decorate([Property(true)], Series.prototype, \"visible\", void 0);\n\n  __decorate([Complex({\n    color: 'transparent',\n    width: 0\n  }, Border)], Series.prototype, \"border\", void 0);\n\n  __decorate([Property(1)], Series.prototype, \"opacity\", void 0);\n\n  __decorate([Property(0)], Series.prototype, \"zOrder\", void 0);\n\n  __decorate([Property('Line')], Series.prototype, \"type\", void 0);\n\n  __decorate([Complex(null, ErrorBarSettings)], Series.prototype, \"errorBar\", void 0);\n\n  __decorate([Complex(null, MarkerSettings)], Series.prototype, \"marker\", void 0);\n\n  __decorate([Complex({}, DragSettings)], Series.prototype, \"dragSettings\", void 0);\n\n  __decorate([Collection([], Trendline)], Series.prototype, \"trendlines\", void 0);\n\n  __decorate([Property(true)], Series.prototype, \"enableTooltip\", void 0);\n\n  __decorate([Property('')], Series.prototype, \"tooltipMappingName\", void 0);\n\n  __decorate([Property('SeriesType')], Series.prototype, \"legendShape\", void 0);\n\n  __decorate([Property(null)], Series.prototype, \"selectionStyle\", void 0);\n\n  __decorate([Property(1)], Series.prototype, \"minRadius\", void 0);\n\n  __decorate([Property(3)], Series.prototype, \"maxRadius\", void 0);\n\n  __decorate([Property('Natural')], Series.prototype, \"splineType\", void 0);\n\n  __decorate([Property(0.5)], Series.prototype, \"cardinalSplineTension\", void 0);\n\n  __decorate([Complex(null, EmptyPointSettings)], Series.prototype, \"emptyPointSettings\", void 0);\n\n  __decorate([Property(true)], Series.prototype, \"showMean\", void 0);\n\n  __decorate([Property('Normal')], Series.prototype, \"boxPlotMode\", void 0);\n\n  __decorate([Property(null)], Series.prototype, \"columnWidth\", void 0);\n\n  __decorate([Property(0)], Series.prototype, \"columnSpacing\", void 0);\n\n  __decorate([Property('#C64E4A')], Series.prototype, \"negativeFillColor\", void 0);\n\n  __decorate([Property('#4E81BC')], Series.prototype, \"summaryFillColor\", void 0);\n\n  __decorate([Property()], Series.prototype, \"intermediateSumIndexes\", void 0);\n\n  __decorate([Property()], Series.prototype, \"sumIndexes\", void 0);\n\n  __decorate([Complex({\n    color: 'black',\n    width: 2\n  }, Connector)], Series.prototype, \"connector\", void 0);\n\n  __decorate([Complex(null, CornerRadius)], Series.prototype, \"cornerRadius\", void 0);\n\n  return Series;\n}(SeriesBase);\n\nexport { Series };","map":null,"metadata":{},"sourceType":"module"}