{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { setDefaultOptions, deepExtend, limitValue } from '../../common';\nimport { ANGULAR_SPEED, DEGREE, DEFAULT_LINE_WIDTH, RADIAL_POINTER } from '../constants';\nimport Pointer from '../pointer';\nimport RadialPointerAnimation from './radial-pointer-animation';\nvar CAP_SIZE = 0.05;\nvar Circle = drawing.Circle;\nvar Group = drawing.Group;\nvar Path = drawing.Path;\n\nvar RadialPointer = function (Pointer) {\n  function RadialPointer() {\n    Pointer.apply(this, arguments);\n  }\n\n  if (Pointer) RadialPointer.__proto__ = Pointer;\n  RadialPointer.prototype = Object.create(Pointer && Pointer.prototype);\n  RadialPointer.prototype.constructor = RadialPointer;\n\n  RadialPointer.prototype.setAngle = function setAngle(angle) {\n    this.elements.transform(geo.transform().rotate(angle, this.center));\n  };\n\n  RadialPointer.prototype.repaint = function repaint() {\n    var ref = this;\n    var scale = ref.scale;\n    var options = ref.options;\n    var oldAngle = scale.slotAngle(options._oldValue);\n    var newAngle = scale.slotAngle(options.value);\n\n    if (options.animation.transitions === false) {\n      this.setAngle(newAngle);\n    } else {\n      new RadialPointerAnimation(this.elements, deepExtend(options.animation, {\n        oldAngle: oldAngle,\n        newAngle: newAngle\n      })).play();\n    }\n  };\n\n  RadialPointer.prototype.render = function render() {\n    var ref = this;\n    var scale = ref.scale;\n    var options = ref.options;\n    var elements = new Group();\n\n    if (options.animation !== false) {\n      deepExtend(options.animation, {\n        startAngle: 0,\n        center: scale.arc.center,\n        reverse: scale.options.reverse\n      });\n    }\n\n    elements.append(this._renderNeedle(), this._renderCap());\n    this.elements = elements;\n    this.setAngle(DEGREE);\n    return elements;\n  };\n\n  RadialPointer.prototype.reflow = function reflow(arc) {\n    var center = this.center = arc.center;\n    var length = limitValue(this.options.length || 1, 0.1, 1.5);\n    var radius = this.radius = arc.getRadiusX() * length;\n    var capSize = this.capSize = Math.round(radius * this.options.cap.size);\n    this.bbox = geo.Rect.fromPoints(new geo.Point(center.x - capSize, center.y - capSize), new geo.Point(center.x + capSize, center.y + capSize));\n  };\n\n  RadialPointer.prototype._renderNeedle = function _renderNeedle() {\n    var minorTickSize = this.scale.options.minorTicks.size;\n    var center = this.center;\n    var needleColor = this.options.color;\n    var needlePath = new Path({\n      fill: {\n        color: needleColor\n      },\n      stroke: {\n        color: needleColor,\n        width: DEFAULT_LINE_WIDTH\n      }\n    });\n    needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();\n    return needlePath;\n  };\n\n  RadialPointer.prototype._renderCap = function _renderCap() {\n    var options = this.options;\n    var capColor = options.cap.color || options.color;\n    var circle = new geo.Circle(this.center, this.capSize);\n    var cap = new Circle(circle, {\n      fill: {\n        color: capColor\n      },\n      stroke: {\n        color: capColor\n      }\n    });\n    return cap;\n  };\n\n  return RadialPointer;\n}(Pointer);\n\nsetDefaultOptions(RadialPointer, {\n  cap: {\n    size: CAP_SIZE\n  },\n  arrow: {\n    width: 16,\n    height: 14\n  },\n  animation: {\n    type: RADIAL_POINTER,\n    duration: ANGULAR_SPEED\n  }\n});\nexport default RadialPointer;","map":null,"metadata":{},"sourceType":"module"}