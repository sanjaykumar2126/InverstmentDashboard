{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * AccumulationChart DataLabel module file\n */\n\n\nimport { extend, createElement, getValue } from '@syncfusion/ej2-base';\nimport { Rect, PathOption, measureText, TextOption } from '@syncfusion/ej2-svg-base';\nimport { ChartLocation, degreeToLocation, isOverlap, stringToNumber, getAngle, appendChildElement } from '../../common/utils/helper';\nimport { textTrim, subtractThickness, Thickness, getElement } from '../../common/utils/helper';\nimport { removeElement, RectOption, textElement, showTooltip } from '../../common/utils/helper';\nimport { colorNameToHex, convertHexToColor, containsRect } from '../../common/utils/helper';\nimport { getSeriesFromIndex } from '../model/acc-base';\nimport { textRender } from '../../common/model/constants';\nimport { getFontStyle, createTemplate, measureElementRect, templateAnimate } from '../../common/utils/helper';\nimport { AccumulationBase } from './accumulation-base';\n/**\n * AccumulationDataLabel module used to render `dataLabel`.\n */\n\nvar AccumulationDataLabel =\n/** @class */\nfunction (_super) {\n  __extends(AccumulationDataLabel, _super);\n\n  function AccumulationDataLabel(accumulation) {\n    var _this = _super.call(this, accumulation) || this;\n\n    _this.id = accumulation.element.id + '_datalabel_Series_';\n\n    if (accumulation.title) {\n      var titleSize = measureText(accumulation.title, accumulation.titleStyle);\n      _this.titleRect = new Rect(accumulation.availableSize.width / 2 - titleSize.width / 2, accumulation.margin.top, titleSize.width, titleSize.height);\n    }\n\n    return _this;\n  }\n  /**\n   * Method to get datalabel text location.\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.getDataLabelPosition = function (point, dataLabel, textSize, points, parent, id) {\n    var radius = this.isCircular() ? !this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point) : this.getLabelDistance(point, dataLabel); //let radius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\n\n    this.getLabelRegion(point, dataLabel.position, textSize, radius, this.marginValue);\n    point.labelAngle = point.midAngle;\n    point.labelPosition = dataLabel.position;\n\n    if (this.accumulation.enableSmartLabels) {\n      this.getSmartLabel(point, dataLabel, textSize, points, parent, id);\n    }\n  };\n  /**\n   * Method to get datalabel bound.\n   */\n\n\n  AccumulationDataLabel.prototype.getLabelRegion = function (point, position, textSize, labelRadius, margin, endAngle) {\n    if (endAngle === void 0) {\n      endAngle = 0;\n    }\n\n    var labelAngle = endAngle || point.midAngle;\n    var space = 10;\n    var location = degreeToLocation(labelAngle, labelRadius, this.isCircular() ? this.center : this.getLabelLocation(point, position));\n    location.y = position === 'Inside' ? location.y - textSize.height / 2 : location.y;\n    location.x = position === 'Inside' ? location.x - textSize.width / 2 : location.x;\n    point.labelRegion = new Rect(location.x, location.y, textSize.width + margin * 2, textSize.height + margin * 2);\n\n    if (position === 'Outside') {\n      point.labelRegion.y -= point.labelRegion.height / 2;\n\n      if (labelAngle >= 90 && labelAngle <= 270) {\n        point.labelRegion.x -= point.labelRegion.width + space;\n      } else {\n        point.labelRegion.x += space;\n      }\n    }\n  };\n  /**\n   * Method to get datalabel smart position.\n   */\n\n\n  AccumulationDataLabel.prototype.getSmartLabel = function (point, dataLabel, textSize, points, parent, id) {\n    var circular = this.isCircular();\n    var labelRadius = circular ? this.radius : this.getLabelDistance(point, dataLabel);\n    var connectorLength = circular ? dataLabel.connectorStyle.length || '4%' : '0px';\n    labelRadius += stringToNumber(connectorLength, labelRadius);\n    var previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\n\n    if (dataLabel.position === 'Inside') {\n      if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points)) || !circular && !containsRect(point.region, point.labelRegion)) {\n        point.labelPosition = 'Outside';\n\n        if (!circular) {\n          labelRadius = this.getLabelDistance(point, dataLabel);\n        }\n\n        this.getLabelRegion(point, point.labelPosition, textSize, labelRadius, this.marginValue);\n        previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\n\n        if (previousPoint && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isConnectorLineOverlapping(point, previousPoint))) {\n          this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\n        }\n      }\n    } else {\n      if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\n        this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\n      }\n    }\n\n    if (this.isOverlapping(point, points) && (this.accumulation.type === 'Pyramid' || this.accumulation.type === 'Funnel')) {\n      var position = 'OutsideLeft';\n      var space = 10;\n      var labelAngle = point.midAngle || 0;\n      var labelRadius_1 = circular ? this.radius : this.getLabelDistance(point, dataLabel);\n      var location_1 = degreeToLocation(labelAngle, -labelRadius_1, this.isCircular() ? this.center : this.getLabelLocation(point, position));\n      point.labelRegion = new Rect(location_1.x, location_1.y, textSize.width + this.marginValue * 2, textSize.height + this.marginValue * 2);\n      point.labelRegion.y -= point.labelRegion.height / 2;\n      point.labelRegion.x = point.labelRegion.x - space - point.labelRegion.width;\n\n      if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\n        this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius_1, textSize, this.marginValue);\n      }\n    }\n\n    if (this.isOverlapping(point, points) || this.titleRect && point.labelRegion && isOverlap(point.labelRegion, this.titleRect)) {\n      this.setPointVisibileFalse(point);\n    }\n\n    if (this.accumulation.accumulationLegendModule && point.labelVisible && point.labelRegion) {\n      var rect = this.accumulation.accumulationLegendModule.legendBounds;\n      var padding = this.accumulation.legendSettings.border.width / 2;\n      this.textTrimming(point, new Rect(rect.x - padding, rect.y - padding, rect.width + 2 * padding, rect.height + 2 * padding), dataLabel.font, this.accumulation.accumulationLegendModule.position);\n    }\n\n    if (point.labelVisible && point.labelRegion) {\n      var position = this.isCircular() ? point.labelRegion.x >= this.center.x ? 'InsideRight' : 'InsideLeft' : point.labelRegion.x >= point.region.x ? 'InsideRight' : 'InsideLeft';\n      this.textTrimming(point, this.areaRect, dataLabel.font, position);\n    }\n\n    if (point.labelVisible && point.labelRegion && (point.labelRegion.y + point.labelRegion.height > this.areaRect.y + this.areaRect.height || point.labelRegion.y < this.areaRect.y || point.labelRegion.x < this.areaRect.x || point.labelRegion.x + point.labelRegion.width > this.areaRect.x + this.areaRect.width)) {\n      this.setPointVisibileFalse(point);\n    }\n  };\n  /**\n   * To find trimmed datalabel tooltip needed.\n   * @return {void}\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.move = function (e, x, y, isTouch) {\n    var _this = this;\n\n    if (e.target.textContent.indexOf('...') > -1) {\n      var targetId = e.target.id.split(this.id);\n\n      if (targetId.length === 2) {\n        var seriesIndex = parseInt(targetId[1].split('_text_')[0], 10);\n        var pointIndex = parseInt(targetId[1].split('_text_')[1], 10);\n\n        if (!isNaN(seriesIndex) && !isNaN(pointIndex)) {\n          if (isTouch) {\n            removeElement(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n          }\n\n          var point = getSeriesFromIndex(seriesIndex, this.accumulation.visibleSeries).points[pointIndex];\n          showTooltip(point.text || point.y.toString(), x, y, this.areaRect.width, this.accumulation.element.id + '_EJ2_Datalabel_Tooltip', getElement(this.accumulation.element.id + '_Secondary_Element'));\n        }\n      }\n    } else {\n      removeElement(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n    }\n\n    if (isTouch) {\n      clearTimeout(this.clearTooltip);\n      this.clearTooltip = +setTimeout(function () {\n        removeElement(_this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n      }, 1000);\n    }\n  };\n  /**\n   * To find previous valid label point\n   */\n\n\n  AccumulationDataLabel.prototype.findPreviousPoint = function (points, index, position) {\n    var point = points[0];\n\n    for (var i = index - 1; i >= 0; i--) {\n      point = points[i];\n\n      if (point.visible && point.labelVisible && point.labelRegion && point.labelPosition === position) {\n        return point;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * To find current point datalabel is overlapping with other points\n   */\n\n\n  AccumulationDataLabel.prototype.isOverlapping = function (currentPoint, points) {\n    for (var i = currentPoint.index - 1; i >= 0; i--) {\n      if (points[i].visible && points[i].labelVisible && points[i].labelRegion && currentPoint.labelRegion && currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * To get text trimmed while exceeds the accumulation chart area.\n   */\n\n\n  AccumulationDataLabel.prototype.textTrimming = function (point, rect, font, position) {\n    if (isOverlap(point.labelRegion, rect)) {\n      var size = point.labelRegion.width;\n\n      if (position === 'Right') {\n        size = rect.x - point.labelRegion.x;\n      } else if (position === 'Left') {\n        size = point.labelRegion.x - (rect.x + rect.width);\n\n        if (size < 0) {\n          size += point.labelRegion.width;\n          point.labelRegion.x = rect.x + rect.width;\n        }\n      } else if (position === 'InsideRight') {\n        size = rect.x + rect.width - point.labelRegion.x;\n      } else if (position === 'InsideLeft') {\n        size = point.labelRegion.x + point.labelRegion.width - rect.x;\n\n        if (size < point.labelRegion.width) {\n          point.labelRegion.x = rect.x;\n        }\n      } else {\n        this.setPointVisibileFalse(point);\n      }\n\n      if (point.labelVisible && point.labelRegion) {\n        if (size < point.labelRegion.width) {\n          point.label = textTrim(size - this.marginValue * 2, point.label, font);\n          point.labelRegion.width = size;\n        }\n\n        if (point.label.length === 3 && point.label.indexOf('...') > -1) {\n          this.setPointVisibileFalse(point);\n        }\n      }\n    }\n  };\n  /**\n   * To set point label visible and region to disable.\n   */\n\n\n  AccumulationDataLabel.prototype.setPointVisibileFalse = function (point) {\n    point.labelVisible = false;\n    point.labelRegion = null;\n  };\n  /**\n   * To set datalabel angle position for outside labels\n   */\n\n\n  AccumulationDataLabel.prototype.setOuterSmartLabel = function (previousPoint, point, border, labelRadius, textsize, margin) {\n    if (!this.isCircular()) {\n      this.setSmartLabelForSegments(point, previousPoint, labelRadius, textsize, margin);\n    } else {\n      var labelAngle = this.getOverlappedAngle(previousPoint.labelRegion, point.labelRegion, point.midAngle, border * 2);\n      this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\n\n      if (labelAngle > point.endAngle) {\n        this.setPointVisibileFalse(point);\n      }\n\n      point.labelAngle = labelAngle;\n\n      while (point.labelVisible && (isOverlap(previousPoint.labelRegion, point.labelRegion) || labelAngle <= previousPoint.labelAngle || this.isConnectorLineOverlapping(point, previousPoint))) {\n        if (labelAngle > point.endAngle) {\n          this.setPointVisibileFalse(point);\n          break;\n        }\n\n        point.labelAngle = labelAngle;\n        this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\n        labelAngle += 0.1;\n      }\n    }\n  };\n  /**\n   * Sets smart label positions for funnel and pyramid series\n   */\n\n\n  AccumulationDataLabel.prototype.setSmartLabelForSegments = function (point, prevPoint, distance, textSize, margin) {\n    var textRegion = point.labelRegion; //let overlapWidth: number = prevPoint.labelRegion.x + prevPoint.labelRegion.width - textRegion.x;\n\n    var overlapHeight = this.accumulation.type === 'Funnel' ? prevPoint.labelRegion.y - (textRegion.y + textRegion.height) : point.labelRegion.y - (prevPoint.labelRegion.y + prevPoint.labelRegion.height);\n\n    if (overlapHeight < 0) {\n      point.labelRegion.y += this.accumulation.type === 'Funnel' ? overlapHeight : -overlapHeight;\n    }\n  };\n  /**\n   * To find connector line overlapping.\n   */\n\n\n  AccumulationDataLabel.prototype.isConnectorLineOverlapping = function (point, previous) {\n    var position;\n\n    if (!this.isCircular() && point.labelRegion.x < point.region.x) {\n      position = 'outsideLeft';\n    }\n\n    var start = this.getLabelLocation(point, position);\n    var end = new ChartLocation(0, 0);\n    this.getEdgeOfLabel(point.labelRegion, point.labelAngle, end, 0, point);\n    var previousstart = this.getLabelLocation(previous);\n    var previousend = new ChartLocation(0, 0);\n    this.getEdgeOfLabel(previous.labelRegion, previous.labelAngle, previousend, 0, point);\n    return this.isLineRectangleIntersect(start, end, point.labelRegion) || this.isLineRectangleIntersect(start, end, previous.labelRegion) || this.isLineRectangleIntersect(previousstart, previousend, point.labelRegion);\n  };\n  /**\n   * To find two rectangle intersect\n   */\n\n\n  AccumulationDataLabel.prototype.isLineRectangleIntersect = function (line1, line2, rect) {\n    var rectPoints = [new ChartLocation(Math.round(rect.x), Math.round(rect.y)), new ChartLocation(Math.round(rect.x + rect.width), Math.round(rect.y)), new ChartLocation(Math.round(rect.x + rect.width), Math.round(rect.y + rect.height)), new ChartLocation(Math.round(rect.x), Math.round(rect.y + rect.height))];\n    line1.x = Math.round(line1.x);\n    line1.y = Math.round(line1.y);\n    line2.x = Math.round(line2.x);\n    line2.y = Math.round(line2.y);\n\n    for (var i = 0; i < rectPoints.length; i++) {\n      if (this.isLinesIntersect(line1, line2, rectPoints[i], rectPoints[(i + 1) % rectPoints.length])) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * To find two line intersect\n   */\n\n\n  AccumulationDataLabel.prototype.isLinesIntersect = function (point1, point2, point11, point12) {\n    var a1 = point2.y - point1.y;\n    var b1 = point1.x - point2.x;\n    var c1 = a1 * point1.x + b1 * point1.y;\n    var a2 = point12.y - point11.y;\n    var b2 = point11.x - point12.x;\n    var c2 = a2 * point11.x + b2 * point11.y;\n    var delta = a1 * b2 - a2 * b1;\n\n    if (delta !== 0) {\n      var x = (b2 * c1 - b1 * c2) / delta;\n      var y = (a1 * c2 - a2 * c1) / delta;\n      var lies = Math.min(point1.x, point2.x) <= x && x <= Math.max(point1.x, point2.x);\n      lies = lies && Math.min(point1.y, point2.y) <= y && y <= Math.max(point1.y, point2.y);\n      lies = lies && Math.min(point11.x, point12.x) <= x && x <= Math.max(point11.x, point12.x);\n      lies = lies && Math.min(point11.y, point12.y) <= y && y <= Math.max(point11.y, point12.y);\n      return lies;\n    }\n\n    return false;\n  };\n  /**\n   * To get two rectangle overlapping angles.\n   */\n\n\n  AccumulationDataLabel.prototype.getOverlappedAngle = function (first, second, angle, padding) {\n    var x = first.x;\n\n    if (angle >= 90 && angle <= 270) {\n      second.y = first.y - (padding + second.height / 2);\n      x = first.x + first.width;\n    } else {\n      second.y = first.y + first.height + padding;\n    }\n\n    return getAngle(this.center, new ChartLocation(x, second.y));\n  };\n  /**\n   * To get connector line path\n   */\n\n\n  AccumulationDataLabel.prototype.getConnectorPath = function (label, point, dataLabel, end) {\n    if (end === void 0) {\n      end = 0;\n    }\n\n    var connector = dataLabel.connectorStyle;\n    var labelRadius = this.isCircular() ? !this.isVariousRadius() ? this.labelRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point) : this.getLabelDistance(point, dataLabel); //let labelRadius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\n\n    var start = this.getConnectorStartPoint(point, connector);\n    var labelAngle = end || point.midAngle;\n    var middle = new ChartLocation(0, 0);\n    var endPoint = this.getEdgeOfLabel(label, labelAngle, middle, connector.width, point);\n\n    if (connector.type === 'Curve') {\n      if (this.isCircular()) {\n        var r = labelRadius - (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) : this.radius); //let r: number = labelRadius - this.radius;\n\n        middle = degreeToLocation(labelAngle, labelRadius - r / 2, this.center);\n        return 'M ' + start.x + ' ' + start.y + ' Q ' + middle.x + ' ' + middle.y + ' ' + endPoint.x + ' ' + endPoint.y;\n      } else {\n        return this.getPolyLinePath(start, endPoint);\n      }\n    } else {\n      return 'M ' + start.x + ' ' + start.y + ' L ' + middle.x + ' ' + middle.y + ' L ' + endPoint.x + ' ' + endPoint.y;\n    }\n  };\n  /**\n   * Finds the curved path for funnel/pyramid data label connectors\n   */\n\n\n  AccumulationDataLabel.prototype.getPolyLinePath = function (start, end) {\n    var controlPoints = [start, end];\n\n    if (start.y === end.y) {\n      return 'M ' + start.x + ' ' + start.y + ' L ' + end.x + ' ' + end.y;\n    }\n\n    var path = 'M';\n\n    for (var i = 0; i <= 16; i++) {\n      var t = i / 16;\n      var points = this.getBezierPoint(t, controlPoints, 0, 2);\n      path += points.x + ',' + points.y;\n\n      if (i !== 16) {\n        path += ' L';\n      }\n    }\n\n    return path;\n  };\n  /**\n   * Finds the bezier point for funnel/pyramid data label connectors\n   */\n\n\n  AccumulationDataLabel.prototype.getBezierPoint = function (t, controlPoints, index, count) {\n    if (count === 1) {\n      return controlPoints[index];\n    }\n\n    var p0 = this.getBezierPoint(t, controlPoints, index, count - 1);\n    var p1 = this.getBezierPoint(t, controlPoints, index + 1, count - 1);\n    var x = p0.x ? p0.x : p0.x;\n    var y = p0.y ? p0.y : p0.y;\n    var x1 = p1.x ? p1.x : p1.x;\n    var y1 = p1.y ? p1.y : p1.y;\n    var x2 = (1 - t) * x + t * x1;\n    var y2 = (1 - t) * y + t * y1;\n\n    if (p0.x) {\n      return {\n        x: x2,\n        y: y2\n      };\n    } else {\n      return {\n        x: x2,\n        y: y2\n      };\n    }\n  };\n  /**\n   * To get label edges based on the center and label rect position.\n   */\n\n\n  AccumulationDataLabel.prototype.getEdgeOfLabel = function (labelshape, angle, middle, border, point) {\n    if (border === void 0) {\n      border = 1;\n    }\n\n    var edge = new ChartLocation(labelshape.x, labelshape.y);\n\n    if (angle >= 90 && angle <= 270) {\n      edge.x += labelshape.width + border / 2;\n      edge.y += labelshape.height / 2;\n      middle.x = edge.x + 10;\n      middle.y = edge.y;\n    } else if (point && point.region && point.region.x > point.labelRegion.x) {\n      edge.x += border * 2 + labelshape.width;\n      edge.y += labelshape.height / 2;\n      middle.x = edge.x + 10;\n      middle.y = edge.y;\n    } else {\n      edge.x -= border / 2;\n      edge.y += labelshape.height / 2;\n      middle.x = edge.x - 10;\n      middle.y = edge.y;\n    }\n\n    return edge;\n  };\n  /**\n   * Finds the distance between the label position and the edge/center of the funnel/pyramid\n   */\n\n\n  AccumulationDataLabel.prototype.getLabelDistance = function (point, dataLabel) {\n    if (point.labelPosition && dataLabel.position !== point.labelPosition || dataLabel.connectorStyle.length) {\n      var length_1 = stringToNumber(dataLabel.connectorStyle.length || '70px', this.accumulation.initialClipRect.width);\n\n      if (length_1 < this.accumulation.initialClipRect.width) {\n        return length_1;\n      }\n    }\n\n    var position = point.labelPosition || dataLabel.position;\n    var series = this.accumulation.visibleSeries[0];\n    var extraSpace = (this.accumulation.initialClipRect.width - series.triangleSize.width) / 2;\n    var labelLocation;\n\n    switch (position) {\n      case 'Inside':\n        return 0;\n\n      case 'Outside':\n        labelLocation = point.symbolLocation.x + point.labelOffset.x;\n        return this.accumulation.initialClipRect.width - labelLocation - extraSpace;\n    }\n  };\n  /**\n   * Finds the label position / beginning of the connector(ouside funnel labels)\n   */\n\n\n  AccumulationDataLabel.prototype.getLabelLocation = function (point, position) {\n    if (position === void 0) {\n      position = 'Outside';\n    }\n\n    if (this.accumulation.type !== 'Pie') {\n      position = position === 'OutsideLeft' ? 'OutsideLeft' : point.labelPosition || position;\n      var location_2 = {\n        x: point.symbolLocation.x,\n        y: point.symbolLocation.y - point.labelOffset.y\n      };\n\n      switch (position) {\n        case 'Inside':\n          location_2.y = point.region.y + point.region.height / 2;\n          break;\n\n        case 'Outside':\n          location_2.x += point.labelOffset.x;\n          break;\n\n        case 'OutsideLeft':\n          location_2.x -= point.labelOffset.x;\n      }\n\n      return location_2;\n    } else {\n      //return degreeToLocation(point.midAngle, this.radius, this.center);\n      return degreeToLocation(point.midAngle, this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) : this.radius, this.center);\n    }\n  };\n  /**\n   * Finds the beginning of connector line\n   */\n\n\n  AccumulationDataLabel.prototype.getConnectorStartPoint = function (point, connector) {\n    // return this.isCircular() ? degreeToLocation(point.midAngle, this.radius - connector.width, this.center) :\n    //     this.getLabelLocation(point);\n    var position;\n\n    if (!this.isCircular() && point.region.x > point.labelRegion.x) {\n      position = 'OutsideLeft';\n    }\n\n    return this.isCircular() ? degreeToLocation(point.midAngle, (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) : this.radius) - connector.width, this.center) : this.getLabelLocation(point, position);\n  };\n  /**\n   * To find area rect based on margin, available size.\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.findAreaRect = function () {\n    this.areaRect = new Rect(0, 0, this.accumulation.availableSize.width, this.accumulation.availableSize.height);\n    var margin = this.accumulation.margin;\n    subtractThickness(this.areaRect, new Thickness(margin.left, margin.right, margin.top, margin.bottom));\n  };\n  /**\n   * To render the data labels from series points.\n   */\n\n\n  AccumulationDataLabel.prototype.renderDataLabel = function (point, dataLabel, parent, points, series, templateElement, redraw) {\n    var id = this.accumulation.element.id + '_datalabel_Series_' + series + '_';\n    var datalabelGroup = this.accumulation.renderer.createGroup({\n      id: id + 'g_' + point.index\n    });\n    point.label = point.originalText || point.y.toString();\n    var border = {\n      width: dataLabel.border.width,\n      color: dataLabel.border.color\n    };\n    var argsFont = extend({}, getValue('properties', dataLabel.font), null, true);\n    var argsData = {\n      cancel: false,\n      name: textRender,\n      series: this.accumulation.visibleSeries[0],\n      point: point,\n      text: point.label,\n      border: border,\n      color: dataLabel.fill,\n      template: dataLabel.template,\n      font: argsFont\n    };\n    this.accumulation.trigger(textRender, argsData);\n    var isTemplate = argsData.template !== null;\n    point.labelVisible = !argsData.cancel;\n    point.text = point.label = argsData.text;\n\n    if (Number(point.label)) {\n      point.label = this.accumulation.intl.formatNumber(+point.label, {\n        useGrouping: this.accumulation.useGroupingSeparator\n      });\n    }\n\n    this.marginValue = argsData.border.width ? 5 + argsData.border.width : 1; // Template element\n\n    var childElement = createElement('div', {\n      id: this.accumulation.element.id + '_Series_' + 0 + '_DataLabel_' + point.index,\n      styles: 'position: absolute;background-color:' + argsData.color + ';' + getFontStyle(dataLabel.font) + ';border:' + argsData.border.width + 'px solid ' + argsData.border.color + ';'\n    });\n    var textSize = isTemplate ? this.getTemplateSize(childElement, point, argsData, redraw) : measureText(point.label, dataLabel.font);\n    textSize.height += 4; // 4 for calculation with padding for smart label shape\n\n    textSize.width += 4;\n    this.getDataLabelPosition(point, dataLabel, textSize, points, datalabelGroup, id);\n    var dataLabelElement;\n    var location;\n    var element;\n\n    if (point.labelVisible) {\n      this.correctLabelRegion(point.labelRegion, textSize);\n\n      if (isTemplate) {\n        this.setTemplateStyle(childElement, point, templateElement, dataLabel.font.color, argsData.color, redraw);\n      } else {\n        location = new ChartLocation(point.labelRegion.x + this.marginValue, point.labelRegion.y + textSize.height * 3 / 4 + this.marginValue);\n        element = getElement(id + 'shape_' + point.index);\n        var startLocation = element ? new ChartLocation(+element.getAttribute('x'), +element.getAttribute('y')) : null;\n        dataLabelElement = this.accumulation.renderer.drawRectangle(new RectOption(id + 'shape_' + point.index, argsData.color, argsData.border, 1, point.labelRegion, dataLabel.rx, dataLabel.ry));\n        appendChildElement(false, datalabelGroup, dataLabelElement, redraw, true, 'x', 'y', startLocation, null, false, false, null, this.accumulation.duration);\n        textElement(this.accumulation.renderer, new TextOption(id + 'text_' + point.index, location.x, location.y, 'start', point.label, '', 'auto'), argsData.font, argsData.font.color || this.getSaturatedColor(point, argsData.color), datalabelGroup, false, redraw, true, false, this.accumulation.duration);\n        element = null;\n      }\n\n      if (this.accumulation.accumulationLegendModule && (dataLabel.position === 'Outside' || this.accumulation.enableSmartLabels)) {\n        this.accumulation.visibleSeries[0].findMaxBounds(this.accumulation.visibleSeries[0].labelBound, point.labelRegion);\n      }\n\n      if (point.labelPosition === 'Outside') {\n        var element_1 = getElement(id + 'connector_' + point.index);\n        var previousDirection = element_1 ? element_1.getAttribute('d') : '';\n        var pathElement = this.accumulation.renderer.drawPath(new PathOption(id + 'connector_' + point.index, 'transparent', dataLabel.connectorStyle.width, dataLabel.connectorStyle.color || point.color, 1, dataLabel.connectorStyle.dashArray, this.getConnectorPath(extend({}, point.labelRegion, null, true), point, dataLabel, point.labelAngle)));\n        appendChildElement(false, datalabelGroup, pathElement, redraw, true, null, null, null, previousDirection, false, false, null, this.accumulation.duration);\n      }\n\n      appendChildElement(false, parent, datalabelGroup, redraw);\n    }\n  };\n  /**\n   * To find the template element size\n   * @param element\n   * @param point\n   * @param argsData\n   */\n\n\n  AccumulationDataLabel.prototype.getTemplateSize = function (element, point, argsData, redraw) {\n    var clientRect;\n    element = createTemplate(element, point.index, argsData.template, this.accumulation, point, this.accumulation.visibleSeries[0]);\n    clientRect = measureElementRect(element, redraw);\n    return {\n      width: clientRect.width,\n      height: clientRect.height\n    };\n  };\n  /**\n   * To set the template element style\n   * @param childElement\n   * @param point\n   * @param parent\n   * @param labelColor\n   * @param fill\n   */\n\n\n  AccumulationDataLabel.prototype.setTemplateStyle = function (childElement, point, parent, labelColor, fill, redraw) {\n    childElement.style.left = point.labelRegion.x + 'px';\n    childElement.style.top = point.labelRegion.y + 'px';\n    childElement.style.color = labelColor || this.getSaturatedColor(point, fill);\n\n    if (childElement.childElementCount) {\n      appendChildElement(false, parent, childElement, redraw, true, 'left', 'top');\n      this.doTemplateAnimation(this.accumulation, childElement);\n    }\n  };\n  /**\n   * To find saturated color for datalabel\n   */\n\n\n  AccumulationDataLabel.prototype.getSaturatedColor = function (point, color) {\n    var saturatedColor;\n\n    if (this.marginValue >= 1) {\n      saturatedColor = color === 'transparent' ? this.getLabelBackground(point) : color;\n    } else {\n      saturatedColor = this.getLabelBackground(point);\n    }\n\n    saturatedColor = saturatedColor === 'transparent' ? window.getComputedStyle(document.body, null).backgroundColor : saturatedColor;\n    var rgbValue = convertHexToColor(colorNameToHex(saturatedColor));\n    var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n    return contrast >= 128 ? 'black' : 'white';\n  };\n  /**\n   * Animates the data label template.\n   * @return {void}.\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.doTemplateAnimation = function (accumulation, element) {\n    var series = accumulation.visibleSeries[0];\n    var delay = series.animation.delay + series.animation.duration;\n\n    if (series.animation.enable && accumulation.animateSeries) {\n      element.style.visibility = 'hidden';\n      templateAnimate(element, delay, 200, 'ZoomIn');\n    }\n  };\n  /**\n   * To find background color for the datalabel\n   */\n\n\n  AccumulationDataLabel.prototype.getLabelBackground = function (point) {\n    return point.labelPosition === 'Outside' ? this.accumulation.background || this.accumulation.themeStyle.background : point.color;\n  };\n  /**\n   * To correct the padding between datalabel regions.\n   */\n\n\n  AccumulationDataLabel.prototype.correctLabelRegion = function (labelRegion, textSize, padding) {\n    if (padding === void 0) {\n      padding = 4;\n    }\n\n    labelRegion.height -= padding;\n    labelRegion.width -= padding;\n    labelRegion.x += padding / 2;\n    labelRegion.y += padding / 2;\n    textSize.height -= padding;\n    textSize.width -= padding;\n  };\n  /**\n   * To get the dataLabel module name\n   */\n\n\n  AccumulationDataLabel.prototype.getModuleName = function () {\n    return 'AccumulationDataLabel';\n  };\n  /**\n   * To destroy the data label.\n   * @return {void}\n   * @private\n   */\n\n\n  AccumulationDataLabel.prototype.destroy = function (accumulation) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return AccumulationDataLabel;\n}(AccumulationBase);\n\nexport { AccumulationDataLabel };","map":null,"metadata":{},"sourceType":"module"}