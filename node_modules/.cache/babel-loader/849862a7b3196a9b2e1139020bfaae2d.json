{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { drawSymbol } from '../../common/utils/helper';\nimport { PathOption, Size } from '@syncfusion/ej2-svg-base';\nimport { Browser, extend, remove } from '@syncfusion/ej2-base';\nimport { ChartData } from '../../chart/utils/get-data';\nimport { withInBounds, PointData, stopTimer } from '../../common/utils/helper';\nimport { colorNameToHex, convertHexToColor } from '../../common/utils/helper';\n/**\n * Marker Module used to render the marker for line type series.\n */\n\nvar MarkerExplode =\n/** @class */\nfunction (_super) {\n  __extends(MarkerExplode, _super);\n  /**\n   * Constructor for the marker module.\n   * @private\n   */\n\n\n  function MarkerExplode(chart) {\n    var _this = _super.call(this, chart) || this;\n\n    _this.elementId = chart.element.id;\n    return _this;\n  }\n  /**\n   * @hidden\n   */\n\n\n  MarkerExplode.prototype.addEventListener = function () {\n    if (this.chart.isDestroyed) {\n      return;\n    }\n\n    this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);\n    this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);\n  };\n  /**\n   * @hidden\n   */\n\n\n  MarkerExplode.prototype.removeEventListener = function () {\n    if (this.chart.isDestroyed) {\n      return;\n    }\n\n    this.chart.off(Browser.touchMoveEvent, this.mouseMoveHandler);\n    this.chart.off(Browser.touchEndEvent, this.mouseUpHandler);\n  };\n  /**\n   * @hidden\n   */\n\n\n  MarkerExplode.prototype.mouseUpHandler = function () {\n    var chart = this.chart;\n\n    if (chart.isTouch && !chart.crosshair.enable && !this.isSelected(chart)) {\n      this.markerMove(true);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  MarkerExplode.prototype.mouseMoveHandler = function () {\n    var chart = this.chart;\n\n    if ((!chart.crosshair.enable || chart.tooltip.enable) && (!chart.isTouch || chart.startMove) && !this.isSelected(chart)) {\n      this.markerMove(false);\n    }\n  };\n\n  MarkerExplode.prototype.markerMove = function (remove) {\n    var _this = this;\n\n    var chart = this.chart;\n    this.currentPoints = [];\n    var data;\n    var previous;\n    var explodeSeries;\n    var series;\n\n    if (!chart.tooltip.shared || !chart.tooltip.enable) {\n      data = this.getData();\n      series = data.series;\n      previous = this.previousPoints[0];\n      explodeSeries = series && (series.type === 'Bubble' || series.drawType === 'Scatter' || series.type === 'Scatter' || series.type !== 'Candle' && series.type !== 'Hilo' && series.type !== 'HiloOpenClose' && series.marker.visible && series.marker.width !== 0 && series.marker.height !== 0);\n      data.lierIndex = this.lierIndex;\n\n      if (data.point && explodeSeries && (!previous || previous.point !== data.point || previous && previous.lierIndex > 3 && previous.lierIndex !== this.lierIndex)) {\n        this.currentPoints.push(data);\n      }\n\n      if (data.point && explodeSeries && chart.isPointMouseDown) {\n        this.currentPoints.push(data);\n      }\n    } else {\n      if (!withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n        return null;\n      }\n\n      if (chart.tooltip.enable) {\n        var pointData = chart.chartAreaType === 'PolarRadar' ? this.getData() : null;\n\n        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n          var chartSeries = _a[_i];\n\n          if (!chartSeries.enableTooltip || chartSeries.category === 'Indicator') {\n            continue;\n          }\n\n          if (chart.chartAreaType === 'Cartesian' && chartSeries.visible) {\n            data = this.getClosestX(chart, chartSeries);\n          } else if (chart.chartAreaType === 'PolarRadar' && chartSeries.visible && pointData.point !== null) {\n            data = new PointData(chartSeries.points[pointData.point.index], chartSeries);\n          }\n\n          if (data) {\n            this.currentPoints.push(data);\n            data = null;\n          }\n        }\n      }\n    }\n\n    var length = this.previousPoints.length;\n\n    if (this.currentPoints.length > 0) {\n      if (length === 0 || chart.isPointMouseDown || length > 0 && this.previousPoints[0].point !== this.currentPoints[0].point) {\n        if (this.previousPoints.length > 0) {\n          this.removeHighlightedMarker();\n        }\n\n        var _loop_1 = function (data_1) {\n          if (data_1 && data_1.point || series.type !== 'Candle' && series.type !== 'Hilo' && series.type !== 'HiloOpenClose') {\n            stopTimer(this_1.markerExplode);\n            this_1.isRemove = true;\n            data_1.point.symbolLocations.map(function (location, index) {\n              if (!data_1.series.isRectSeries || data_1.point.marker.visible) {\n                _this.drawTrackBall(data_1.series, data_1.point, location, index);\n              }\n            });\n          }\n        };\n\n        var this_1 = this;\n\n        for (var _b = 0, _c = this.currentPoints; _b < _c.length; _b++) {\n          var data_1 = _c[_b];\n\n          _loop_1(data_1);\n        }\n\n        this.previousPoints = extend([], this.currentPoints, null, true);\n      }\n    }\n\n    if (!chart.tooltip.enable && (this.currentPoints.length === 0 && this.isRemove || remove && this.isRemove || !withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect))) {\n      this.isRemove = false;\n      this.markerExplode = setTimeout(function () {\n        _this.removeHighlightedMarker();\n      }, 2000);\n    }\n\n    this.currentPoints = [];\n  };\n\n  MarkerExplode.prototype.drawTrackBall = function (series, point, location, index) {\n    var marker = point.marker;\n    var seriesMarker = series.marker;\n    var shape = marker.shape || seriesMarker.shape;\n    var element = series.symbolElement || series.seriesElement;\n    var symbolId = this.elementId + '_Series_' + series.index + '_Point_' + point.index + '_Trackball' + (index ? index : '');\n    var size = new Size((marker.width || seriesMarker.width) + 5, (marker.height || seriesMarker.height) + 5);\n    var border = marker.border || series.border;\n    var explodeSeries = series.type === 'BoxAndWhisker' || series.type === 'Bubble' || series.type === 'Scatter';\n    var borderColor = border.color && border.color !== 'transparent' ? border.color : marker.fill || point.interior || (explodeSeries ? point.color : series.interior);\n    var colorValue = convertHexToColor(colorNameToHex(borderColor));\n    var borderWidth = marker.border ? marker.border.width : seriesMarker.border.width;\n    var markerShadow = series.chart.themeStyle.markerShadow || 'rgba(' + colorValue.r + ',' + colorValue.g + ',' + colorValue.b + ',0.2)';\n\n    for (var i = 0; i < 2; i++) {\n      var options = new PathOption(symbolId + '_' + i, i ? marker.fill || point.color || (explodeSeries ? series.interior : '#ffffff') : 'transparent', borderWidth + (i ? 0 : 8), i ? borderColor : markerShadow, marker.opacity || seriesMarker.opacity, null, null);\n      var symbol = drawSymbol(location, shape, size, seriesMarker.imageUrl, options, '', this.chart.svgRenderer, series.clipRect);\n      symbol.setAttribute('style', 'pointer-events:none');\n      symbol.setAttribute('class', 'EJ2-Trackball');\n      element.appendChild(symbol);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  MarkerExplode.prototype.removeHighlightedMarker = function () {\n    var elements = document.getElementsByClassName('EJ2-Trackball');\n\n    for (var i = 0, len = elements.length; i < len; i++) {\n      remove(elements[0]);\n    }\n\n    this.previousPoints = [];\n  };\n\n  return MarkerExplode;\n}(ChartData);\n\nexport { MarkerExplode };","map":null,"metadata":{},"sourceType":"module"}