{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { getActualDesiredIntervalsCount, triggerLabelRender } from '../../common/utils/helper';\nimport { DoubleRange } from '../utils/double-range';\nimport { withIn } from '../../common/utils/helper';\nimport { extend, getValue } from '@syncfusion/ej2-base';\nimport { NiceInterval } from '../axis/axis-helper';\n/**\n * `Category` module is used to render category axis.\n */\n\nvar Category =\n/** @class */\nfunction (_super) {\n  __extends(Category, _super);\n  /**\n   * Constructor for the category module.\n   * @private\n   */\n\n\n  function Category(chart) {\n    return _super.call(this, chart) || this;\n  }\n  /**\n   * The function to calculate the range and labels for the axis.\n   * @return {void}\n   */\n\n\n  Category.prototype.calculateRangeAndInterval = function (size, axis) {\n    this.calculateRange(axis, size);\n    this.getActualRange(axis, size);\n    this.applyRangePadding(axis, size);\n    this.calculateVisibleLabels(axis);\n  };\n  /**\n   * Actual Range for the axis.\n   * @private\n   */\n\n\n  Category.prototype.getActualRange = function (axis, size) {\n    this.initializeDoubleRange(axis); // axis.doubleRange = new DoubleRange(<number>this.min, <number>this.max);\n\n    axis.actualRange = {};\n\n    if (!axis.interval) {\n      axis.actualRange.interval = Math.max(1, Math.floor(axis.doubleRange.delta / getActualDesiredIntervalsCount(size, axis)));\n    } else {\n      axis.actualRange.interval = Math.ceil(axis.interval);\n    }\n\n    axis.actualRange.min = axis.doubleRange.start;\n    axis.actualRange.max = axis.doubleRange.end;\n    axis.actualRange.delta = axis.doubleRange.delta;\n  };\n  /**\n   * Padding for the axis.\n   * @private\n   */\n\n\n  Category.prototype.applyRangePadding = function (axis, size) {\n    var ticks = axis.labelPlacement === 'BetweenTicks' && this.chart.chartAreaType !== 'PolarRadar' ? 0.5 : 0;\n\n    if (ticks > 0) {\n      axis.actualRange.min -= ticks;\n      axis.actualRange.max += ticks;\n    } else {\n      axis.actualRange.max += axis.actualRange.max ? 0 : 0.5;\n    }\n\n    axis.doubleRange = new DoubleRange(axis.actualRange.min, axis.actualRange.max);\n    axis.actualRange.delta = axis.doubleRange.delta;\n    this.calculateVisibleRange(size, axis);\n  };\n  /**\n   * Calculate label for the axis.\n   * @private\n   */\n\n\n  Category.prototype.calculateVisibleLabels = function (axis) {\n    /*! Generate axis labels */\n    axis.visibleLabels = [];\n    var tempInterval = Math.ceil(axis.visibleRange.min);\n    var labelStyle;\n\n    if (axis.zoomFactor < 1 || axis.zoomPosition > 0) {\n      tempInterval = axis.visibleRange.min - axis.visibleRange.min % axis.visibleRange.interval;\n    }\n\n    var position;\n    axis.startLabel = axis.labels[Math.round(axis.visibleRange.min)];\n    axis.endLabel = axis.labels[Math.floor(axis.visibleRange.max)];\n\n    for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {\n      labelStyle = extend({}, getValue('properties', axis.labelStyle), null, true);\n\n      if (withIn(tempInterval, axis.visibleRange) && axis.labels.length > 0) {\n        position = Math.round(tempInterval);\n        triggerLabelRender(this.chart, position, axis.labels[position] ? axis.labels[position].toString() : position.toString(), labelStyle, axis);\n      }\n    }\n\n    if (axis.getMaxLabelWidth) {\n      axis.getMaxLabelWidth(this.chart);\n    }\n  };\n  /**\n   * Get module name\n   */\n\n\n  Category.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'Category';\n  };\n  /**\n   * To destroy the category axis.\n   * @return {void}\n   * @private\n   */\n\n\n  Category.prototype.destroy = function (chart) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return Category;\n}(NiceInterval);\n\nexport { Category };","map":null,"metadata":{},"sourceType":"module"}