{"ast":null,"code":"import ErrorRangeCalculator from './error-bars/error-range-calculator';\nimport CategoricalErrorBar from './error-bars/categorical-error-bar';\nimport SeriesBinder from './series-binder';\nimport { ERROR_LOW_FIELD, ERROR_HIGH_FIELD } from './constants';\nimport evalOptions from './utils/eval-options';\nimport categoriesCount from './utils/categories-count';\nimport { ChartElement, Box } from '../core';\nimport { VALUE, STRING, MIN_VALUE, MAX_VALUE } from '../common/constants';\nimport { convertableToNumber, deepExtend, defined, isNumber, last, setDefaultOptions, sparseArrayLimits } from '../common';\n\nvar CategoricalChart = function (ChartElement) {\n  function CategoricalChart(plotArea, options) {\n    ChartElement.call(this, options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]); // Value axis ranges grouped by axis name, e.g.:\n    // primary: { min: 0, max: 1 }\n\n    this.valueAxisRanges = {};\n    this.points = [];\n    this.categoryPoints = [];\n    this.seriesPoints = [];\n    this.seriesOptions = [];\n    this._evalSeries = [];\n    this.render();\n  }\n\n  if (ChartElement) CategoricalChart.__proto__ = ChartElement;\n  CategoricalChart.prototype = Object.create(ChartElement && ChartElement.prototype);\n  CategoricalChart.prototype.constructor = CategoricalChart;\n\n  CategoricalChart.prototype.render = function render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  };\n\n  CategoricalChart.prototype.pointOptions = function pointOptions(series, seriesIx) {\n    var options = this.seriesOptions[seriesIx];\n\n    if (!options) {\n      var defaults = this.pointType().prototype.defaults;\n      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n        vertical: !this.options.invertAxes\n      }, series);\n    }\n\n    return options;\n  };\n\n  CategoricalChart.prototype.plotValue = function plotValue(point) {\n    if (!point) {\n      return 0;\n    }\n\n    if (this.options.isStacked100 && isNumber(point.value)) {\n      var categoryIx = point.categoryIx;\n      var categoryPoints = this.categoryPoints[categoryIx];\n      var otherValues = [];\n      var categorySum = 0;\n\n      for (var i = 0; i < categoryPoints.length; i++) {\n        var other = categoryPoints[i];\n\n        if (other) {\n          var stack = point.series.stack;\n          var otherStack = other.series.stack;\n\n          if (stack && otherStack && stack.group !== otherStack.group) {\n            continue;\n          }\n\n          if (isNumber(other.value)) {\n            categorySum += Math.abs(other.value);\n            otherValues.push(Math.abs(other.value));\n          }\n        }\n      }\n\n      if (categorySum > 0) {\n        return point.value / categorySum;\n      }\n    }\n\n    return point.value;\n  };\n\n  CategoricalChart.prototype.plotRange = function plotRange(point, startValue) {\n    var this$1 = this;\n    if (startValue === void 0) startValue = 0;\n    var categoryPoints = this.categoryPoints[point.categoryIx];\n\n    if (this.options.isStacked) {\n      var plotValue = this.plotValue(point);\n      var positive = plotValue >= 0;\n      var prevValue = startValue;\n      var isStackedBar = false;\n\n      for (var i = 0; i < categoryPoints.length; i++) {\n        var other = categoryPoints[i];\n\n        if (point === other) {\n          break;\n        }\n\n        var stack = point.series.stack;\n        var otherStack = other.series.stack;\n\n        if (stack && otherStack) {\n          if (typeof stack === STRING && stack !== otherStack) {\n            continue;\n          }\n\n          if (stack.group && stack.group !== otherStack.group) {\n            continue;\n          }\n        }\n\n        var otherValue = this$1.plotValue(other);\n\n        if (otherValue >= 0 && positive || otherValue < 0 && !positive) {\n          prevValue += otherValue;\n          plotValue += otherValue;\n          isStackedBar = true;\n\n          if (this$1.options.isStacked100) {\n            plotValue = Math.min(plotValue, 1);\n          }\n        }\n      }\n\n      if (isStackedBar) {\n        prevValue -= startValue;\n      }\n\n      return [prevValue, plotValue];\n    }\n\n    var series = point.series;\n    var valueAxis = this.seriesValueAxis(series);\n    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    return [axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue];\n  };\n\n  CategoricalChart.prototype.stackLimits = function stackLimits(axisName, stackName) {\n    var this$1 = this;\n    var min = MAX_VALUE;\n    var max = MIN_VALUE;\n\n    for (var i = 0; i < this.categoryPoints.length; i++) {\n      var categoryPoints = this$1.categoryPoints[i];\n\n      if (!categoryPoints) {\n        continue;\n      }\n\n      for (var pIx = 0; pIx < categoryPoints.length; pIx++) {\n        var point = categoryPoints[pIx];\n\n        if (point) {\n          if (point.series.stack === stackName || point.series.axis === axisName) {\n            var to = this$1.plotRange(point, 0)[1];\n\n            if (defined(to) && isFinite(to)) {\n              max = Math.max(max, to);\n              min = Math.min(min, to);\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  CategoricalChart.prototype.updateStackRange = function updateStackRange() {\n    var this$1 = this;\n    var ref = this.options;\n    var isStacked = ref.isStacked;\n    var chartSeries = ref.series;\n    var limitsCache = {};\n\n    if (isStacked) {\n      for (var i = 0; i < chartSeries.length; i++) {\n        var series = chartSeries[i];\n        var axisName = series.axis;\n        var key = axisName + series.stack;\n        var limits = limitsCache[key];\n\n        if (!limits) {\n          limits = this$1.stackLimits(axisName, series.stack);\n          var errorTotals = this$1.errorTotals;\n\n          if (errorTotals) {\n            if (errorTotals.negative.length) {\n              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);\n            }\n\n            if (errorTotals.positive.length) {\n              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);\n            }\n          }\n\n          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n            limitsCache[key] = limits;\n          } else {\n            limits = null;\n          }\n        }\n\n        if (limits) {\n          this$1.valueAxisRanges[axisName] = limits;\n        }\n      }\n    }\n  };\n\n  CategoricalChart.prototype.addErrorBar = function addErrorBar(point, data, categoryIx) {\n    var value = point.value;\n    var series = point.series;\n    var seriesIx = point.seriesIx;\n    var errorBars = point.options.errorBars;\n    var lowValue = data.fields[ERROR_LOW_FIELD];\n    var highValue = data.fields[ERROR_HIGH_FIELD];\n    var errorRange;\n\n    if (isNumber(lowValue) && isNumber(highValue)) {\n      errorRange = {\n        low: lowValue,\n        high: highValue\n      };\n    } else if (errorBars && defined(errorBars.value)) {\n      this.seriesErrorRanges = this.seriesErrorRanges || [];\n      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new ErrorRangeCalculator(errorBars.value, series, VALUE);\n      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n    }\n\n    if (errorRange) {\n      point.low = errorRange.low;\n      point.high = errorRange.high;\n      this.addPointErrorBar(point, categoryIx);\n    }\n  };\n\n  CategoricalChart.prototype.addPointErrorBar = function addPointErrorBar(point, categoryIx) {\n    var isVertical = !this.options.invertAxes;\n    var options = point.options.errorBars;\n    var series = point.series;\n    var low = point.low;\n    var high = point.high;\n\n    if (this.options.isStacked) {\n      var stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n      low = stackedErrorRange.low;\n      high = stackedErrorRange.high;\n    } else {\n      var fields = {\n        categoryIx: categoryIx,\n        series: series\n      };\n      this.updateRange({\n        value: low\n      }, fields);\n      this.updateRange({\n        value: high\n      }, fields);\n    }\n\n    var errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\n    point.errorBars = [errorBar];\n    point.append(errorBar);\n  };\n\n  CategoricalChart.prototype.stackedErrorRange = function stackedErrorRange(point, categoryIx) {\n    var plotValue = this.plotRange(point, 0)[1] - point.value;\n    var low = point.low + plotValue;\n    var high = point.high + plotValue;\n    this.errorTotals = this.errorTotals || {\n      positive: [],\n      negative: []\n    };\n\n    if (low < 0) {\n      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n    }\n\n    if (high > 0) {\n      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n    }\n\n    return {\n      low: low,\n      high: high\n    };\n  };\n\n  CategoricalChart.prototype.addValue = function addValue(data, fields) {\n    var categoryIx = fields.categoryIx;\n    var series = fields.series;\n    var seriesIx = fields.seriesIx;\n    var categoryPoints = this.categoryPoints[categoryIx];\n\n    if (!categoryPoints) {\n      this.categoryPoints[categoryIx] = categoryPoints = [];\n    }\n\n    var seriesPoints = this.seriesPoints[seriesIx];\n\n    if (!seriesPoints) {\n      this.seriesPoints[seriesIx] = seriesPoints = [];\n    }\n\n    var point = this.createPoint(data, fields);\n\n    if (point) {\n      Object.assign(point, fields);\n      point.owner = this;\n      point.noteText = data.fields.noteText;\n\n      if (!defined(point.dataItem)) {\n        point.dataItem = series.data[categoryIx];\n      }\n\n      this.addErrorBar(point, data, categoryIx);\n    }\n\n    this.points.push(point);\n    seriesPoints.push(point);\n    categoryPoints.push(point);\n    this.updateRange(data.valueFields, fields);\n  };\n\n  CategoricalChart.prototype.evalPointOptions = function evalPointOptions(options, value, category, categoryIx, series, seriesIx) {\n    var state = {\n      defaults: series._defaults,\n      excluded: [\"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\"]\n    };\n    var doEval = this._evalSeries[seriesIx];\n\n    if (!defined(doEval)) {\n      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n    }\n\n    var pointOptions = options;\n\n    if (doEval) {\n      pointOptions = deepExtend({}, pointOptions);\n      evalOptions(pointOptions, {\n        value: value,\n        category: category,\n        index: categoryIx,\n        series: series,\n        dataItem: series.data[categoryIx]\n      }, state);\n    }\n\n    return pointOptions;\n  };\n\n  CategoricalChart.prototype.updateRange = function updateRange(data, fields) {\n    var axisName = fields.series.axis;\n    var value = data.value;\n    var axisRange = this.valueAxisRanges[axisName];\n\n    if (isFinite(value) && value !== null) {\n      axisRange = this.valueAxisRanges[axisName] = axisRange || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n      axisRange.min = Math.min(axisRange.min, value);\n      axisRange.max = Math.max(axisRange.max, value);\n    }\n  };\n\n  CategoricalChart.prototype.seriesValueAxis = function seriesValueAxis(series) {\n    var plotArea = this.plotArea;\n    var axisName = series.axis;\n    var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n\n    if (!axis) {\n      throw new Error(\"Unable to locate value axis with name \" + axisName);\n    }\n\n    return axis;\n  };\n\n  CategoricalChart.prototype.reflow = function reflow(targetBox) {\n    var this$1 = this;\n    var categorySlots = this.categorySlots = [];\n    var chartPoints = this.points;\n    var categoryAxis = this.categoryAxis;\n    var pointIx = 0;\n    this.traverseDataPoints(function (data, fields) {\n      var categoryIx = fields.categoryIx;\n      var currentSeries = fields.series;\n      var valueAxis = this$1.seriesValueAxis(currentSeries);\n      var point = chartPoints[pointIx++];\n      var categorySlot = categorySlots[categoryIx];\n\n      if (!categorySlot) {\n        categorySlots[categoryIx] = categorySlot = this$1.categorySlot(categoryAxis, categoryIx, valueAxis);\n      }\n\n      if (point) {\n        var plotRange = this$1.plotRange(point, valueAxis.startValue());\n        var valueSlot = this$1.valueSlot(valueAxis, plotRange);\n\n        if (valueSlot) {\n          var pointSlot = this$1.pointSlot(categorySlot, valueSlot);\n          point.aboveAxis = this$1.aboveAxis(point, valueAxis);\n          point.stackValue = plotRange[1];\n\n          if (this$1.options.isStacked100) {\n            point.percentage = this$1.plotValue(point);\n          }\n\n          this$1.reflowPoint(point, pointSlot);\n        } else {\n          point.visible = false;\n        }\n      }\n    });\n    this.reflowCategories(categorySlots);\n\n    if (!this.options.clip && this.options.limitPoints && this.points.length) {\n      this.limitPoints();\n    }\n\n    this.box = targetBox;\n  };\n\n  CategoricalChart.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {\n    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n  };\n\n  CategoricalChart.prototype.limitPoints = function limitPoints() {\n    var this$1 = this;\n    var categoryPoints = this.categoryPoints;\n    var points = categoryPoints[0].concat(last(categoryPoints));\n\n    for (var idx = 0; idx < points.length; idx++) {\n      if (points[idx]) {\n        this$1.limitPoint(points[idx]);\n      }\n    }\n  };\n\n  CategoricalChart.prototype.limitPoint = function limitPoint(point) {\n    var limittedSlot = this.categoryAxis.limitSlot(point.box);\n\n    if (!limittedSlot.equals(point.box)) {\n      point.reflow(limittedSlot);\n    }\n  };\n\n  CategoricalChart.prototype.aboveAxis = function aboveAxis(point, valueAxis) {\n    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    var value = point.value;\n    return valueAxis.options.reverse ? value < axisCrossingValue : value >= axisCrossingValue;\n  };\n\n  CategoricalChart.prototype.categoryAxisCrossingValue = function categoryAxisCrossingValue(valueAxis) {\n    var categoryAxis = this.categoryAxis;\n    var options = valueAxis.options;\n    var crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);\n    return crossingValues[categoryAxis.axisIndex || 0] || 0;\n  };\n\n  CategoricalChart.prototype.reflowPoint = function reflowPoint(point, pointSlot) {\n    point.reflow(pointSlot);\n  };\n\n  CategoricalChart.prototype.reflowCategories = function reflowCategories() {};\n\n  CategoricalChart.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {\n    var options = this.options;\n    var invertAxes = options.invertAxes;\n    var slotX = invertAxes ? valueSlot : categorySlot;\n    var slotY = invertAxes ? categorySlot : valueSlot;\n    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n  };\n\n  CategoricalChart.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {\n    return categoryAxis.getSlot(categoryIx);\n  };\n\n  CategoricalChart.prototype.traverseDataPoints = function traverseDataPoints(callback) {\n    var this$1 = this;\n    var series = this.options.series;\n    var count = categoriesCount(series);\n    var seriesCount = series.length;\n\n    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      this$1._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\n    }\n\n    for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n      for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {\n        var currentSeries = series[seriesIx$1];\n        var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);\n\n        var pointData = this$1._bindPoint(currentSeries, seriesIx$1, categoryIx);\n\n        callback(pointData, {\n          category: currentCategory,\n          categoryIx: categoryIx,\n          series: currentSeries,\n          seriesIx: seriesIx$1\n        });\n      }\n    }\n\n    for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {\n      this$1._outOfRangeCallback(series[seriesIx$2], \"_outOfRangeMaxPoint\", seriesIx$2, callback);\n    }\n  };\n\n  CategoricalChart.prototype._outOfRangeCallback = function _outOfRangeCallback(series, field, seriesIx, callback) {\n    var outOfRangePoint = series[field];\n\n    if (outOfRangePoint) {\n      var categoryIx = outOfRangePoint.categoryIx;\n\n      var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);\n\n      callback(pointData, {\n        category: outOfRangePoint.category,\n        categoryIx: categoryIx,\n        series: series,\n        seriesIx: seriesIx,\n        dataItem: outOfRangePoint.item\n      });\n    }\n  };\n\n  CategoricalChart.prototype._bindPoint = function _bindPoint(series, seriesIx, categoryIx, item) {\n    if (!this._bindCache) {\n      this._bindCache = [];\n    }\n\n    var bindCache = this._bindCache[seriesIx];\n\n    if (!bindCache) {\n      bindCache = this._bindCache[seriesIx] = [];\n    }\n\n    var data = bindCache[categoryIx];\n\n    if (!data) {\n      data = bindCache[categoryIx] = SeriesBinder.current.bindPoint(series, categoryIx, item);\n    }\n\n    return data;\n  };\n\n  CategoricalChart.prototype.formatPointValue = function formatPointValue(point, format) {\n    if (point.value === null) {\n      return \"\";\n    }\n\n    return this.chartService.format.auto(format, point.value);\n  };\n\n  CategoricalChart.prototype.pointValue = function pointValue(data) {\n    return data.valueFields.value;\n  };\n\n  return CategoricalChart;\n}(ChartElement);\n\nsetDefaultOptions(CategoricalChart, {\n  series: [],\n  invertAxes: false,\n  isStacked: false,\n  clip: true,\n  limitPoints: true\n});\nexport default CategoricalChart;","map":null,"metadata":{},"sourceType":"module"}