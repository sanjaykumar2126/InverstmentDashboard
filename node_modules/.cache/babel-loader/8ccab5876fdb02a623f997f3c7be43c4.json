{"ast":null,"code":"/**\n *\n */\nimport { createElement, updateBlazorTemplate } from '@syncfusion/ej2-base';\nimport { measureText } from '../../smithchart/utils/helper';\nimport { getTemplateFunction, convertElementFromLabel, PathOption } from '../../smithchart/utils/helper';\nimport { SmithchartLabelPosition } from '../../smithchart/utils/utils';\nimport { LabelOption } from '../../smithchart/utils/utils';\n/* tslint:disable:no-string-literal */\n\nvar DataLabel =\n/** @class */\nfunction () {\n  function DataLabel() {\n    this.textOptions = [];\n    this.labelOptions = [];\n    this.allPoints = [];\n  }\n\n  DataLabel.prototype.drawDataLabel = function (smithchart, seriesindex, groupElement, pointsRegion, bounds) {\n    this.textOptions = [];\n    this.allPoints = [];\n    var margin = smithchart.margin;\n    var pointIndex;\n    var marker = smithchart.series[seriesindex].marker;\n    var region;\n    var labelPosition;\n    var labelText;\n    var textSize;\n    var dataLabel = marker.dataLabel;\n    var font = dataLabel.textStyle;\n    var count = pointsRegion.length;\n\n    for (var i = 0; i < count; i++) {\n      labelText = smithchart.series[seriesindex].points[i].reactance.toString();\n      textSize = measureText(labelText, font);\n      region = pointsRegion[i]['point'];\n      var xPos = region.x - textSize.width / 2;\n      var yPos = region.y - (textSize.height + marker['height'] + margin.top);\n      var width = textSize.width + margin.left / 2 + margin.right / 2;\n      var height = textSize.height + margin.top / 2 + margin.bottom / 2;\n      pointIndex = i;\n      labelPosition = new SmithchartLabelPosition();\n      labelPosition = {\n        textX: xPos + margin.left / 2,\n        textY: yPos + height / 2 + margin.top / 2,\n        x: xPos,\n        y: yPos\n      };\n      this.textOptions[i] = {\n        id: smithchart.element.id + '_Series' + seriesindex + '_Points' + pointIndex + '_dataLabel' + '_displayText' + i,\n        x: labelPosition['textX'],\n        y: labelPosition['textY'],\n        fill: 'black',\n        text: labelText,\n        font: font,\n        xPosition: xPos,\n        yPosition: yPos,\n        width: width,\n        height: height,\n        location: region,\n        labelOptions: labelPosition,\n        visible: true,\n        connectorFlag: null\n      };\n    }\n\n    var labelOption = new LabelOption();\n    labelOption.textOptions = this.textOptions;\n    this.labelOptions.push(labelOption);\n    this.drawDatalabelSymbol(smithchart, seriesindex, dataLabel, groupElement, bounds, pointsRegion);\n  };\n\n  DataLabel.prototype.calculateSmartLabels = function (points, seriesIndex) {\n    var length = points['textOptions'].length;\n    var count = 0;\n\n    for (var k = 0; k < length; k++) {\n      this.allPoints[this.allPoints.length] = points['textOptions'][k];\n      this.connectorFlag = false;\n      this.compareDataLabels(k, points, count, seriesIndex);\n      this.labelOptions[seriesIndex]['textOptions'][k] = points['textOptions'][k];\n      this.labelOptions[seriesIndex]['textOptions'][k].connectorFlag = this.connectorFlag;\n    }\n  };\n\n  DataLabel.prototype.compareDataLabels = function (i, points, count, m) {\n    var length = this.allPoints.length;\n    var padding = 10;\n    var collide;\n    var currentLabel;\n    var prevLabel;\n\n    for (var j = 0; j < length; j++) {\n      prevLabel = this.allPoints[j];\n      currentLabel = this.allPoints[length - 1];\n      collide = this.isCollide(prevLabel, currentLabel);\n\n      if (collide) {\n        this.connectorFlag = true;\n\n        switch (count) {\n          case 0:\n            // Right\n            this.resetValues(currentLabel);\n            this.prevLabel = prevLabel;\n            currentLabel['xPosition'] = this.prevLabel['xPosition'] + (this.prevLabel['width'] / 2 + currentLabel['width'] / 2 + padding);\n            currentLabel['x'] = currentLabel['xPosition'] + padding / 2;\n            count += 1;\n            this.compareDataLabels(i, points, count, m);\n            break;\n\n          case 1:\n            // Right Bottom\n            this.resetValues(currentLabel);\n            currentLabel['xPosition'] = this.prevLabel['xPosition'] + this.prevLabel['width'] / 2 + currentLabel['width'] / 2 + padding;\n            currentLabel['x'] = currentLabel['xPosition'] + padding / 2;\n            currentLabel['yPosition'] = currentLabel['location'].y + currentLabel['height'] / 2 + padding / 2;\n            currentLabel['y'] = currentLabel['yPosition'] + currentLabel['height'] / 2 + padding / 2;\n            count += 1;\n            this.compareDataLabels(i, points, count, m);\n            break;\n\n          case 2:\n            // Bottom\n            this.resetValues(currentLabel);\n            currentLabel['yPosition'] = currentLabel['location'].y + currentLabel['height'] / 2 + padding / 2;\n            currentLabel['y'] = currentLabel['yPosition'] + currentLabel['height'] / 2 + padding / 2;\n            count += 1;\n            this.compareDataLabels(i, points, count, m);\n            break;\n\n          case 3:\n            // Left Bottom\n            this.resetValues(currentLabel);\n            currentLabel['xPosition'] = this.prevLabel['xPosition'] - this.prevLabel['width'] / 2 - currentLabel['width'] / 2 - padding;\n            currentLabel['x'] = currentLabel['xPosition'] + padding / 2;\n            currentLabel['yPosition'] = currentLabel['height'] / 2 + currentLabel['location'].y + padding / 2;\n            currentLabel['y'] = currentLabel['yPosition'] + currentLabel['height'] / 2 + padding / 2;\n            count += 1;\n            this.compareDataLabels(i, points, count, m);\n            break;\n\n          case 4:\n            // Left\n            this.resetValues(currentLabel);\n            currentLabel['xPosition'] = this.prevLabel['xPosition'] - this.prevLabel['width'] / 2 - currentLabel['width'] / 2 - padding;\n            currentLabel['x'] = currentLabel['xPosition'] + padding / 2;\n            count += 1;\n            this.compareDataLabels(i, points, count, m);\n            break;\n\n          case 5:\n            //Left Top\n            this.resetValues(currentLabel);\n            currentLabel['xPosition'] = this.prevLabel['xPosition'] - this.prevLabel['width'] / 2 - currentLabel['width'] / 2 - padding;\n            currentLabel['x'] = currentLabel['xPosition'] + padding / 2;\n            currentLabel['yPosition'] = this.prevLabel['yPosition'] - currentLabel['height'] - padding;\n            currentLabel['y'] = currentLabel['yPosition'] + currentLabel['height'] / 2 + padding / 2;\n            count += 1;\n            this.compareDataLabels(i, points, count, m);\n            break;\n\n          case 6:\n            // Top\n            this.resetValues(currentLabel);\n            currentLabel['yPosition'] = this.prevLabel['yPosition'] - (currentLabel['height'] + padding);\n            currentLabel['y'] = currentLabel['yPosition'] + currentLabel['height'] / 2 + padding / 2;\n            count += 1;\n            this.compareDataLabels(i, points, count, m);\n            break;\n\n          case 7:\n            // Right Top\n            this.resetValues(currentLabel);\n            currentLabel['xPosition'] = this.prevLabel['xPosition'] + this.prevLabel['width'] / 2 + currentLabel['width'] / 2 + padding;\n            currentLabel['x'] = currentLabel['xPosition'] + padding / 2;\n            currentLabel['yPosition'] = this.prevLabel['yPosition'] - currentLabel['height'] - padding;\n            currentLabel['y'] = currentLabel['yPosition'] + currentLabel['height'] / 2 + padding / 2;\n            count += 1;\n            this.compareDataLabels(i, points, count, m);\n            break;\n\n          case 8:\n            count = 0;\n            this.compareDataLabels(i, points, count, m);\n            break;\n        }\n      }\n    }\n  };\n\n  DataLabel.prototype.isCollide = function (dataLabel1, dataLabel2) {\n    var state = false;\n\n    if (dataLabel1 !== dataLabel2) {\n      state = !( // to compare data labels\n      dataLabel1['y'] + dataLabel1['height'] < dataLabel2['y'] || dataLabel1['y'] > dataLabel2['y'] + dataLabel2['height'] || dataLabel1['x'] + dataLabel1['width'] / 2 < dataLabel2['x'] - dataLabel2['width'] / 2 || dataLabel1['x'] - dataLabel1['width'] / 2 > dataLabel2['x'] + dataLabel2['width'] / 2);\n    }\n\n    return state;\n  };\n\n  DataLabel.prototype.resetValues = function (currentPoint) {\n    currentPoint['xPosition'] = currentPoint['labelOptions']['x'];\n    currentPoint['yPosition'] = currentPoint['labelOptions']['y'];\n    currentPoint['x'] = currentPoint['labelOptions']['textX'];\n    currentPoint['y'] = currentPoint['labelOptions']['textY'];\n  };\n\n  DataLabel.prototype.drawConnectorLines = function (smithchart, seriesIndex, index, currentPoint, groupElement) {\n    var xPos = currentPoint['xPosition'];\n    var yPos = currentPoint['yPosition'];\n    var location = currentPoint['location'];\n    var endY;\n\n    if (location.y > currentPoint['y']) {\n      endY = currentPoint['y'];\n    } else {\n      endY = currentPoint['y'] - currentPoint['height'] / 2; // bottom\n    }\n\n    var connectorDirection = 'M' + ' ' + location.x + ' ' + location.y + ' ' + 'L' + ' ' + currentPoint['x'] + ' ' + endY;\n    var connectorLineValues = smithchart.series[seriesIndex].marker.dataLabel.connectorLine;\n    var stroke = connectorLineValues.color ? connectorLineValues.color : smithchart.series[seriesIndex].fill || smithchart.seriesColors[seriesIndex % smithchart.seriesColors.length];\n    var options = new PathOption(smithchart.element.id + '_dataLabelConnectorLine' + '_series' + seriesIndex + '_point' + index, 'none', connectorLineValues.width, stroke, 1, 'none', connectorDirection);\n    var element = smithchart.renderer.drawPath(options);\n    groupElement.appendChild(element);\n  };\n\n  DataLabel.prototype.drawDatalabelSymbol = function (smithchart, seriesindex, dataLabel, groupElement, bounds, pointsRegion) {\n    for (var i = 0; i < smithchart.series[seriesindex].points.length; i++) {\n      if (dataLabel.template) {\n        var labelTemplateElement = createElement('div', {\n          id: smithchart.element.id + '_seriesIndex_' + seriesindex + '_Label_Template_Group',\n          className: 'template',\n          styles: 'position: absolute;'\n          /* 'top:' + bounds['x'] + 'px;' +\n           'left:' + bounds['y'] + 'px;' +\n           'height:' + smithchart.availableSize.height + 'px;' +\n           'width:' + smithchart.availableSize.width + 'px;'*/\n\n        });\n        document.getElementById(smithchart.element.id + '_Secondary_Element').appendChild(labelTemplateElement);\n        var templateFn = void 0;\n        var labelElement = void 0;\n        var id = dataLabel.template + '_seriesIndex' + seriesindex + '_pointIndex' + i + smithchart.element.id;\n        var data = {\n          point: smithchart.series[seriesindex].points[i].reactance\n        };\n        templateFn = getTemplateFunction(dataLabel.template);\n        var templateElement = templateFn(smithchart);\n        labelElement = convertElementFromLabel(templateElement, id, data, seriesindex, smithchart);\n        labelTemplateElement.appendChild(labelElement);\n        labelElement.style.left = pointsRegion[i].point.x - labelElement.offsetWidth / 2 + 'px';\n        labelElement.style.top = pointsRegion[i].point.y - labelElement.offsetHeight - smithchart.series[seriesindex].marker.height / 2 + 'px';\n        var blazorId = '_seriesIndex' + seriesindex + '_pointIndex' + i + smithchart.element.id;\n        updateBlazorTemplate(blazorId + 'Template', 'Template');\n        var left = parseInt(labelElement.style.left, 10);\n        var top_1 = parseInt(labelElement.style.top, 10);\n        var width = labelElement.offsetWidth;\n        var height = labelElement.offsetHeight;\n        var region = pointsRegion[i]['point'];\n        var labelPosition = {\n          textX: left,\n          textY: top_1,\n          x: left,\n          y: top_1\n        };\n        this.labelOptions[seriesindex]['textOptions'][i] = {\n          id: id,\n          x: left,\n          y: top_1,\n          fill: 'black',\n          text: '',\n          font: dataLabel.textStyle,\n          xPosition: left,\n          yPosition: top_1,\n          width: width,\n          height: height,\n          location: region,\n          labelOptions: labelPosition,\n          visible: true,\n          connectorFlag: null\n        };\n      }\n    }\n  };\n\n  return DataLabel;\n}();\n\nexport { DataLabel };","map":null,"metadata":{},"sourceType":"module"}