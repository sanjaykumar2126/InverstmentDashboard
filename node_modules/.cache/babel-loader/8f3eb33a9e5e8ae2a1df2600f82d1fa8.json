{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { drawSymbol, valueToCoefficient, ChartLocation, getElement } from '../../chart/index';\nimport { withIn, PointData, textElement } from '../../common/utils/helper';\nimport { BaseTooltip } from '../../common/user-interaction/tooltip';\nimport { Tooltip, PathOption, TextOption, measureText, Size } from '@syncfusion/ej2-svg-base';\nimport { createElement, remove } from '@syncfusion/ej2-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\nimport { stockEventRender } from '../../common/model/constants';\n/**\n * @private\n */\n\nvar StockEvents =\n/** @class */\nfunction (_super) {\n  __extends(StockEvents, _super);\n\n  function StockEvents(stockChart) {\n    var _this = _super.call(this, stockChart.chart) || this;\n    /** @private */\n\n\n    _this.symbolLocations = [];\n    _this.stockChart = stockChart;\n    _this.chartId = _this.stockChart.element.id;\n    return _this;\n  }\n  /**\n   * @private\n   * To render stock events in chart\n   */\n\n\n  StockEvents.prototype.renderStockEvents = function () {\n    var sChart = this.stockChart;\n    var stockEvent;\n    var stockEventElement;\n    var symbolLocation;\n    var textSize; // Creation of group elements for stock events\n\n    var stockEventsElementGroup = sChart.renderer.createGroup({\n      id: this.chartId + '_StockEvents'\n    });\n    this.symbolLocations = initialArray(sChart.series.length, sChart.stockEvents.length, new ChartLocation(0, 0));\n\n    for (var i = 0; i < sChart.stockEvents.length; i++) {\n      stockEvent = this.stockChart.stockEvents[i];\n\n      for (var _i = 0, _a = sChart.chart.series; _i < _a.length; _i++) {\n        var series = _a[_i];\n        var argsData = {\n          name: stockEventRender,\n          stockChart: sChart,\n          text: stockEvent.text,\n          type: stockEvent.type,\n          cancel: false,\n          series: series\n        };\n        sChart.trigger(stockEventRender, argsData);\n        stockEvent.text = argsData.text;\n        stockEvent.type = argsData.type;\n        textSize = measureText(stockEvent.text + 'W', stockEvent.textStyle);\n\n        if (!argsData.cancel) {\n          stockEventElement = sChart.renderer.createGroup({\n            id: this.chartId + '_Series_' + series.index + '_StockEvents_' + i\n          });\n\n          if (withIn(this.dateParse(stockEvent.date).getTime(), series.xAxis.visibleRange)) {\n            symbolLocation = this.findClosePoint(series, stockEvent);\n\n            if (!stockEvent.showOnSeries) {\n              symbolLocation.y = series.yAxis.rect.y + series.yAxis.rect.height;\n            }\n\n            this.symbolLocations[series.index][i] = symbolLocation;\n            this.createStockElements(stockEventElement, stockEvent, series, i, symbolLocation, textSize);\n            stockEventsElementGroup.appendChild(stockEventElement);\n          }\n        }\n      }\n    }\n\n    return stockEventsElementGroup;\n  };\n\n  StockEvents.prototype.findClosePoint = function (series, sEvent) {\n    var closeIndex = this.getClosest(series, this.dateParse(sEvent.date).getTime());\n    var pointData;\n    var point;\n    var xPixel;\n    var yPixel;\n\n    for (var k = 0; k < series.points.length; k++) {\n      point = series.points[k];\n\n      if (closeIndex === point.xValue && point.visible) {\n        pointData = new PointData(point, series);\n      } else if (k !== 0 && k !== series.points.length) {\n        if (closeIndex > series.points[k - 1].xValue && closeIndex < series.points[k + 1].xValue) {\n          pointData = new PointData(point, series);\n        }\n      }\n    }\n\n    xPixel = series.xAxis.rect.x + valueToCoefficient(pointData.point.xValue, series.xAxis) * series.xAxis.rect.width;\n    yPixel = valueToCoefficient(pointData.point[sEvent.placeAt], series.yAxis) * series.yAxis.rect.height;\n    yPixel = yPixel * -1 + (series.yAxis.rect.y + series.yAxis.rect.height);\n    return new ChartLocation(xPixel, yPixel);\n  };\n\n  StockEvents.prototype.createStockElements = function (stockEventElement, stockEve, series, i, symbolLocation, textSize) {\n    var result = new Size(textSize.width > 20 ? textSize.width : 20, textSize.height > 20 ? textSize.height : 20);\n    var pathString;\n    var pathOption;\n    var lx = symbolLocation.x;\n    var ly = symbolLocation.y;\n    var stockId = this.chartId + '_Series_' + series.index + '_StockEvents_' + i;\n    var border = stockEve.border;\n\n    switch (stockEve.type) {\n      case 'Flag':\n      case 'Circle':\n      case 'Square':\n        stockEventElement.appendChild(drawSymbol(new ChartLocation(lx, ly), 'Circle', new Size(2, 2), '', new PathOption(stockId + '_Circle', 'transparent', border.width, border.color), this.dateParse(stockEve.date).toISOString()));\n        stockEventElement.appendChild(drawSymbol(new ChartLocation(lx, ly - 5), 'VerticalLine', new Size(9, 9), '', new PathOption(stockId + '_Path', border.color, border.width, border.color), this.dateParse(stockEve.date).toISOString()));\n        stockEventElement.appendChild(drawSymbol(new ChartLocation(stockEve.type !== 'Flag' ? lx : lx + result.width / 2, ly - result.height), stockEve.type, result, '', new PathOption(stockId + '_Shape', stockEve.background, border.width, border.color), this.dateParse(stockEve.date).toISOString()));\n        textElement(this.stockChart.renderer, new TextOption(stockId + '_Text', stockEve.type !== 'Flag' ? symbolLocation.x : symbolLocation.x + result.width / 2, symbolLocation.y - result.height, 'middle', stockEve.text, '', 'middle'), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);\n        break;\n\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowRight':\n      case 'ArrowLeft':\n        pathString = 'M' + ' ' + lx + ' ' + ly + ' ' + this.findArrowpaths(stockEve.type);\n        pathOption = new PathOption(stockId + '_Shape', stockEve.background, border.width, border.color, 1, '', pathString);\n        stockEventElement.appendChild(this.stockChart.renderer.drawPath(pathOption));\n        break;\n\n      case 'Triangle':\n      case 'InvertedTriangle':\n        result.height = 3 * textSize.height;\n        result.width = textSize.width + 1.5 * textSize.width;\n        stockEventElement.appendChild(drawSymbol(new ChartLocation(symbolLocation.x, symbolLocation.y), stockEve.type, new Size(20, 20), '', new PathOption(stockId + '_Shape', stockEve.background, border.width, border.color), this.dateParse(stockEve.date).toISOString()));\n        textElement(this.stockChart.renderer, new TextOption(stockId + '_Text', symbolLocation.x, symbolLocation.y, 'middle', stockEve.text, '', 'middle'), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);\n        break;\n\n      case 'Text':\n        textSize.height += 8; //padding for text height\n\n        pathString = 'M' + ' ' + lx + ' ' + ly + ' ' + 'L' + ' ' + (lx - 5) + ' ' + (ly - 5) + ' ' + 'L' + ' ' + (lx - textSize.width / 2) + ' ' + (ly - 5) + ' ' + 'L' + ' ' + (lx - textSize.width / 2) + ' ' + (ly - textSize.height) + ' ' + 'L' + ' ' + (lx + textSize.width / 2) + ' ' + (ly - textSize.height) + ' ' + 'L' + ' ' + (lx + textSize.width / 2) + ' ' + (ly - 5) + ' ' + 'L' + ' ' + (lx + 5) + ' ' + (ly - 5) + ' ' + 'Z';\n        pathOption = new PathOption(stockId + '_Shape', stockEve.background, border.width, border.color, 1, '', pathString);\n        stockEventElement.appendChild(this.stockChart.renderer.drawPath(pathOption));\n        textElement(this.stockChart.renderer, new TextOption(stockId + '_Text', lx, ly - textSize.height / 2, 'middle', stockEve.text, '', 'middle'), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);\n        break;\n\n      default:\n        //pin type calculation.\n        pathString = 'M' + ' ' + lx + ' ' + ly + ' ' + 'L' + ' ' + (lx - textSize.width / 2) + ' ' + (ly - textSize.height / 3) + ' ' + 'L' + ' ' + (lx - textSize.width / 2) + ' ' + (ly - textSize.height) + ' ' + 'L' + ' ' + (lx + textSize.width / 2) + ' ' + (ly - textSize.height) + ' ' + 'L' + ' ' + (lx + textSize.width / 2) + ' ' + (ly - textSize.height / 3) + ' ' + 'Z';\n        pathOption = new PathOption(stockId + '_Shape', stockEve.background, border.width, border.color, 1, '', pathString);\n        stockEventElement.appendChild(this.stockChart.renderer.drawPath(pathOption)); //append text element\n\n        textElement(this.stockChart.renderer, new TextOption(stockId + '_Text', lx, ly - textSize.height / 2, 'middle', stockEve.text, '', 'middle'), stockEve.textStyle, stockEve.textStyle.color, stockEventElement);\n    }\n  };\n\n  StockEvents.prototype.renderStockEventTooltip = function (targetId) {\n    var seriesIndex = parseInt(targetId.split('_StockEvents_')[0].replace(/\\D+/g, ''), 10);\n    var pointIndex = parseInt(targetId.split('_StockEvents_')[1].replace(/\\D+/g, ''), 10);\n    var updatedLocation = this.symbolLocations[seriesIndex][pointIndex];\n    var pointLocation = new ChartLocation(updatedLocation.x, updatedLocation.y + this.stockChart.toolbarHeight + this.stockChart.titleSize.height);\n    this.applyHighLights(pointIndex, seriesIndex); //title size and toolbar height is added location for placing tooltip\n\n    var svgElement = this.getElement(this.chartId + '_StockEvents_Tooltip_svg');\n    var isTooltip = svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0;\n\n    if (!isTooltip) {\n      if (getElement(this.chartId + '_StockEvents_Tooltip_svg')) {\n        remove(getElement(this.chartId + '_StockEvents_Tooltip'));\n      }\n\n      var tooltipElement = createElement('div', {\n        id: this.chartId + '_StockEvents_Tooltip',\n        className: 'ejSVGTooltip',\n        attrs: {\n          'style': 'pointer-events:none; position:absolute;z-index: 1'\n        }\n      });\n      getElement(this.chartId + '_Secondary_Element').appendChild(tooltipElement);\n      this.stockEventTooltip = new Tooltip({\n        opacity: 1,\n        header: '',\n        content: [this.stockChart.stockEvents[pointIndex].description],\n        enableAnimation: true,\n        location: pointLocation,\n        theme: this.stockChart.theme,\n        inverted: true,\n        areaBounds: this.stockChart.chart.chartAxisLayoutPanel.seriesClipRect\n      });\n      this.stockEventTooltip.areaBounds.y += this.stockChart.toolbarHeight + this.stockChart.titleSize.height;\n      this.stockEventTooltip.appendTo('#' + tooltipElement.id);\n    } else {\n      this.stockEventTooltip.content = [this.stockChart.stockEvents[pointIndex].description];\n      this.stockEventTooltip.location = pointLocation;\n      this.stockEventTooltip.dataBind();\n    }\n  };\n  /**\n   * Remove the stock event tooltip\n   * @param duration\n   */\n\n\n  StockEvents.prototype.removeStockEventTooltip = function (duration) {\n    var _this = this;\n\n    var tooltipElement = this.getElement(this.chartId + '_StockEvents_Tooltip');\n    this.stopAnimation();\n\n    if (tooltipElement && this.stockEventTooltip) {\n      this.toolTipInterval = setTimeout(function () {\n        _this.stockEventTooltip.fadeOut();\n\n        _this.removeHighLights();\n      }, duration);\n    }\n  };\n\n  StockEvents.prototype.findArrowpaths = function (type) {\n    var arrowString = '';\n\n    switch (type) {\n      case 'ArrowUp':\n        arrowString = 'l -10 10 l 5 0 l 0 10 l 10 0 l 0 -10 l 5 0 z';\n        break;\n\n      case 'ArrowDown':\n        arrowString = 'l -10 -10 l 5 0 l 0 -10 l 10 0 l 0 10 l 5 0 z';\n        break;\n\n      case 'ArrowLeft':\n        arrowString = 'l -10 -10 l 0 5 l -10 0 l 0 10 l 10 0 l 0 5 z';\n        break;\n\n      case 'ArrowRight':\n        arrowString = 'l 10 -10 l 0 5 l 10 0 l 0 10 l -10 0 l 0 5 z';\n        break;\n    }\n\n    return arrowString;\n  };\n\n  StockEvents.prototype.applyHighLights = function (pointIndex, seriesIndex) {\n    if (this.pointIndex !== pointIndex || this.seriesIndex !== seriesIndex) {\n      this.removeHighLights();\n    }\n\n    this.pointIndex = pointIndex;\n    this.seriesIndex = seriesIndex;\n    var stockId = this.chartId + '_Series_' + seriesIndex + '_StockEvents_' + pointIndex;\n    this.setOpacity(stockId + '_Shape', 0.5);\n    this.setOpacity(stockId + '_Text', 0.5);\n  };\n\n  StockEvents.prototype.removeHighLights = function () {\n    var stockId = this.chartId + '_Series_' + this.seriesIndex + '_StockEvents_' + this.pointIndex;\n    this.setOpacity(stockId + '_Shape', 1);\n    this.setOpacity(stockId + '_Text', 1);\n  };\n\n  StockEvents.prototype.setOpacity = function (elementId, opacity) {\n    if (getElement(elementId)) {\n      getElement(elementId).setAttribute('opacity', opacity.toString());\n    }\n  };\n  /**\n   * @param value\n   * To convert the c# or javascript date formats into js format\n   * refer chart control's dateTime processing.\n   */\n\n\n  StockEvents.prototype.dateParse = function (value) {\n    var dateParser = this.chart.intl.getDateParser({\n      skeleton: 'full',\n      type: 'dateTime'\n    });\n    var dateFormatter = this.chart.intl.getDateFormat({\n      skeleton: 'full',\n      type: 'dateTime'\n    });\n    return new Date(Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n      val: value\n    }).val)))));\n  };\n\n  return StockEvents;\n}(BaseTooltip);\n\nexport { StockEvents };\n\nfunction initialArray(numrows, numcols, initial) {\n  var arr = [];\n\n  for (var i = 0; i < numrows; ++i) {\n    var columns = [];\n\n    for (var j = 0; j < numcols; ++j) {\n      columns[j] = initial;\n    }\n\n    arr[i] = columns;\n  }\n\n  return arr;\n}","map":null,"metadata":{},"sourceType":"module"}