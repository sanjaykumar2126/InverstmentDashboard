{"ast":null,"code":"import PlotAreaBase from './plotarea-base';\nimport AxisGroupRangeTracker from '../axis-group-range-tracker';\nimport PlotAreaEventsMixin from '../mixins/plotarea-events-mixin';\nimport SeriesAggregator from '../aggregates/series-aggregator';\nimport DefaultAggregates from '../aggregates/default-aggregates';\nimport SeriesBinder from '../series-binder';\nimport BarChart from '../bar-chart/bar-chart';\nimport RangeBarChart from '../range-bar-chart/range-bar-chart';\nimport BulletChart from '../bullet-chart/bullet-chart';\nimport LineChart from '../line-chart/line-chart';\nimport AreaChart from '../area-chart/area-chart';\nimport RangeAreaChart from '../range-area-chart/range-area-chart';\nimport OHLCChart from '../ohlc-chart/ohlc-chart';\nimport CandlestickChart from '../candlestick-chart/candlestick-chart';\nimport BoxPlotChart from '../box-plot-chart/box-plot-chart';\nimport WaterfallChart from '../waterfall-chart/waterfall-chart';\nimport { CategoryAxis, DateCategoryAxis, NumericAxis, LogarithmicAxis, Point } from '../../core';\nimport { appendIfNotNull, categoriesCount, createOutOfRangePoints, equalsIgnoreCase, filterSeriesByType, getDateField, getField, isDateAxis, singleItemOrArray } from '../utils';\nimport { BAR, COLUMN, BULLET, VERTICAL_BULLET, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL, BOX_PLOT, VERTICAL_BOX_PLOT, OHLC, CANDLESTICK, LOGARITHMIC, STEP, EQUALLY_SPACED_SERIES } from '../constants';\nimport { DATE, MAX_VALUE } from '../../common/constants';\nimport { setDefaultOptions, inArray, isNumber, deepExtend, defined, eventElement, grep } from '../../common';\nvar AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];\nvar OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);\n\nvar CategoricalPlotArea = function (PlotAreaBase) {\n  function CategoricalPlotArea() {\n    PlotAreaBase.apply(this, arguments);\n  }\n\n  if (PlotAreaBase) CategoricalPlotArea.__proto__ = PlotAreaBase;\n  CategoricalPlotArea.prototype = Object.create(PlotAreaBase && PlotAreaBase.prototype);\n  CategoricalPlotArea.prototype.constructor = CategoricalPlotArea;\n\n  CategoricalPlotArea.prototype.initFields = function initFields(series) {\n    var this$1 = this;\n    this.namedCategoryAxes = {};\n    this.namedValueAxes = {};\n    this.valueAxisRangeTracker = new AxisGroupRangeTracker();\n\n    if (series.length > 0) {\n      this.invertAxes = inArray(series[0].type, [BAR, BULLET, VERTICAL_LINE, VERTICAL_AREA, VERTICAL_RANGE_AREA, RANGE_BAR, HORIZONTAL_WATERFALL, VERTICAL_BOX_PLOT]);\n\n      for (var i = 0; i < series.length; i++) {\n        var stack = series[i].stack;\n\n        if (stack && stack.type === \"100%\") {\n          this$1.stack100 = true;\n          break;\n        }\n      }\n    }\n  };\n\n  CategoricalPlotArea.prototype.render = function render(panes) {\n    if (panes === void 0) panes = this.panes;\n    this.createCategoryAxes(panes);\n    this.aggregateCategories(panes);\n    this.createCategoryAxesLabels(panes);\n    this.createCharts(panes);\n    this.createValueAxes(panes);\n  };\n\n  CategoricalPlotArea.prototype.removeAxis = function removeAxis(axis) {\n    var axisName = axis.options.name;\n    PlotAreaBase.prototype.removeAxis.call(this, axis);\n\n    if (axis instanceof CategoryAxis) {\n      delete this.namedCategoryAxes[axisName];\n    } else {\n      this.valueAxisRangeTracker.reset(axisName);\n      delete this.namedValueAxes[axisName];\n    }\n\n    if (axis === this.categoryAxis) {\n      delete this.categoryAxis;\n    }\n\n    if (axis === this.valueAxis) {\n      delete this.valueAxis;\n    }\n  };\n\n  CategoricalPlotArea.prototype.createCharts = function createCharts(panes) {\n    var this$1 = this;\n    var seriesByPane = this.groupSeriesByPane();\n\n    for (var i = 0; i < panes.length; i++) {\n      var pane = panes[i];\n      var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n      this$1.addToLegend(paneSeries);\n      var visibleSeries = this$1.filterVisibleSeries(paneSeries);\n\n      if (!visibleSeries) {\n        continue;\n      }\n\n      var groups = this$1.groupSeriesByCategoryAxis(visibleSeries);\n\n      for (var groupIx = 0; groupIx < groups.length; groupIx++) {\n        this$1.createChartGroup(groups[groupIx], pane);\n      }\n    }\n  };\n\n  CategoricalPlotArea.prototype.createChartGroup = function createChartGroup(series, pane) {\n    this.createAreaChart(filterSeriesByType(series, [AREA, VERTICAL_AREA]), pane);\n    this.createRangeAreaChart(filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]), pane);\n    this.createBarChart(filterSeriesByType(series, [COLUMN, BAR]), pane);\n    this.createRangeBarChart(filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]), pane);\n    this.createBulletChart(filterSeriesByType(series, [BULLET, VERTICAL_BULLET]), pane);\n    this.createCandlestickChart(filterSeriesByType(series, CANDLESTICK), pane);\n    this.createBoxPlotChart(filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]), pane);\n    this.createOHLCChart(filterSeriesByType(series, OHLC), pane);\n    this.createWaterfallChart(filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]), pane);\n    this.createLineChart(filterSeriesByType(series, [LINE, VERTICAL_LINE]), pane);\n  };\n\n  CategoricalPlotArea.prototype.aggregateCategories = function aggregateCategories(panes) {\n    var this$1 = this;\n    var series = this.srcSeries || this.series;\n    var processedSeries = [];\n    this._currentPointsCache = {};\n    this._seriesPointsCache = this._seriesPointsCache || {};\n\n    for (var i = 0; i < series.length; i++) {\n      var currentSeries = series[i];\n      var categoryAxis = this$1.seriesCategoryAxis(currentSeries);\n      var axisPane = this$1.findPane(categoryAxis.options.pane);\n      var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n\n      if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {\n        currentSeries = this$1.aggregateSeries(currentSeries, categoryAxis);\n      } else {\n        currentSeries = this$1.filterSeries(currentSeries, categoryAxis);\n      }\n\n      processedSeries.push(currentSeries);\n    }\n\n    this._seriesPointsCache = this._currentPointsCache;\n    this._currentPointsCache = null;\n    this.srcSeries = series;\n    this.series = processedSeries;\n  };\n\n  CategoricalPlotArea.prototype.filterSeries = function filterSeries(series, categoryAxis) {\n    var dataLength = (series.data || {}).length;\n    categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);\n\n    if (!(isNumber(categoryAxis.options.min) || isNumber(categoryAxis.options.max))) {\n      return series;\n    }\n\n    var range = categoryAxis.currentRangeIndices();\n    var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);\n    var currentSeries = deepExtend({}, series);\n    currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);\n\n    if (outOfRangePoints) {\n      createOutOfRangePoints(currentSeries, range, dataLength, function (idx) {\n        return {\n          item: series.data[idx],\n          category: categoryAxis.categoryAt(idx, true),\n          categoryIx: idx - range.min\n        };\n      }, function (idx) {\n        return defined(series.data[idx]);\n      });\n    }\n\n    return currentSeries;\n  };\n\n  CategoricalPlotArea.prototype.clearSeriesPointsCache = function clearSeriesPointsCache() {\n    this._seriesPointsCache = {};\n  };\n\n  CategoricalPlotArea.prototype.seriesSourcePoints = function seriesSourcePoints(series, categoryAxis) {\n    var this$1 = this;\n    var key = series.index + \";\" + categoryAxis.categoriesHash();\n\n    if (this._seriesPointsCache[key]) {\n      this._currentPointsCache[key] = this._seriesPointsCache[key];\n      return this._seriesPointsCache[key];\n    }\n\n    var axisOptions = categoryAxis.options;\n    var srcCategories = axisOptions.srcCategories;\n    var dateAxis = equalsIgnoreCase(axisOptions.type, DATE);\n    var srcData = series.data;\n    var getFn = dateAxis ? getDateField : getField;\n    var result = [];\n\n    if (!dateAxis) {\n      categoryAxis.mapCategories(); //fixes major performance issue caused by searching for the index for large data\n    }\n\n    for (var idx = 0; idx < srcData.length; idx++) {\n      var category = void 0;\n\n      if (series.categoryField) {\n        category = getFn(series.categoryField, srcData[idx], this$1.chartService.intl);\n      } else {\n        category = srcCategories[idx];\n      }\n\n      if (defined(category) && category !== null) {\n        var categoryIx = categoryAxis.totalIndex(category);\n        result[categoryIx] = result[categoryIx] || {\n          items: [],\n          category: category\n        };\n        result[categoryIx].items.push(idx);\n      }\n    }\n\n    this._currentPointsCache[key] = result;\n    return result;\n  };\n\n  CategoricalPlotArea.prototype.aggregateSeries = function aggregateSeries(series, categoryAxis) {\n    var srcData = series.data;\n\n    if (!srcData.length) {\n      return series;\n    }\n\n    var srcPoints = this.seriesSourcePoints(series, categoryAxis);\n    var result = deepExtend({}, series);\n    var aggregator = new SeriesAggregator(deepExtend({}, series), SeriesBinder.current, DefaultAggregates.current);\n    var data = result.data = [];\n    var dataItems = categoryAxis.options.dataItems || [];\n    var range = categoryAxis.currentRangeIndices();\n\n    var categoryItem = function (idx) {\n      var categoryIdx = idx - range.min;\n      var point = srcPoints[idx];\n\n      if (!point) {\n        point = srcPoints[idx] = {};\n      }\n\n      point.categoryIx = categoryIdx;\n\n      if (!point.item) {\n        var category = categoryAxis.categoryAt(idx, true);\n        point.category = category;\n        point.item = aggregator.aggregatePoints(point.items, category);\n      }\n\n      return point;\n    };\n\n    for (var idx = range.min; idx <= range.max; idx++) {\n      var point = categoryItem(idx);\n      data[point.categoryIx] = point.item;\n\n      if (point.items && point.items.length) {\n        dataItems[point.categoryIx] = point.item;\n      }\n    }\n\n    if (inArray(result.type, OUT_OF_RANGE_SERIES)) {\n      createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, function (idx) {\n        return srcPoints[idx];\n      });\n    }\n\n    categoryAxis.options.dataItems = dataItems;\n    return result;\n  };\n\n  CategoricalPlotArea.prototype.appendChart = function appendChart(chart, pane) {\n    var series = chart.options.series;\n    var categoryAxis = this.seriesCategoryAxis(series[0]);\n    var categories = categoryAxis.options.categories;\n    var categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);\n\n    if (categoriesToAdd > 0) {\n      //consider setting an option to axis instead of adding fake categories\n      categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);\n\n      while (categoriesToAdd--) {\n        categories.push(\"\");\n      }\n    }\n\n    this.valueAxisRangeTracker.update(chart.valueAxisRanges);\n    PlotAreaBase.prototype.appendChart.call(this, chart, pane);\n  }; // TODO: Refactor, optionally use series.pane option\n\n\n  CategoricalPlotArea.prototype.seriesPaneName = function seriesPaneName(series) {\n    var options = this.options;\n    var axisName = series.axis;\n    var axisOptions = [].concat(options.valueAxis);\n    var axis = grep(axisOptions, function (a) {\n      return a.name === axisName;\n    })[0];\n    var panes = options.panes || [{}];\n    var defaultPaneName = (panes[0] || {}).name || \"default\";\n    var paneName = (axis || {}).pane || defaultPaneName;\n    return paneName;\n  };\n\n  CategoricalPlotArea.prototype.seriesCategoryAxis = function seriesCategoryAxis(series) {\n    var axisName = series.categoryAxis;\n    var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;\n\n    if (!axis) {\n      throw new Error(\"Unable to locate category axis with name \" + axisName);\n    }\n\n    return axis;\n  };\n\n  CategoricalPlotArea.prototype.stackableChartOptions = function stackableChartOptions(firstSeries, pane) {\n    var stack = firstSeries.stack;\n    var isStacked100 = stack && stack.type === \"100%\";\n    var clip = pane.options.clip;\n    return {\n      isStacked: stack,\n      isStacked100: isStacked100,\n      clip: clip\n    };\n  };\n\n  CategoricalPlotArea.prototype.groupSeriesByCategoryAxis = function groupSeriesByCategoryAxis(series) {\n    var categoryAxes = [];\n    var unique = {};\n\n    for (var idx = 0; idx < series.length; idx++) {\n      var name = series[idx].categoryAxis || \"$$default$$\";\n\n      if (!unique.hasOwnProperty(name)) {\n        unique[name] = true;\n        categoryAxes.push(name);\n      }\n    }\n\n    var groups = [];\n\n    for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {\n      var axis = categoryAxes[axisIx];\n      var axisSeries = groupSeries(series, axis, axisIx);\n\n      if (axisSeries.length === 0) {\n        continue;\n      }\n\n      groups.push(axisSeries);\n    }\n\n    return groups;\n  };\n\n  CategoricalPlotArea.prototype.createBarChart = function createBarChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    var firstSeries = series[0];\n    var barChart = new BarChart(this, Object.assign({\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing\n    }, this.stackableChartOptions(firstSeries, pane)));\n    this.appendChart(barChart, pane);\n  };\n\n  CategoricalPlotArea.prototype.createRangeBarChart = function createRangeBarChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    var firstSeries = series[0];\n    var rangeColumnChart = new RangeBarChart(this, {\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing\n    });\n    this.appendChart(rangeColumnChart, pane);\n  };\n\n  CategoricalPlotArea.prototype.createBulletChart = function createBulletChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    var firstSeries = series[0];\n    var bulletChart = new BulletChart(this, {\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(bulletChart, pane);\n  };\n\n  CategoricalPlotArea.prototype.createLineChart = function createLineChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    var firstSeries = series[0];\n    var lineChart = new LineChart(this, Object.assign({\n      invertAxes: this.invertAxes,\n      series: series\n    }, this.stackableChartOptions(firstSeries, pane)));\n    this.appendChart(lineChart, pane);\n  };\n\n  CategoricalPlotArea.prototype.createAreaChart = function createAreaChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    var firstSeries = series[0];\n    var areaChart = new AreaChart(this, Object.assign({\n      invertAxes: this.invertAxes,\n      series: series\n    }, this.stackableChartOptions(firstSeries, pane)));\n    this.appendChart(areaChart, pane);\n  };\n\n  CategoricalPlotArea.prototype.createRangeAreaChart = function createRangeAreaChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    var rangeAreaChart = new RangeAreaChart(this, {\n      invertAxes: this.invertAxes,\n      series: series,\n      clip: pane.options.clip\n    });\n    this.appendChart(rangeAreaChart, pane);\n  };\n\n  CategoricalPlotArea.prototype.createOHLCChart = function createOHLCChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    var firstSeries = series[0];\n    var chart = new OHLCChart(this, {\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      series: series,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(chart, pane);\n  };\n\n  CategoricalPlotArea.prototype.createCandlestickChart = function createCandlestickChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    var firstSeries = series[0];\n    var chart = new CandlestickChart(this, {\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      series: series,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(chart, pane);\n  };\n\n  CategoricalPlotArea.prototype.createBoxPlotChart = function createBoxPlotChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    var firstSeries = series[0];\n    var chart = new BoxPlotChart(this, {\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      series: series,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(chart, pane);\n  };\n\n  CategoricalPlotArea.prototype.createWaterfallChart = function createWaterfallChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n\n    var firstSeries = series[0];\n    var waterfallChart = new WaterfallChart(this, {\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing\n    });\n    this.appendChart(waterfallChart, pane);\n  };\n\n  CategoricalPlotArea.prototype.axisRequiresRounding = function axisRequiresRounding(categoryAxisName, categoryAxisIndex) {\n    var this$1 = this;\n    var centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);\n\n    for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {\n      var currentSeries = this$1.series[seriesIx];\n\n      if (inArray(currentSeries.type, AREA_SERIES)) {\n        var line = currentSeries.line;\n\n        if (line && line.style === STEP) {\n          centeredSeries.push(currentSeries);\n        }\n      }\n    }\n\n    for (var seriesIx$1 = 0; seriesIx$1 < centeredSeries.length; seriesIx$1++) {\n      var seriesAxis = centeredSeries[seriesIx$1].categoryAxis || \"\";\n\n      if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {\n        return true;\n      }\n    }\n  };\n\n  CategoricalPlotArea.prototype.aggregatedAxis = function aggregatedAxis(categoryAxisName, categoryAxisIndex) {\n    var series = this.series;\n\n    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      var seriesAxis = series[seriesIx].categoryAxis || \"\";\n\n      if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {\n        return true;\n      }\n    }\n  };\n\n  CategoricalPlotArea.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {\n    var axes = this.axes;\n\n    for (var i = 0; i < axes.length; i++) {\n      if (axes[i] instanceof CategoryAxis) {\n        axes[i].createLabels();\n      }\n    }\n  };\n\n  CategoricalPlotArea.prototype.createCategoryAxes = function createCategoryAxes(panes) {\n    var this$1 = this;\n    var invertAxes = this.invertAxes;\n    var definitions = [].concat(this.options.categoryAxis);\n    var axes = [];\n\n    for (var i = 0; i < definitions.length; i++) {\n      var axisOptions = definitions[i];\n      var axisPane = this$1.findPane(axisOptions.pane);\n\n      if (inArray(axisPane, panes)) {\n        var name = axisOptions.name;\n        var categories = axisOptions.categories;\n        if (categories === void 0) categories = [];\n        axisOptions = deepExtend({\n          vertical: invertAxes,\n          reverse: !invertAxes && this$1.chartService.rtl,\n          axisCrossingValue: invertAxes ? MAX_VALUE : 0\n        }, axisOptions);\n\n        if (!defined(axisOptions.justified)) {\n          axisOptions.justified = this$1.isJustified();\n        }\n\n        if (this$1.axisRequiresRounding(name, i)) {\n          axisOptions.justified = false;\n        }\n\n        var categoryAxis = void 0;\n\n        if (isDateAxis(axisOptions, categories[0])) {\n          categoryAxis = new DateCategoryAxis(axisOptions, this$1.chartService);\n        } else {\n          categoryAxis = new CategoryAxis(axisOptions, this$1.chartService);\n        }\n\n        definitions[i].categories = categoryAxis.options.srcCategories;\n\n        if (name) {\n          if (this$1.namedCategoryAxes[name]) {\n            throw new Error(\"Category axis with name \" + name + \" is already defined\");\n          }\n\n          this$1.namedCategoryAxes[name] = categoryAxis;\n        }\n\n        categoryAxis.axisIndex = i;\n        axes.push(categoryAxis);\n        this$1.appendAxis(categoryAxis);\n      }\n    }\n\n    var primaryAxis = this.categoryAxis || axes[0];\n    this.categoryAxis = primaryAxis;\n\n    if (invertAxes) {\n      this.axisY = primaryAxis;\n    } else {\n      this.axisX = primaryAxis;\n    }\n  };\n\n  CategoricalPlotArea.prototype.isJustified = function isJustified() {\n    var series = this.series;\n\n    for (var i = 0; i < series.length; i++) {\n      var currentSeries = series[i];\n\n      if (!inArray(currentSeries.type, AREA_SERIES)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  CategoricalPlotArea.prototype.createValueAxes = function createValueAxes(panes) {\n    var this$1 = this;\n    var tracker = this.valueAxisRangeTracker;\n    var defaultRange = tracker.query();\n    var definitions = [].concat(this.options.valueAxis);\n    var invertAxes = this.invertAxes;\n    var baseOptions = {\n      vertical: !invertAxes,\n      reverse: invertAxes && this.chartService.rtl\n    };\n    var axes = [];\n\n    if (this.stack100) {\n      baseOptions.roundToMajorUnit = false;\n      baseOptions.labels = {\n        format: \"P0\"\n      };\n    }\n\n    for (var i = 0; i < definitions.length; i++) {\n      var axisOptions = definitions[i];\n      var axisPane = this$1.findPane(axisOptions.pane);\n\n      if (inArray(axisPane, panes)) {\n        var name = axisOptions.name;\n        var defaultAxisRange = equalsIgnoreCase(axisOptions.type, LOGARITHMIC) ? {\n          min: 0.1,\n          max: 1\n        } : {\n          min: 0,\n          max: 1\n        };\n        var range = tracker.query(name) || defaultRange || defaultAxisRange;\n\n        if (i === 0 && range && defaultRange) {\n          range.min = Math.min(range.min, defaultRange.min);\n          range.max = Math.max(range.max, defaultRange.max);\n        }\n\n        var axisType = void 0;\n\n        if (equalsIgnoreCase(axisOptions.type, LOGARITHMIC)) {\n          axisType = LogarithmicAxis;\n        } else {\n          axisType = NumericAxis;\n        }\n\n        var valueAxis = new axisType(range.min, range.max, deepExtend({}, baseOptions, axisOptions), this$1.chartService);\n\n        if (name) {\n          if (this$1.namedValueAxes[name]) {\n            throw new Error(\"Value axis with name \" + name + \" is already defined\");\n          }\n\n          this$1.namedValueAxes[name] = valueAxis;\n        }\n\n        valueAxis.axisIndex = i;\n        axes.push(valueAxis);\n        this$1.appendAxis(valueAxis);\n      }\n    }\n\n    var primaryAxis = this.valueAxis || axes[0];\n    this.valueAxis = primaryAxis;\n\n    if (invertAxes) {\n      this.axisX = primaryAxis;\n    } else {\n      this.axisY = primaryAxis;\n    }\n  };\n\n  CategoricalPlotArea.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {\n    var coords = chart._eventCoordinates(e);\n\n    var point = new Point(coords.x, coords.y);\n    var pane = this.pointPane(point);\n    var categories = [];\n    var values = [];\n\n    if (!pane) {\n      return;\n    }\n\n    var allAxes = pane.axes;\n\n    for (var i = 0; i < allAxes.length; i++) {\n      var axis = allAxes[i];\n\n      if (axis.getValue) {\n        appendIfNotNull(values, axis.getValue(point));\n      } else {\n        appendIfNotNull(categories, axis.getCategory(point));\n      }\n    }\n\n    if (categories.length === 0) {\n      appendIfNotNull(categories, this.categoryAxis.getCategory(point));\n    }\n\n    if (categories.length > 0 && values.length > 0) {\n      chart.trigger(eventType, {\n        element: eventElement(e),\n        originalEvent: e,\n        category: singleItemOrArray(categories),\n        value: singleItemOrArray(values)\n      });\n    }\n  };\n\n  CategoricalPlotArea.prototype.pointPane = function pointPane(point) {\n    var panes = this.panes;\n\n    for (var i = 0; i < panes.length; i++) {\n      var currentPane = panes[i];\n\n      if (currentPane.contentBox.containsPoint(point)) {\n        return currentPane;\n      }\n    }\n  };\n\n  CategoricalPlotArea.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options) {\n    updateAxisOptions(this.options, axis, options);\n    updateAxisOptions(this.originalOptions, axis, options);\n  };\n\n  return CategoricalPlotArea;\n}(PlotAreaBase);\n\nfunction updateAxisOptions(targetOptions, axis, options) {\n  var axesOptions = axis instanceof CategoryAxis ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);\n  deepExtend(axesOptions[axis.axisIndex], options);\n}\n\nfunction groupSeries(series, axis, axisIx) {\n  return grep(series, function (s) {\n    return axisIx === 0 && !s.categoryAxis || s.categoryAxis === axis;\n  });\n}\n\nsetDefaultOptions(CategoricalPlotArea, {\n  categoryAxis: {},\n  valueAxis: {}\n});\ndeepExtend(CategoricalPlotArea.prototype, PlotAreaEventsMixin);\nexport default CategoricalPlotArea;","map":null,"metadata":{},"sourceType":"module"}