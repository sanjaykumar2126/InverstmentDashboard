{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { setDefaultOptions, deepExtend, round, isArray } from '../../common';\nimport { COORD_PRECISION } from '../../common/constants';\nimport Gauge from '../gauge';\nimport RadialScale from './radial-scale';\nimport RadialPointer from './radial-pointer';\nvar Group = drawing.Group;\n\nvar RadialGauge = function (Gauge) {\n  function RadialGauge() {\n    Gauge.apply(this, arguments);\n  }\n\n  if (Gauge) RadialGauge.__proto__ = Gauge;\n  RadialGauge.prototype = Object.create(Gauge && Gauge.prototype);\n  RadialGauge.prototype.constructor = RadialGauge;\n\n  RadialGauge.prototype.reflow = function reflow(bbox) {\n    var this$1 = this;\n    var pointers = this.pointers;\n    this.scale.reflow(bbox);\n    this._initialPlotArea = this.scale.bbox;\n\n    for (var i = 0; i < pointers.length; i++) {\n      pointers[i].reflow(this$1.scale.arc);\n      this$1._initialPlotArea = geo.Rect.union(this$1._initialPlotArea, pointers[i].bbox);\n    }\n\n    this.fitScale(bbox);\n    this.alignScale(bbox);\n\n    this._buildVisual(this.gaugeArea, pointers, this.scale);\n\n    this._draw();\n  };\n\n  RadialGauge.prototype._buildVisual = function _buildVisual(gaugeArea, pointers, scale) {\n    var visuals = this._visuals = new Group();\n    visuals.append(gaugeArea);\n    visuals.append(scale.ticks);\n    visuals.append(scale.ranges);\n\n    this._buildPointers(pointers);\n\n    visuals.append(scale.labelElements);\n  };\n\n  RadialGauge.prototype._buildPointers = function _buildPointers(pointers) {\n    var this$1 = this;\n\n    for (var i = 0; i < pointers.length; i++) {\n      var current = pointers[i];\n      current.render();\n\n      this$1._visuals.append(current.elements);\n\n      current.value(current.options.value);\n    }\n  };\n\n  RadialGauge.prototype.fitScale = function fitScale(bbox) {\n    var this$1 = this;\n    var arc = this.scale.arc;\n    var plotAreaBox = this._initialPlotArea;\n    var step = Math.abs(this.getDiff(plotAreaBox, bbox));\n    var min = round(step, COORD_PRECISION);\n    var max = round(-step, COORD_PRECISION);\n    var minDiff, midDiff, maxDiff, mid, oldDiff;\n    var staleFlag = 0;\n    var i = 0;\n\n    while (i++ < 100) {\n      staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;\n\n      if (staleFlag > 5) {\n        break;\n      }\n\n      if (min !== mid) {\n        minDiff = this$1.getPlotBox(min, bbox, arc);\n\n        if (0 <= minDiff && minDiff <= 2) {\n          break;\n        }\n      }\n\n      if (max !== mid) {\n        maxDiff = this$1.getPlotBox(max, bbox, arc);\n\n        if (0 <= maxDiff && maxDiff <= 2) {\n          break;\n        }\n      }\n\n      if (minDiff > 0 && maxDiff > 0) {\n        mid = min * 2;\n      } else if (minDiff < 0 && maxDiff < 0) {\n        mid = max * 2;\n      } else {\n        mid = round((min + max) / 2 || 1, COORD_PRECISION);\n      }\n\n      midDiff = this$1.getPlotBox(mid, bbox, arc);\n\n      if (0 <= midDiff && midDiff <= 2) {\n        break;\n      }\n\n      oldDiff = maxDiff;\n\n      if (midDiff > 0) {\n        max = mid;\n        maxDiff = midDiff;\n      } else {\n        min = mid;\n        minDiff = midDiff;\n      }\n    }\n  };\n\n  RadialGauge.prototype.getPlotBox = function getPlotBox(step, bbox, arc) {\n    var this$1 = this;\n    var scale = this.scale;\n    var pointers = this.pointers;\n    var radius = arc.getRadiusX();\n    var scaleArc = arc.clone();\n    scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);\n    scale.arc = scaleArc;\n    scale.reflow(bbox);\n    this.plotBbox = scale.bbox;\n\n    for (var i = 0; i < pointers.length; i++) {\n      pointers[i].reflow(scaleArc);\n      this$1.plotBbox = geo.Rect.union(this$1.plotBbox, pointers[i].bbox);\n    }\n\n    return this.getDiff(this.plotBbox, bbox);\n  };\n\n  RadialGauge.prototype.getDiff = function getDiff(plotBox, box) {\n    return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());\n  };\n\n  RadialGauge.prototype.alignScale = function alignScale(bbox) {\n    var this$1 = this;\n    var plotBoxCenter = this.plotBbox.center();\n    var boxCenter = bbox.center();\n    var paddingX = plotBoxCenter.x - boxCenter.x;\n    var paddingY = plotBoxCenter.y - boxCenter.y;\n    var ref = this;\n    var scale = ref.scale;\n    var pointers = ref.pointers;\n    scale.arc.center.x -= paddingX;\n    scale.arc.center.y -= paddingY;\n    scale.reflow(bbox);\n\n    for (var i = 0; i < pointers.length; i++) {\n      pointers[i].reflow(scale.arc);\n      this$1.plotBbox = geo.Rect.union(scale.bbox, pointers[i].bbox);\n    }\n  };\n\n  RadialGauge.prototype._createModel = function _createModel() {\n    var this$1 = this;\n    var options = this.options;\n    var pointers = options.pointer;\n    var scale = this.scale = new RadialScale(options.scale, this.contextService);\n    this.pointers = [];\n    var pointersArr = isArray(pointers) ? pointers : [pointers];\n\n    for (var i = 0; i < pointersArr.length; i++) {\n      var current = new RadialPointer(scale, deepExtend({}, pointersArr[i], {\n        animation: {\n          transitions: options.transitions\n        }\n      }));\n      this$1.pointers.push(current);\n    }\n  };\n\n  return RadialGauge;\n}(Gauge);\n\nsetDefaultOptions(RadialGauge, {\n  transitions: true,\n  gaugeArea: {\n    background: \"\"\n  }\n});\nexport default RadialGauge;","map":null,"metadata":{},"sourceType":"module"}