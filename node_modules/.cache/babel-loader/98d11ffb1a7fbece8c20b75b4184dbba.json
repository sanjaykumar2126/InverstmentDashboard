{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { extend, Browser, remove } from '@syncfusion/ej2-base';\nimport { PointData, ChartLocation } from '../../common/utils/helper';\nimport { valueToCoefficient, removeElement, valueToPolarCoefficient, withInBounds } from '../../common/utils/helper';\nimport { BaseTooltip } from '../../common/user-interaction/tooltip';\nimport { tooltipRender } from '../../common/model/constants';\n/**\n * `Tooltip` module is used to render the tooltip for chart series.\n */\n\nvar Tooltip =\n/** @class */\nfunction (_super) {\n  __extends(Tooltip, _super);\n  /**\n   * Constructor for tooltip module.\n   * @private.\n   */\n\n\n  function Tooltip(chart) {\n    var _this = _super.call(this, chart) || this;\n\n    _this.addEventListener();\n\n    return _this;\n  }\n  /**\n   * @hidden\n   */\n\n\n  Tooltip.prototype.addEventListener = function () {\n    if (this.chart.isDestroyed) {\n      return;\n    }\n\n    var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';\n    this.chart.on(cancelEvent, this.mouseLeaveHandler, this);\n    this.chart.on('tapHold', this.longPress, this);\n    this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);\n    this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);\n  };\n\n  Tooltip.prototype.mouseUpHandler = function () {\n    var chart = this.control;\n\n    if (chart.isTouch && !this.isSelected(chart) && (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect) && chart.tooltip.shared || !chart.tooltip.shared)) {\n      if (!chart.crosshair.enable) {\n        this.tooltip();\n        this.removeTooltip(2000);\n      } else if (chart.startMove) {\n        this.removeTooltip(2000);\n      }\n    }\n  };\n\n  Tooltip.prototype.mouseLeaveHandler = function () {\n    this.removeTooltip(1000);\n  };\n\n  Tooltip.prototype.mouseMoveHandler = function () {\n    var chart = this.chart; // Tooltip for chart series.\n\n    if (!chart.disableTrackTooltip && !this.isSelected(chart)) {\n      if (!chart.tooltip.shared && (!chart.isTouch || chart.startMove)) {\n        this.tooltip();\n      }\n\n      if (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n        if (chart.tooltip.shared && (!chart.isTouch || chart.startMove)) {\n          this.tooltip();\n        }\n      } else {\n        if (chart.tooltip.shared) {\n          this.removeTooltip(1000);\n        }\n      }\n    }\n  };\n  /**\n   * Handles the long press on chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Tooltip.prototype.longPress = function () {\n    var chart = this.chart;\n\n    if (chart.crosshair.enable && withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n      this.tooltip();\n    }\n\n    return false;\n  };\n  /**\n   * Renders the tooltip.\n   * @return {void}\n   */\n\n\n  Tooltip.prototype.tooltip = function () {\n    if (this.chart.stockChart && this.chart.stockChart.onPanning) {\n      this.removeTooltip(1000);\n      return null;\n    }\n\n    var svgElement;\n    var elementId = this.chart.enableCanvas ? this.element.id + '_tooltip_group' : this.element.id + '_tooltip_svg';\n    svgElement = this.getElement(elementId);\n    var isTooltip = svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0;\n    var tooltipDiv = this.getTooltipElement(isTooltip);\n\n    if (this.chart.enableCanvas && tooltipDiv) {\n      document.getElementById(this.chart.element.id + '_Secondary_Element').appendChild(tooltipDiv);\n      tooltipDiv.appendChild(document.getElementById(this.chart.element.id + '_tooltip_svg'));\n    }\n\n    if (!this.chart.tooltip.shared) {\n      this.renderSeriesTooltip(this.chart, !isTooltip, tooltipDiv);\n    } else {\n      this.renderGroupedTooltip(this.chart, !isTooltip, tooltipDiv);\n    }\n  };\n\n  Tooltip.prototype.findHeader = function (data) {\n    if (this.header === '') {\n      return '';\n    }\n\n    this.header = this.parseTemplate(data.point, data.series, this.header, data.series.xAxis, data.series.yAxis);\n\n    if (this.header.replace(/<b>/g, '').replace(/<\\/b>/g, '').trim() !== '') {\n      return this.header;\n    }\n\n    return '';\n  };\n\n  Tooltip.prototype.findShapes = function () {\n    if (!this.chart.tooltip.enableMarker) {\n      return [];\n    }\n\n    var marker = [];\n\n    for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {\n      var data = _a[_i];\n      marker.push(data.point.marker.shape || data.series.marker.shape);\n    }\n\n    return marker;\n  };\n\n  Tooltip.prototype.renderSeriesTooltip = function (chart, isFirst, tooltipDiv) {\n    var data = this.getData();\n    data.lierIndex = this.lierIndex;\n    var rect = chart.chartAxisLayoutPanel.seriesClipRect;\n    this.currentPoints = [];\n    var tool;\n\n    if (this.findData(data, this.previousPoints[0])) {\n      if (this.pushData(data, isFirst, tooltipDiv, true)) {\n        this.triggerTooltipRender(data, isFirst, this.getTooltipText(data), this.findHeader(data));\n      }\n    } else {\n      if (!data.point && this.isRemove) {\n        this.removeTooltip(1000);\n        this.isRemove = false;\n      } else {\n        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n          var series = _a[_i];\n\n          if (series.visible) {\n            data = this.getClosestX(chart, series) || data;\n          }\n        }\n      }\n    }\n\n    if (data && data.point) {\n      this.findMouseValue(data, chart);\n    }\n  };\n\n  Tooltip.prototype.triggerTooltipRender = function (point, isFirst, textCollection, headerText, firstText) {\n    var _this = this;\n\n    if (firstText === void 0) {\n      firstText = true;\n    }\n\n    var argsData = {\n      cancel: false,\n      name: tooltipRender,\n      text: textCollection,\n      headerText: headerText,\n      series: this.chart.isBlazor ? {} : point.series,\n      textStyle: this.textStyle,\n      point: point.point,\n      data: {\n        pointX: point.point.x,\n        pointY: point.point.y,\n        seriesIndex: point.series.index,\n        seriesName: point.series.name,\n        pointIndex: point.point.index,\n        pointText: point.point.text\n      }\n    };\n\n    var chartTooltipSuccess = function (argsData) {\n      if (!argsData.cancel) {\n        if (point.series.type === 'BoxAndWhisker') {\n          _this.removeText();\n\n          isFirst = true;\n        }\n\n        _this.headerText = argsData.headerText;\n        _this.formattedText = _this.formattedText.concat(argsData.text);\n        _this.text = _this.formattedText;\n\n        _this.createTooltip(_this.chart, isFirst, _this.getSymbolLocation(point), point.series.clipRect, point.point, _this.findShapes(), _this.findMarkerHeight(_this.currentPoints[0]), _this.chart.chartAxisLayoutPanel.seriesClipRect, null, _this.getTemplateText(point));\n      } else {\n        _this.removeHighlight(_this.control);\n\n        remove(_this.getElement(_this.element.id + '_tooltip'));\n      }\n\n      _this.isRemove = true;\n    };\n\n    chartTooltipSuccess.bind(this, point);\n    this.chart.trigger(tooltipRender, argsData, chartTooltipSuccess);\n  };\n\n  Tooltip.prototype.findMarkerHeight = function (pointData) {\n    if (!this.chart.tooltip.enableMarker) {\n      return 0;\n    }\n\n    var markerHeight = 0;\n    var series = pointData.series;\n    markerHeight = (series.marker.visible || this.chart.tooltip.shared && (!series.isRectSeries || series.marker.visible) || series.type === 'Scatter' || series.drawType === 'Scatter') && !(series.type === 'Candle' || series.type === 'Hilo' || series.type === 'HiloOpenClose') ? (series.marker.height + 2) / 2 + 2 * series.marker.border.width : 0;\n    return markerHeight;\n  };\n\n  Tooltip.prototype.findData = function (data, previous) {\n    return data.point && (!previous || previous.point !== data.point || previous && previous.lierIndex > 3 && previous.lierIndex !== this.lierIndex || previous.point === data.point);\n  };\n\n  Tooltip.prototype.getSymbolLocation = function (data) {\n    var location;\n\n    if (data.series.type !== 'BoxAndWhisker') {\n      if (!data.point.symbolLocations[0]) {\n        return null;\n      }\n\n      location = new ChartLocation(data.point.symbolLocations[0].x, data.point.symbolLocations[0].y);\n    }\n\n    switch (data.series.type) {\n      case 'BoxAndWhisker':\n        return this.getBoxLocation(data);\n\n      case 'Waterfall':\n        return this.getWaterfallRegion(data, location);\n\n      case 'RangeArea':\n        return this.getRangeArea(data, location);\n\n      default:\n        return location;\n    }\n  };\n\n  Tooltip.prototype.getRangeArea = function (data, location) {\n    if (data.point.regions[0]) {\n      if (!this.inverted) {\n        location.y = data.point.regions[0].y + data.point.regions[0].height / 2;\n      } else {\n        location.x = data.point.regions[0].x + data.point.regions[0].width / 2;\n      }\n    }\n\n    return location;\n  };\n\n  Tooltip.prototype.getWaterfallRegion = function (data, location) {\n    if (!this.inverted) {\n      location.y = data.point.y < 0 ? location.y - data.point.regions[0].height : location.y;\n    } else {\n      location.x = data.point.y < 0 ? location.x + data.point.regions[0].width : location.x;\n    }\n\n    return location;\n  };\n\n  Tooltip.prototype.getTooltipText = function (pointData) {\n    var series = pointData.series;\n    return this.parseTemplate(pointData.point, series, this.getFormat(this.chart, series), series.xAxis, series.yAxis);\n  };\n\n  Tooltip.prototype.getTemplateText = function (data) {\n    if (this.chart.tooltip.template) {\n      var point = extend({}, data.point);\n      point.x = this.formatPointValue(data.point, data.series.xAxis, 'x', true, false);\n\n      if (data.series.seriesType === 'XY') {\n        point.y = this.formatPointValue(data.point, data.series.yAxis, 'y', false, true);\n      } else {\n        point.low = this.formatPointValue(data.point, data.series.yAxis, 'low', false, true);\n        point.high = this.formatPointValue(data.point, data.series.yAxis, 'high', false, true);\n      }\n\n      return point;\n    } else {\n      return data.point;\n    }\n  };\n\n  Tooltip.prototype.findMouseValue = function (data, chart) {\n    if (!chart.requireInvertedAxis) {\n      if (chart.chartAreaType === 'PolarRadar') {\n        this.valueX = valueToPolarCoefficient(data.point.xValue, data.series.xAxis) * data.series.xAxis.rect.width + data.series.xAxis.rect.x;\n      } else {\n        this.valueX = valueToCoefficient(data.point.xValue, data.series.xAxis) * data.series.xAxis.rect.width + data.series.xAxis.rect.x;\n      }\n\n      this.valueY = chart.mouseY;\n    } else {\n      this.valueY = (1 - valueToCoefficient(data.point.xValue, data.series.xAxis)) * data.series.xAxis.rect.height + data.series.xAxis.rect.y;\n      this.valueX = chart.mouseX;\n    }\n  };\n\n  Tooltip.prototype.renderGroupedTooltip = function (chart, isFirst, tooltipDiv) {\n    var data;\n    var height = 0;\n    var width = 0;\n    var pointData = chart.chartAreaType === 'PolarRadar' ? this.getData() : null;\n    this.stopAnimation();\n    this.removeHighlight(chart);\n    this.currentPoints = [];\n    var extraPoints = [];\n    var headerContent = '';\n\n    if (isFirst) {\n      if (!chart.stockChart) {\n        if (tooltipDiv) {\n          document.getElementById(this.element.id + '_Secondary_Element').appendChild(tooltipDiv);\n        }\n      } else {\n        document.getElementById(chart.stockChart.element.id + '_Secondary_Element').appendChild(tooltipDiv);\n      }\n    }\n\n    this.removeText();\n\n    for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n      var series = _a[_i];\n\n      if (!series.enableTooltip || !series.visible) {\n        continue;\n      }\n\n      if (chart.chartAreaType === 'Cartesian' && series.visible) {\n        data = this.getClosestX(chart, series);\n      } else if (chart.chartAreaType === 'PolarRadar' && series.visible && pointData.point !== null) {\n        data = new PointData(series.points[pointData.point.index], series);\n      }\n\n      if (data && this.header !== '' && this.currentPoints.length === 0) {\n        headerContent = this.findHeader(data);\n      }\n\n      if (data) {\n        this.triggerSharedTooltip(data, isFirst, this.getTooltipText(data), this.findHeader(data), extraPoints);\n      } // if (data && this.triggerEvent(data, isFirst, this.getTooltipText(data)), this.findHeader(data)) {\n      //     this.findMouseValue(data, chart);\n      //     (<PointData[]>this.currentPoints).push(data);\n      //     data = null;\n      // } else if (data) {\n      //     extraPoints.push(data);\n      // }\n\n    }\n\n    if (this.currentPoints.length > 0) {\n      this.createTooltip(chart, isFirst, this.findSharedLocation(), this.currentPoints.length === 1 ? this.currentPoints[0].series.clipRect : null, null, this.findShapes(), this.findMarkerHeight(this.currentPoints[0]), chart.chartAxisLayoutPanel.seriesClipRect, extraPoints);\n    } else if (this.getElement(this.element.id + '_tooltip_path')) {\n      this.getElement(this.element.id + '_tooltip_path').setAttribute('d', '');\n    }\n  };\n\n  Tooltip.prototype.triggerSharedTooltip = function (point, isFirst, textCollection, headerText, extraPoints) {\n    var _this = this;\n\n    var argsData = {\n      cancel: false,\n      name: tooltipRender,\n      text: textCollection,\n      headerText: headerText,\n      point: point.point,\n      series: this.chart.isBlazor ? {} : point.series,\n      textStyle: this.textStyle,\n      data: {\n        pointX: point.point.x,\n        pointY: point.point.y,\n        seriesIndex: point.series.index,\n        seriesName: point.series.name,\n        pointIndex: point.point.index,\n        pointText: point.point.text\n      }\n    };\n\n    var sharedTooltipSuccess = function (argsData) {\n      if (!argsData.cancel) {\n        if (point.series.type === 'BoxAndWhisker') {\n          _this.removeText();\n\n          isFirst = true;\n        }\n\n        _this.formattedText = _this.formattedText.concat(argsData.text);\n        _this.text = _this.formattedText;\n        _this.headerText = argsData.headerText;\n\n        _this.findMouseValue(point, _this.chart);\n\n        _this.currentPoints.push(point);\n\n        point = null;\n      } else {\n        extraPoints.push(point);\n      }\n    };\n\n    sharedTooltipSuccess.bind(this, point, extraPoints);\n    this.chart.trigger(tooltipRender, argsData, sharedTooltipSuccess);\n  };\n\n  Tooltip.prototype.findSharedLocation = function () {\n    var stockChart = this.chart.stockChart;\n\n    if (stockChart) {\n      if (this.text.length === 1) {\n        this.text.push('');\n      }\n\n      var toolbarHeight = stockChart.enablePeriodSelector ? stockChart.toolbarHeight : 0;\n      var element = document.getElementById(stockChart.element.id + '_ChartTitle');\n      var titleHeight = stockChart.title !== '' ? element.getBoundingClientRect().height + 10 : 0;\n      return new ChartLocation(this.chart.chartAxisLayoutPanel.seriesClipRect.x + 5, this.chart.chartAxisLayoutPanel.seriesClipRect.y + toolbarHeight + 5 + titleHeight);\n    } else {\n      if (this.currentPoints.length > 1) {\n        return new ChartLocation(this.valueX, this.valueY);\n      } else {\n        return this.getSymbolLocation(this.currentPoints[0]);\n      }\n    }\n  };\n\n  Tooltip.prototype.getBoxLocation = function (data) {\n    var location;\n    location = this.lierIndex > 3 ? data.point.symbolLocations[this.lierIndex - 4] : {\n      x: data.point.regions[0].x + data.point.regions[0].width / 2,\n      y: data.point.regions[0].y + data.point.regions[0].height / 2\n    };\n    return location;\n  };\n\n  Tooltip.prototype.parseTemplate = function (point, series, format, xAxis, yAxis) {\n    var val;\n    var textValue;\n    var xFormat;\n    var customLabelFormat;\n    var chart = this.chart;\n\n    for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {\n      var dataValue = _a[_i];\n      val = new RegExp('${point' + '.' + dataValue + '}', 'gm');\n      format = format.replace(val.source, this.formatPointValue(point, val.source === '${point.x}' ? xAxis : yAxis, dataValue, val.source === '${point.x}', val.source === '${point.high}' || val.source === '${point.open}' || val.source === '${point.close}' || val.source === '${point.low}' || val.source === '${point.y}' || val.source === '${point.minimum}' || val.source === '${point.maximum}' || val.source === '${point.outliers}' || val.source === '${point.upperQuartile}' || val.source === '${point.lowerQuartile}' || val.source === '${point.median}'));\n    }\n\n    for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {\n      var dataValue = _c[_b];\n      val = new RegExp('${series' + '.' + dataValue + '}', 'gm');\n      textValue = series[dataValue];\n      format = format.replace(val.source, textValue);\n    }\n\n    return format;\n  };\n\n  Tooltip.prototype.formatPointValue = function (point, axis, dataValue, isXPoint, isYPoint) {\n    var textValue;\n    var customLabelFormat;\n    var value;\n\n    if (axis.valueType !== 'Category' && isXPoint) {\n      customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;\n      textValue = customLabelFormat ? axis.labelFormat.replace('{value}', axis.format(point[dataValue])) : axis.format(point[dataValue]);\n    } else if (isYPoint) {\n      customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;\n      value = dataValue === 'outliers' ? axis.format(point[dataValue][this.lierIndex - 4]) : axis.format(point[dataValue]);\n      textValue = customLabelFormat ? axis.labelFormat.replace('{value}', value) : value;\n    } else {\n      textValue = point[dataValue];\n    }\n\n    return textValue;\n  };\n\n  Tooltip.prototype.getFormat = function (chart, series) {\n    if (chart.tooltip.format) {\n      if (series.seriesType === 'XY' && series.category === 'Indicator') {\n        return this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);\n      }\n\n      return chart.tooltip.format;\n    }\n\n    var textX = series.type === 'Histogram' ? '${point.minimum}' + '-' + '${point.maximum}' : '${point.x}';\n    var format = !chart.tooltip.shared ? textX : '${series.name}';\n\n    switch (series.seriesType) {\n      case 'XY':\n        if (series.category === 'Indicator') {\n          this.getIndicatorTooltipFormat(series, chart, chart.tooltip.format);\n        }\n\n        return format + ' : ' + (series.type === 'Bubble' ? '<b>${point.y}</b>  Size : <b>${point.size}</b>' : '<b>${point.y}</b>');\n\n      case 'HighLow':\n        return format + '<br/>High : <b>${point.high}</b><br/>Low : <b>${point.low}</b>';\n\n      case 'HighLowOpenClose':\n        return format + ('<br/>High : <b>${point.high}</b><br/>Low : <b>${point.low}</b><br/>' + 'Open : <b>${point.open}</b><br/>Close : <b>${point.close}</b>');\n\n      case 'BoxPlot':\n        {\n          return format + '<br/>' + (this.lierIndex > 3 ? 'Outliers : <b>${point.outliers}</b>' : 'Maximum : <b>${point.maximum}</b><br/>Q3 : <b>${point.upperQuartile}</b><br/>' + 'Median : <b>${point.median}</b><br/>Q1 : <b>${point.lowerQuartile}</b><br/>Minimum : <b>${point.minimum}</b>');\n        }\n    }\n\n    return '';\n  };\n\n  Tooltip.prototype.getIndicatorTooltipFormat = function (series, chart, format) {\n    var toolTip;\n    var points = [];\n\n    if (series.seriesType === 'XY') {\n      toolTip = series.name + ' : <b>${point.y}</b>';\n    } else {\n      toolTip = format;\n    }\n\n    return toolTip;\n  };\n  /*\n     * @hidden\n     */\n\n\n  Tooltip.prototype.removeHighlightedMarker = function (data) {\n    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n      var item = data_1[_i];\n      removeElement(this.element.id + '_Series_' + item.series.index + '_Point_' + item.point.index + '_Trackball');\n    }\n\n    if (this.chart.markerRender) {\n      this.chart.markerRender.removeHighlightedMarker();\n    }\n\n    this.previousPoints = [];\n  };\n  /**\n   * Get module name.\n   */\n\n\n  Tooltip.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'Tooltip';\n  };\n  /**\n   * To destroy the tooltip.\n   * @return {void}\n   * @private\n   */\n\n\n  Tooltip.prototype.destroy = function (chart) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return Tooltip;\n}(BaseTooltip);\n\nexport { Tooltip };","map":null,"metadata":{},"sourceType":"module"}