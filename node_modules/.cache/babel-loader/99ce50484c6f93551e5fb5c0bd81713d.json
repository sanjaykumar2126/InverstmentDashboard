{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * AccumulationChart base file\n */\n\n\nimport { Property, ChildProperty, Complex, createElement } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined, getValue } from '@syncfusion/ej2-base';\nimport { DataManager } from '@syncfusion/ej2-data';\nimport { Border, Font, Animation, EmptyPointSettings, Connector } from '../../common/model/base';\nimport { Rect, PathOption } from '@syncfusion/ej2-svg-base';\nimport { stringToNumber, appendChildElement } from '../../common/utils/helper';\nimport { seriesRender, pointRender } from '../../common/model/constants';\nimport { getSeriesColor } from '../../common/model/theme';\nimport { getElement, firstToLowerCase } from '../../common/utils/helper';\n/**\n * Annotation for accumulation series\n */\n\nvar AccumulationAnnotationSettings =\n/** @class */\nfunction (_super) {\n  __extends(AccumulationAnnotationSettings, _super);\n\n  function AccumulationAnnotationSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(null)], AccumulationAnnotationSettings.prototype, \"content\", void 0);\n\n  __decorate([Property('0')], AccumulationAnnotationSettings.prototype, \"x\", void 0);\n\n  __decorate([Property('0')], AccumulationAnnotationSettings.prototype, \"y\", void 0);\n\n  __decorate([Property('Pixel')], AccumulationAnnotationSettings.prototype, \"coordinateUnits\", void 0);\n\n  __decorate([Property('Chart')], AccumulationAnnotationSettings.prototype, \"region\", void 0);\n\n  __decorate([Property('Middle')], AccumulationAnnotationSettings.prototype, \"verticalAlignment\", void 0);\n\n  __decorate([Property('Center')], AccumulationAnnotationSettings.prototype, \"horizontalAlignment\", void 0);\n\n  __decorate([Property(null)], AccumulationAnnotationSettings.prototype, \"description\", void 0);\n\n  return AccumulationAnnotationSettings;\n}(ChildProperty);\n\nexport { AccumulationAnnotationSettings };\n/**\n * Configures the dataLabel in accumulation chart.\n */\n\nvar AccumulationDataLabelSettings =\n/** @class */\nfunction (_super) {\n  __extends(AccumulationDataLabelSettings, _super);\n\n  function AccumulationDataLabelSettings() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(false)], AccumulationDataLabelSettings.prototype, \"visible\", void 0);\n\n  __decorate([Property(null)], AccumulationDataLabelSettings.prototype, \"name\", void 0);\n\n  __decorate([Property('transparent')], AccumulationDataLabelSettings.prototype, \"fill\", void 0);\n\n  __decorate([Property('Inside')], AccumulationDataLabelSettings.prototype, \"position\", void 0);\n\n  __decorate([Property(5)], AccumulationDataLabelSettings.prototype, \"rx\", void 0);\n\n  __decorate([Property(5)], AccumulationDataLabelSettings.prototype, \"ry\", void 0);\n\n  __decorate([Complex({\n    width: null,\n    color: null\n  }, Border)], AccumulationDataLabelSettings.prototype, \"border\", void 0);\n\n  __decorate([Complex({\n    size: '11px',\n    color: '',\n    fontStyle: 'Normal',\n    fontWeight: 'Normal',\n    fontFamily: 'Segoe UI'\n  }, Font)], AccumulationDataLabelSettings.prototype, \"font\", void 0);\n\n  __decorate([Complex({}, Connector)], AccumulationDataLabelSettings.prototype, \"connectorStyle\", void 0);\n\n  __decorate([Property(null)], AccumulationDataLabelSettings.prototype, \"template\", void 0);\n\n  return AccumulationDataLabelSettings;\n}(ChildProperty);\n\nexport { AccumulationDataLabelSettings };\n/**\n * Center value of the Pie series.\n */\n\nvar PieCenter =\n/** @class */\nfunction (_super) {\n  __extends(PieCenter, _super);\n\n  function PieCenter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property('50%')], PieCenter.prototype, \"x\", void 0);\n\n  __decorate([Property('50%')], PieCenter.prototype, \"y\", void 0);\n\n  return PieCenter;\n}(ChildProperty);\n\nexport { PieCenter };\n/**\n * Points model for the series.\n * @public\n */\n\nvar AccPoints =\n/** @class */\nfunction () {\n  function AccPoints() {\n    /** accumulation point visibility */\n    this.visible = true;\n    /** accumulation point symbol location */\n\n    this.symbolLocation = null;\n    /** @private */\n\n    this.region = null;\n    /** @private */\n\n    this.labelRegion = null;\n    /** @private */\n\n    this.labelVisible = true;\n    this.regions = null;\n    /** @private */\n\n    this.isExplode = false;\n    /** @private */\n\n    this.isClubbed = false;\n    /** @private */\n\n    this.isSliced = false;\n  }\n\n  return AccPoints;\n}();\n\nexport { AccPoints };\n/**\n *  Configures the series in accumulation chart.\n */\n\nvar AccumulationSeries =\n/** @class */\nfunction (_super) {\n  __extends(AccumulationSeries, _super);\n\n  function AccumulationSeries() {\n    /**\n     * Specifies the dataSource for the series. It can be an array of JSON objects or an instance of DataManager.\n     * ```html\n     * <div id='Pie'></div>\n     * ```\n     * ```typescript\n     * let dataManager: DataManager = new DataManager({\n     *         url: 'http://mvc.syncfusion.com/Services/Northwnd.svc/Tasks/'\n     * });\n     * let query: Query = new Query().take(50).where('Estimate', 'greaterThan', 0, false);\n     * let pie: AccumulationChart = new AccumulationChart({\n     * ...\n     *     series: [{\n     *        dataSource: dataManager,\n     *        xName: 'Id',\n     *        yName: 'Estimate',\n     *        query: query\n     *    }],\n     * ...\n     * });\n     * pie.appendTo('#Pie');\n     * ```\n     * @default ''\n     */\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** @private */\n\n\n    _this.points = [];\n    /** @private */\n\n    _this.clubbedPoints = [];\n    /** @private */\n\n    _this.sumOfPoints = 0;\n    /** @private */\n\n    _this.isRectSeries = true;\n    /** @private */\n\n    _this.clipRect = new Rect(0, 0, 0, 0);\n    /** @private */\n\n    _this.category = 'Series';\n    return _this;\n  }\n  /** @private To refresh the Datamanager for series */\n\n\n  AccumulationSeries.prototype.refreshDataManager = function (accumulation, render) {\n    var _this = this;\n\n    var dateSource = this.dataSource || accumulation.dataSource;\n\n    if (!(dateSource instanceof DataManager) && isNullOrUndefined(this.query)) {\n      this.dataManagerSuccess({\n        result: dateSource,\n        count: dateSource.length\n      }, accumulation, render);\n      return;\n    }\n\n    var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());\n    dataManager.then(function (e) {\n      return _this.dataManagerSuccess(e, accumulation, render);\n    });\n  };\n  /**\n   * To get points on dataManager is success\n   * @private\n   */\n\n\n  AccumulationSeries.prototype.dataManagerSuccess = function (e, accumulation, render) {\n    var argsData = {\n      name: seriesRender,\n      series: this,\n      data: e.result\n    };\n    accumulation.trigger(seriesRender, argsData);\n    this.resultData = e.result !== '' ? e.result : [];\n    this.getPoints(this.resultData, accumulation); // tslint:disable\n\n    if (++accumulation.seriesCounts === accumulation.visibleSeries.length && render || window['Blazor'] && !render && accumulation.seriesCounts === 1) {\n      accumulation.refreshChart();\n    }\n  };\n  /** @private To find points from result data */\n\n\n  AccumulationSeries.prototype.getPoints = function (result, accumulation) {\n    var length = Object.keys(result).length;\n    this.sumOfPoints = 0;\n\n    if (length === 0) {\n      return null;\n    }\n\n    this.findSumOfPoints(result);\n    this.points = [];\n    this.clubbedPoints = [];\n    this.sumOfClub = 0;\n    var point;\n    var colors = this.palettes.length ? this.palettes : getSeriesColor(accumulation.theme);\n    var clubValue = stringToNumber(this.groupTo, this.sumOfPoints);\n\n    for (var i = 0; i < length; i++) {\n      point = this.setPoints(result, i, colors);\n      var currentY = point.y;\n\n      if (!this.isClub(point, clubValue, i)) {\n        if (isNullOrUndefined(point.y)) {\n          point.visible = false;\n        }\n\n        this.pushPoints(point, colors);\n      } else {\n        point.index = this.clubbedPoints.length;\n        point.isExplode = true;\n        this.clubbedPoints.push(point);\n        point.isSliced = true;\n      }\n    }\n\n    this.lastGroupTo = this.groupTo;\n\n    if (this.sumOfClub > 0) {\n      var clubPoint_1 = this.generateClubPoint();\n      this.pushPoints(clubPoint_1, colors);\n      var pointsLength_1 = this.points.length - 1;\n      this.clubbedPoints.map(function (point) {\n        point.index += pointsLength_1;\n        point.color = clubPoint_1.color;\n      });\n    }\n\n    if (this.clubbedPoints.length && this.explode && this.type === 'Pie' && (this.explodeAll || this.points[this.points.length - 1].index === this.explodeIndex)) {\n      this.points.splice(this.points.length - 1, 1);\n      this.points = this.points.concat(this.clubbedPoints);\n    }\n  };\n\n  AccumulationSeries.prototype.generateClubPoint = function () {\n    var clubPoint = new AccPoints();\n    clubPoint.isClubbed = true;\n    clubPoint.x = 'Others';\n    clubPoint.y = this.sumOfClub;\n    clubPoint.text = clubPoint.originalText = clubPoint.x + ': ' + this.sumOfClub;\n    clubPoint.sliceRadius = '80%';\n    return clubPoint;\n  };\n  /**\n   * Method to set point index and color\n   */\n\n\n  AccumulationSeries.prototype.pushPoints = function (point, colors) {\n    point.index = this.points.length;\n    point.isExplode = this.explodeAll || point.index === this.explodeIndex;\n    point.color = point.color || colors[point.index % colors.length];\n    this.points.push(point);\n  };\n  /**\n   * Method to find club point\n   */\n\n\n  AccumulationSeries.prototype.isClub = function (point, clubValue, index) {\n    if (!isNullOrUndefined(clubValue)) {\n      if (this.groupMode === 'Value' && Math.abs(point.y) <= clubValue) {\n        this.sumOfClub += Math.abs(point.y);\n        return true;\n      } else if (this.groupMode === 'Point' && index >= clubValue) {\n        this.sumOfClub += Math.abs(point.y);\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Method to find sum of points in the series\n   */\n\n\n  AccumulationSeries.prototype.findSumOfPoints = function (result) {\n    var length = Object.keys(result).length;\n\n    for (var i = 0; i < length; i++) {\n      if (!isNullOrUndefined(result[i]) && !isNullOrUndefined(result[i][this.yName]) && !isNaN(result[i][this.yName])) {\n        this.sumOfPoints += Math.abs(result[i][this.yName]);\n      }\n    }\n  };\n  /**\n   * Method to set points x, y and text from data source\n   */\n\n\n  AccumulationSeries.prototype.setPoints = function (data, i, colors) {\n    var point = new AccPoints();\n    point.x = getValue(this.xName, data[i]);\n    point.y = getValue(this.yName, data[i]);\n    point.percentage = +(point.y / this.sumOfPoints * 100).toFixed(2);\n    point.color = getValue(this.pointColorMapping, data[i]);\n    point.text = point.originalText = getValue(this.dataLabel.name || '', data[i]);\n    point.tooltip = getValue(this.tooltipMappingName || '', data[i]);\n    point.sliceRadius = getValue(this.radius, data[i]);\n    point.sliceRadius = isNullOrUndefined(point.sliceRadius) ? '80%' : point.sliceRadius;\n    this.setAccEmptyPoint(point, i, data, colors);\n    return point;\n  };\n  /**\n   * Method render the series elements for accumulation chart\n   * @private\n   */\n\n\n  AccumulationSeries.prototype.renderSeries = function (accumulation, redraw) {\n    var seriesGroup = redraw ? getElement(accumulation.element.id + '_Series_' + this.index) : accumulation.renderer.createGroup({\n      id: accumulation.element.id + '_Series_' + this.index\n    });\n    this.renderPoints(accumulation, seriesGroup, redraw);\n    var datalabelGroup;\n\n    if (accumulation.accumulationDataLabelModule && this.dataLabel.visible) {\n      datalabelGroup = accumulation.renderer.createGroup({\n        id: accumulation.element.id + '_datalabel_Series_' + this.index\n      });\n      datalabelGroup.style.visibility = this.animation.enable && accumulation.animateSeries && this.type === 'Pie' ? 'hidden' : 'visible';\n      this.renderDataLabel(accumulation, datalabelGroup, redraw);\n    }\n\n    if (this.type === 'Pie') {\n      this.findMaxBounds(this.labelBound, this.accumulationBound);\n      accumulation.pieSeriesModule.animateSeries(accumulation, this.animation, this, seriesGroup);\n    }\n\n    if (accumulation.accumulationLegendModule) {\n      this.labelBound.x -= accumulation.explodeDistance;\n      this.labelBound.y -= accumulation.explodeDistance;\n      this.labelBound.height += accumulation.explodeDistance - this.labelBound.y;\n      this.labelBound.width += accumulation.explodeDistance - this.labelBound.x;\n    }\n  };\n  /**\n   * Method render the points elements for accumulation chart series.\n   */\n\n\n  AccumulationSeries.prototype.renderPoints = function (accumulation, seriesGroup, redraw) {\n    var pointId = accumulation.element.id + '_Series_' + this.index + '_Point_';\n    var option;\n\n    for (var _i = 0, _a = this.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n      var argsData = {\n        cancel: false,\n        name: pointRender,\n        series: this,\n        point: point,\n        fill: point.color,\n        border: this.isEmpty(point) ? {\n          width: this.emptyPointSettings.border.width,\n          color: this.emptyPointSettings.border.color\n        } : {\n          width: this.border.width,\n          color: this.border.color\n        }\n      };\n      accumulation.trigger(pointRender, argsData);\n      point.color = argsData.fill;\n      option = new PathOption(pointId + point.index, point.color, argsData.border.width || 1, argsData.border.color || point.color, this.opacity, '', '');\n      accumulation[firstToLowerCase(this.type) + 'SeriesModule'].renderPoint(point, this, accumulation, option, seriesGroup, redraw);\n    }\n\n    appendChildElement(false, accumulation.getSeriesElement(), seriesGroup, redraw);\n  };\n  /**\n   * Method render the datalabel elements for accumulation chart.\n   */\n\n\n  AccumulationSeries.prototype.renderDataLabel = function (accumulation, datalabelGroup, redraw) {\n    accumulation.accumulationDataLabelModule.findAreaRect();\n    var element = createElement('div', {\n      id: accumulation.element.id + '_Series_0' + '_DataLabelCollections'\n    });\n\n    for (var _i = 0, _a = this.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      if (point.visible) {\n        accumulation.accumulationDataLabelModule.renderDataLabel(point, this.dataLabel, datalabelGroup, this.points, this.index, element, redraw);\n      }\n    }\n\n    if (this.dataLabel.template !== null && element.childElementCount) {\n      appendChildElement(false, getElement(accumulation.element.id + '_Secondary_Element'), element, redraw);\n    }\n\n    appendChildElement(false, accumulation.getSeriesElement(), datalabelGroup, redraw);\n  };\n  /**\n   * To find maximum bounds for smart legend placing\n   * @private\n   */\n\n\n  AccumulationSeries.prototype.findMaxBounds = function (totalbound, bound) {\n    totalbound.x = bound.x < totalbound.x ? bound.x : totalbound.x;\n    totalbound.y = bound.y < totalbound.y ? bound.y : totalbound.y;\n    totalbound.height = bound.y + bound.height > totalbound.height ? bound.y + bound.height : totalbound.height;\n    totalbound.width = bound.x + bound.width > totalbound.width ? bound.x + bound.width : totalbound.width;\n  };\n  /**\n   * To set empty point value for null points\n   * @private\n   */\n\n\n  AccumulationSeries.prototype.setAccEmptyPoint = function (point, i, data, colors) {\n    if (!(isNullOrUndefined(point.y) || isNaN(point.y))) {\n      return null;\n    }\n\n    point.color = this.emptyPointSettings.fill || point.color;\n\n    switch (this.emptyPointSettings.mode) {\n      case 'Zero':\n        point.y = 0;\n        point.visible = true;\n        break;\n\n      case 'Average':\n        var previous = data[i - 1] ? data[i - 1][this.yName] || 0 : 0;\n        var next = data[i + 1] ? data[i + 1][this.yName] || 0 : 0;\n        point.y = (Math.abs(previous) + Math.abs(next)) / 2;\n        this.sumOfPoints += point.y;\n        point.visible = true;\n        break;\n\n      default:\n        point.visible = false;\n        break;\n    }\n  };\n  /**\n   * To find point is empty\n   */\n\n\n  AccumulationSeries.prototype.isEmpty = function (point) {\n    return point.color === this.emptyPointSettings.fill;\n  };\n\n  __decorate([Property('')], AccumulationSeries.prototype, \"dataSource\", void 0);\n\n  __decorate([Property()], AccumulationSeries.prototype, \"query\", void 0);\n\n  __decorate([Property('')], AccumulationSeries.prototype, \"xName\", void 0);\n\n  __decorate([Property('')], AccumulationSeries.prototype, \"name\", void 0);\n\n  __decorate([Property('')], AccumulationSeries.prototype, \"tooltipMappingName\", void 0);\n\n  __decorate([Property('')], AccumulationSeries.prototype, \"yName\", void 0);\n\n  __decorate([Property(true)], AccumulationSeries.prototype, \"visible\", void 0);\n\n  __decorate([Complex({\n    color: null,\n    width: 0\n  }, Border)], AccumulationSeries.prototype, \"border\", void 0);\n\n  __decorate([Complex(null, Animation)], AccumulationSeries.prototype, \"animation\", void 0);\n\n  __decorate([Property('SeriesType')], AccumulationSeries.prototype, \"legendShape\", void 0);\n\n  __decorate([Property('')], AccumulationSeries.prototype, \"pointColorMapping\", void 0);\n\n  __decorate([Property(null)], AccumulationSeries.prototype, \"selectionStyle\", void 0);\n\n  __decorate([Property(null)], AccumulationSeries.prototype, \"groupTo\", void 0);\n\n  __decorate([Property('Value')], AccumulationSeries.prototype, \"groupMode\", void 0);\n\n  __decorate([Complex({}, AccumulationDataLabelSettings)], AccumulationSeries.prototype, \"dataLabel\", void 0);\n\n  __decorate([Property([])], AccumulationSeries.prototype, \"palettes\", void 0);\n\n  __decorate([Property(0)], AccumulationSeries.prototype, \"startAngle\", void 0);\n\n  __decorate([Property(null)], AccumulationSeries.prototype, \"endAngle\", void 0);\n\n  __decorate([Property('80%')], AccumulationSeries.prototype, \"radius\", void 0);\n\n  __decorate([Property('0')], AccumulationSeries.prototype, \"innerRadius\", void 0);\n\n  __decorate([Property('Pie')], AccumulationSeries.prototype, \"type\", void 0);\n\n  __decorate([Property(true)], AccumulationSeries.prototype, \"enableTooltip\", void 0);\n\n  __decorate([Property(false)], AccumulationSeries.prototype, \"explode\", void 0);\n\n  __decorate([Property('30%')], AccumulationSeries.prototype, \"explodeOffset\", void 0);\n\n  __decorate([Property(false)], AccumulationSeries.prototype, \"explodeAll\", void 0);\n\n  __decorate([Property(null)], AccumulationSeries.prototype, \"explodeIndex\", void 0);\n\n  __decorate([Complex({\n    mode: 'Drop'\n  }, EmptyPointSettings)], AccumulationSeries.prototype, \"emptyPointSettings\", void 0);\n\n  __decorate([Property(0)], AccumulationSeries.prototype, \"gapRatio\", void 0);\n\n  __decorate([Property('80%')], AccumulationSeries.prototype, \"width\", void 0);\n\n  __decorate([Property('80%')], AccumulationSeries.prototype, \"height\", void 0);\n\n  __decorate([Property('20%')], AccumulationSeries.prototype, \"neckWidth\", void 0);\n\n  __decorate([Property('20%')], AccumulationSeries.prototype, \"neckHeight\", void 0);\n\n  __decorate([Property('Linear')], AccumulationSeries.prototype, \"pyramidMode\", void 0);\n\n  __decorate([Property(1)], AccumulationSeries.prototype, \"opacity\", void 0);\n\n  return AccumulationSeries;\n}(ChildProperty);\n\nexport { AccumulationSeries };\n/**\n * method to get series from index\n * @private\n */\n\nexport function getSeriesFromIndex(index, visibleSeries) {\n  for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {\n    var series = visibleSeries_1[_i];\n\n    if (index === series.index) {\n      return series;\n    }\n  }\n\n  return visibleSeries[0];\n}\n/**\n * method to get point from index\n * @private\n */\n\nexport function pointByIndex(index, points) {\n  for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n    var point = points_1[_i];\n\n    if (point.index === index) {\n      return point;\n    }\n  }\n\n  return null;\n}","map":null,"metadata":{},"sourceType":"module"}