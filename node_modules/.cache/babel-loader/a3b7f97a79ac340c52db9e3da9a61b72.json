{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * Selection src file\n */\n\n\nimport { Browser } from '@syncfusion/ej2-base';\nimport { remove } from '@syncfusion/ej2-base';\nimport { extend, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { ChartLocation, RectOption, CircleOption, withInBounds, getDraggedRectLocation, removeElement, getElement } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { Index } from '../../common/model/base';\nimport { dragComplete } from '../../common/model/constants';\nimport { BaseSelection } from '../../common/user-interaction/selection';\n/**\n * `Selection` module handles the selection for chart.\n * @private\n */\n\nvar Selection =\n/** @class */\nfunction (_super) {\n  __extends(Selection, _super);\n  /**\n   * Constructor for selection module.\n   * @private.\n   */\n\n\n  function Selection(chart) {\n    var _this = _super.call(this, chart) || this;\n\n    _this.isdrawRect = true;\n    _this.chart = chart;\n    _this.renderer = chart.renderer;\n\n    _this.addEventListener();\n\n    return _this;\n  }\n  /**\n   * Binding events for selection module.\n   */\n\n\n  Selection.prototype.addEventListener = function () {\n    if (this.chart.isDestroyed || this.chart.stockChart && this.chart.stockChart.onPanning) {\n      return;\n    }\n\n    var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';\n    this.chart.on(Browser.touchMoveEvent, this.mouseMove, this);\n    this.chart.on(cancelEvent, this.completeSelection, this);\n    this.chart.on('click', this.calculateSelectedElements, this);\n    this.chart.on(Browser.touchStartEvent, this.mousedown, this);\n    this.chart.on(Browser.touchEndEvent, this.completeSelection, this);\n  };\n  /**\n   * Chart mouse down\n   */\n\n\n  Selection.prototype.mousedown = function (e) {\n    var chart = this.chart;\n\n    if (chart.isPointMouseDown || chart.selectionMode === 'None' || chart.isChartDrag) {\n      return;\n    }\n\n    if (chart.isDoubleTap || !chart.isTouch || this.rectPoints) {\n      this.dragStart(chart, chart.chartAxisLayoutPanel.seriesClipRect, chart.mouseDownX, chart.mouseDownY, e);\n    }\n  };\n  /**\n   * UnBinding events for selection module.\n   */\n\n\n  Selection.prototype.removeEventListener = function () {\n    if (this.chart.isDestroyed) {\n      return;\n    }\n\n    this.chart.off(Browser.touchMoveEvent, this.mouseMove);\n    this.chart.off('pointerleave' || 'mouseleave', this.completeSelection);\n    this.chart.off('click', this.calculateSelectedElements);\n    this.chart.off(Browser.touchStartEvent, this.mousedown);\n    this.chart.off(Browser.touchEndEvent, this.completeSelection);\n  };\n  /**\n   * To find private variable values\n   */\n\n\n  Selection.prototype.initPrivateVariables = function (chart) {\n    this.styleId = chart.element.id + '_ej2_chart_selection';\n    this.unselected = chart.element.id + '_ej2_deselected';\n    this.closeIconId = chart.element.id + '_ej2_drag_close';\n    this.draggedRectGroup = chart.element.id + '_ej2_drag_group';\n    this.draggedRect = chart.element.id + '_ej2_drag_rect';\n    this.selectedDataIndexes = [];\n    this.rectPoints = null;\n    this.isSeriesMode = chart.selectionMode === 'Series';\n  };\n  /**\n   * Method to select the point and series.\n   * @return {void}\n   */\n\n\n  Selection.prototype.invokeSelection = function (chart) {\n    this.initPrivateVariables(chart);\n    this.series = extend({}, chart.visibleSeries, null, true);\n    this.seriesStyles();\n\n    if (!(chart.selectionMode.indexOf('Drag') > -1)) {\n      this.selectDataIndex(chart, this.concatIndexes(chart.selectedDataIndexes, this.selectedDataIndexes));\n    }\n  };\n\n  Selection.prototype.generateStyle = function (series) {\n    if (series) {\n      return series.selectionStyle || this.styleId + '_series_' + series.index;\n    }\n\n    return 'undefined';\n  };\n\n  Selection.prototype.selectDataIndex = function (chart, indexes) {\n    for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {\n      var index = indexes_1[_i];\n      this.performSelection(index, chart, this.getElementByIndex(chart, index)[0]);\n    }\n  };\n\n  Selection.prototype.getElementByIndex = function (chart, index, suffix) {\n    if (suffix === void 0) {\n      suffix = '';\n    }\n\n    var elementId = chart.element.id + '_Series_' + index.series + '_Point' + '_' + index.point;\n    var series = chart.series[index.series];\n    elementId = !series.isRectSeries && series.type !== 'Scatter' && series.type !== 'Bubble' && series.marker.visible ? elementId + '_Symbol' + suffix : elementId;\n    return [getElement(elementId), series.type === 'RangeArea' && series.marker.visible ? getElement(elementId + '1') : null];\n  };\n\n  Selection.prototype.getClusterElements = function (chart, index) {\n    var clusters = [];\n\n    for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n      var series = _a[_i];\n      index = new Index(series.index, index.point);\n      clusters.push(this.getElementByIndex(chart, index)[0]);\n    }\n\n    return clusters;\n  };\n\n  Selection.prototype.findElements = function (chart, series, index, suffix) {\n    if (suffix === void 0) {\n      suffix = '';\n    }\n\n    if (this.isSeriesMode) {\n      return this.getSeriesElements(series);\n    } else if (chart.selectionMode === 'Cluster') {\n      return this.getClusterElements(chart, index);\n    } else {\n      return this.getElementByIndex(chart, index, suffix);\n    }\n  };\n  /**\n   * To find the selected element.\n   * @return {void}\n   * @private\n   */\n\n\n  Selection.prototype.calculateSelectedElements = function (event) {\n    if (this.chart.selectionMode === 'None' || event.target.id.indexOf(this.chart.element.id + '_') === -1) {\n      return;\n    }\n\n    if (event.target.id.indexOf('_Series_') > -1) {\n      this.performSelection(this.indexFinder(event.target.id), this.chart, event.target);\n    }\n  };\n\n  Selection.prototype.performSelection = function (index, chart, element) {\n    this.isSeriesMode = chart.selectionMode === 'Series';\n\n    if (chart.series[index.series].type === 'BoxAndWhisker' && element.id === chart.element.id + '_Series_' + index.series + '_Point_' + index.point + '_BoxPath') {\n      element = element.parentElement;\n    }\n\n    switch (chart.selectionMode) {\n      case 'Series':\n        this.selection(chart, index, this.getSeriesElements(chart.series[index.series]));\n        this.blurEffect(chart.element.id, chart.visibleSeries);\n        break;\n\n      case 'Point':\n        if (!isNaN(index.point)) {\n          this.selection(chart, index, [element]);\n          this.blurEffect(chart.element.id, chart.visibleSeries);\n        }\n\n        break;\n\n      case 'Cluster':\n        if (!isNaN(index.point)) {\n          this.clusterSelection(chart, chart.series, index);\n          this.blurEffect(chart.element.id, chart.visibleSeries);\n        }\n\n        break;\n    }\n  };\n\n  Selection.prototype.selection = function (chart, index, selectedElements) {\n    if (!chart.isMultiSelect && chart.selectionMode.indexOf('Drag') === -1) {\n      this.removeMultiSelectEelments(chart, this.selectedDataIndexes, index, chart.series);\n    }\n\n    var className = selectedElements[0] && (selectedElements[0].getAttribute('class') || '');\n\n    if (selectedElements[0] && className.indexOf(this.getSelectionClass(selectedElements[0].id)) > -1) {\n      this.removeStyles(selectedElements);\n      this.addOrRemoveIndex(this.selectedDataIndexes, index);\n    } else {\n      this.applyStyles(selectedElements);\n      this.addOrRemoveIndex(this.selectedDataIndexes, index, true);\n    }\n  };\n\n  Selection.prototype.clusterSelection = function (chart, series, index) {\n    this.selection(chart, index, this.getClusterElements(chart, new Index(index.series, index.point)));\n  };\n\n  Selection.prototype.removeMultiSelectEelments = function (chart, index, currentIndex, seriesCollection) {\n    var series;\n\n    for (var i = 0; i < index.length; i++) {\n      series = seriesCollection[index[i].series];\n\n      if (this.isSeriesMode && !this.toEquals(index[i], currentIndex, this.isSeriesMode) || this.control.selectionMode === 'Cluster' && !this.toEquals(index[i], currentIndex, false) || !this.isSeriesMode && this.toEquals(index[i], currentIndex, true) && !this.toEquals(index[i], currentIndex, false)) {\n        this.removeStyles(this.findElements(chart, series, index[i]));\n        index.splice(i, 1);\n        i--;\n      }\n    }\n  };\n\n  Selection.prototype.blurEffect = function (chartId, visibleSeries) {\n    var visibility = this.checkVisibility(this.selectedDataIndexes); // legend click scenario\n\n    for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {\n      var series = visibleSeries_1[_i];\n\n      if (series.visible) {\n        this.checkSelectionElements(getElement(chartId + 'SeriesGroup' + series.index), this.generateStyle(series), visibility);\n\n        if (!isNullOrUndefined(getElement(chartId + 'SymbolGroup' + series.index))) {\n          this.checkSelectionElements(getElement(chartId + 'SymbolGroup' + series.index), this.generateStyle(series), visibility);\n        }\n      }\n    }\n  };\n\n  Selection.prototype.checkSelectionElements = function (element, className, visibility) {\n    var children = this.isSeriesMode ? [element] : element.childNodes;\n    var elementClassName;\n    var parentClassName;\n    var legendShape;\n    var selectElement = element;\n\n    for (var i = 0; i < children.length; i++) {\n      elementClassName = children[i].getAttribute('class') || '';\n      parentClassName = children[i].parentNode.getAttribute('class') || '';\n\n      if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {\n        this.addSvgClass(children[i], this.unselected);\n      } else {\n        selectElement = children[i];\n        this.removeSvgClass(children[i], this.unselected);\n      }\n    }\n\n    if (this.control.legendModule && this.control.legendSettings.visible) {\n      legendShape = document.getElementById(this.control.element.id + '_chart_legend_shape_' + className.split('_series_')[1]);\n\n      if (legendShape) {\n        elementClassName = selectElement.getAttribute('class') || '';\n        parentClassName = selectElement.parentNode.getAttribute('class') || '';\n\n        if (elementClassName.indexOf(className) === -1 && parentClassName.indexOf(className) === -1 && visibility) {\n          this.addSvgClass(legendShape, this.unselected);\n        } else {\n          this.removeSvgClass(legendShape, this.unselected);\n        }\n      }\n    }\n  };\n\n  Selection.prototype.applyStyles = function (elements) {\n    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n      var element = elements_1[_i];\n\n      if (element) {\n        this.removeSvgClass(element.parentNode, this.unselected);\n        this.removeSvgClass(element, this.unselected);\n        this.addSvgClass(element, this.getSelectionClass(element.id));\n      }\n    }\n  };\n\n  Selection.prototype.getSelectionClass = function (id) {\n    return this.generateStyle(this.control.series[this.indexFinder(id).series]);\n  };\n\n  Selection.prototype.removeStyles = function (elements) {\n    for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {\n      var element = elements_2[_i];\n\n      if (element) {\n        this.removeSvgClass(element, this.getSelectionClass(element.id));\n      }\n    }\n  };\n\n  Selection.prototype.addOrRemoveIndex = function (indexes, index, add) {\n    for (var i = 0; i < indexes.length; i++) {\n      if (this.toEquals(indexes[i], index, this.isSeriesMode)) {\n        indexes.splice(i, 1);\n        i--;\n      }\n    }\n\n    if (add) {\n      indexes.push(index);\n    }\n  };\n\n  Selection.prototype.toEquals = function (first, second, checkSeriesOnly) {\n    return (first.series === second.series || this.control.selectionMode === 'Cluster' && !checkSeriesOnly) && (checkSeriesOnly || first.point === second.point);\n  };\n  /**\n   * To redraw the selected points.\n   * @return {void}\n   * @private\n   */\n\n\n  Selection.prototype.redrawSelection = function (chart, oldMode) {\n    this.isSeriesMode = oldMode === 'Series';\n    var selectedDataIndexes = extend([], this.selectedDataIndexes, null, true);\n    this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);\n    this.blurEffect(chart.element.id, chart.visibleSeries);\n    this.selectDataIndex(chart, selectedDataIndexes);\n  };\n  /** @private */\n\n\n  Selection.prototype.legendSelection = function (chart, series) {\n    var seriesStyle = this.generateStyle(chart.visibleSeries[series]);\n    var selectedElements = document.getElementsByClassName(seriesStyle);\n    this.isSeriesMode = chart.selectionMode === 'Series';\n    var isBlurEffectNeeded = true;\n\n    if (selectedElements.length > 0) {\n      var elements = [];\n\n      for (var i = 0; i < selectedElements.length; i++) {\n        elements.push(selectedElements[i]);\n      }\n\n      this.removeStyles(elements);\n      this.isSeriesMode = true;\n      this.addOrRemoveIndex(this.selectedDataIndexes, new Index(series, NaN));\n\n      for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n        var series_1 = _a[_i];\n        seriesStyle = this.generateStyle(series_1);\n\n        if (document.getElementsByClassName(seriesStyle).length > 0) {\n          for (var _b = 0, elements_3 = elements; _b < elements_3.length; _b++) {\n            var element = elements_3[_b];\n            this.checkSelectionElements(element, seriesStyle, true);\n          }\n\n          isBlurEffectNeeded = false;\n          break;\n        }\n      }\n\n      if (isBlurEffectNeeded) {\n        this.isSeriesMode = chart.selectionMode === 'Series';\n        this.blurEffect(chart.element.id, chart.visibleSeries);\n      }\n    } else {\n      var seriesElements = this.getSeriesElements(chart.visibleSeries[series]);\n\n      for (var _c = 0, seriesElements_1 = seriesElements; _c < seriesElements_1.length; _c++) {\n        var seriesElement = seriesElements_1[_c];\n        this.checkSelectionElements(seriesElement, seriesStyle, false);\n      }\n\n      this.isSeriesMode = true;\n      this.selection(chart, new Index(series, NaN), seriesElements);\n      this.isSeriesMode = chart.selectionMode === 'Series';\n      this.blurEffect(chart.element.id, chart.visibleSeries);\n    }\n  };\n\n  Selection.prototype.getSeriesElements = function (series) {\n    var seriesElements = [series.seriesElement];\n\n    if (series.marker.visible && series.type !== 'Scatter' && series.type !== 'Bubble' && !series.isRectSeries) {\n      seriesElements.push(series.symbolElement);\n    }\n\n    return seriesElements;\n  };\n\n  Selection.prototype.indexFinder = function (id) {\n    var ids = ['NaN', 'NaN'];\n\n    if (id.indexOf('SeriesGroup') > -1) {\n      ids = id.split('SeriesGroup');\n      ids[0] = ids[1];\n    } else if (id.indexOf('SymbolGroup') > -1) {\n      ids = id.split('SymbolGroup');\n      ids[0] = ids[1];\n    } else if (id.indexOf('_Point_') > -1) {\n      ids = id.split('_Series_')[1].split('_Point_');\n    } else if (id.indexOf('_Series_') > -1) {\n      ids[0] = id.split('_Series_')[1];\n    }\n\n    return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));\n  };\n  /**\n   * Drag selection that returns the selected data.\n   * @return {void}\n   * @private\n   */\n\n\n  Selection.prototype.calculateDragSelectedElements = function (chart, dragRect) {\n    this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);\n    var rect = new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);\n    var axisOffset = new ChartLocation(chart.chartAxisLayoutPanel.seriesClipRect.x, chart.chartAxisLayoutPanel.seriesClipRect.y);\n    this.removeOffset(rect, axisOffset);\n    var points;\n    var index;\n    var selectedPointValues = [];\n    var selectedSeriesValues = [];\n    this.isSeriesMode = false;\n    var symbolLocation;\n\n    var _loop_1 = function (series) {\n      if (series.visible) {\n        points = series.points;\n        selectedPointValues = [];\n        var xAxisOffset_1;\n        var yAxisOffset_1;\n\n        if ((chart.isTransposed || series.type.indexOf('Bar') !== -1) && !(chart.isTransposed && series.type.indexOf('Bar') !== -1)) {\n          xAxisOffset_1 = series.xAxis.rect.y - axisOffset.y;\n          yAxisOffset_1 = series.yAxis.rect.x - axisOffset.x;\n        } else {\n          xAxisOffset_1 = series.xAxis.rect.x - axisOffset.x;\n          yAxisOffset_1 = series.yAxis.rect.y - axisOffset.y;\n        }\n\n        for (var j = 0; j < points.length; j++) {\n          var yValue = series.type !== 'RangeArea' ? points[j].yValue : points[j].regions[0].y;\n          var isCurrentPoint = void 0;\n          var selectedPointX = points[j].xValue;\n\n          if (chart.primaryXAxis.valueType === 'Category') {\n            selectedPointX = points[j].x.toLocaleString();\n          } else if (chart.primaryXAxis.valueType === 'DateTime') {\n            selectedPointX = new Date(points[j].xValue);\n          }\n\n          if (series.type === 'BoxAndWhisker') {\n            isCurrentPoint = points[j].regions.some(function (region) {\n              return withInBounds(region.x + xAxisOffset_1, region.y + yAxisOffset_1, rect);\n            });\n          } else {\n            isCurrentPoint = points[j].symbolLocations.some(function (location) {\n              return location && withInBounds(location.x + xAxisOffset_1, location.y + yAxisOffset_1, rect);\n            });\n          }\n\n          if (isCurrentPoint && series.category !== 'Indicator') {\n            index = new Index(series.index, points[j].index);\n            this_1.selection(chart, index, this_1.findElements(chart, series, index));\n            selectedPointValues.push({\n              x: selectedPointX,\n              y: yValue\n            });\n          }\n\n          if (isCurrentPoint && series.type === 'RangeArea') {\n            selectedPointValues.push({\n              x: selectedPointX,\n              y: points[j].regions[0].y\n            });\n          }\n        }\n\n        selectedSeriesValues.push(selectedPointValues);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n      var series = _a[_i];\n\n      _loop_1(series);\n    }\n\n    this.blurEffect(chart.element.id, chart.visibleSeries);\n    this.rectPoints = new Rect(dragRect.x, dragRect.y, dragRect.width, dragRect.height);\n    this.createCloseButton(dragRect.x + dragRect.width, dragRect.y);\n    var args = {\n      name: dragComplete,\n      selectedDataValues: selectedSeriesValues,\n      cancel: false\n    };\n    chart.trigger(dragComplete, args);\n  };\n\n  Selection.prototype.removeOffset = function (rect, clip) {\n    rect.x -= clip.x;\n    rect.y -= clip.y;\n  };\n  /**\n   * Method to draw dragging rect.\n   * @return {void}\n   * @private\n   */\n\n\n  Selection.prototype.drawDraggingRect = function (chart, dragRect) {\n    var cartesianLayout = chart.chartAxisLayoutPanel.seriesClipRect;\n    var border = chart.chartArea.border.width;\n\n    if (this.isdrawRect) {\n      cartesianLayout.x = cartesianLayout.x - border / 2;\n      cartesianLayout.y = cartesianLayout.y - border / 2;\n      cartesianLayout.width = cartesianLayout.width + border;\n      cartesianLayout.height = cartesianLayout.height + border;\n      this.isdrawRect = false;\n    }\n\n    switch (chart.selectionMode) {\n      case 'DragX':\n        dragRect.y = cartesianLayout.y;\n        dragRect.height = cartesianLayout.height;\n        break;\n\n      case 'DragY':\n        dragRect.x = cartesianLayout.x;\n        dragRect.width = cartesianLayout.width;\n        break;\n    }\n\n    if (dragRect.width < 5 || dragRect.height < 5) {\n      return null;\n    }\n\n    var element = getElement(this.draggedRect);\n\n    if (this.closeIcon) {\n      removeElement(this.closeIconId);\n    }\n\n    if (element) {\n      this.setAttributes(element, dragRect);\n    } else {\n      var dragGroup = chart.svgRenderer.createGroup({\n        id: this.draggedRectGroup\n      });\n      var svgElement = document.getElementById(chart.element.id + '_series_svg');\n      chart.enableCanvas ? svgElement.appendChild(dragGroup) : chart.svgObject.appendChild(dragGroup);\n      element = chart.svgRenderer.drawRectangle(new RectOption(this.draggedRect, chart.themeStyle.selectionRectFill, {\n        color: chart.themeStyle.selectionRectStroke,\n        width: 1\n      }, 1, dragRect));\n      element.setAttribute('style', 'cursor:move;');\n      dragGroup.appendChild(element);\n    }\n  };\n\n  Selection.prototype.createCloseButton = function (x, y) {\n    var closeIcon = this.chart.svgRenderer.createGroup({\n      id: this.closeIconId,\n      style: 'cursor:pointer; visibility: visible;'\n    });\n    closeIcon.appendChild(this.chart.svgRenderer.drawCircle(new CircleOption(this.closeIconId + '_circle', '#FFFFFF', {\n      color: this.chart.themeStyle.selectionCircleStroke,\n      width: 1\n    }, 1, x, y, 10)));\n    var direction = 'M ' + (x - 4) + ' ' + (y - 4) + ' L ' + (x + 4) + ' ' + (y + 4) + ' M ' + (x - 4) + ' ' + (y + 4) + ' L ' + (x + 4) + ' ' + (y - 4);\n    closeIcon.appendChild(this.chart.svgRenderer.drawPath({\n      id: this.closeIconId + '_cross',\n      d: direction,\n      stroke: this.chart.themeStyle.selectionCircleStroke,\n      'stroke-width': 2,\n      fill: this.chart.themeStyle.selectionCircleStroke\n    }, null));\n    this.closeIcon = closeIcon;\n    getElement(this.draggedRectGroup).appendChild(closeIcon);\n  };\n  /**\n   * Method to remove dragged element.\n   * @return {void}\n   * @private\n   */\n\n\n  Selection.prototype.removeDraggedElements = function (chart, event) {\n    if (event.target.id.indexOf(this.closeIconId) > -1 && event.type.indexOf('move') === -1) {\n      this.removeSelectedElements(chart, this.selectedDataIndexes, chart.series);\n      this.blurEffect(chart.element.id, chart.visibleSeries);\n      remove(getElement(this.draggedRectGroup));\n      this.changeCursorStyle(false, chart.svgObject, 'auto');\n      this.rectPoints = null;\n    }\n  };\n  /**\n   * Method to resize the drag rect.\n   * @return {void}\n   * @private\n   */\n\n\n  Selection.prototype.resizingSelectionRect = function (chart, location, tapped) {\n    var rect = new Rect(this.rectPoints.x, this.rectPoints.y, this.rectPoints.width, this.rectPoints.height);\n    var resize = this.findResizeMode(chart.svgObject, rect, location);\n\n    if (this.resizing) {\n      rect = getDraggedRectLocation(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, chart.chartAxisLayoutPanel.seriesClipRect);\n      this.drawDraggingRect(chart, rect);\n      this.dragRect = rect;\n    }\n\n    if (tapped) {\n      this.resizing = resize;\n    }\n  };\n\n  Selection.prototype.findResizeMode = function (chartSvgObject, rect, location) {\n    var cursorStyle = 'se-resize';\n    var resize = false;\n\n    if (!this.resizing) {\n      var resizeEdges = [new Rect(rect.x, rect.y - 10, rect.width - 5, 20), new Rect(rect.x - 10, rect.y, 20, rect.height), new Rect(rect.x, rect.y + rect.height - 10, rect.width - 10, 20), new Rect(rect.x + rect.width - 10, rect.y + 5, 20, rect.height - 15), new Rect(rect.x + rect.width - 10, rect.y + rect.height - 10, 20, 20)]; //corner\n\n      for (var i = 0; i < resizeEdges.length; i++) {\n        if (withInBounds(location.x, location.y, resizeEdges[i])) {\n          cursorStyle = i === 4 ? cursorStyle : i % 2 === 0 ? 'ns-resize' : 'ew-resize';\n          resize = true;\n          this.resizeMode = i;\n          break;\n        }\n      }\n    } else {\n      var x = rect.x;\n      var y = rect.y;\n      var width = location.x - x;\n      var height = location.y - y;\n\n      switch (this.resizeMode) {\n        case 0:\n          height = Math.abs(rect.height + rect.y - location.y);\n          rect.y = Math.min(rect.height + rect.y, location.y);\n          rect.height = height;\n          break;\n\n        case 1:\n          width = Math.abs(rect.width + rect.x - location.x);\n          rect.x = Math.min(rect.width + rect.x, location.x);\n          rect.width = width;\n          break;\n\n        case 2:\n          rect.height = Math.abs(height);\n          rect.y = Math.min(location.y, y);\n          break;\n\n        case 3:\n          rect.width = Math.abs(width);\n          rect.x = Math.min(location.x, x);\n          break;\n\n        case 4:\n          rect.width = Math.abs(width);\n          rect.height = Math.abs(height);\n          rect.x = Math.min(location.x, x);\n          rect.y = Math.min(location.y, y);\n          break;\n      }\n    }\n\n    this.changeCursorStyle(resize, getElement(this.draggedRect), cursorStyle);\n    this.changeCursorStyle(resize, chartSvgObject, cursorStyle);\n    return resize;\n  };\n\n  Selection.prototype.changeCursorStyle = function (isResize, rectelement, cursorStyle) {\n    cursorStyle = isResize ? cursorStyle : this.control.svgObject === rectelement ? 'auto' : 'move';\n    rectelement.setAttribute('style', 'cursor:' + cursorStyle + ';');\n  };\n\n  Selection.prototype.removeSelectedElements = function (chart, index, seriesCollection) {\n    index.splice(0, index.length);\n    var seriesElements;\n\n    for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {\n      var series = seriesCollection_1[_i];\n      seriesElements = this.getSeriesElements(series);\n      this.removeStyles(seriesElements);\n\n      for (var _a = 0, seriesElements_2 = seriesElements; _a < seriesElements_2.length; _a++) {\n        var seriesElement = seriesElements_2[_a];\n        this.removeStyles(this.getChildren(seriesElement));\n      }\n    }\n  };\n\n  Selection.prototype.setAttributes = function (ele, object) {\n    var keys = Object.keys(object);\n\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var key = keys_1[_i];\n      ele.setAttribute(key, object[key]);\n    }\n  };\n  /**\n   * Method to move the dragged rect.\n   * @return {void}\n   * @private\n   */\n\n\n  Selection.prototype.draggedRectMoved = function (chart, grabbedPoint, doDrawing) {\n    var rect = new Rect(this.rectPoints.x, this.rectPoints.y, this.rectPoints.width, this.rectPoints.height);\n    rect.x -= grabbedPoint.x - chart.mouseX;\n    rect.y -= grabbedPoint.y - chart.mouseY;\n    rect = getDraggedRectLocation(rect.x, rect.y, rect.x + rect.width, rect.height + rect.y, chart.chartAxisLayoutPanel.seriesClipRect);\n\n    if (doDrawing) {\n      this.drawDraggingRect(chart, rect);\n    } else {\n      this.calculateDragSelectedElements(chart, rect);\n    }\n  };\n  /**\n   * To complete the selection.\n   * @return {void}\n   * @private\n   */\n\n\n  Selection.prototype.completeSelection = function (e) {\n    var chart = this.chart;\n\n    if (chart.selectionMode === 'None') {\n      return;\n    }\n\n    if ((this.dragging || this.resizing) && this.dragRect.width > 5 && this.dragRect.height > 5) {\n      this.calculateDragSelectedElements(chart, this.dragRect);\n    } else if (this.rectGrabbing && this.rectPoints.width && this.rectPoints.height) {\n      this.draggedRectMoved(chart, this.dragRect);\n    }\n\n    this.dragging = false;\n    this.rectGrabbing = false;\n    this.resizing = false;\n    this.removeDraggedElements(chart, e);\n  };\n\n  Selection.prototype.getDragRect = function (chart, seriesClipRect) {\n    return getDraggedRectLocation(chart.mouseDownX, chart.mouseDownY, chart.mouseX, chart.mouseY, seriesClipRect);\n  };\n  /** @private */\n\n\n  Selection.prototype.dragStart = function (chart, seriesClipRect, mouseDownX, mouseDownY, event) {\n    this.dragging = chart.selectionMode.indexOf('Drag') > -1 && (chart.isDoubleTap || !chart.isTouch) && chart.chartAreaType !== 'PolarRadar';\n\n    if (this.dragging) {\n      this.dragRect = new Rect(chart.mouseDownX, chart.mouseDownY, 0, 0);\n\n      if (chart.mouseDownX < seriesClipRect.x || chart.mouseDownX > seriesClipRect.x + seriesClipRect.width || chart.mouseDownY < seriesClipRect.y || chart.mouseDownY > seriesClipRect.y + seriesClipRect.height) {\n        this.dragging = false;\n      }\n    }\n\n    if (this.rectPoints) {\n      this.dragRect = new Rect(chart.mouseDownX, chart.mouseDownY, 0, 0);\n      this.resizingSelectionRect(chart, new ChartLocation(mouseDownX, mouseDownY), true);\n      this.rectGrabbing = withInBounds(mouseDownX, mouseDownY, this.rectPoints);\n    }\n  };\n  /** @private */\n\n\n  Selection.prototype.mouseMove = function (event) {\n    var chart = this.chart;\n\n    if (chart.selectionMode === 'None') {\n      return;\n    }\n\n    if (event.type === 'touchmove' && (Browser.isIos || Browser.isIos7) && this.dragging && event.preventDefault) {\n      event.preventDefault();\n    }\n\n    var insideMoving = withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect);\n\n    if (insideMoving) {\n      if (this.rectGrabbing && !this.resizing) {\n        this.draggedRectMoved(chart, this.dragRect, true);\n      } else if (this.dragging && !this.resizing) {\n        this.dragRect = this.getDragRect(chart, chart.chartAxisLayoutPanel.seriesClipRect);\n        this.drawDraggingRect(chart, this.dragRect);\n      }\n\n      if (this.rectPoints) {\n        this.resizingSelectionRect(chart, new ChartLocation(chart.mouseX, chart.mouseY));\n      }\n    } else {\n      this.completeSelection(event);\n    }\n  };\n  /**\n   * Get module name.\n   * @private\n   */\n\n\n  Selection.prototype.getModuleName = function () {\n    return 'Selection';\n  };\n  /**\n   * To destroy the selection.\n   * @return {void}\n   * @private\n   */\n\n\n  Selection.prototype.destroy = function (chart) {\n    this.removeEventListener(); // Destroy method performed here\n  };\n\n  return Selection;\n}(BaseSelection);\n\nexport { Selection };","map":null,"metadata":{},"sourceType":"module"}