{"ast":null,"code":"import { ChartData } from '../utils/get-data';\nimport { getTransform, firstToLowerCase } from '../../common/utils/helper';\nimport { dragStart, drag, dragEnd } from '../../common/model/constants';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * `DataEditing` module handles data editing\n */\n\nvar DataEditing =\n/** @class */\nfunction () {\n  /**\n   * Constructor for DataEditing module.\n   * @private.\n   */\n  function DataEditing(chart) {\n    this.chart = chart;\n  }\n  /**\n   * Point drag start here\n   */\n\n\n  DataEditing.prototype.pointMouseDown = function () {\n    var chart = this.chart;\n    var series;\n    var data = new ChartData(chart);\n    var pointData = data.getData();\n\n    if (pointData.point && (data.insideRegion || !pointData.series.isRectSeries)) {\n      this.seriesIndex = pointData.series.index;\n      this.pointIndex = pointData.point.index;\n      series = chart.series[this.seriesIndex];\n\n      if (series.dragSettings.enable && !chart.zoomModule) {\n        chart.trigger(dragStart, {\n          series: pointData.series,\n          seriesIndex: this.seriesIndex,\n          pointIndex: this.pointIndex,\n          point: pointData.point,\n          oldValue: chart.visibleSeries[this.seriesIndex].yData[this.pointIndex],\n          newValue: chart.visibleSeries[this.seriesIndex].points[this.pointIndex].yValue\n        });\n        chart.isPointMouseDown = true;\n        chart.zoomSettings.enableDeferredZooming = false;\n      }\n    }\n  };\n  /**\n   * Point dragging\n   */\n\n\n  DataEditing.prototype.pointMouseMove = function (event) {\n    var chart = this.chart;\n    var series;\n\n    if (event.type === 'touchmove' && event.preventDefault) {\n      event.preventDefault();\n    }\n\n    var data = new ChartData(chart);\n    var pointData = data.getData();\n\n    if (pointData.series.dragSettings.enable && pointData.point && (data.insideRegion || !pointData.series.isRectSeries)) {\n      this.getCursorStyle(pointData);\n    } else {\n      chart.svgObject.setAttribute('style', 'cursor: null');\n    }\n\n    if (chart.isPointMouseDown) {\n      series = chart.series[this.seriesIndex];\n\n      if (series.type.indexOf('Spline') > -1) {\n        chart[firstToLowerCase(series.type) + 'SeriesModule'].findSplinePoint(series);\n      }\n\n      this.pointDragging(this.seriesIndex, this.pointIndex);\n    }\n  };\n  /**\n   * Get cursor style\n   */\n\n\n  DataEditing.prototype.getCursorStyle = function (pointData) {\n    var chart = this.chart;\n\n    if (pointData.series.type === 'Bar' && chart.isTransposed) {\n      chart.svgObject.setAttribute('style', 'cursor:ns-resize');\n    } else if (chart.isTransposed || pointData.series.type === 'Bar') {\n      chart.svgObject.setAttribute('style', 'cursor:ew-resize');\n    } else {\n      chart.svgObject.setAttribute('style', 'cursor:ns-resize');\n    }\n  };\n  /**\n   * Dragging calculation\n   */\n\n\n  DataEditing.prototype.pointDragging = function (si, pi) {\n    var chart = this.chart;\n    var yValueArray = [];\n    var y;\n    var ySize;\n    var yValue;\n    var series = chart.visibleSeries[si];\n    var pointDrag = series.dragSettings;\n    var xAxis = series.xAxis;\n    var yAxis = series.yAxis;\n    var minRange;\n    var maxRange; // To get drag region for column and bar series\n\n    var extra = series.isRectSeries ? 1 : 0;\n    var axis = getTransform(xAxis, yAxis, chart.requireInvertedAxis);\n\n    if (series.type === 'Bar') {\n      y = chart.isTransposed ? axis.y + axis.height - chart.mouseY : chart.mouseX - axis.x;\n      ySize = chart.isTransposed ? axis.height : axis.width;\n    } else {\n      y = chart.isTransposed ? chart.mouseX - axis.x : axis.y + axis.height - chart.mouseY;\n      ySize = chart.isTransposed ? axis.width : axis.height;\n    }\n\n    yValue = yAxis.isInversed ? 1 - y / ySize : y / ySize;\n    yValue = yValue * yAxis.visibleRange.delta + yAxis.visibleRange.min;\n    minRange = yAxis.minimum !== null ? yAxis.visibleRange.min + extra : isNullOrUndefined(pointDrag.minY) ? yValue : pointDrag.minY;\n    maxRange = yAxis.maximum !== null ? yAxis.visibleRange.max + extra : isNullOrUndefined(pointDrag.maxY) ? yValue : pointDrag.maxY;\n\n    if (maxRange >= yValue && minRange <= yValue) {\n      series.points[pi].yValue = series.points[pi].y = chart.dragY = yAxis.valueType === 'Logarithmic' ? Math.pow(yAxis.logBase, yValue) : parseFloat(yValue.toFixed(2));\n      series.points[pi].interior = pointDrag.fill;\n\n      for (var i = 0; i < series.points.length; i++) {\n        yValueArray[i] = series.points[i].yValue;\n      }\n\n      series.yMin = Math.min.apply(null, yValueArray);\n      series.yMax = Math.max.apply(null, yValueArray);\n      chart.refreshBound();\n      chart.trigger(drag, {\n        seriesIndex: si,\n        pointIndex: pi,\n        series: series,\n        point: series.points[pi],\n        oldValue: chart.visibleSeries[this.seriesIndex].yData[this.pointIndex],\n        newValue: series.points[pi].yValue\n      });\n    }\n  };\n  /**\n   * Point drag ends here\n   */\n\n\n  DataEditing.prototype.pointMouseUp = function () {\n    var chart = this.chart;\n\n    if (chart.isPointMouseDown) {\n      if (chart.series[this.seriesIndex].dragSettings.enable) {\n        chart.trigger(dragEnd, {\n          series: chart.series[this.seriesIndex],\n          point: chart.visibleSeries[this.seriesIndex].points[this.pointIndex],\n          seriesIndex: this.seriesIndex,\n          pointIndex: this.pointIndex,\n          oldValue: chart.visibleSeries[this.seriesIndex].yData[this.pointIndex],\n          newValue: chart.visibleSeries[this.seriesIndex].points[this.pointIndex].yValue\n        });\n        chart.visibleSeries[this.seriesIndex].points[this.pointIndex].y = chart.visibleSeries[this.seriesIndex].points[this.pointIndex].yValue;\n        chart.isPointMouseDown = false;\n        this.seriesIndex = this.pointIndex = undefined;\n      }\n    }\n  };\n  /**\n   * Get module name.\n   */\n\n\n  DataEditing.prototype.getModuleName = function () {\n    // Returns te module name\n    return 'DataEditing';\n  };\n  /**\n   * To destroy the DataEditing.\n   * @return {void}\n   * @private\n   */\n\n\n  DataEditing.prototype.destroy = function (chart) {// Destroy method performed here\n  };\n\n  return DataEditing;\n}();\n\nexport { DataEditing };","map":null,"metadata":{},"sourceType":"module"}