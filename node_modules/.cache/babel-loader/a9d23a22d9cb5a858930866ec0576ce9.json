{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport BoxElement from './box-element';\nimport TextBox from './text-box';\nimport ShapeElement from './shape-element';\nimport Box from './box';\nimport { CIRCLE, TOP, BOTTOM, LEFT, RIGHT, CENTER, INSIDE, OUTSIDE, NOTE_CLICK, NOTE_HOVER, NOTE_LEAVE } from '../common/constants';\nimport { alignPathToPixel, defined, deepExtend, eventElement, getTemplate, inArray, setDefaultOptions } from '../common';\nvar DEFAULT_ICON_SIZE = 7;\nvar DEFAULT_LABEL_COLOR = \"#fff\";\n\nvar Note = function (BoxElement) {\n  function Note(fields, options, chartService) {\n    BoxElement.call(this, options);\n    this.fields = fields;\n    this.chartService = chartService;\n    this.render();\n  }\n\n  if (BoxElement) Note.__proto__ = BoxElement;\n  Note.prototype = Object.create(BoxElement && BoxElement.prototype);\n  Note.prototype.constructor = Note;\n\n  Note.prototype.hide = function hide() {\n    this.options.visible = false;\n  };\n\n  Note.prototype.show = function show() {\n    this.options.visible = true;\n  };\n\n  Note.prototype.render = function render() {\n    var this$1 = this;\n    var options = this.options;\n\n    if (options.visible) {\n      var label = options.label;\n      var icon = options.icon;\n      var box = new Box();\n\n      var childAlias = function () {\n        return this$1;\n      };\n\n      var size = icon.size;\n      var text = this.fields.text;\n      var width, height;\n\n      if (defined(label) && label.visible) {\n        var noteTemplate = getTemplate(label);\n\n        if (noteTemplate) {\n          text = noteTemplate(this.fields);\n        } else if (label.format) {\n          text = this.chartService.format.auto(label.format, text);\n        }\n\n        if (!label.color) {\n          label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\n        }\n\n        this.label = new TextBox(text, deepExtend({}, label));\n        this.label.aliasFor = childAlias;\n\n        if (label.position === INSIDE && !defined(size)) {\n          if (icon.type === CIRCLE) {\n            size = Math.max(this.label.box.width(), this.label.box.height());\n          } else {\n            width = this.label.box.width();\n            height = this.label.box.height();\n          }\n\n          box.wrap(this.label.box);\n        }\n      }\n\n      icon.width = width || size || DEFAULT_ICON_SIZE;\n      icon.height = height || size || DEFAULT_ICON_SIZE;\n      var marker = new ShapeElement(deepExtend({}, icon));\n      marker.aliasFor = childAlias;\n      this.marker = marker;\n      this.append(marker);\n\n      if (this.label) {\n        this.append(this.label);\n      }\n\n      marker.reflow(new Box());\n      this.wrapperBox = box.wrap(marker.box);\n    }\n  };\n\n  Note.prototype.reflow = function reflow(targetBox) {\n    var ref = this;\n    var options = ref.options;\n    var label = ref.label;\n    var marker = ref.marker;\n    var wrapperBox = ref.wrapperBox;\n    var center = targetBox.center();\n    var length = options.line.length;\n    var position = options.position; // TODO: Review\n\n    if (options.visible) {\n      var lineStart, box, contentBox;\n\n      if (inArray(position, [LEFT, RIGHT])) {\n        if (position === LEFT) {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\n\n          if (options.line.visible) {\n            lineStart = [targetBox.x1, center.y];\n            this.linePoints = [lineStart, [contentBox.x2, center.y]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        } else {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\n\n          if (options.line.visible) {\n            lineStart = [targetBox.x2, center.y];\n            this.linePoints = [lineStart, [contentBox.x1, center.y]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        }\n      } else {\n        if (position === BOTTOM) {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\n\n          if (options.line.visible) {\n            lineStart = [center.x, targetBox.y2];\n            this.linePoints = [lineStart, [center.x, contentBox.y1]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        } else {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\n\n          if (options.line.visible) {\n            lineStart = [center.x, targetBox.y1];\n            this.linePoints = [lineStart, [center.x, contentBox.y2]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        }\n      }\n\n      if (marker) {\n        marker.reflow(contentBox);\n      }\n\n      if (label) {\n        label.reflow(contentBox);\n\n        if (marker) {\n          if (options.label.position === OUTSIDE) {\n            label.box.alignTo(marker.box, position);\n          }\n\n          label.reflow(label.box);\n        }\n      }\n\n      this.contentBox = contentBox;\n      this.targetBox = targetBox;\n      this.box = box || contentBox;\n    }\n  };\n\n  Note.prototype.createVisual = function createVisual() {\n    BoxElement.prototype.createVisual.call(this);\n    this.visual.options.noclip = this.options.noclip;\n\n    if (this.options.visible) {\n      this.createLine();\n    }\n  };\n\n  Note.prototype.renderVisual = function renderVisual() {\n    var this$1 = this;\n    var options = this.options;\n    var customVisual = options.visual;\n\n    if (options.visible && customVisual) {\n      this.visual = customVisual(Object.assign(this.fields, {\n        sender: this.getSender(),\n        rect: this.targetBox.toRect(),\n        options: {\n          background: options.background,\n          border: options.background,\n          icon: options.icon,\n          label: options.label,\n          line: options.line,\n          position: options.position,\n          visible: options.visible\n        },\n        createVisual: function () {\n          this$1.createVisual();\n          this$1.renderChildren();\n          var defaultVisual = this$1.visual;\n          delete this$1.visual;\n          return defaultVisual;\n        }\n      }));\n      this.addVisual();\n    } else {\n      BoxElement.prototype.renderVisual.call(this);\n    }\n  };\n\n  Note.prototype.createLine = function createLine() {\n    var options = this.options.line;\n\n    if (this.linePoints) {\n      var path = draw.Path.fromPoints(this.linePoints, {\n        stroke: {\n          color: options.color,\n          width: options.width,\n          dashType: options.dashType\n        }\n      });\n      alignPathToPixel(path);\n      this.visual.append(path);\n    }\n  };\n\n  Note.prototype.click = function click(widget, e) {\n    var args = this.eventArgs(e);\n\n    if (!widget.trigger(NOTE_CLICK, args)) {\n      e.preventDefault();\n    }\n  };\n\n  Note.prototype.over = function over(widget, e) {\n    var args = this.eventArgs(e);\n\n    if (!widget.trigger(NOTE_HOVER, args)) {\n      e.preventDefault();\n    }\n  };\n\n  Note.prototype.out = function out(widget, e) {\n    var args = this.eventArgs(e);\n    widget.trigger(NOTE_LEAVE, args);\n  };\n\n  Note.prototype.eventArgs = function eventArgs(e) {\n    var options = this.options;\n    return Object.assign(this.fields, {\n      element: eventElement(e),\n      text: defined(options.label) ? options.label.text : \"\",\n      visual: this.visual\n    });\n  };\n\n  return Note;\n}(BoxElement);\n\nsetDefaultOptions(Note, {\n  icon: {\n    visible: true,\n    type: CIRCLE\n  },\n  label: {\n    position: INSIDE,\n    visible: true,\n    align: CENTER,\n    vAlign: CENTER\n  },\n  line: {\n    visible: true\n  },\n  visible: true,\n  position: TOP,\n  zIndex: 2\n});\nexport default Note;","map":null,"metadata":{},"sourceType":"module"}