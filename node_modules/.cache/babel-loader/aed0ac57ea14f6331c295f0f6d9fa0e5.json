{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * AccumulationChart Tooltip file\n */\n\n\nimport { Browser, remove } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { AccPointData, withInBounds, indexFinder } from '../../common/utils/helper';\nimport { BaseTooltip } from '../../common/user-interaction/tooltip';\nimport { tooltipRender } from '../../common/model/constants';\n/**\n * `AccumulationTooltip` module is used to render tooltip for accumulation chart.\n */\n\nvar AccumulationTooltip =\n/** @class */\nfunction (_super) {\n  __extends(AccumulationTooltip, _super);\n\n  function AccumulationTooltip(accumulation) {\n    var _this = _super.call(this, accumulation) || this;\n\n    _this.accumulation = accumulation;\n\n    _this.addEventListener();\n\n    return _this;\n  }\n  /**\n   * @hidden\n   */\n\n\n  AccumulationTooltip.prototype.addEventListener = function () {\n    if (this.accumulation.isDestroyed) {\n      return;\n    }\n\n    this.accumulation.on(Browser.isPointer ? 'pointerleave' : 'mouseleave', this.mouseLeaveHandler, this);\n    this.accumulation.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);\n    this.accumulation.on(Browser.touchEndEvent, this.mouseUpHandler, this);\n  };\n\n  AccumulationTooltip.prototype.mouseLeaveHandler = function (e) {\n    this.removeTooltip(1000);\n  };\n\n  AccumulationTooltip.prototype.mouseUpHandler = function (e) {\n    var control = this.accumulation;\n\n    if (control.tooltip.enable && control.isTouch && withInBounds(control.mouseX, control.mouseY, control.initialClipRect)) {\n      this.tooltip(e);\n      this.removeTooltip(2000);\n    }\n  };\n\n  AccumulationTooltip.prototype.mouseMoveHandler = function (e) {\n    var control = this.accumulation; // Tooltip for chart series.    \n\n    if (control.tooltip.enable && withInBounds(control.mouseX, control.mouseY, control.initialClipRect)) {\n      this.tooltip(e);\n    }\n  };\n  /**\n   * Renders the tooltip.\n   * @param  {PointerEvent} event - Mouse move event.\n   * @return {void}\n   */\n\n\n  AccumulationTooltip.prototype.tooltip = function (event) {\n    var svgElement = this.getElement(this.element.id + '_tooltip_svg');\n    var isTooltip = svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0;\n    var tooltipDiv = this.getTooltipElement(isTooltip);\n    this.renderSeriesTooltip(event, this.accumulation, !isTooltip, tooltipDiv);\n  };\n\n  AccumulationTooltip.prototype.renderSeriesTooltip = function (e, chart, isFirst, tooltipDiv) {\n    var data = this.getPieData(e, chart, chart.mouseX, chart.mouseY);\n    var rect = chart.initialClipRect;\n    this.currentPoints = [];\n\n    if (data.point && (!this.previousPoints[0] || this.previousPoints[0].point !== data.point)) {\n      if (this.pushData(data, isFirst, tooltipDiv, false)) {\n        this.triggerTooltipRender(data, isFirst, this.getTooltipText(data, chart.tooltip), this.findHeader(data));\n      }\n    } else {\n      if (!data.point && this.isRemove) {\n        this.removeTooltip(1000);\n        this.isRemove = false;\n      }\n    }\n  };\n\n  AccumulationTooltip.prototype.triggerTooltipRender = function (point, isFirst, textCollection, headerText, firstText) {\n    var _this = this;\n\n    if (firstText === void 0) {\n      firstText = true;\n    }\n\n    var argsData = {\n      cancel: false,\n      name: tooltipRender,\n      text: textCollection,\n      point: point.point,\n      textStyle: this.textStyle,\n      series: this.accumulation.isBlazor ? {} : point.series,\n      headerText: headerText,\n      data: {\n        pointX: point.point.x,\n        pointY: point.point.y,\n        seriesIndex: point.series.index,\n        pointIndex: point.point.index,\n        pointText: point.point.text,\n        seriesName: point.series.name\n      }\n    };\n\n    var tooltipSuccess = function (argsData) {\n      if (!argsData.cancel) {\n        _this.formattedText = _this.formattedText.concat(argsData.text);\n        _this.text = _this.formattedText;\n        _this.headerText = argsData.headerText;\n\n        _this.createTooltip(_this.chart, isFirst, point.point.symbolLocation, point.series.clipRect, point.point, ['Circle'], 0, _this.chart.initialClipRect, null, point.point);\n      } else {\n        _this.removeHighlight(_this.control);\n\n        remove(_this.getElement(_this.element.id + '_tooltip'));\n      }\n\n      _this.isRemove = true;\n    };\n\n    tooltipSuccess.bind(this, point);\n    this.chart.trigger(tooltipRender, argsData, tooltipSuccess);\n  };\n\n  AccumulationTooltip.prototype.getPieData = function (e, chart, x, y) {\n    var target = e.target;\n    var id = indexFinder(target.id, true);\n\n    if (!isNaN(id.series)) {\n      var seriesIndex = id.series;\n      var pointIndex = id.point;\n\n      if (!isNullOrUndefined(seriesIndex) && !isNaN(seriesIndex) && !isNullOrUndefined(pointIndex) && !isNaN(pointIndex)) {\n        var series = this.getSeriesFromIndex(seriesIndex, chart.visibleSeries);\n\n        if (series.enableTooltip) {\n          return new AccPointData(series.points[pointIndex], series);\n        }\n      }\n    }\n\n    return new AccPointData(null, null);\n  };\n  /**\n   * To get series from index\n   */\n\n\n  AccumulationTooltip.prototype.getSeriesFromIndex = function (index, visibleSeries) {\n    return visibleSeries[0];\n  };\n\n  AccumulationTooltip.prototype.getTooltipText = function (data, tooltip) {\n    var series = data.series;\n    var format = this.accumulation.useGroupingSeparator ? '${point.x} : <b>${point.label}</b>' : '${point.x} : <b>${point.y}</b>';\n    format = tooltip.format ? tooltip.format : format;\n    return this.parseTemplate(data.point, series, format);\n  };\n\n  AccumulationTooltip.prototype.findHeader = function (data) {\n    if (this.header === '') {\n      return '';\n    }\n\n    this.header = this.parseTemplate(data.point, data.series, this.header);\n\n    if (this.header.replace(/<b>/g, '').replace(/<\\/b>/g, '').trim() !== '') {\n      return this.header;\n    }\n\n    return '';\n  };\n\n  AccumulationTooltip.prototype.parseTemplate = function (point, series, format) {\n    var value;\n    var textValue;\n\n    for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {\n      var dataValue = _a[_i];\n      value = new RegExp('${point' + '.' + dataValue + '}', 'gm');\n      format = format.replace(value.source, point[dataValue]);\n    }\n\n    for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {\n      var dataValue = _c[_b];\n      value = new RegExp('${series' + '.' + dataValue + '}', 'gm');\n      textValue = series[dataValue];\n      format = format.replace(value.source, textValue);\n    }\n\n    return format;\n  };\n  /**\n   * Get module name\n   */\n\n\n  AccumulationTooltip.prototype.getModuleName = function () {\n    return 'AccumulationTooltip';\n  };\n  /**\n   * To destroy the Tooltip.\n   * @return {void}\n   * @private\n   */\n\n\n  AccumulationTooltip.prototype.destroy = function (chart) {\n    /**\n     * Destroy method calling here\n     */\n  };\n\n  return AccumulationTooltip;\n}(BaseTooltip);\n\nexport { AccumulationTooltip };","map":null,"metadata":{},"sourceType":"module"}