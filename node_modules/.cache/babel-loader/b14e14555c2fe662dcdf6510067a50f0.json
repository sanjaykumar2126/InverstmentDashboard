{"ast":null,"code":"import CategoricalChart from '../categorical-chart';\nimport LinePoint from './line-point';\nimport LineSegment from './line-segment';\nimport StepLineSegment from './step-line-segment';\nimport SplineSegment from './spline-segment';\nimport LineChartMixin from '../mixins/line-chart-mixin';\nimport ClipAnimationMixin from '../mixins/clip-animation-mixin';\nimport { ZERO, SMOOTH, STEP } from '../constants';\nimport { deepExtend, defined, isFunction } from '../../common';\n\nvar LineChart = function (CategoricalChart) {\n  function LineChart() {\n    CategoricalChart.apply(this, arguments);\n  }\n\n  if (CategoricalChart) LineChart.__proto__ = CategoricalChart;\n  LineChart.prototype = Object.create(CategoricalChart && CategoricalChart.prototype);\n  LineChart.prototype.constructor = LineChart;\n\n  LineChart.prototype.render = function render() {\n    CategoricalChart.prototype.render.call(this);\n    this.updateStackRange();\n    this.renderSegments();\n  };\n\n  LineChart.prototype.pointType = function pointType() {\n    return LinePoint;\n  };\n\n  LineChart.prototype.createPoint = function createPoint(data, fields) {\n    var categoryIx = fields.categoryIx;\n    var category = fields.category;\n    var series = fields.series;\n    var seriesIx = fields.seriesIx;\n    var missingValues = this.seriesMissingValues(series);\n    var value = data.valueFields.value;\n\n    if (!defined(value) || value === null) {\n      if (missingValues === ZERO) {\n        value = 0;\n      } else {\n        return null;\n      }\n    }\n\n    var pointOptions = this.pointOptions(series, seriesIx);\n    pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n    var color = data.fields.color || series.color;\n\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    }\n\n    var point = new LinePoint(value, pointOptions);\n    point.color = color;\n    this.append(point);\n    return point;\n  };\n\n  LineChart.prototype.plotRange = function plotRange(point) {\n    var this$1 = this;\n    var plotValue = this.plotValue(point);\n\n    if (this.options.isStacked) {\n      var categoryIx = point.categoryIx;\n      var categoryPoints = this.categoryPoints[categoryIx];\n\n      for (var i = 0; i < categoryPoints.length; i++) {\n        var other = categoryPoints[i];\n\n        if (point === other) {\n          break;\n        }\n\n        plotValue += this$1.plotValue(other);\n\n        if (this$1.options.isStacked100) {\n          plotValue = Math.min(plotValue, 1);\n        }\n      }\n    }\n\n    return [plotValue, plotValue];\n  };\n\n  LineChart.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {\n    var style = currentSeries.style;\n    var pointType;\n\n    if (style === STEP) {\n      pointType = StepLineSegment;\n    } else if (style === SMOOTH) {\n      pointType = SplineSegment;\n    } else {\n      pointType = LineSegment;\n    }\n\n    return new pointType(linePoints, currentSeries, seriesIx);\n  };\n\n  LineChart.prototype.animationPoints = function animationPoints() {\n    var points = this.points;\n    var result = [];\n\n    for (var idx = 0; idx < points.length; idx++) {\n      result.push((points[idx] || {}).marker);\n    }\n\n    return result.concat(this._segments);\n  };\n\n  return LineChart;\n}(CategoricalChart);\n\ndeepExtend(LineChart.prototype, LineChartMixin, ClipAnimationMixin);\nexport default LineChart;","map":null,"metadata":{},"sourceType":"module"}