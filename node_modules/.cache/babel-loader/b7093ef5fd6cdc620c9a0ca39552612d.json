{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport { WHITE } from '../common/constants';\nimport { Class, deepExtend, defined, valueOrDefault } from '../common';\n\nvar ChartElement = function (Class) {\n  function ChartElement(options) {\n    Class.call(this);\n    this.children = [];\n    this.options = deepExtend({}, this.options, this.initUserOptions(options));\n  }\n\n  if (Class) ChartElement.__proto__ = Class;\n  ChartElement.prototype = Object.create(Class && Class.prototype);\n  ChartElement.prototype.constructor = ChartElement;\n\n  ChartElement.prototype.initUserOptions = function initUserOptions(options) {\n    return options;\n  };\n\n  ChartElement.prototype.reflow = function reflow(targetBox) {\n    var children = this.children;\n    var box;\n\n    for (var i = 0; i < children.length; i++) {\n      var currentChild = children[i];\n      currentChild.reflow(targetBox);\n      box = box ? box.wrap(currentChild.box) : currentChild.box.clone();\n    }\n\n    this.box = box || targetBox;\n  };\n\n  ChartElement.prototype.destroy = function destroy() {\n    var children = this.children;\n\n    if (this.animation) {\n      this.animation.destroy();\n    }\n\n    for (var i = 0; i < children.length; i++) {\n      children[i].destroy();\n    }\n  };\n\n  ChartElement.prototype.getRoot = function getRoot() {\n    var parent = this.parent;\n    return parent ? parent.getRoot() : null;\n  };\n\n  ChartElement.prototype.getSender = function getSender() {\n    var service = this.getService();\n\n    if (service) {\n      return service.sender;\n    }\n  };\n\n  ChartElement.prototype.getService = function getService() {\n    var element = this;\n\n    while (element) {\n      if (element.chartService) {\n        return element.chartService;\n      }\n\n      element = element.parent;\n    }\n  };\n\n  ChartElement.prototype.translateChildren = function translateChildren(dx, dy) {\n    var children = this.children;\n    var childrenCount = children.length;\n\n    for (var i = 0; i < childrenCount; i++) {\n      children[i].box.translate(dx, dy);\n    }\n  };\n\n  ChartElement.prototype.append = function append() {\n    var arguments$1 = arguments;\n    var this$1 = this;\n\n    for (var i = 0; i < arguments.length; i++) {\n      var item = arguments$1[i];\n      this$1.children.push(item);\n      item.parent = this$1;\n    }\n  };\n\n  ChartElement.prototype.renderVisual = function renderVisual() {\n    if (this.options.visible === false) {\n      return;\n    }\n\n    this.createVisual();\n    this.addVisual();\n    this.renderChildren();\n    this.createAnimation();\n    this.renderComplete();\n  };\n\n  ChartElement.prototype.addVisual = function addVisual() {\n    if (this.visual) {\n      this.visual.chartElement = this;\n\n      if (this.parent) {\n        this.parent.appendVisual(this.visual);\n      }\n    }\n  };\n\n  ChartElement.prototype.renderChildren = function renderChildren() {\n    var children = this.children;\n    var length = children.length;\n\n    for (var i = 0; i < length; i++) {\n      children[i].renderVisual();\n    }\n  };\n\n  ChartElement.prototype.createVisual = function createVisual() {\n    this.visual = new draw.Group({\n      zIndex: this.options.zIndex,\n      visible: valueOrDefault(this.options.visible, true)\n    });\n  };\n\n  ChartElement.prototype.createAnimation = function createAnimation() {\n    if (this.visual && this.options.animation) {\n      this.animation = draw.Animation.create(this.visual, this.options.animation);\n    }\n  };\n\n  ChartElement.prototype.appendVisual = function appendVisual(childVisual) {\n    if (!childVisual.chartElement) {\n      childVisual.chartElement = this;\n    }\n\n    if (childVisual.options.noclip) {\n      this.clipRoot().visual.append(childVisual);\n    } else if (defined(childVisual.options.zIndex)) {\n      this.stackRoot().stackVisual(childVisual);\n    } else if (this.isStackRoot) {\n      this.stackVisual(childVisual);\n    } else if (this.visual) {\n      this.visual.append(childVisual);\n    } else {\n      // Allow chart elements without visuals to\n      // pass through child visuals\n      this.parent.appendVisual(childVisual);\n    }\n  };\n\n  ChartElement.prototype.clipRoot = function clipRoot() {\n    if (this.parent) {\n      return this.parent.clipRoot();\n    }\n\n    return this;\n  };\n\n  ChartElement.prototype.stackRoot = function stackRoot() {\n    if (this.parent) {\n      return this.parent.stackRoot();\n    }\n\n    return this;\n  };\n\n  ChartElement.prototype.stackVisual = function stackVisual(childVisual) {\n    var zIndex = childVisual.options.zIndex || 0;\n    var visuals = this.visual.children;\n    var length = visuals.length;\n    var pos;\n\n    for (pos = 0; pos < length; pos++) {\n      var sibling = visuals[pos];\n      var here = valueOrDefault(sibling.options.zIndex, 0);\n\n      if (here > zIndex) {\n        break;\n      }\n    }\n\n    this.visual.insert(pos, childVisual);\n  };\n\n  ChartElement.prototype.traverse = function traverse(callback) {\n    var children = this.children;\n    var length = children.length;\n\n    for (var i = 0; i < length; i++) {\n      var child = children[i];\n      callback(child);\n\n      if (child.traverse) {\n        child.traverse(callback);\n      }\n    }\n  };\n\n  ChartElement.prototype.closest = function closest(match) {\n    var element = this;\n    var matched = false;\n\n    while (element && !matched) {\n      matched = match(element);\n\n      if (!matched) {\n        element = element.parent;\n      }\n    }\n\n    if (matched) {\n      return element;\n    }\n  };\n\n  ChartElement.prototype.renderComplete = function renderComplete() {};\n\n  ChartElement.prototype.hasHighlight = function hasHighlight() {\n    var options = (this.options || {}).highlight;\n    return !(!this.createHighlight || options && options.visible === false);\n  };\n\n  ChartElement.prototype.toggleHighlight = function toggleHighlight(show) {\n    var this$1 = this;\n    var options = (this.options || {}).highlight || {};\n    var customVisual = options.visual;\n    var highlight = this._highlight;\n\n    if (!highlight) {\n      var highlightOptions = {\n        fill: {\n          color: WHITE,\n          opacity: 0.2\n        },\n        stroke: {\n          color: WHITE,\n          width: 1,\n          opacity: 0.2\n        }\n      };\n\n      if (customVisual) {\n        highlight = this._highlight = customVisual(Object.assign(this.highlightVisualArgs(), {\n          createVisual: function () {\n            return this$1.createHighlight(highlightOptions);\n          },\n          sender: this.getSender(),\n          series: this.series,\n          dataItem: this.dataItem,\n          category: this.category,\n          value: this.value,\n          percentage: this.percentage,\n          runningTotal: this.runningTotal,\n          total: this.total\n        }));\n\n        if (!highlight) {\n          return;\n        }\n      } else {\n        highlight = this._highlight = this.createHighlight(highlightOptions);\n      }\n\n      if (!defined(highlight.options.zIndex)) {\n        highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);\n      }\n\n      this.appendVisual(highlight);\n    }\n\n    highlight.visible(show);\n  };\n\n  ChartElement.prototype.createGradientOverlay = function createGradientOverlay(element, options, gradientOptions) {\n    var overlay = new draw.Path(Object.assign({\n      stroke: {\n        color: \"none\"\n      },\n      fill: this.createGradient(gradientOptions),\n      closed: element.options.closed\n    }, options));\n    overlay.segments.elements(element.segments.elements());\n    return overlay;\n  };\n\n  ChartElement.prototype.createGradient = function createGradient(options) {\n    if (this.parent) {\n      return this.parent.createGradient(options);\n    }\n  };\n\n  return ChartElement;\n}(Class);\n\nChartElement.prototype.options = {};\nexport default ChartElement;","map":null,"metadata":{},"sourceType":"module"}