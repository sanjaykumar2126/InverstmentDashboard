{"ast":null,"code":"import { extend, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { PathOption, drawPath, drawRectangle, RectOption, Rect, CircleOption, drawCircle } from '../utils/helper';\nimport { measureText, renderTextElement, TextOption } from '../utils/helper';\nimport { DataManager, Query } from '@syncfusion/ej2-data';\n/**\n * Sparkline rendering calculation file\n */\n\nvar SparklineRenderer =\n/** @class */\nfunction () {\n  /**\n   * Sparkline data calculations\n   * @param sparkline\n   */\n  function SparklineRenderer(sparkline) {\n    this.sparkline = sparkline;\n  }\n  /**\n   * To process the sparkline data\n   */\n\n\n  SparklineRenderer.prototype.processData = function () {\n    var data = this.sparkline.dataSource;\n\n    if (isNullOrUndefined(data) || !data.length) {\n      return;\n    } else if (!isNaN(this.sparkline.dataSource[0]) || this.sparkline.valueType === 'Numeric') {\n      data = this.sparkline.enableRtl ? data.reverse() : data;\n      this.sparkline.sparklineData = data; // extend([], data) as Object[];\n    } else {\n      this['process' + this.sparkline.valueType]();\n    }\n\n    this.axisCalculation();\n  };\n  /* tslint:disable:no-string-literal */\n\n  /* tslint:disable:no-eval */\n\n\n  SparklineRenderer.prototype.processDataManager = function () {\n    var _this = this;\n\n    var dataModule;\n    var queryModule;\n\n    if (this.sparkline.dataSource instanceof DataManager) {\n      dataModule = this.sparkline.dataSource;\n      queryModule = this.sparkline.query instanceof Query ? this.sparkline.query : new Query();\n      var dataManager = dataModule.executeQuery(queryModule);\n      dataManager.then(function (e) {\n        _this.sparkline.setProperties({\n          dataSource: e['result']\n        }, true);\n\n        _this.sparkline.sparklineData = _this.sparkline.dataSource;\n\n        _this.sparkline.processSparklineData();\n      });\n    } else {\n      this.sparkline.processSparklineData();\n    }\n  };\n  /**\n   * To process sparkline category data.\n   */\n\n\n  SparklineRenderer.prototype.processCategory = function (data, x, y) {\n    var _this = this;\n\n    if (data === void 0) {\n      data = this.sparkline.dataSource;\n    }\n\n    if (x === void 0) {\n      x = this.sparkline.xName;\n    }\n\n    if (y === void 0) {\n      y = this.sparkline.yName;\n    }\n\n    var temp = [];\n    var xValues = [];\n    data.forEach(function (value, index) {\n      if (xValues.indexOf(value[x]) === -1) {\n        xValues.push(value[x]);\n      }\n\n      var currentData = {};\n      currentData[_this.sparkline.xName] = xValues.indexOf(value[x]);\n      currentData[_this.sparkline.yName] = value[y];\n      temp.push(currentData);\n    });\n    this.sparkline.sparklineData = temp;\n  };\n  /**\n   * To process sparkline DateTime data.\n   */\n\n\n  SparklineRenderer.prototype.processDateTime = function (data, x, y) {\n    if (data === void 0) {\n      data = this.sparkline.dataSource;\n    }\n\n    if (x === void 0) {\n      x = this.sparkline.xName;\n    }\n\n    if (y === void 0) {\n      y = this.sparkline.yName;\n    }\n\n    var temp = [];\n    data.forEach(function (value, index) {\n      var currentData = {};\n      currentData[x] = value[x].getTime();\n      currentData[y] = value[y];\n      temp.push(currentData);\n    });\n    this.sparkline.sparklineData = temp;\n  };\n  /**\n   * To render sparkline series.\n   * @private\n   */\n\n\n  SparklineRenderer.prototype.renderSeries = function () {\n    var spark = this.sparkline;\n    this.clipId = spark.element.id + '_sparkline_clip_path';\n    this.drawAxis();\n    var args = {\n      name: 'seriesRendering',\n      cancel: false,\n      lineWidth: spark.lineWidth,\n      border: spark.border,\n      fill: spark.fill,\n      sparkline: spark\n    };\n    spark.trigger(args.name, args);\n\n    if (!this.visiblePoints || args.cancel) {\n      return;\n    }\n\n    if (spark.type !== 'Pie' && spark.type !== 'WinLoss' && spark.rangeBandSettings.length) {\n      var group = this.sparkline.renderer.createGroup({\n        id: this.sparkline.element.id + '_sparkline_rangeband_g'\n      });\n\n      for (var i = 0; i < spark.rangeBandSettings.length; i++) {\n        if (spark.axisSettings.minY <= spark.rangeBandSettings[i].startRange || spark.axisSettings.maxY >= spark.rangeBandSettings[i].endRange) {\n          this.rangeBand(spark.rangeBandSettings[i], group, i);\n        }\n      }\n\n      this.sparkline.svgObject.appendChild(group);\n    }\n\n    this['render' + spark.type](this.visiblePoints, args);\n    this.renderMarker(this.visiblePoints);\n    this.renderLabel(this.visiblePoints);\n  };\n  /**\n   * To render a range band\n   */\n\n\n  SparklineRenderer.prototype.rangeBand = function (rangeBandSettings, group, index) {\n    var model = this.sparkline;\n    var height = model.availableSize.height - model.padding.top * 2;\n    var width = model.availableSize.width - model.padding.left * 2;\n    var stValue = rangeBandSettings.startRange;\n    var edValue = rangeBandSettings.endRange;\n    var stHeight = height - height / this.unitY * (stValue - this.min) + model.padding.top;\n    var edHeight = height - height / this.unitY * (edValue - this.min) + model.padding.top;\n    var color = rangeBandSettings.color || this.sparkline.sparkTheme.rangeBandColor;\n\n    if (edHeight > height + model.padding.top) {\n      edHeight = height + model.padding.top;\n    } else if (edHeight < 0 + model.padding.top) {\n      edHeight = 0 + model.padding.top;\n    }\n\n    if (stHeight > height + model.padding.top) {\n      stHeight = height + model.padding.top;\n    } else if (stHeight < 0 + model.padding.top) {\n      stHeight = 0 + model.padding.top;\n    }\n\n    var path = 'M ' + model.padding.left + ' ' + stHeight + ' L ' + (width + model.padding.left) + ' ' + stHeight + ' L ' + (width + model.padding.left) + ' ' + edHeight + ' L ' + model.padding.left + ' ' + edHeight + ' Z ';\n    var pathOption = {\n      'id': model.element.id + '_rangeBand_' + index,\n      'fill': color,\n      'opacity': rangeBandSettings.opacity,\n      'stroke': 'transparent',\n      'stroke-width': model.lineWidth,\n      'd': path,\n      'stroke-dasharray': ''\n    };\n    drawPath(this.sparkline, pathOption, group);\n  };\n  /**\n   * To render line series\n   */\n\n\n  SparklineRenderer.prototype.renderLine = function (points, args) {\n    var spark = this.sparkline;\n    var g = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_g',\n      'clip-path': 'url(#' + this.clipId + ')'\n    });\n    var color = this.sparkline.fill;\n    color = this.sparkline.fill === '#00bdae' && this.sparkline.theme === 'Bootstrap4' ? this.sparkline.sparkTheme.axisLineColor : color;\n    var pathOption = new PathOption(spark.element.id + '_sparkline_line', 'transparent', args.lineWidth, color, spark.opacity);\n    var d = '';\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      if (i === 0) {\n        d = 'M ' + points[0].x + ' ' + points[i].y + ' ';\n      }\n\n      d += 'L ' + points[i].x + ' ' + points[i].y + ' ';\n    }\n\n    pathOption.d = d;\n    drawPath(this.sparkline, pathOption, g);\n    this.sparkline.svgObject.appendChild(g);\n  };\n  /**\n   * To render pie series\n   */\n\n  /* tslint:disable:no-string-literal */\n\n\n  SparklineRenderer.prototype.renderPie = function (points, args) {\n    var spark = this.sparkline;\n    var height = spark.availableSize.height - (spark.padding.top + spark.padding.bottom);\n    var width = spark.availableSize.width - (spark.padding.left + spark.padding.right);\n    var area = height <= width ? height / 2 : width / 2;\n    var X = spark.availableSize.width / 2; // center position of x\n\n    var Y = spark.availableSize.height / 2; // center position of y\n\n    var deg = 0;\n    var stRad;\n    var edRad;\n    var stroke = args.border.color;\n    var opacity = spark.opacity;\n    var strokeWidth = args.border.width;\n    var colors = spark.palette.length ? spark.palette : ['#00bdae', '#404041', '#357cd2', '#e56590', '#f8b883', '#70ad47', '#dd8abd', '#7f84e8', '#7bb4eb', '#ea7a57'];\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_g'\n    });\n    var low;\n    var high;\n    var locations = extend([], [], points);\n\n    if (spark.highPointColor || spark.lowPointColor) {\n      var pointsYvalues = locations.map(function (a) {\n        return a.yVal;\n      });\n      low = Math.min.apply(null, pointsYvalues);\n      high = Math.max.apply(null, pointsYvalues);\n    }\n\n    this.negativePointIndexes = [];\n\n    for (var i = 0, stDeg = 90, edDeg = void 0, flag = void 0; i < points.length; i++) {\n      stDeg += deg;\n      deg = points[i]['degree'];\n      edDeg = stDeg + deg;\n      stRad = (stDeg - 90) * Math.PI / 180.0;\n      edRad = (edDeg - 90) * Math.PI / 180.0;\n      points[i]['stAng'] = stRad;\n      points[i]['endAng'] = edRad;\n      flag = deg < 180 ? '0' : '1';\n      var temp = points[i]['coordinates'] = {\n        sX: X + area * Math.cos(stRad),\n        sY: Y + area * Math.sin(stRad),\n        eX: X + area * Math.cos(edRad),\n        eY: Y + area * Math.sin(edRad)\n      };\n      var pathArc = 'M ' + X + ' ' + Y + ' L ' + temp['eX'] + ' ' + temp['eY'] + ' A ' + area + ' ' + area + ' 0 ' + flag + ',0 ' + temp['sX'] + ' ' + temp['sY'] + ' Z';\n      var pathOption = {\n        'id': spark.element.id + '_sparkline_pie_' + i,\n        'opacity': opacity,\n        'fill': colors[i % colors.length],\n        'stroke': stroke,\n        'stroke-width': strokeWidth,\n        'd': pathArc,\n        'stroke-dasharray': ''\n      };\n      this.getPieSpecialPoint(points[i], spark, pathOption, i, high, low, points.length);\n      var pointArgs = this.triggerPointRender('pointRendering', i, pathOption.fill, {\n        color: stroke,\n        width: strokeWidth\n      });\n      pathOption.fill = pointArgs.fill;\n      pathOption.stroke = pointArgs.border.color;\n      pathOption['stroke-width'] = pointArgs.border.width;\n\n      if (!pointArgs.cancel) {\n        var element = drawPath(this.sparkline, pathOption, group);\n        element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n      }\n\n      var diffRadian = edRad - stRad;\n      var mid = {\n        x: X + area / 2 * Math.cos(stRad + diffRadian / 2),\n        y: Y + area / 2 * Math.sin(stRad + diffRadian / 2)\n      };\n      points[i].location.x = mid.x;\n      points[i].location.y = mid.y;\n    }\n\n    this.sparkline.svgObject.appendChild(group);\n  };\n  /**\n   * To get special point color and option for Pie series.\n   */\n\n\n  SparklineRenderer.prototype.getPieSpecialPoint = function (temp, spark, option, i, high, low, length) {\n    if (temp.yVal < 0 && spark.negativePointColor) {\n      option.fill = spark.negativePointColor;\n      this.negativePointIndexes.push(i);\n    }\n\n    if (i === 0 && spark.startPointColor) {\n      option.fill = spark.startPointColor;\n      this.startPointIndex = i;\n    } else if (i === length - 1 && spark.endPointColor) {\n      option.fill = spark.endPointColor;\n      this.endPointIndex = i;\n    }\n\n    if (temp.yVal === high && spark.highPointColor) {\n      option.fill = spark.highPointColor;\n      this.highPointIndex = i;\n    } else if (temp.yVal === low && spark.lowPointColor) {\n      option.fill = spark.lowPointColor;\n      this.lowPointIndex = i;\n    }\n  };\n  /**\n   * To render area series\n   */\n\n\n  SparklineRenderer.prototype.renderArea = function (points, args) {\n    var spark = this.sparkline;\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_g',\n      'clip-path': 'url(#' + this.clipId + ')'\n    });\n    var pathOption = new PathOption(spark.element.id + '_sparkline_area', args.fill, 0, 'transparent', spark.opacity);\n    var d = '';\n    var str = '';\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      if (i !== 0) {\n        str += 'L ' + points[i].x + ' ' + points[i].y + ' ';\n      } else {\n        d = 'M ' + points[i].x + ' ' + this.axisHeight + ' ';\n        str = 'M ' + points[i].x + ' ' + points[i].y + ' ';\n      }\n\n      d += 'L ' + points[i].x + ' ' + points[i].y + ' ';\n\n      if (i === len - 1) {\n        d += 'L ' + points[i].x + ' ' + this.axisHeight + ' Z';\n      }\n    }\n\n    pathOption.d = d;\n    drawPath(this.sparkline, pathOption, group);\n    pathOption = new PathOption(spark.element.id + '_sparkline_area_str', 'transparent', args.border.width, args.border.color, spark.opacity, '', str);\n    drawPath(this.sparkline, pathOption, group);\n    this.sparkline.svgObject.appendChild(group);\n  };\n  /**\n   * To render column series\n   */\n\n\n  SparklineRenderer.prototype.renderColumn = function (points, args) {\n    var spark = this.sparkline;\n    var locations = extend([], [], points);\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_g',\n      'clip-path': 'url(#' + this.clipId + ')'\n    });\n    var lowPos;\n    var highPos;\n\n    if (this.sparkline.highPointColor || this.sparkline.lowPointColor) {\n      var pointsYPos = locations.map(function (a) {\n        return a.markerPosition;\n      });\n      highPos = Math.min.apply(null, pointsYPos);\n      lowPos = Math.max.apply(null, pointsYPos);\n    }\n\n    var id = spark.element.id + '_sparkline_column_';\n    var rectOptions = new RectOption(id, '', args.border, spark.opacity, null);\n    var paletteLength = spark.palette.length;\n    var temp;\n    var len = points.length;\n    this.negativePointIndexes = [];\n\n    for (var i = 0; i < len; i++) {\n      temp = points[i];\n      rectOptions.id = id + i;\n      rectOptions.fill = paletteLength ? spark.palette[i % paletteLength] : args.fill;\n      rectOptions.rect = new Rect(temp.x, temp.y, temp.width, temp.height);\n      this.getSpecialPoint(true, temp, spark, rectOptions, i, highPos, lowPos, len);\n      temp.location.y = temp.markerPosition <= this.axisHeight ? temp.y : temp.y + temp.height;\n      temp.location.x = temp.x + temp.width / 2;\n      rectOptions.stroke = args.border.color ? args.border.color : rectOptions.fill;\n      var pointArgs = this.triggerPointRender('pointRendering', i, rectOptions.fill, {\n        color: rectOptions.stroke,\n        width: args.border.width\n      });\n      rectOptions.fill = pointArgs.fill;\n      rectOptions.stroke = pointArgs.border.color;\n      rectOptions['stroke-width'] = pointArgs.border.width;\n\n      if (!pointArgs.cancel) {\n        var element = drawRectangle(spark, rectOptions, group);\n        element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n      }\n    }\n\n    this.sparkline.svgObject.appendChild(group);\n  };\n  /**\n   * To render WinLoss series\n   */\n\n\n  SparklineRenderer.prototype.renderWinLoss = function (points, args) {\n    var spark = this.sparkline;\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_g',\n      'clip-path': 'url(#' + this.clipId + ')'\n    });\n    var id = spark.element.id + '_sparkline_winloss_';\n    var options = new RectOption(id, '', args.border, spark.opacity, null);\n    var temp;\n    var len = points.length;\n    var paletteLength = spark.palette.length;\n\n    for (var i = 0; i < len; i++) {\n      temp = points[i];\n      options.id = id + i;\n      options.fill = paletteLength ? spark.palette[i % paletteLength] : temp.yVal === this.axisValue ? this.sparkline.tiePointColor || '#a216f3' : temp.yVal > this.axisValue ? args.fill : spark.negativePointColor || '#e20f07';\n      options.stroke = args.border.color ? args.border.color : options.fill;\n      options.rect = new Rect(temp.x, temp.y, temp.width, temp.height);\n      temp.location.x = temp.x + temp.width / 2;\n      temp.location.y = temp.yVal >= this.axisValue ? temp.y : temp.y + temp.height;\n      var pointArgs = this.triggerPointRender('pointRendering', i, options.fill, {\n        color: options.stroke,\n        width: args.border.width\n      });\n      options.fill = pointArgs.fill;\n      options.stroke = pointArgs.border.color;\n      options['stroke-width'] = pointArgs.border.width;\n\n      if (!pointArgs.cancel) {\n        var element = drawRectangle(spark, options, group);\n        element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n      }\n    }\n\n    this.sparkline.svgObject.appendChild(group);\n  };\n\n  SparklineRenderer.prototype.renderMarker = function (points) {\n    var spark = this.sparkline;\n    var marker = spark.markerSettings;\n\n    if (spark.type === 'Pie' || spark.type === 'WinLoss' || !marker.visible.length) {\n      return;\n    }\n\n    var locations = extend([], [], points);\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_marker_g',\n      'clip-path': 'url(#' + this.clipId + ')'\n    });\n    var temp;\n    var id = spark.element.id + '_sparkline_marker_';\n    var option = new CircleOption('', marker.fill, marker.border, marker.opacity, 0, 0, marker.size / 2, '');\n    var highPos;\n    var lowPos;\n    var visible = marker.visible.join();\n\n    if (visible.toLowerCase().indexOf('high') > -1 || visible.toLowerCase().indexOf('low') > -1) {\n      var pointsYPos = locations.map(function (a) {\n        return a.markerPosition;\n      });\n      highPos = Math.min.apply(null, pointsYPos);\n      lowPos = Math.max.apply(null, pointsYPos);\n    }\n\n    this.negativePointIndexes = [];\n\n    for (var i = 0, length_1 = points.length; i < length_1; i++) {\n      temp = points[i];\n      option.id = id + i;\n      option.cx = temp.location.x;\n      option.cy = temp.location.y;\n      option.fill = marker.fill;\n      var render = visible.toLowerCase().indexOf('all') > -1;\n      render = this.getSpecialPoint(render, temp, spark, option, i, highPos, lowPos, length_1, visible.toLowerCase());\n      option.stroke = marker.border.color || option.fill;\n      var markerArgs = {\n        name: 'markerRendering',\n        cancel: false,\n        border: {\n          color: option.stroke,\n          width: marker.border.width\n        },\n        fill: option.fill,\n        pointIndex: i,\n        sparkline: this.sparkline,\n        x: option.cx,\n        y: option.cy,\n        size: marker.size\n      };\n      this.sparkline.trigger(markerArgs.name, markerArgs);\n\n      if (render && !markerArgs.cancel) {\n        option.fill = markerArgs.fill;\n        option.stroke = markerArgs.border.color;\n        option['stroke-width'] = markerArgs.border.width;\n        option.r = markerArgs.size / 2;\n        var element = drawCircle(spark, option, group);\n        element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n      }\n    }\n\n    this.sparkline.svgObject.appendChild(group);\n  };\n  /**\n   * To get special point color and option.\n   */\n\n\n  SparklineRenderer.prototype.getSpecialPoint = function (render, temp, spark, option, i, highPos, lowPos, length, visible) {\n    if (visible === void 0) {\n      visible = '';\n    }\n\n    if (temp.markerPosition > this.axisHeight) {\n      option.fill = spark.negativePointColor || option.fill;\n      this.negativePointIndexes.push(i);\n      render = render || visible.indexOf('negative') > -1;\n    }\n\n    if (i === 0) {\n      option.fill = spark.startPointColor || option.fill;\n      this.startPointIndex = i;\n      render = render || visible.indexOf('start') > -1;\n    } else if (i === length - 1) {\n      option.fill = spark.endPointColor || option.fill;\n      this.endPointIndex = i;\n      render = render || visible.indexOf('end') > -1;\n    }\n\n    if (temp.markerPosition === highPos) {\n      option.fill = spark.highPointColor || option.fill;\n      this.highPointIndex = i;\n      render = render || visible.indexOf('high') > -1;\n    } else if (temp.markerPosition === lowPos) {\n      option.fill = spark.lowPointColor || option.fill;\n      this.lowPointIndex = i;\n      render = render || visible.indexOf('low') > -1;\n    }\n\n    return render;\n  };\n  /**\n   * To render data label for sparkline.\n   */\n\n\n  SparklineRenderer.prototype.renderLabel = function (points) {\n    var spark = this.sparkline;\n    var dataLabel = spark.dataLabelSettings;\n    var color = dataLabel.textStyle.color || spark.sparkTheme.dataLabelColor;\n\n    if (spark.type === 'WinLoss' || !dataLabel.visible.length) {\n      return;\n    }\n\n    var locations = extend([], [], points);\n    var id = spark.element.id + '_sparkline_label_';\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_label_g',\n      style: 'pointer-events: none;'\n    });\n    var g;\n    var temp;\n    var textId = id + 'text_';\n    var rectId = id + 'rect_';\n    var option = new TextOption('', 0, 0, 'middle', '', 'middle');\n    var labelStyle = dataLabel.textStyle;\n    var pointsYPos = locations.map(function (a) {\n      return a.markerPosition;\n    });\n    var highPos = Math.min.apply(null, pointsYPos);\n    var lowPos = Math.max.apply(null, pointsYPos);\n    var space = 1;\n    var padding = dataLabel.fill !== 'transparent' || dataLabel.border.width ? 2 : 0;\n    var size = measureText('sparkline_measure_text', labelStyle);\n    var rectOptions = new RectOption('', dataLabel.fill, dataLabel.border, dataLabel.opacity, null);\n    var edgeLabelOption;\n    labelStyle.fontFamily = spark.sparkTheme.labelFontFamily || labelStyle.fontFamily;\n\n    for (var i = 0, length_2 = points.length; i < length_2; i++) {\n      temp = points[i];\n      option.id = textId + i;\n      option.x = temp.location.x + dataLabel.offset.x;\n      option.y = (spark.type === 'Pie' ? temp.location.y : temp.markerPosition > this.axisHeight ? temp.location.y + size.height / 2 + space + padding : temp.location.y - size.height / 2 - space - padding) + dataLabel.offset.y;\n      option.text = dataLabel.format !== '' ? this.formatter(dataLabel.format, this.sparkline.dataSource[i]) : temp.yVal.toString();\n      var labelArgs = {\n        name: 'dataLabelRendering',\n        cancel: false,\n        border: dataLabel.border,\n        fill: dataLabel.fill,\n        pointIndex: i,\n        sparkline: this.sparkline,\n        x: option.x,\n        y: option.y,\n        text: option.text,\n        color: color\n      };\n      this.sparkline.trigger(labelArgs.name, labelArgs);\n      size = measureText(labelArgs.text, labelStyle);\n      option.text = labelArgs.text;\n      var render = dataLabel.visible.join().toLowerCase().indexOf('all') > -1;\n      render = this.getLabelVisible(render, temp, i, dataLabel, length_2, highPos, lowPos);\n      edgeLabelOption = this.arrangeLabelPosition(dataLabel.edgeLabelMode, render, labelArgs.x, i, length_2, size, padding);\n\n      if (render && !labelArgs.cancel && edgeLabelOption.render) {\n        rectOptions.id = rectId + i;\n        rectOptions.fill = labelArgs.fill;\n        rectOptions.stroke = labelArgs.border.color;\n        rectOptions['stroke-width'] = labelArgs.border.width;\n        option.x = edgeLabelOption.x;\n        option.y = labelArgs.y;\n        rectOptions.rect = new Rect(option.x - (size.width / 2 + padding), option.y - padding - size.height / 1.75, size.width + padding * 2, size.height + padding * 2);\n        g = this.sparkline.renderer.createGroup({\n          id: id + 'g' + i\n        });\n        drawRectangle(spark, rectOptions, g);\n        renderTextElement(option, labelStyle, labelArgs.color, g);\n        group.appendChild(g);\n      }\n    }\n\n    this.sparkline.svgObject.appendChild(group);\n  };\n\n  SparklineRenderer.prototype.arrangeLabelPosition = function (edgeLabel, render, x, index, length, size, padding) {\n    if (edgeLabel === 'None') {\n      return {\n        x: x,\n        render: render\n      };\n    }\n\n    if (index === 0 && x - size.width / 2 - padding <= 0) {\n      if (edgeLabel === 'Hide') {\n        render = false;\n      } else {\n        x = this.sparkline.padding.left + padding + size.width / 2;\n      }\n    } else if (index === length - 1 && x + size.width / 2 + padding >= this.sparkline.availableSize.width) {\n      if (edgeLabel === 'Hide') {\n        render = false;\n      } else {\n        x -= size.width / 2 + padding;\n      }\n    }\n\n    return {\n      x: x,\n      render: render\n    };\n  };\n  /**\n   * To get special point color and option.\n   */\n\n\n  SparklineRenderer.prototype.getLabelVisible = function (render, temp, i, label, length, highPos, lowPos) {\n    var labelVisible = label.visible.join().toLowerCase();\n\n    if (temp.markerPosition > this.axisHeight) {\n      render = render || labelVisible.indexOf('negative') > -1;\n    }\n\n    if (i === 0) {\n      render = render || labelVisible.indexOf('start') > -1;\n    } else if (i === length - 1) {\n      render = render || labelVisible.indexOf('end') > -1;\n    }\n\n    if (temp.markerPosition === highPos) {\n      render = render || labelVisible.indexOf('high') > -1;\n    } else if (temp.markerPosition === lowPos) {\n      render = render || labelVisible.indexOf('low') > -1;\n    }\n\n    return render;\n  };\n  /**\n   * To format text\n   */\n\n\n  SparklineRenderer.prototype.formatter = function (format, data) {\n    if (isNullOrUndefined(format)) {\n      return null;\n    }\n\n    var keys = Object.keys(data);\n\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var key = keys_1[_i];\n      format = format.split('${' + key + '}').join(data[key]);\n    }\n\n    return format;\n  };\n  /**\n   * To calculate min max for x and y axis\n   */\n\n\n  SparklineRenderer.prototype.axisCalculation = function () {\n    this.findRanges(this.sparkline.sparklineData);\n  };\n  /**\n   * To find x axis interval.\n   */\n\n\n  SparklineRenderer.prototype.getInterval = function (data, x, type) {\n    var interval = 1;\n    var x1 = data[0][x];\n    var x2 = isNullOrUndefined(data[1]) ? undefined : data[1][x];\n\n    if (!isNullOrUndefined(x1) && !isNullOrUndefined(x2)) {\n      var temp = extend([], data);\n      var validData_1 = [];\n      temp.forEach(function (value) {\n        if (!isNullOrUndefined(value[x])) {\n          validData_1.push(value);\n        }\n      });\n      validData_1.sort(function (a, b) {\n        if (isNullOrUndefined(a[x]) || isNullOrUndefined(b[x])) {\n          return 0;\n        }\n\n        return a[x] - b[x];\n      });\n      validData_1 = this.sparkline.enableRtl ? validData_1.reverse() : validData_1;\n      interval = validData_1[1][x] - validData_1[0][x];\n    }\n\n    return interval;\n  };\n  /**\n   * To calculate axis ranges internally.\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  SparklineRenderer.prototype.findRanges = function (data) {\n    var model = this.sparkline;\n    var max;\n    var min;\n    var minX;\n    var maxX;\n    var maxPointsLength = data.length;\n    var temp;\n    var sumofValues = 0;\n    var isNumericArray = Array.isArray(data) && typeof data[0] !== 'object';\n\n    if (isNumericArray) {\n      if (model.type === 'Pie') {\n        for (var i = 0; i < maxPointsLength; i++) {\n          sumofValues += Math.abs(data[i]);\n        }\n      } else {\n        max = Math.max.apply(null, data);\n        min = Math.min.apply(null, data);\n        minX = 0;\n        maxX = maxPointsLength - 1;\n      }\n    } else {\n      if (model.type === 'Pie') {\n        for (var i = 0; i < maxPointsLength; i++) {\n          sumofValues += Math.abs(data[i][model.yName]);\n        }\n      } else {\n        if (isNullOrUndefined(data[0][model.xName])) {\n          var x_1 = data.map(function (z) {\n            return z[model.yName];\n          });\n          max = Math.max.apply(null, x_1);\n          min = Math.min.apply(null, x_1);\n        } else {\n          temp = extend([], data);\n          temp = temp.sort(function (a, b) {\n            return a[model.yName] - b[model.yName];\n          });\n          max = temp[temp.length - 1][model.yName];\n          min = temp[0][model.yName];\n        }\n\n        if (!isNullOrUndefined(data[0][model.xName])) {\n          temp = temp.sort(function (a, b) {\n            return a[model.xName] - b[model.xName];\n          });\n          temp = this.sparkline.enableRtl ? temp.reverse() : temp;\n          maxX = temp[temp.length - 1][model.xName];\n          minX = temp[0][model.xName];\n        } else {\n          minX = 0;\n          maxX = maxPointsLength - 1;\n        }\n      }\n    }\n\n    var y2;\n    var height;\n    var width;\n    var x1 = 0;\n    var y1;\n    var padding = model.padding;\n    var point;\n    var axis = model.axisSettings;\n    var value = axis.value;\n    var theme = model.theme.toLowerCase();\n\n    if (model.type !== 'Pie') {\n      this.maxLength = maxPointsLength;\n      height = model.availableSize.height - (padding.bottom + padding.top);\n      width = model.availableSize.width - (padding.left + padding.right);\n      maxX = isNullOrUndefined(axis.maxX) ? maxX : axis.maxX;\n      minX = isNullOrUndefined(axis.minX) ? minX : axis.minX;\n      max = isNullOrUndefined(axis.maxY) ? max : axis.maxY;\n      min = isNullOrUndefined(axis.minY) ? min : axis.minY;\n      var color = axis.lineSettings.color || this.sparkline.sparkTheme.axisLineColor;\n      var eventArgs = {\n        name: 'axisRendering',\n        cancel: false,\n        sparkline: model,\n        maxX: maxX,\n        minX: minX,\n        maxY: max,\n        minY: min,\n        value: axis.value,\n        lineColor: color,\n        lineWidth: axis.lineSettings.width\n      };\n      model.trigger('axisRendering', eventArgs);\n\n      if (eventArgs.cancel) {\n        this.visiblePoints = [];\n        return;\n      }\n\n      maxX = eventArgs.maxX;\n      minX = eventArgs.minX;\n      max = eventArgs.maxY;\n      min = eventArgs.minY;\n      value = this.axisValue = eventArgs.value;\n      this.axisColor = eventArgs.lineColor;\n      this.axisWidth = eventArgs.lineWidth;\n      var unitX = maxX - minX;\n      var unitY = max - min;\n      unitX = unitX === 0 ? 1 : unitX;\n      unitY = unitY === 0 ? 1 : unitY;\n      this.unitX = unitX;\n      this.unitY = unitY;\n      this.min = min;\n      x1 = 0;\n      y1 = height - height / unitY * -min;\n      y1 = min < 0 && max <= 0 ? 0 : min < 0 && max > 0 ? y1 : height;\n\n      if (value >= min && value <= max) {\n        y1 = height - Math.round(height * ((value - min) / this.unitY));\n      }\n\n      this.axisHeight = y1 + padding.top;\n    }\n\n    var percent;\n    var x;\n    var y;\n    var visiblePoints = [];\n    var interval = this.getInterval(data, model.xName, model.valueType);\n\n    for (var i = 0; i < maxPointsLength; i++) {\n      if (isNullOrUndefined(data[i][model.xName]) && isNullOrUndefined(data[i][model.yName]) && data[i][model.yName] !== 0 && isNumericArray) {\n        x = i;\n        y = data[i];\n      } else if (isNullOrUndefined(data[i][model.xName])) {\n        x = i;\n        y = data[i][model.yName];\n      } else {\n        x = data[i][model.xName];\n        y = data[i][model.yName];\n      }\n\n      if (isNullOrUndefined(x) || isNullOrUndefined(y)) {\n        continue;\n      }\n\n      if (model.type === 'Line' || model.type === 'Area') {\n        y2 = min !== max && maxPointsLength !== 1 ? height - Math.round(height * ((y - min) / this.unitY)) : padding.top;\n        point = {\n          x: minX !== maxX ? Math.round(width * ((x - minX) / this.unitX)) : width / 2,\n          y: y2,\n          markerPosition: y2\n        };\n      } else if (model.type === 'Column' || model.type === 'WinLoss') {\n        var colWidth = width / ((maxX - minX) / interval + 1);\n        var calSpace = 0.5;\n        var space = calSpace * 2; //calspace is default space for column and winloss\n\n        colWidth -= space;\n        x1 = (x - minX) / interval * (colWidth + space) + space / 2;\n\n        if (model.type === 'WinLoss') {\n          // win or gain column height half of the height , draw(zero) height factor\n          var winLossFactor = 0.5;\n          var drawHeightFactor = 40;\n          y2 = y > value ? height / 4 : y < value ? height * winLossFactor : height * winLossFactor - height / drawHeightFactor;\n          point = {\n            x: x1,\n            y: y2,\n            height: y !== value ? height / 4 : height / 20,\n            width: colWidth,\n            markerPosition: y2 > y1 ? y1 + Math.abs(y2 - y1) : y2\n          };\n        } else {\n          var z = height / this.unitY * (y - min);\n          var z1 = y === min && y > value ? maxPointsLength !== 1 && this.unitY !== 1 ? height / this.unitY * (min / 2) : z | 1 : y === max && y < value && maxPointsLength !== 1 && this.unitY !== 1 ? height / this.unitY * (-max / 2) : z;\n          y2 = Math.abs(height - z1);\n          point = {\n            x: x1,\n            y: y2 > y1 ? y1 : y2,\n            height: Math.abs(y2 - y1),\n            width: colWidth,\n            markerPosition: y2 > y1 ? y1 + Math.abs(y2 - y1) : y2\n          };\n        }\n      } else if (model.type === 'Pie') {\n        percent = Math.abs(y) / sumofValues * 100;\n        point = {\n          percent: percent,\n          degree: Math.abs(y) / sumofValues * 360\n        };\n      }\n\n      if (model.type !== 'Pie') {\n        point.x += padding.left;\n        point.y += padding.top;\n      }\n\n      if (model.type !== 'WinLoss') {\n        point.markerPosition += padding.top;\n      }\n\n      point.location = {\n        x: point.x,\n        y: point.y\n      };\n      point.xVal = x;\n      point.yVal = y;\n      visiblePoints.push(point);\n    }\n\n    visiblePoints.sort(function (a, b) {\n      return a.x - b.x;\n    });\n    this.visiblePoints = visiblePoints;\n  };\n  /**\n   * To render the sparkline axis\n   */\n\n\n  SparklineRenderer.prototype.drawAxis = function () {\n    var spark = this.sparkline;\n    var height = this.axisHeight;\n\n    if (spark.type !== 'WinLoss' && spark.type !== 'Pie' && spark.axisSettings.lineSettings.visible) {\n      var xAxis = {\n        'id': spark.element.id + '_Sparkline_XAxis',\n        'x1': spark.padding.left,\n        'y1': height,\n        'x2': spark.availableSize.width - spark.padding.right,\n        'y2': height,\n        'stroke': this.axisColor,\n        'opacity': spark.axisSettings.lineSettings.opacity,\n        'stroke-dasharray': spark.axisSettings.lineSettings.dashArray,\n        'stroke-width': this.axisWidth,\n        'clip-path': 'url(#' + this.clipId + ')'\n      };\n      spark.svgObject.appendChild(spark.renderer.drawLine(xAxis));\n    }\n  };\n  /**\n   * To trigger point render event\n   */\n\n\n  SparklineRenderer.prototype.triggerPointRender = function (name, i, fill, border) {\n    var args = {\n      name: name,\n      cancel: false,\n      border: border,\n      fill: fill,\n      sparkline: this.sparkline.isBlazor ? null : this.sparkline,\n      pointIndex: i\n    };\n    this.sparkline.trigger(name, args);\n    return args;\n  };\n\n  return SparklineRenderer;\n}();\n\nexport { SparklineRenderer };","map":null,"metadata":{},"sourceType":"module"}