{"ast":null,"code":"import { Animation, Browser, createElement } from '@syncfusion/ej2-base';\nimport { textElement, getValueXByPoint, stopTimer, getValueYByPoint, ChartLocation, withInBounds, removeElement } from '../../common/utils/helper';\nimport { PathOption, Rect, TextOption, findDirection, measureText, SvgRenderer } from '@syncfusion/ej2-svg-base';\n/**\n * `Crosshair` module is used to render the crosshair for chart.\n */\n\nvar Crosshair =\n/** @class */\nfunction () {\n  /**\n   * Constructor for crosshair module.\n   * @private\n   */\n  function Crosshair(chart) {\n    this.arrowLocation = new ChartLocation(0, 0);\n    this.rx = 2;\n    this.ry = 2;\n    this.chart = chart;\n    this.elementID = this.chart.element.id;\n    this.svgRenderer = new SvgRenderer(this.chart.element.id);\n    this.addEventListener();\n  }\n  /**\n   * @hidden\n   */\n\n\n  Crosshair.prototype.addEventListener = function () {\n    if (this.chart.isDestroyed) {\n      return;\n    }\n\n    var cancelEvent = Browser.isPointer ? 'pointerleave' : 'mouseleave';\n    this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);\n    this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);\n    this.chart.on(cancelEvent, this.mouseLeaveHandler, this);\n    this.chart.on('tapHold', this.longPress, this);\n  };\n\n  Crosshair.prototype.mouseUpHandler = function () {\n    if (this.chart.startMove) {\n      this.removeCrosshair(2000);\n    }\n  };\n\n  Crosshair.prototype.mouseLeaveHandler = function () {\n    this.removeCrosshair(1000);\n  };\n\n  Crosshair.prototype.mouseMoveHandler = function (event) {\n    var chart = this.chart;\n\n    if (event.type === 'touchmove' && (Browser.isIos || Browser.isIos7) && chart.startMove && event.preventDefault) {\n      event.preventDefault();\n    } // Tooltip for chart series.\n\n\n    if (!chart.disableTrackTooltip) {\n      if (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n        if (chart.startMove || !chart.isTouch) {\n          this.crosshair();\n        }\n      } else {\n        this.removeCrosshair(1000);\n      }\n    }\n  };\n  /**\n   * Handles the long press on chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Crosshair.prototype.longPress = function () {\n    var chart = this.chart;\n\n    if (withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n      this.crosshair();\n    }\n\n    return false;\n  };\n  /**\n   * Renders the crosshair.\n   * @return {void}\n   */\n\n\n  Crosshair.prototype.crosshair = function () {\n    var chart = this.chart;\n    var horizontalCross = '';\n    var verticalCross = '';\n    var options;\n    var axisTooltipGroup = document.getElementById(this.elementID + '_crosshair_axis');\n    var crosshair = chart.crosshair;\n    var tooltipdiv = document.getElementById(this.elementID + '_tooltip');\n    var chartRect = chart.chartAxisLayoutPanel.seriesClipRect;\n    var crossGroup = chart.enableCanvas ? document.getElementById(this.elementID + '_Secondary_Element') : document.getElementById(this.elementID + '_UserInteraction');\n    var crosshairsvg;\n    var cross = document.getElementById(this.elementID + '_Crosshair');\n\n    if (chart.enableCanvas) {\n      if (!cross) {\n        cross = createElement('div', {\n          id: this.elementID + '_Crosshair',\n          styles: 'position: absolute; pointer-events: none'\n        });\n        crossGroup.appendChild(cross);\n      }\n    }\n\n    this.stopAnimation();\n\n    if (chart.tooltip.enable && !withInBounds(chart.tooltipModule.valueX, chart.tooltipModule.valueY, chartRect)) {\n      return null;\n    }\n\n    if (chart.stockChart && chart.stockChart.onPanning) {\n      this.removeCrosshair(1000);\n      return null;\n    }\n\n    this.valueX = chart.tooltip.enable ? chart.tooltipModule.valueX : chart.mouseX;\n    this.valueY = chart.tooltip.enable ? chart.tooltipModule.valueY : chart.mouseY;\n\n    if (!chart.enableCanvas) {\n      crossGroup.setAttribute('opacity', '1');\n    }\n\n    if (crosshair.lineType === 'Both' || crosshair.lineType === 'Horizontal') {\n      horizontalCross += 'M ' + chartRect.x + ' ' + this.valueY + ' L ' + (chartRect.x + chartRect.width) + ' ' + this.valueY;\n    }\n\n    if (crosshair.lineType === 'Both' || crosshair.lineType === 'Vertical') {\n      verticalCross += 'M ' + this.valueX + ' ' + chartRect.y + ' L ' + this.valueX + ' ' + (chartRect.y + chartRect.height);\n    }\n\n    if (chart.enableCanvas) {\n      if (!axisTooltipGroup) {\n        axisTooltipGroup = this.svgRenderer.createGroup({\n          'id': this.elementID + '_crosshair_axis'\n        });\n      }\n\n      var elementID = chart.tooltip.enable ? chart.element.id + '_tooltip_svg' : chart.element.id + '_svg';\n      crosshairsvg = this.svgRenderer.createSvg({\n        id: elementID,\n        width: chart.availableSize.width,\n        height: chart.availableSize.height\n      });\n\n      if (chart.tooltip.enable) {\n        tooltipdiv = !tooltipdiv ? chart.tooltipModule.createElement() : tooltipdiv;\n        tooltipdiv.appendChild(crosshairsvg);\n        crossGroup.appendChild(tooltipdiv);\n      }\n\n      options = new PathOption(this.elementID + '_HorizontalLine', 'none', crosshair.line.width, crosshair.line.color || chart.themeStyle.crosshairLine, 1, crosshair.dashArray, horizontalCross);\n      this.drawCrosshairLine(options, cross, chartRect.x, this.valueY, chartRect.width, 0, horizontalCross);\n      options.d = verticalCross;\n      options.id = this.elementID + '_VerticalLine';\n      this.drawCrosshairLine(options, cross, this.valueX, chartRect.y, 0, chartRect.height, verticalCross);\n      this.renderAxisTooltip(chart, chartRect, axisTooltipGroup);\n      crosshairsvg.appendChild(axisTooltipGroup);\n\n      if (!chart.tooltip.enable) {\n        cross.appendChild(crosshairsvg);\n      }\n    } else {\n      if (crossGroup.childNodes.length === 0) {\n        axisTooltipGroup = chart.renderer.createGroup({\n          'id': this.elementID + '_crosshair_axis'\n        });\n        options = new PathOption(this.elementID + '_HorizontalLine', 'none', crosshair.line.width, crosshair.line.color || chart.themeStyle.crosshairLine, 1, crosshair.dashArray, horizontalCross);\n        this.renderCrosshairLine(options, crossGroup);\n        options.d = verticalCross;\n        options.id = this.elementID + '_VerticalLine';\n        this.renderCrosshairLine(options, crossGroup);\n        crossGroup.appendChild(axisTooltipGroup);\n        this.renderAxisTooltip(chart, chartRect, crossGroup.lastChild);\n      } else {\n        document.getElementById(this.elementID + '_HorizontalLine').setAttribute('d', horizontalCross);\n        document.getElementById(this.elementID + '_VerticalLine').setAttribute('d', verticalCross);\n        this.renderAxisTooltip(chart, chartRect, crossGroup.lastChild);\n      }\n    }\n  };\n\n  Crosshair.prototype.renderCrosshairLine = function (options, crossGroup) {\n    var htmlObject = this.chart.renderer.drawPath(options);\n    crossGroup.appendChild(htmlObject);\n  };\n\n  Crosshair.prototype.drawCrosshairLine = function (options, crossGroup, left, top, width, height, direction) {\n    if (!document.getElementById(options.id) && direction) {\n      var line = createElement('div', {\n        id: options.id\n      });\n      crossGroup.appendChild(line);\n    }\n\n    if (document.getElementById(options.id)) {\n      var style = 'top:' + top.toString() + 'px;' + 'left:' + left.toString() + 'px;' + 'width:' + width + 'px;' + 'height:' + height + 'px;' + 'fill:' + options.stroke + ';' + 'border: 0.5px solid black;' + 'position: absolute';\n      var crosshairline = document.getElementById(options.id);\n      var crosshairtooltip = document.getElementById(this.elementID + '_crosshair_axis');\n      crosshairline.setAttribute('style', style);\n      crossGroup.style.opacity = '1';\n\n      if (crosshairtooltip) {\n        crosshairtooltip.style.opacity = '1';\n      }\n    }\n  };\n\n  Crosshair.prototype.renderAxisTooltip = function (chart, chartRect, axisGroup) {\n    var axis;\n    var text;\n    var rect;\n    var pathElement;\n    var textElem;\n    var options;\n    var padding = 5;\n    var direction;\n    var axisRect;\n\n    for (var k = 0, length_1 = chart.axisCollections.length; k < length_1; k++) {\n      axis = chart.axisCollections[k];\n      axisRect = !axis.placeNextToAxisLine ? axis.rect : axis.updatedRect;\n\n      if (axis.crosshairTooltip.enable) {\n        if (this.valueX <= axisRect.x + axisRect.width && axisRect.x <= this.valueX || this.valueY <= axisRect.y + axisRect.height && axisRect.y <= this.valueY) {\n          pathElement = document.getElementById(this.elementID + '_axis_tooltip_' + k);\n          textElem = document.getElementById(this.elementID + '_axis_tooltip_text_' + k);\n          text = this.getAxisText(axis);\n\n          if (!text) {\n            continue;\n          }\n\n          rect = this.tooltipLocation(text, axis, chartRect, axisRect);\n\n          if (pathElement === null) {\n            if (chart.enableCanvas) {\n              pathElement = this.svgRenderer.drawPath({\n                'id': this.elementID + '_axis_tooltip_' + k,\n                'fill': axis.crosshairTooltip.fill || chart.themeStyle.crosshairFill\n              }, null);\n            } else {\n              pathElement = chart.renderer.drawPath({\n                'id': this.elementID + '_axis_tooltip_' + k,\n                'fill': axis.crosshairTooltip.fill || chart.themeStyle.crosshairFill\n              }, null);\n            }\n\n            axisGroup.appendChild(pathElement);\n            options = new TextOption(this.elementID + '_axis_tooltip_text_' + k, 0, 0, 'start', text);\n            var render = chart.enableCanvas ? this.svgRenderer : chart.renderer;\n            textElem = textElement(render, options, axis.crosshairTooltip.textStyle, axis.crosshairTooltip.textStyle.color || chart.themeStyle.crosshairLabel, axisGroup);\n          }\n\n          direction = findDirection(this.rx, this.ry, rect, this.arrowLocation, 10, this.isTop, this.isBottom, this.isLeft, this.valueX, this.valueY);\n          pathElement.setAttribute('d', direction);\n          textElem.textContent = text;\n          textElem.setAttribute('x', (rect.x + padding).toString());\n          textElem.setAttribute('y', (rect.y + padding + 3 * this.elementSize.height / 4).toString());\n        } else {\n          removeElement(this.elementID + '_axis_tooltip_' + k);\n          removeElement(this.elementID + '_axis_tooltip_text_' + k);\n        }\n      }\n    }\n  };\n\n  Crosshair.prototype.getAxisText = function (axis) {\n    var value;\n    this.isBottom = false;\n    this.isTop = false;\n    this.isLeft = false;\n    this.isRight = false;\n    var labelValue = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n\n    if (axis.orientation === 'Horizontal') {\n      value = getValueXByPoint(Math.abs(this.valueX - axis.rect.x), axis.rect.width, axis) + labelValue;\n      this.isBottom = !axis.opposedPosition;\n      this.isTop = axis.opposedPosition;\n    } else {\n      value = getValueYByPoint(Math.abs(this.valueY - axis.rect.y), axis.rect.height, axis) + labelValue;\n      this.isRight = axis.opposedPosition;\n      this.isLeft = !axis.opposedPosition;\n    }\n\n    if (axis.valueType === 'DateTime') {\n      return axis.format(new Date(value));\n    } else if (axis.valueType === 'Category') {\n      return axis.labels[Math.floor(value)];\n    } else if (axis.valueType === 'DateTimeCategory') {\n      return this.chart.dateTimeCategoryModule.getIndexedAxisLabel(axis.labels[Math.floor(value)], axis.format);\n    } else if (axis.valueType === 'Logarithmic') {\n      return value = axis.format(Math.pow(axis.logBase, value));\n    } else {\n      var customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;\n      return customLabelFormat ? axis.labelFormat.replace('{value}', axis.format(value)) : axis.format(value);\n    }\n  };\n\n  Crosshair.prototype.tooltipLocation = function (text, axis, bounds, axisRect) {\n    var isBottom = false;\n    var isLeft = false;\n    var padding = 5;\n    var arrowPadding = 10;\n    var tooltipRect;\n    var boundsX = bounds.x;\n    var boundsY = bounds.y;\n    var islabelInside = axis.labelPosition === 'Inside';\n    var scrollBarHeight = axis.scrollbarSettings.enable || axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject ? axis.scrollBarHeight : 0;\n    this.elementSize = measureText(text, axis.crosshairTooltip.textStyle);\n\n    if (axis.orientation === 'Horizontal') {\n      var yLocation = islabelInside ? axisRect.y - this.elementSize.height - (padding * 2 + arrowPadding) : axisRect.y + scrollBarHeight;\n      var height = islabelInside ? axisRect.y - this.elementSize.height - arrowPadding : axisRect.y + arrowPadding;\n      this.arrowLocation = new ChartLocation(this.valueX, yLocation);\n      tooltipRect = new Rect(this.valueX - this.elementSize.width / 2 - padding, height + (!islabelInside ? scrollBarHeight : 0), this.elementSize.width + padding * 2, this.elementSize.height + padding * 2);\n\n      if (axis.opposedPosition) {\n        tooltipRect.y = islabelInside ? axisRect.y : axisRect.y - (this.elementSize.height + padding * 2 + arrowPadding) - scrollBarHeight;\n      }\n\n      if (tooltipRect.x < boundsX) {\n        tooltipRect.x = boundsX;\n      }\n\n      if (tooltipRect.x + tooltipRect.width > boundsX + bounds.width) {\n        tooltipRect.x -= tooltipRect.x + tooltipRect.width - (boundsX + bounds.width);\n      }\n\n      if (this.arrowLocation.x + arrowPadding / 2 > tooltipRect.x + tooltipRect.width - this.rx) {\n        this.arrowLocation.x = tooltipRect.x + tooltipRect.width - this.rx - arrowPadding / 2;\n      }\n\n      if (this.arrowLocation.x - arrowPadding / 2 < tooltipRect.x + this.rx) {\n        this.arrowLocation.x = tooltipRect.x + this.rx + arrowPadding / 2;\n      }\n    } else {\n      scrollBarHeight = scrollBarHeight * (axis.opposedPosition ? 1 : -1);\n      this.arrowLocation = new ChartLocation(axisRect.x, this.valueY);\n      var width = islabelInside ? axisRect.x - scrollBarHeight : axisRect.x - this.elementSize.width - (padding * 2 + arrowPadding);\n      tooltipRect = new Rect(width + scrollBarHeight, this.valueY - this.elementSize.height / 2 - padding, this.elementSize.width + padding * 2, this.elementSize.height + padding * 2);\n\n      if (axis.opposedPosition) {\n        tooltipRect.x = islabelInside ? axisRect.x - this.elementSize.width - arrowPadding : axisRect.x + arrowPadding + scrollBarHeight;\n\n        if (tooltipRect.x + tooltipRect.width > this.chart.availableSize.width) {\n          this.arrowLocation.x -= tooltipRect.x + tooltipRect.width - this.chart.availableSize.width;\n          tooltipRect.x -= tooltipRect.x + tooltipRect.width - this.chart.availableSize.width;\n        }\n      } else {\n        if (tooltipRect.x < 0) {\n          this.arrowLocation.x -= tooltipRect.x;\n          tooltipRect.x = 0;\n        }\n      }\n\n      if (tooltipRect.y < boundsY) {\n        tooltipRect.y = boundsY;\n      }\n\n      if (tooltipRect.y + tooltipRect.height >= boundsY + bounds.height) {\n        tooltipRect.y -= tooltipRect.y + tooltipRect.height - (boundsY + bounds.height);\n      }\n\n      if (this.arrowLocation.y + arrowPadding / 2 > tooltipRect.y + tooltipRect.height - this.ry) {\n        this.arrowLocation.y = tooltipRect.y + tooltipRect.height - this.ry - arrowPadding / 2;\n      }\n\n      if (this.arrowLocation.y - arrowPadding / 2 < tooltipRect.y + this.ry) {\n        this.arrowLocation.y = tooltipRect.y + this.ry + arrowPadding / 2;\n      }\n    }\n\n    return tooltipRect;\n  };\n\n  Crosshair.prototype.stopAnimation = function () {\n    stopTimer(this.crosshairInterval);\n  };\n\n  Crosshair.prototype.progressAnimation = function () {\n    stopTimer(this.crosshairInterval);\n  };\n  /**\n   * Removes the crosshair on mouse leave.\n   * @return {void}\n   * @private\n   */\n\n\n  Crosshair.prototype.removeCrosshair = function (duration) {\n    var chart = this.chart;\n    var crosshair = chart.enableCanvas ? document.getElementById(this.elementID + '_Crosshair') : document.getElementById(this.elementID + '_UserInteraction');\n    var crosshairtooltip = chart.enableCanvas ? document.getElementById(this.elementID + '_crosshair_axis') : null;\n    this.stopAnimation();\n\n    if (crosshair && crosshair.getAttribute('opacity') !== '0') {\n      this.crosshairInterval = setTimeout(function () {\n        new Animation({}).animate(crosshair, {\n          duration: 200,\n          progress: function (args) {\n            // crosshair.removeAttribute('e-animate');\n            crosshair.style.animation = '';\n\n            if (!chart.enableCanvas) {\n              crosshair.setAttribute('opacity', (1 - args.timeStamp / args.duration).toString());\n            } else {\n              crosshair.style.opacity = (1 - args.timeStamp / args.duration).toString();\n              crosshairtooltip.style.opacity = (1 - args.timeStamp / args.duration).toString();\n            }\n          },\n          end: function (model) {\n            if (chart.enableCanvas) {\n              crosshair.style.opacity = '0';\n              crosshairtooltip.style.opacity = '0';\n            } else {\n              crosshair.setAttribute('opacity', '0');\n            }\n\n            chart.startMove = false;\n\n            if (chart.tooltipModule) {\n              chart.tooltipModule.valueX = null;\n              chart.tooltipModule.valueY = null;\n            }\n          }\n        });\n      }, duration);\n    }\n  };\n  /**\n   * Get module name.\n   */\n\n\n  Crosshair.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'Crosshair';\n  };\n  /**\n   * To destroy the crosshair.\n   * @return {void}\n   * @private\n   */\n\n\n  Crosshair.prototype.destroy = function (chart) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return Crosshair;\n}();\n\nexport { Crosshair };","map":null,"metadata":{},"sourceType":"module"}