{"ast":null,"code":"import { measureText, TextOption, renderTextElement, CircleOption, PathOption, RectOption } from '../../smithchart/utils/helper';\nimport { SmithchartRect, LegendSeries } from '../../smithchart/utils/utils';\n/* tslint:disable:no-string-literal */\n\nvar SmithchartLegend =\n/** @class */\nfunction () {\n  function SmithchartLegend() {\n    this.legendSeries = [];\n  }\n\n  SmithchartLegend.prototype.renderLegend = function (smithchart) {\n    this.calculateLegendBounds(smithchart);\n\n    this._drawLegend(smithchart);\n\n    return this.legendActualBounds;\n  };\n\n  SmithchartLegend.prototype.calculateLegendBounds = function (smithchart) {\n    var legendSeries = new LegendSeries();\n    this.legendSeries = [];\n    var padding = 10;\n    var legend = smithchart.legendSettings;\n    var legendSizeHeight = legend.height;\n    var legendSizeWidth = legend.width;\n    var itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0;\n    var position = legend.position.toLowerCase();\n    var font = legend.title.textStyle;\n    var width = 0;\n    var height = 0;\n    var legendItemWidth = 0;\n    var legendItemHeight = 0;\n    var legendHeight = 0;\n    var svgObjectWidth = smithchart.availableSize.width - (smithchart.elementSpacing * 4 - legend.border.width * 2 + smithchart.border.width * 2);\n    var svgObjectHeight = smithchart.availableSize.height - (smithchart.elementSpacing * 4 - legend.border.width * 2 + smithchart.border.width * 2);\n    var rowCount = legend.rowCount;\n    var columnCount = legend.columnCount;\n    var titleSize = measureText(smithchart.legendSettings['title']['text'], font);\n    var maxRowWidth = 0;\n    var totalRowHeight = 0;\n    var curRowWidth = 0;\n    var curRowHeight = 0;\n    var allowItems;\n    var itemsCountRow = 0;\n    var length = smithchart.series.length;\n    var legendBounds;\n\n    if (smithchart.legendSettings.visible && length !== 0) {\n      if (position === 'bottom' || position === 'top' || position === 'custom') {\n        if (rowCount && columnCount && rowCount <= columnCount) {\n          rowCount = length / columnCount;\n        } else if (rowCount == null && columnCount != null) {\n          rowCount = length / columnCount;\n        } else if (rowCount == null && columnCount == null) {\n          rowCount = 1;\n        }\n\n        if (rowCount) {\n          allowItems = Math.ceil(length / rowCount);\n        }\n      } else {\n        if (rowCount && columnCount && rowCount <= columnCount) {\n          columnCount = length / rowCount;\n        } else if (rowCount != null && columnCount == null) {\n          columnCount = length / rowCount;\n        } else if (rowCount == null && columnCount == null) {\n          columnCount = 1;\n        }\n\n        if (columnCount) {\n          allowItems = columnCount;\n        }\n      }\n\n      for (var i = 0; i < length; i++) {\n        this.legendSeries.push({\n          text: smithchart.series[i]['name'] ? smithchart.series[i]['name'] : 'series' + i,\n          seriesIndex: i,\n          shape: smithchart.legendSettings.shape,\n          fill: smithchart.series[i].fill || smithchart.seriesColors[i % smithchart.seriesColors.length],\n          bounds: null\n        });\n\n        var legendsize = this._getLegendSize(smithchart, this.legendSeries[i]);\n\n        legendItemWidth = Math.max(legendsize['width'], legendItemWidth);\n        legendItemHeight = Math.max(legendsize['height'], legendItemHeight);\n        this.legendSeries[i]['bounds'] = {\n          width: legendItemWidth,\n          height: legendItemHeight\n        };\n        itemsCountRow = itemsCountRow + 1;\n        curRowWidth = curRowWidth + legendItemWidth + itemPadding;\n        curRowHeight = Math.max(legendItemHeight, curRowHeight);\n\n        if (position === 'top' || position === 'bottom' || position === 'custom') {\n          if (curRowWidth > svgObjectWidth) {\n            curRowWidth -= legendsize.width + itemPadding;\n            maxRowWidth = Math.max(maxRowWidth, curRowWidth);\n            curRowWidth = legendsize.width + itemPadding;\n            totalRowHeight = totalRowHeight + curRowHeight + itemPadding;\n          }\n        }\n\n        if (itemsCountRow === allowItems || i === length - 1) {\n          maxRowWidth = Math.max(maxRowWidth, curRowWidth);\n          totalRowHeight = totalRowHeight + curRowHeight + itemPadding;\n          legendHeight = totalRowHeight;\n          itemsCountRow = 0;\n          curRowHeight = 0;\n          curRowWidth = 0;\n        }\n      }\n\n      width = titleSize.width > maxRowWidth - itemPadding ? titleSize.width + padding * 2 + itemPadding : maxRowWidth + padding * 2 - smithchart.border.width * 2;\n      height = legendHeight + smithchart.elementSpacing;\n      legendBounds = {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      };\n    }\n\n    this.legendActualBounds = legendBounds;\n\n    if (legendSizeWidth != null) {\n      this.legendActualBounds.width = legendSizeWidth;\n    }\n\n    if (legendSizeHeight != null) {\n      this.legendActualBounds.height = legendSizeHeight;\n    }\n  };\n\n  SmithchartLegend.prototype._getLegendSize = function (smithchart, series) {\n    var legend = smithchart.legendSettings;\n    var symbolWidth = legend.itemStyle.width;\n    var symbolHeight = legend.itemStyle.height;\n    var textSize = measureText(series.text, legend.textStyle);\n    var width = symbolWidth + textSize.width + legend.shapePadding;\n    var height = Math.max(symbolHeight, textSize.height);\n    return {\n      width: width,\n      height: height\n    };\n  }; // tslint:disable:max-func-body-length\n\n\n  SmithchartLegend.prototype._drawLegend = function (smithchart) {\n    var legend = smithchart.legendSettings;\n    var legendPosition = legend.position.toLowerCase();\n    var alignment = legend.alignment;\n    var legendBounds = this.legendActualBounds;\n    var maxWidth = 0;\n    var startX;\n    var startY;\n    var titleFont = smithchart.title.font ? smithchart.title.font : smithchart.title.textStyle;\n    var smithchartTitleHeight = measureText(smithchart.title.text, titleFont).height;\n    var smithchartSubtitleHeight = measureText(smithchart.title.subtitle.text, smithchart.title.subtitle.textStyle).height;\n    var elementSpacing = smithchart.elementSpacing;\n    var offset = smithchartTitleHeight + smithchartSubtitleHeight + elementSpacing + smithchart.margin.top;\n    var itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0;\n    var svgObjectWidth = smithchart.availableSize.width;\n    var svgObjectHeight = smithchart.availableSize.height;\n    var legendBorder = legend.border.width;\n    var legendWidth = 0;\n    var titleSize = measureText(legend['title']['text'], legend.title.textStyle);\n    var legendTitleHeight = titleSize.height;\n    var borderSize = smithchart.border.width;\n    var svgWidth = svgObjectWidth - borderSize * 2;\n    var svgHeight = svgObjectHeight - borderSize * 2;\n    legendBounds.height += legendTitleHeight;\n\n    if (legendPosition !== 'custom') {\n      switch (legendPosition) {\n        case 'bottom':\n          legendBounds.y = svgHeight - (legendBounds.height + legendBorder + elementSpacing);\n          break;\n\n        case 'top':\n          legendBounds.y = borderSize + offset;\n          break;\n\n        case 'right':\n          legendBounds.x = svgWidth - legendBounds.width - elementSpacing * 2;\n          break;\n\n        case 'left':\n          legendBounds.x = borderSize + elementSpacing * 2;\n          break;\n      }\n\n      if (legendPosition === 'left' || legendPosition === 'right') {\n        switch (alignment) {\n          case 'Center':\n            legendBounds.y = svgHeight / 2 - (legendBounds.height + legendBorder * 2) / 2 + elementSpacing / 2;\n            break;\n\n          case 'Near':\n            legendBounds.y = borderSize + elementSpacing * 2 + offset;\n            break;\n\n          case 'Far':\n            legendBounds.y = svgHeight - (legendBounds.height + legendBorder) - elementSpacing * 2;\n            break;\n        }\n      } else {\n        switch (alignment) {\n          case 'Center':\n            legendBounds.x = svgWidth / 2 - (legendBounds.width + legendBorder * 2) / 2 + elementSpacing / 2;\n            break;\n\n          case 'Near':\n            legendBounds.x = borderSize + elementSpacing * 2;\n            break;\n\n          case 'Far':\n            legendBounds.x = svgWidth - (legendBounds.width + legendBorder) - elementSpacing * 2;\n            break;\n        }\n      }\n    } else {\n      legendBounds.y = legend.location.y < svgHeight ? legend.location.y : 0;\n      legendBounds.x = legend.location.x < svgWidth ? legend.location.x : 0;\n    }\n\n    if (legendPosition === 'bottom' || legendPosition === 'top') {\n      for (var i = 0; i < this.legendSeries.length; i++) {\n        legendWidth += this.legendSeries[i].bounds.width + itemPadding;\n\n        if (legendWidth > svgWidth) {\n          legendBounds.x = svgWidth / 2 - (legendBounds.width + legendBorder * 2) / 2 + elementSpacing / 2;\n          break;\n        }\n      }\n    }\n\n    var gLegendEle = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_legend_group'\n    });\n    smithchart.svgObject.appendChild(gLegendEle);\n    this.legendItemGroup = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + 'legendItem_Group'\n    });\n    var currentX = startX = elementSpacing;\n    var currentY = startY = elementSpacing;\n\n    if (legend.title.text !== '' && legend.title.visible) {\n      gLegendEle.appendChild(this.drawLegendTitle(smithchart, legend, legendBounds, gLegendEle));\n      currentY = startY = elementSpacing + legendTitleHeight;\n    }\n\n    for (var k = 0; k < this.legendSeries.length; k++) {\n      if ((legend.rowCount < legend.columnCount || legend.rowCount === legend.columnCount) && (legendPosition === 'top' || legendPosition === 'bottom' || legendPosition === 'custom')) {\n        if (currentX + this.legendSeries[k]['bounds'].width > legendBounds.width + startX) {\n          currentX = elementSpacing;\n          currentY += this.legendSeries[k]['bounds'].height + itemPadding;\n        }\n\n        this.legendGroup = this.drawLegendItem(smithchart, legend, this.legendSeries[k], k, currentX, currentY, legendBounds);\n        gLegendEle.appendChild(this.legendGroup);\n        currentX += this.legendSeries[k]['bounds'].width + itemPadding;\n      } else {\n        if (currentY + this.legendSeries[k]['bounds'].height + itemPadding + legendTitleHeight + borderSize > legendBounds.height + startY) {\n          currentY = startY;\n          currentX += maxWidth + itemPadding;\n        }\n\n        this.legendGroup = this.drawLegendItem(smithchart, legend, this.legendSeries[k], k, currentX, currentY, legendBounds);\n        gLegendEle.appendChild(this.legendGroup);\n        currentY += this.legendSeries[k]['bounds'].height + itemPadding;\n        maxWidth = Math.max(maxWidth, this.legendSeries[k]['bounds'].width);\n      }\n    }\n\n    gLegendEle.setAttribute('transform', 'translate(' + legendBounds.x.toString() + ',' + legendBounds.y.toString() + ')');\n    this.drawLegendBorder(gLegendEle, smithchart, legend, legendBounds);\n  };\n\n  SmithchartLegend.prototype.drawLegendBorder = function (gLegendEle, smithchart, legend, legendBounds) {\n    var borderRect = new RectOption(smithchart.element.id + '_svg' + '_legendRect', 'none', legend.border, 1, new SmithchartRect(0, 0, legendBounds.width, legendBounds.height));\n    gLegendEle.appendChild(smithchart.renderer.drawRectangle(borderRect));\n  };\n\n  SmithchartLegend.prototype.drawLegendTitle = function (smithchart, legend, legendBounds, gLegendEle) {\n    var elementSpacing = smithchart.elementSpacing;\n    var titleSize = measureText(legend.title.text, legend.title.textStyle);\n    var titleWidth = titleSize.width;\n    var titleHeight = titleSize.height;\n    var textAlignment = legend.title.textAlignment;\n    var startX = 0;\n    var legendBoundsWidth = legendBounds.width;\n    var startY = elementSpacing + titleHeight / 2;\n\n    switch (textAlignment) {\n      case 'Far':\n        startX = legendBoundsWidth - titleWidth - startX;\n        break;\n\n      case 'Center':\n        startX = legendBoundsWidth / 2 - titleWidth / 2;\n        break;\n    }\n\n    if (startX < 0) {\n      startX = 0;\n      legendBoundsWidth = titleWidth;\n    }\n\n    if (legendBoundsWidth < titleWidth + startX) {\n      legendBoundsWidth = titleWidth + startX;\n    }\n\n    var options = new TextOption(smithchart.element.id + '_LegendTitleText', startX, startY, 'start', legend.title.text);\n    var element = renderTextElement(options, legend.title.textStyle, smithchart.themeStyle.legendLabel, gLegendEle);\n    element.setAttribute('aria-label', legend.title.description || legend.title.text);\n    return element;\n  };\n\n  SmithchartLegend.prototype.drawLegendItem = function (smithchart, legend, legendSeries, k, x, y, legendBounds) {\n    var location;\n    var radius;\n    var symbol = legend.itemStyle;\n    var itemPadding = legend.itemPadding;\n    var textHeight;\n    radius = Math.sqrt(symbol['width'] * symbol['width'] + symbol['height'] * symbol['height']) / 2;\n    textHeight = measureText(legendSeries['text'], legend.textStyle).height;\n    location = {\n      x: x + symbol['width'] / 2,\n      y: y + (textHeight > symbol['height'] ? textHeight : symbol['height']) / 2\n    };\n    var legendGroup = smithchart.renderer.createGroup({\n      id: smithchart.element.id + '_svg' + '_Legend' + k.toString()\n    });\n    legendGroup['style']['cursor'] = legend.toggleVisibility ? 'pointer' : 'default';\n    var legendEventArgs = {\n      text: legendSeries['text'],\n      fill: legendSeries['fill'],\n      shape: legendSeries['shape'],\n      name: 'legendRender',\n      cancel: false\n    };\n    smithchart.trigger('legendRender', legendEventArgs);\n    var shape = this.drawLegendShape(smithchart, legendSeries, location.x, location.y, k, legend, legendEventArgs);\n    legendGroup.appendChild(shape);\n    var options = new TextOption(smithchart.element.id + '_LegendItemText' + k.toString(), location.x + symbol['width'] / 2 + legend.shapePadding, location.y + textHeight / 4, 'start', legendEventArgs.text);\n    legend.textStyle.fontFamily = smithchart.themeStyle.fontFamily || legend.textStyle.fontFamily;\n    legend.textStyle.size = smithchart.themeStyle.fontSize || legend.textStyle.size;\n    var element = renderTextElement(options, legend.textStyle, smithchart.themeStyle.legendLabel, legendGroup);\n    element.setAttribute('aria-label', legend.description || 'Click to show or hide the ' + options.text + ' series');\n    legendGroup.appendChild(element);\n    this.legendItemGroup.appendChild(legendGroup);\n    return this.legendItemGroup;\n  };\n\n  SmithchartLegend.prototype.drawLegendShape = function (smithchart, legendSeries, locX, locY, index, legend, legendEventArgs) {\n    var element;\n    var circleOptions;\n    var pathOptions;\n    var path;\n    var symbol = legend.itemStyle;\n    var width = symbol['width'];\n    var height = symbol['height'];\n    var x = locX + -width / 2;\n    var y = locY + -height / 2;\n    var border = {\n      color: symbol.border.color,\n      width: symbol.border.width\n    };\n    var opacity = 1;\n    var fill = smithchart.series[index].visibility === 'visible' ? legendEventArgs.fill : 'grey';\n    var shape = legendEventArgs.shape.toLowerCase();\n    var radius = Math.sqrt(height * height + width * width) / 2;\n\n    switch (shape) {\n      case 'circle':\n        circleOptions = new CircleOption(smithchart.element.id + '_svg' + '_LegendItemShape' + index.toString(), fill, border, opacity, locX, locY, radius, null);\n        element = smithchart.renderer.drawCircle(circleOptions);\n        break;\n\n      case 'rectangle':\n        path = 'M' + ' ' + x + ' ' + (locY + -height / 2) + ' ' + 'L' + ' ' + (width / 2 + locX) + ' ' + (locY + -height / 2) + ' ' + 'L' + ' ' + (locX + width / 2) + ' ' + (locY + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (locY + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (locY + -height / 2) + ' z';\n        pathOptions = new PathOption(smithchart.element.id + '_svg' + '_LegendItemShape' + index.toString(), fill, border.width, border.color, 1, '', path);\n        element = smithchart.renderer.drawPath(pathOptions);\n        break;\n\n      case 'diamond':\n        path = 'M' + ' ' + x + ' ' + locY + ' ' + 'L' + ' ' + locX + ' ' + (locY + -height / 2) + ' ' + 'L' + ' ' + (width / 2 + locX) + ' ' + locY + ' ' + 'L' + ' ' + locX + ' ' + (locY + height / 2) + ' ' + 'L' + ' ' + x + ' ' + locY + ' z';\n        pathOptions = new PathOption(smithchart.element.id + '_svg' + '_LegendItemShape' + index.toString(), fill, border.width, border.color, 1, '', path);\n        element = smithchart.renderer.drawPath(pathOptions);\n        break;\n\n      case 'pentagon':\n        var eq = 72;\n\n        for (var j = 0; j <= 5; j++) {\n          var xValue = radius * Math.cos(Math.PI / 180 * (j * eq));\n          var yValue = radius * Math.sin(Math.PI / 180 * (j * eq));\n\n          if (j === 0) {\n            path = 'M' + ' ' + (xValue + locX) + ' ' + (locY + yValue) + ' ';\n          } else {\n            path = path.concat('L' + ' ' + (locX + xValue) + ' ' + (locY + yValue) + ' ');\n          }\n        }\n\n        path = path.concat('Z');\n        pathOptions = new PathOption(smithchart.element.id + '_svg' + '_LegendItemShape' + index.toString(), fill, border.width, border.color, 1, '', path);\n        element = smithchart.renderer.drawPath(pathOptions);\n        break;\n\n      case 'triangle':\n        path = 'M' + ' ' + x + ' ' + (height / 2 + locY) + ' ' + 'L' + ' ' + locX + ' ' + (locY + -height / 2) + ' ' + 'L' + ' ' + (locX + width / 2) + ' ' + (locY + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (locY + height / 2) + ' Z';\n        pathOptions = new PathOption(smithchart.element.id + '_svg' + '_LegendItemShape' + index.toString(), fill, border.width, border.color, 1, '', path);\n        element = smithchart.renderer.drawPath(pathOptions);\n        break;\n    }\n\n    return element;\n  };\n  /**\n   * Get module name.\n   */\n\n\n  SmithchartLegend.prototype.getModuleName = function () {\n    return 'SmithchartLegend';\n  };\n  /**\n   * To destroy the legend.\n   * @return {void}\n   * @private\n   */\n\n\n  SmithchartLegend.prototype.destroy = function (smithchart) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return SmithchartLegend;\n}();\n\nexport { SmithchartLegend };","map":null,"metadata":{},"sourceType":"module"}