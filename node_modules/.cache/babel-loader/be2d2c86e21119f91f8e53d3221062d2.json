{"ast":null,"code":"import { EventHandler, Browser, createElement } from '@syncfusion/ej2-base';\nimport { getRectLocation, minMax, getElement, ChartLocation, RectOption } from '../../common/utils/helper';\nimport { Rect, measureText } from '@syncfusion/ej2-svg-base';\nimport { Toolkit } from './zooming-toolkit';\nimport { zoomComplete } from '../../common/model/constants';\nimport { withInBounds } from '../../common/utils/helper';\n/**\n * `Zooming` module handles the zooming for chart.\n */\n\nvar Zoom =\n/** @class */\nfunction () {\n  /**\n   * Constructor for Zooming module.\n   * @private.\n   */\n  function Zoom(chart) {\n    this.chart = chart;\n    this.isPointer = Browser.isPointer;\n    this.browserName = Browser.info.name;\n    this.wheelEvent = this.browserName === 'mozilla' ? this.isPointer ? 'mousewheel' : 'DOMMouseScroll' : 'mousewheel';\n    this.cancelEvent = this.isPointer ? 'pointerleave' : 'mouseleave';\n    this.addEventListener();\n    this.isDevice = Browser.isDevice;\n    var zooming = chart.zoomSettings;\n    this.toolkit = new Toolkit(chart);\n    this.zooming = zooming;\n    this.elementId = chart.element.id;\n    this.zoomingRect = new Rect(0, 0, 0, 0);\n    this.zoomAxes = [];\n    this.zoomkitOpacity = 0.3;\n    this.isIOS = Browser.isIos || Browser.isIos7;\n    this.isZoomed = this.performedUI = this.zooming.enablePan && this.zooming.enableSelectionZooming;\n\n    if (zooming.enableScrollbar) {\n      chart.scrollElement = createElement('div', {\n        id: chart.element.id + '_scrollElement'\n      });\n    }\n  }\n  /**\n   * Function that handles the Rectangular zooming.\n   * @return {void}\n   */\n\n\n  Zoom.prototype.renderZooming = function (e, chart, isTouch) {\n    this.calculateZoomAxesRange(chart, chart.axisCollections);\n\n    if (this.zooming.enableSelectionZooming && (!isTouch || chart.isDoubleTap && this.touchStartList.length === 1) && (!this.isPanning || chart.isDoubleTap)) {\n      this.isPanning = this.isDevice ? true : this.isPanning;\n      this.performedUI = true;\n      this.drawZoomingRectangle(chart);\n    } else if (this.isPanning && chart.isChartDrag) {\n      if (!isTouch || isTouch && this.touchStartList.length === 1) {\n        this.pinchTarget = isTouch ? e.target : null;\n        this.doPan(chart, chart.axisCollections);\n      }\n    }\n  }; // Zooming rectangle drawn here\n\n\n  Zoom.prototype.drawZoomingRectangle = function (chart) {\n    var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n    var startLocation = new ChartLocation(chart.previousMouseMoveX, chart.previousMouseMoveY);\n    var endLocation = new ChartLocation(chart.mouseX, chart.mouseY);\n    var rect = this.zoomingRect = getRectLocation(startLocation, endLocation, areaBounds);\n\n    if (rect.width > 0 && rect.height > 0) {\n      this.isZoomed = true;\n      chart.disableTrackTooltip = true;\n      chart.svgObject.setAttribute('cursor', 'crosshair');\n\n      if (this.zooming.mode === 'X') {\n        rect.height = areaBounds.height;\n        rect.y = areaBounds.y;\n      } else if (this.zooming.mode === 'Y') {\n        rect.width = areaBounds.width;\n        rect.x = areaBounds.x;\n      }\n\n      var svg = chart.enableCanvas ? document.getElementById(this.elementId + '_tooltip_svg') : chart.svgObject;\n      svg.appendChild(chart.svgRenderer.drawRectangle(new RectOption(this.elementId + '_ZoomArea', chart.themeStyle.selectionRectFill, {\n        color: chart.themeStyle.selectionRectStroke,\n        width: 1\n      }, 1, rect, 0, 0, '', '3')));\n    }\n  }; // Panning performed here\n\n\n  Zoom.prototype.doPan = function (chart, axes) {\n    if (chart.startMove && chart.crosshair.enable) {\n      return null;\n    }\n\n    var currentScale;\n    var offset;\n    this.isZoomed = true;\n    var translateX;\n    var translateY;\n    this.offset = !chart.delayRedraw ? chart.chartAxisLayoutPanel.seriesClipRect : this.offset;\n    chart.delayRedraw = true;\n    chart.disableTrackTooltip = true;\n    var argsData;\n    axes.forEach(function (axis) {\n      argsData = {\n        cancel: false,\n        name: zoomComplete,\n        axis: axis,\n        previousZoomFactor: axis.zoomFactor,\n        previousZoomPosition: axis.zoomPosition,\n        currentZoomFactor: axis.zoomFactor,\n        currentZoomPosition: axis.zoomPosition\n      };\n      currentScale = Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1);\n\n      if (axis.orientation === 'Horizontal') {\n        offset = (chart.previousMouseMoveX - chart.mouseX) / axis.rect.width / currentScale;\n        argsData.currentZoomPosition = minMax(axis.zoomPosition + offset, 0, 1 - axis.zoomFactor);\n      } else {\n        offset = (chart.previousMouseMoveY - chart.mouseY) / axis.rect.height / currentScale;\n        argsData.currentZoomPosition = minMax(axis.zoomPosition - offset, 0, 1 - axis.zoomFactor);\n      }\n\n      chart.trigger(zoomComplete, argsData);\n\n      if (!argsData.cancel) {\n        axis.zoomFactor = argsData.currentZoomFactor;\n        axis.zoomPosition = argsData.currentZoomPosition;\n      }\n    });\n\n    if (this.zooming.enableDeferredZooming) {\n      translateX = chart.mouseX - chart.mouseDownX;\n      translateY = chart.mouseY - chart.mouseDownY;\n\n      switch (this.zooming.mode) {\n        case 'X':\n          translateY = 0;\n          break;\n\n        case 'Y':\n          translateX = 0;\n          break;\n      }\n\n      this.setTransform(translateX, translateY, null, null, chart, false);\n      this.refreshAxis(chart.chartAxisLayoutPanel, chart, chart.axisCollections);\n\n      if (chart.enableCanvas) {\n        this.performZoomRedraw(chart);\n      }\n    } else {\n      this.performZoomRedraw(chart);\n    }\n\n    chart.previousMouseMoveX = chart.mouseX;\n    chart.previousMouseMoveY = chart.mouseY;\n  };\n  /**\n   * Redraw the chart on zooming.\n   * @return {void}\n   * @private\n   */\n\n\n  Zoom.prototype.performZoomRedraw = function (chart) {\n    var rect = this.zoomingRect;\n    chart.animateSeries = false;\n\n    if (this.isZoomed) {\n      if (rect.width > 0 && rect.height > 0) {\n        this.performedUI = true;\n        chart.svgObject.setAttribute('cursor', 'auto');\n        this.doZoom(chart, chart.axisCollections, chart.chartAxisLayoutPanel.seriesClipRect);\n        chart.isDoubleTap = false;\n      } else if (chart.disableTrackTooltip) {\n        chart.disableTrackTooltip = false;\n        chart.delayRedraw = false;\n        chart.enableCanvas ? chart.createChartSvg() : chart.removeSvg();\n        chart.refreshAxis();\n        chart.refreshBound();\n      }\n    }\n  };\n\n  Zoom.prototype.refreshAxis = function (layout, chart, axes) {\n    var mode = chart.zoomSettings.mode;\n    layout.measureAxis(new Rect(chart.initialClipRect.x, chart.initialClipRect.y, chart.initialClipRect.width, chart.initialClipRect.height));\n    axes.map(function (axis, index) {\n      if (axis.orientation === 'Horizontal' && mode !== 'Y') {\n        layout.drawXAxisLabels(axis, index, null, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n      }\n\n      if (axis.orientation === 'Vertical' && mode !== 'X') {\n        layout.drawYAxisLabels(axis, index, null, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n      }\n    });\n  }; // Rectangular zoom calculated here performed here\n\n\n  Zoom.prototype.doZoom = function (chart, axes, bounds) {\n    var zoomRect = this.zoomingRect;\n    var mode = this.zooming.mode;\n    var argsData;\n    this.isPanning = chart.zoomSettings.enablePan || this.isPanning;\n    axes.forEach(function (axis) {\n      argsData = {\n        cancel: false,\n        name: zoomComplete,\n        axis: axis,\n        previousZoomFactor: axis.zoomFactor,\n        previousZoomPosition: axis.zoomPosition,\n        currentZoomFactor: axis.zoomFactor,\n        currentZoomPosition: axis.zoomPosition\n      };\n\n      if (axis.orientation === 'Horizontal') {\n        if (mode !== 'Y') {\n          argsData.currentZoomPosition += Math.abs((zoomRect.x - bounds.x) / bounds.width) * axis.zoomFactor;\n          argsData.currentZoomFactor *= zoomRect.width / bounds.width;\n          chart.trigger(zoomComplete, argsData);\n        }\n      } else {\n        if (mode !== 'X') {\n          argsData.currentZoomPosition += (1 - Math.abs((zoomRect.height + (zoomRect.y - bounds.y)) / bounds.height)) * axis.zoomFactor;\n          argsData.currentZoomFactor *= zoomRect.height / bounds.height;\n          chart.trigger(zoomComplete, argsData);\n        }\n      }\n\n      if (!argsData.cancel) {\n        axis.zoomFactor = argsData.currentZoomFactor;\n        axis.zoomPosition = argsData.currentZoomPosition;\n      }\n    });\n    this.zoomingRect = new Rect(0, 0, 0, 0);\n    this.performZoomRedraw(chart);\n  };\n  /**\n   * Function that handles the Mouse wheel zooming.\n   * @return {void}\n   * @private\n   */\n\n\n  Zoom.prototype.performMouseWheelZooming = function (e, mouseX, mouseY, chart, axes) {\n    var direction = this.browserName === 'mozilla' && !this.isPointer ? -e.detail / 3 > 0 ? 1 : -1 : e.wheelDelta / 120 > 0 ? 1 : -1;\n    var mode = this.zooming.mode;\n    var origin = 0.5;\n    var cumulative;\n    var zoomFactor;\n    var zoomPosition;\n    this.isZoomed = true;\n    this.calculateZoomAxesRange(chart, chart.axisCollections);\n    chart.disableTrackTooltip = true;\n    this.performedUI = true;\n    this.isPanning = chart.zoomSettings.enablePan || this.isPanning;\n    var argsData;\n    axes.forEach(function (axis) {\n      argsData = {\n        cancel: false,\n        name: zoomComplete,\n        axis: axis,\n        previousZoomFactor: axis.zoomFactor,\n        previousZoomPosition: axis.zoomPosition,\n        currentZoomFactor: axis.zoomFactor,\n        currentZoomPosition: axis.zoomPosition\n      };\n\n      if (axis.orientation === 'Vertical' && mode !== 'X' || axis.orientation === 'Horizontal' && mode !== 'Y') {\n        cumulative = Math.max(Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1) + 0.25 * direction, 1);\n\n        if (cumulative >= 1) {\n          origin = axis.orientation === 'Horizontal' ? mouseX / axis.rect.width : 1 - mouseY / axis.rect.height;\n          origin = origin > 1 ? 1 : origin < 0 ? 0 : origin;\n          zoomFactor = cumulative === 1 ? 1 : minMax(1 / cumulative, 0, 1);\n          zoomPosition = cumulative === 1 ? 0 : axis.zoomPosition + (axis.zoomFactor - zoomFactor) * origin;\n\n          if (axis.zoomPosition !== zoomPosition || axis.zoomFactor !== zoomFactor) {\n            zoomFactor = zoomPosition + zoomFactor > 1 ? 1 - zoomPosition : zoomFactor;\n          }\n\n          argsData.currentZoomFactor = zoomFactor;\n          argsData.currentZoomPosition = zoomPosition;\n          chart.trigger(zoomComplete, argsData);\n        }\n\n        if (!argsData.cancel) {\n          axis.zoomFactor = argsData.currentZoomFactor;\n          axis.zoomPosition = argsData.currentZoomPosition;\n        }\n      }\n    });\n    this.performZoomRedraw(chart);\n  };\n  /**\n   * Function that handles the Pinch zooming.\n   * @return {void}\n   * @private\n   */\n\n\n  Zoom.prototype.performPinchZooming = function (e, chart) {\n    if (this.zoomingRect.width > 0 && this.zoomingRect.height > 0 || chart.startMove && chart.crosshair.enable) {\n      return false;\n    }\n\n    this.calculateZoomAxesRange(chart, chart.axisCollections);\n    this.isZoomed = true;\n    this.isPanning = true;\n    this.performedUI = true;\n    this.offset = !chart.delayRedraw ? chart.chartAxisLayoutPanel.seriesClipRect : this.offset;\n    chart.delayRedraw = true;\n    chart.disableTrackTooltip = true;\n    var elementOffset = chart.element.getBoundingClientRect();\n    var touchDown = this.touchStartList;\n    var touchMove = this.touchMoveList;\n    var touch0StartX = touchDown[0].pageX - elementOffset.left;\n    var touch0StartY = touchDown[0].pageY - elementOffset.top;\n    var touch0EndX = touchMove[0].pageX - elementOffset.left;\n    var touch0EndY = touchMove[0].pageY - elementOffset.top;\n    var touch1StartX = touchDown[1].pageX - elementOffset.left;\n    var touch1StartY = touchDown[1].pageY - elementOffset.top;\n    var touch1EndX = touchMove[1].pageX - elementOffset.left;\n    var touch1EndY = touchMove[1].pageY - elementOffset.top;\n    var scaleX;\n    var scaleY;\n    var translateXValue;\n    var translateYValue;\n    var pinchRect;\n    var clipX;\n    var clipY;\n    scaleX = Math.abs(touch0EndX - touch1EndX) / Math.abs(touch0StartX - touch1StartX);\n    scaleY = Math.abs(touch0EndY - touch1EndY) / Math.abs(touch0StartY - touch1StartY);\n    clipX = (this.offset.x - touch0EndX) / scaleX + touch0StartX;\n    clipY = (this.offset.y - touch0EndY) / scaleY + touch0StartY;\n    pinchRect = new Rect(clipX, clipY, this.offset.width / scaleX, this.offset.height / scaleY);\n    translateXValue = touch0EndX - scaleX * touch0StartX;\n    translateYValue = touch0EndY - scaleY * touch0StartY;\n\n    if (!isNaN(scaleX - scaleX) && !isNaN(scaleY - scaleY)) {\n      switch (this.zooming.mode) {\n        case 'XY':\n          this.setTransform(translateXValue, translateYValue, scaleX, scaleY, chart, true);\n          break;\n\n        case 'X':\n          this.setTransform(translateXValue, 0, scaleX, 1, chart, true);\n          break;\n\n        case 'Y':\n          this.setTransform(0, translateYValue, 1, scaleY, chart, true);\n          break;\n      }\n    }\n\n    this.calculatePinchZoomFactor(chart, pinchRect);\n    this.refreshAxis(chart.chartAxisLayoutPanel, chart, chart.axisCollections);\n    return true;\n  };\n\n  Zoom.prototype.calculatePinchZoomFactor = function (chart, pinchRect) {\n    var _this = this;\n\n    var mode = this.zooming.mode;\n    var selectionMin;\n    var selectionMax;\n    var rangeMin;\n    var rangeMax;\n    var value;\n    var axisTrans;\n    var argsData;\n    var currentZF;\n    var currentZP;\n    chart.axisCollections.forEach(function (axis, index) {\n      if (axis.orientation === 'Horizontal' && mode !== 'Y' || axis.orientation === 'Vertical' && mode !== 'X') {\n        currentZF = axis.zoomFactor;\n        currentZP = axis.zoomPosition;\n        argsData = {\n          cancel: false,\n          name: zoomComplete,\n          axis: axis,\n          previousZoomFactor: axis.zoomFactor,\n          previousZoomPosition: axis.zoomPosition,\n          currentZoomFactor: currentZF,\n          currentZoomPosition: currentZP\n        };\n\n        if (axis.orientation === 'Horizontal') {\n          value = pinchRect.x - _this.offset.x;\n          axisTrans = axis.rect.width / _this.zoomAxes[index].delta;\n          rangeMin = value / axisTrans + _this.zoomAxes[index].min;\n          value = pinchRect.x + pinchRect.width - _this.offset.x;\n          rangeMax = value / axisTrans + _this.zoomAxes[index].min;\n        } else {\n          value = pinchRect.y - _this.offset.y;\n          axisTrans = axis.rect.height / _this.zoomAxes[index].delta;\n          rangeMin = (value * -1 + axis.rect.height) / axisTrans + _this.zoomAxes[index].min;\n          value = pinchRect.y + pinchRect.height - _this.offset.y;\n          rangeMax = (value * -1 + axis.rect.height) / axisTrans + _this.zoomAxes[index].min;\n        }\n\n        selectionMin = Math.min(rangeMin, rangeMax);\n        selectionMax = Math.max(rangeMin, rangeMax);\n        currentZP = (selectionMin - _this.zoomAxes[index].actualMin) / _this.zoomAxes[index].actualDelta;\n        currentZF = (selectionMax - selectionMin) / _this.zoomAxes[index].actualDelta;\n        argsData.currentZoomPosition = currentZP < 0 ? 0 : currentZP;\n        argsData.currentZoomFactor = currentZF > 1 ? 1 : currentZF;\n        chart.trigger(zoomComplete, argsData);\n\n        if (!argsData.cancel) {\n          axis.zoomFactor = argsData.currentZoomFactor;\n          axis.zoomPosition = argsData.currentZoomPosition;\n        }\n      }\n    });\n  }; // Series transformation style applied here.\n\n\n  Zoom.prototype.setTransform = function (transX, transY, scaleX, scaleY, chart, isPinch) {\n    if (!chart.enableCanvas) {\n      chart.seriesElements.setAttribute('clip-path', 'url(#' + this.elementId + '_ChartAreaClipRect_)');\n    }\n\n    if (chart.indicatorElements) {\n      chart.indicatorElements.setAttribute('clip-path', 'url(#' + this.elementId + '_ChartAreaClipRect_)');\n    }\n\n    var translate;\n    var xAxisLoc;\n    var yAxisLoc;\n    var element;\n\n    if (transX !== null && transY !== null) {\n      chart.visibleSeries.forEach(function (value) {\n        xAxisLoc = chart.requireInvertedAxis ? value.yAxis.rect.x : value.xAxis.rect.x;\n        yAxisLoc = chart.requireInvertedAxis ? value.xAxis.rect.y : value.yAxis.rect.y;\n        translate = 'translate(' + (transX + (isPinch ? scaleX * xAxisLoc : xAxisLoc)) + ',' + (transY + (isPinch ? scaleY * yAxisLoc : yAxisLoc)) + ')';\n        translate = scaleX || scaleY ? translate + ' scale(' + scaleX + ' ' + scaleY + ')' : translate;\n\n        if (value.visible) {\n          if (value.category === 'Indicator') {\n            value.seriesElement.parentNode.setAttribute('transform', translate);\n          } else {\n            if (!chart.enableCanvas) {\n              value.seriesElement.setAttribute('transform', translate);\n            }\n          }\n\n          element = getElement(chart.element.id + '_Series_' + value.index + '_DataLabelCollections');\n\n          if (value.errorBarElement) {\n            value.errorBarElement.setAttribute('transform', translate);\n          }\n\n          if (value.symbolElement) {\n            value.symbolElement.setAttribute('transform', translate);\n          }\n\n          if (value.textElement) {\n            value.textElement.setAttribute('visibility', 'hidden');\n            value.shapeElement.setAttribute('visibility', 'hidden');\n          }\n\n          if (element) {\n            element.style.visibility = 'hidden';\n          }\n        }\n      });\n    }\n  };\n\n  Zoom.prototype.calculateZoomAxesRange = function (chart, axes) {\n    var _this = this;\n\n    var range;\n    var axisRange;\n    chart.axisCollections.forEach(function (axis, index) {\n      axisRange = axis.visibleRange;\n\n      if (_this.zoomAxes[index]) {\n        if (!chart.delayRedraw) {\n          _this.zoomAxes[index].min = axisRange.min;\n          _this.zoomAxes[index].delta = axisRange.delta;\n        }\n      } else {\n        range = {\n          actualMin: axis.actualRange.min,\n          actualDelta: axis.actualRange.delta,\n          min: axisRange.min,\n          delta: axisRange.delta\n        };\n        _this.zoomAxes[index] = range;\n      }\n    });\n  }; // Zooming Toolkit created here\n\n\n  Zoom.prototype.showZoomingToolkit = function (chart) {\n    var toolboxItems = this.zooming.toolbarItems;\n    var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n    var spacing = 5;\n    var render = chart.svgRenderer;\n    var length = this.isDevice ? 1 : toolboxItems.length;\n    var iconSize = this.isDevice ? measureText('Reset Zoom', {\n      size: '12px'\n    }).width : 16;\n    var height = this.isDevice ? measureText('Reset Zoom', {\n      size: '12px'\n    }).height : 22;\n    var width = length * iconSize + (length + 1) * spacing + (length - 1) * spacing;\n    var transX = areaBounds.x + areaBounds.width - width - spacing;\n    var transY = areaBounds.y + spacing;\n    var xPosition = spacing;\n    var outerElement;\n    var toolkit = this.toolkit;\n    var element;\n    var shadowElement = '<filter id=\"chart_shadow\" height=\"130%\"><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"5\"/>';\n    shadowElement += '<feOffset dx=\"-3\" dy=\"4\" result=\"offsetblur\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"1\"/>';\n    shadowElement += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n    if (length === 0 || getElement(this.elementId + '_Zooming_KitCollection')) {\n      return false;\n    }\n\n    var defElement = render.createDefs();\n    toolboxItems = this.isDevice ? ['Reset'] : toolboxItems;\n    defElement.innerHTML = shadowElement;\n    this.toolkitElements = render.createGroup({\n      id: this.elementId + '_Zooming_KitCollection',\n      transform: 'translate(' + transX + ',' + transY + ')'\n    });\n    this.toolkitElements.appendChild(defElement);\n    this.toolkitElements.appendChild(render.drawRectangle(new RectOption(this.elementId + '_Zooming_Rect', '#fafafa', {\n      color: 'transparent',\n      width: 1\n    }, 1, new Rect(0, 0, width, height + spacing * 2), 0, 0)));\n    outerElement = render.drawRectangle(new RectOption(this.elementId + '_Zooming_Rect', '#fafafa', {\n      color: 'transparent',\n      width: 1\n    }, 0.1, new Rect(0, 0, width, height + spacing * 2), 0, 0));\n    outerElement.setAttribute('filter', 'url(#chart_shadow)');\n    this.toolkitElements.appendChild(outerElement);\n    var currentItem;\n\n    for (var i = 1; i <= length; i++) {\n      currentItem = toolboxItems[i - 1];\n      element = render.createGroup({\n        transform: 'translate(' + xPosition + ',' + (this.isDevice ? spacing : spacing + 3) + ')'\n      }); // for desktop toolkit hight is 32 and top padding is 8 icon size 16\n\n      switch (currentItem) {\n        case 'Pan':\n          toolkit.createPanButton(element, this.toolkitElements, chart);\n          break;\n\n        case 'Zoom':\n          toolkit.createZoomButton(element, this.toolkitElements, chart);\n          break;\n\n        case 'ZoomIn':\n          toolkit.createZoomInButton(element, this.toolkitElements, chart);\n          break;\n\n        case 'ZoomOut':\n          toolkit.createZoomOutButton(element, this.toolkitElements, chart);\n          break;\n\n        case 'Reset':\n          toolkit.createResetButton(element, this.toolkitElements, chart, this.isDevice);\n          break;\n      }\n\n      xPosition += iconSize + spacing * 2;\n    }\n\n    this.toolkitElements.setAttribute('opacity', this.isDevice ? '1' : '' + this.zoomkitOpacity);\n    this.toolkitElements.setAttribute('cursor', 'auto');\n\n    if (chart.enableCanvas) {\n      var zoomDiv = document.createElement('div');\n      zoomDiv.id = chart.element.id + '_zoom';\n      zoomDiv.setAttribute('style', 'position:absolute; z-index:1');\n      var zoomheight = chart.availableSize.height / 2;\n      var svg = chart.svgRenderer.createSvg({\n        id: chart.element.id + '_zoomkit_svg',\n        width: chart.availableSize.width,\n        height: zoomheight\n      });\n      svg.setAttribute('style', 'position:absolute');\n      svg.appendChild(this.toolkitElements);\n      zoomDiv.appendChild(svg);\n      document.getElementById(this.elementId + '_Secondary_Element').appendChild(zoomDiv);\n    } else {\n      chart.svgObject.appendChild(this.toolkitElements);\n    }\n\n    if (!this.isDevice) {\n      EventHandler.add(this.toolkitElements, 'mousemove touchstart', this.zoomToolkitMove, this);\n      EventHandler.add(this.toolkitElements, 'mouseleave touchend', this.zoomToolkitLeave, this);\n\n      if (this.isPanning) {\n        toolkit.pan();\n      }\n    }\n\n    return true;\n  };\n  /**\n   * To the show the zooming toolkit.\n   * @return {void}\n   * @private\n   */\n\n\n  Zoom.prototype.applyZoomToolkit = function (chart, axes) {\n    var showToolkit = this.isAxisZoomed(axes);\n\n    if (showToolkit) {\n      this.showZoomingToolkit(chart);\n      this.isZoomed = true;\n    } else {\n      this.toolkit.removeTooltip();\n      this.isPanning = false;\n      this.isZoomed = false;\n      chart.svgObject.setAttribute('cursor', 'auto');\n    }\n  };\n  /**\n   * Return boolean property to show zooming toolkit.\n   * @return {void}\n   * @private\n   */\n\n\n  Zoom.prototype.isAxisZoomed = function (axes) {\n    var showToolkit = false;\n    axes.forEach(function (axis) {\n      showToolkit = showToolkit || axis.zoomFactor !== 1 || axis.zoomPosition !== 0;\n    });\n    return showToolkit;\n  };\n\n  Zoom.prototype.zoomToolkitMove = function (e) {\n    var element = this.toolkitElements;\n    var opacity = +element.getAttribute('opacity');\n    this.zoomkitOpacity = 1;\n    element.setAttribute('opacity', '' + this.zoomkitOpacity);\n    return false;\n  };\n\n  Zoom.prototype.zoomToolkitLeave = function (e) {\n    var element = this.toolkitElements;\n    this.zoomkitOpacity = 0.3;\n    element.setAttribute('opacity', '' + this.zoomkitOpacity);\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Zoom.prototype.addEventListener = function () {\n    if (this.chart.isDestroyed) {\n      return;\n    }\n\n    EventHandler.add(this.chart.element, this.wheelEvent, this.chartMouseWheel, this);\n    this.chart.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);\n    this.chart.on(Browser.touchStartEvent, this.mouseDownHandler, this);\n    this.chart.on(Browser.touchEndEvent, this.mouseUpHandler, this);\n    this.chart.on(this.cancelEvent, this.mouseCancelHandler, this);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Zoom.prototype.removeEventListener = function () {\n    if (this.chart.isDestroyed) {\n      return;\n    }\n\n    EventHandler.remove(this.chart.element, this.wheelEvent, this.chartMouseWheel);\n    this.chart.off(Browser.touchMoveEvent, this.mouseMoveHandler);\n    this.chart.off(Browser.touchStartEvent, this.mouseDownHandler);\n    this.chart.off(Browser.touchEndEvent, this.mouseUpHandler);\n    this.chart.off(this.cancelEvent, this.mouseCancelHandler);\n  };\n  /**\n   * Handles the mouse wheel on chart.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Zoom.prototype.chartMouseWheel = function (e) {\n    var chart = this.chart;\n    var offset = chart.element.getBoundingClientRect();\n    var svgRect = getElement(chart.svgId).getBoundingClientRect();\n    var mouseX = e.clientX - offset.left - Math.max(svgRect.left - offset.left, 0);\n    var mouseY = e.clientY - offset.top - Math.max(svgRect.top - offset.top, 0);\n\n    if (this.zooming.enableMouseWheelZooming && withInBounds(mouseX, mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n      e.preventDefault();\n      this.performMouseWheelZooming(e, mouseX, mouseY, chart, chart.axisCollections);\n    }\n\n    return false;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Zoom.prototype.mouseMoveHandler = function (e) {\n    //Zooming for chart\n    var chart = this.chart;\n    var touches = null;\n\n    if (e.type === 'touchmove') {\n      if (e.preventDefault && this.isIOS && (this.isPanning || chart.isDoubleTap || this.zooming.enablePinchZooming && this.touchStartList.length > 1)) {\n        e.preventDefault();\n      }\n\n      touches = e.touches;\n    }\n\n    if (chart.isChartDrag) {\n      if (chart.isTouch) {\n        this.touchMoveList = this.addTouchPointer(this.touchMoveList, e, touches);\n\n        if (this.zooming.enablePinchZooming && this.touchMoveList.length > 1 && this.touchStartList.length > 1) {\n          this.performPinchZooming(e, chart);\n        }\n      }\n\n      this.renderZooming(e, chart, chart.isTouch);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Zoom.prototype.mouseDownHandler = function (e) {\n    //Zooming for chart\n    var chart = this.chart;\n    var touches = null;\n    var target;\n\n    if (e.type === 'touchstart') {\n      touches = e.touches;\n      target = e.target;\n    } else {\n      target = e.target;\n    }\n\n    if (target.id.indexOf(chart.element.id + '_Zooming_') === -1 && withInBounds(chart.previousMouseMoveX, chart.previousMouseMoveY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n      chart.isChartDrag = true;\n    }\n\n    if (chart.isTouch) {\n      this.touchStartList = this.addTouchPointer(this.touchStartList, e, touches);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Zoom.prototype.mouseUpHandler = function (e) {\n    var chart = this.chart;\n    var performZoomRedraw = e.target.id.indexOf(chart.element.id + '_ZoomOut_') === -1 || e.target.id.indexOf(chart.element.id + '_ZoomIn_') === -1;\n\n    if (chart.isChartDrag || performZoomRedraw) {\n      this.performZoomRedraw(chart);\n    }\n\n    if (chart.isTouch) {\n      if (chart.isDoubleTap && withInBounds(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect) && this.touchStartList.length === 1 && this.isZoomed) {\n        this.toolkit.reset();\n      }\n\n      this.touchStartList = [];\n      chart.isDoubleTap = false;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Zoom.prototype.mouseCancelHandler = function (e) {\n    if (this.isZoomed) {\n      this.performZoomRedraw(this.chart);\n    }\n\n    this.pinchTarget = null;\n    this.touchStartList = [];\n    this.touchMoveList = [];\n  };\n  /**\n   * Handles the touch pointer.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Zoom.prototype.addTouchPointer = function (touchList, e, touches) {\n    if (touches) {\n      touchList = [];\n\n      for (var i = 0, length_1 = touches.length; i < length_1; i++) {\n        touchList.push({\n          pageX: touches[i].clientX,\n          pageY: touches[i].clientY,\n          pointerId: null\n        });\n      }\n    } else {\n      touchList = touchList ? touchList : [];\n\n      if (touchList.length === 0) {\n        touchList.push({\n          pageX: e.clientX,\n          pageY: e.clientY,\n          pointerId: e.pointerId\n        });\n      } else {\n        for (var i = 0, length_2 = touchList.length; i < length_2; i++) {\n          if (touchList[i].pointerId === e.pointerId) {\n            touchList[i] = {\n              pageX: e.clientX,\n              pageY: e.clientY,\n              pointerId: e.pointerId\n            };\n          } else {\n            touchList.push({\n              pageX: e.clientX,\n              pageY: e.clientY,\n              pointerId: e.pointerId\n            });\n          }\n        }\n      }\n    }\n\n    return touchList;\n  };\n  /**\n   * Get module name.\n   */\n\n\n  Zoom.prototype.getModuleName = function () {\n    // Returns te module name\n    return 'Zoom';\n  };\n  /**\n   * To destroy the zooming.\n   * @return {void}\n   * @private\n   */\n\n\n  Zoom.prototype.destroy = function (chart) {\n    // Destroy method performed here\n    this.removeEventListener();\n  };\n\n  return Zoom;\n}();\n\nexport { Zoom };","map":null,"metadata":{},"sourceType":"module"}