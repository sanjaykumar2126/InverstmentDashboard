{"ast":null,"code":"import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\nimport ShapeBuilder from '../shape-builder';\nimport Ring from '../ring';\nimport Point from '../point';\nimport { ARC } from '../../common/constants';\nimport { append, deg, rad } from '../../common';\nvar RadarNumericAxisMixin = {\n  options: {\n    majorGridLines: {\n      visible: true\n    }\n  },\n  createPlotBands: function () {\n    var this$1 = this;\n    var ref = this.options;\n    var type = ref.majorGridLines.type;\n    var plotBands = ref.plotBands;\n    if (plotBands === void 0) plotBands = [];\n    var altAxis = this.plotArea.polarAxis;\n    var majorAngles = altAxis.majorAngles();\n    var center = altAxis.box.center();\n    var group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n\n    for (var i = 0; i < plotBands.length; i++) {\n      var band = plotBands[i];\n      var bandStyle = {\n        fill: {\n          color: band.color,\n          opacity: band.opacity\n        },\n        stroke: {\n          opacity: band.opacity\n        }\n      };\n      var slot = this$1.getSlot(band.from, band.to, true);\n      var ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n      var shape = void 0;\n\n      if (type === ARC) {\n        shape = ShapeBuilder.current.createRing(ring, bandStyle);\n      } else {\n        shape = draw.Path.fromPoints(this$1.plotBandPoints(ring, majorAngles), bandStyle).close();\n      }\n\n      group.append(shape);\n    }\n\n    this.appendVisual(group);\n  },\n  plotBandPoints: function (ring, angles) {\n    var innerPoints = [];\n    var outerPoints = [];\n    var center = [ring.center.x, ring.center.y];\n    var innerCircle = new geom.Circle(center, ring.innerRadius);\n    var outerCircle = new geom.Circle(center, ring.radius);\n\n    for (var i = 0; i < angles.length; i++) {\n      innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n      outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n    }\n\n    innerPoints.reverse();\n    innerPoints.push(innerPoints[0]);\n    outerPoints.push(outerPoints[0]);\n    return outerPoints.concat(innerPoints);\n  },\n  createGridLines: function (altAxis) {\n    var options = this.options;\n    var majorTicks = this.radarMajorGridLinePositions();\n    var majorAngles = altAxis.majorAngles();\n    var center = altAxis.box.center();\n    var gridLines = [];\n\n    if (options.majorGridLines.visible) {\n      gridLines = this.renderGridLines(center, majorTicks, majorAngles, options.majorGridLines);\n    }\n\n    if (options.minorGridLines.visible) {\n      var minorTicks = this.radarMinorGridLinePositions();\n      append(gridLines, this.renderGridLines(center, minorTicks, majorAngles, options.minorGridLines));\n    }\n\n    return gridLines;\n  },\n  renderGridLines: function (center, ticks, angles, options) {\n    var style = {\n      stroke: {\n        width: options.width,\n        color: options.color,\n        dashType: options.dashType\n      }\n    };\n    var skip = options.skip;\n    if (skip === void 0) skip = 0;\n    var step = options.step;\n    if (step === void 0) step = 0;\n    var container = this.gridLinesVisual();\n\n    for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {\n      var tickRadius = center.y - ticks[tickIx];\n\n      if (tickRadius > 0) {\n        var circle = new geom.Circle([center.x, center.y], tickRadius);\n\n        if (options.type === ARC) {\n          container.append(new draw.Circle(circle, style));\n        } else {\n          var line = new draw.Path(style);\n\n          for (var angleIx = 0; angleIx < angles.length; angleIx++) {\n            line.lineTo(circle.pointAt(angles[angleIx] + 180));\n          }\n\n          line.close();\n          container.append(line);\n        }\n      }\n    }\n\n    return container.children;\n  },\n  getValue: function (point) {\n    var lineBox = this.lineBox();\n    var altAxis = this.plotArea.polarAxis;\n    var majorAngles = altAxis.majorAngles();\n    var center = altAxis.box.center();\n    var radius = point.distanceTo(center);\n    var distance = radius;\n\n    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n      var dx = point.x - center.x;\n      var dy = point.y - center.y;\n      var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n      majorAngles.sort(function (a, b) {\n        return angularDistance(a, theta) - angularDistance(b, theta);\n      }); // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n      // Angles are derived from triangle (center, point, gridline X)\n\n      var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n      var alpha = angularDistance(theta, majorAngles[0]);\n      var gamma = 90 - midAngle;\n      var beta = 180 - alpha - gamma;\n      distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n    }\n\n    return this.axisType().prototype.getValue.call(this, new Point(lineBox.x1, lineBox.y2 - distance));\n  }\n};\n\nfunction angularDistance(a, b) {\n  return 180 - Math.abs(Math.abs(a - b) - 180);\n}\n\nexport default RadarNumericAxisMixin;","map":null,"metadata":{},"sourceType":"module"}