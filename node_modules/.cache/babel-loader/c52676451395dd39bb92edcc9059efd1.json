{"ast":null,"code":"import { getMinPointsDelta, getActualDesiredIntervalsCount, setRange, triggerLabelRender } from '../../common/utils/helper';\nimport { DoubleRange } from '../utils/double-range';\nimport { withIn, logBase } from '../../common/utils/helper';\nimport { isNullOrUndefined, extend, getValue } from '@syncfusion/ej2-base';\n/**\n * Numeric module is used to render numeric axis.\n */\n\nvar Double =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the dateTime module.\n   * @private\n   */\n  function Double(chart) {\n    this.chart = chart;\n  }\n  /**\n   * Numeric Nice Interval for the axis.\n   * @private\n   */\n\n\n  Double.prototype.calculateNumericNiceInterval = function (axis, delta, size) {\n    var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);\n    var niceInterval = delta / actualDesiredIntervalsCount;\n\n    if (!isNullOrUndefined(axis.desiredIntervals)) {\n      return niceInterval;\n    }\n\n    var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));\n\n    for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {\n      var interval = _a[_i];\n      var currentInterval = minInterval * interval;\n\n      if (actualDesiredIntervalsCount < delta / currentInterval) {\n        break;\n      }\n\n      niceInterval = currentInterval;\n    }\n\n    return niceInterval;\n  };\n  /**\n   * Actual Range for the axis.\n   * @private\n   */\n\n\n  Double.prototype.getActualRange = function (axis, size) {\n    this.initializeDoubleRange(axis);\n    axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n    axis.actualRange.min = axis.doubleRange.start;\n    axis.actualRange.max = axis.doubleRange.end;\n  };\n  /**\n   * Range for the axis.\n   * @private\n   */\n\n\n  Double.prototype.initializeDoubleRange = function (axis) {\n    //Axis Min\n    if (axis.minimum !== null) {\n      this.min = axis.minimum;\n    } else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {\n      this.min = 0;\n    } // Axis Max\n\n\n    if (axis.maximum !== null) {\n      this.max = axis.maximum;\n    } else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {\n      this.max = 5;\n    }\n\n    if (this.min === this.max) {\n      this.max = axis.valueType.indexOf('Category') > -1 ? this.max : this.min + 1;\n    }\n\n    axis.doubleRange = new DoubleRange(this.min, this.max);\n    axis.actualRange = {};\n  };\n  /**\n   * The function to calculate the range and labels for the axis.\n   * @return {void}\n   * @private\n   */\n\n\n  Double.prototype.calculateRangeAndInterval = function (size, axis) {\n    this.calculateRange(axis, size);\n    this.getActualRange(axis, size);\n    this.applyRangePadding(axis, size);\n    this.calculateVisibleLabels(axis, this.chart);\n  };\n  /**\n   * Calculate Range for the axis.\n   * @private\n   */\n\n\n  Double.prototype.calculateRange = function (axis, size) {\n    /*! Generate axis range */\n    var series;\n    this.min = null;\n    this.max = null;\n\n    if (!setRange(axis)) {\n      for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {\n        var series_1 = _a[_i];\n\n        if (!series_1.visible) {\n          continue;\n        }\n\n        this.paddingInterval = 0;\n        axis.maxPointLength = series_1.points.length;\n\n        if ((series_1.type.indexOf('Column') > -1 || series_1.type.indexOf('Histogram') > -1) && axis.orientation === 'Horizontal' || series_1.type.indexOf('Bar') > -1 && axis.orientation === 'Vertical') {\n          if ((series_1.xAxis.valueType === 'Double' || series_1.xAxis.valueType === 'DateTime') && series_1.xAxis.rangePadding === 'Auto') {\n            this.paddingInterval = getMinPointsDelta(series_1.xAxis, axis.series) * 0.5;\n          }\n        } //For xRange\n\n\n        if (axis.orientation === 'Horizontal') {\n          if (this.chart.requireInvertedAxis) {\n            this.yAxisRange(axis, series_1);\n          } else {\n            this.findMinMax(series_1.xMin - this.paddingInterval, series_1.xMax + this.paddingInterval);\n          }\n        } // For yRange\n\n\n        if (axis.orientation === 'Vertical') {\n          if (this.chart.requireInvertedAxis) {\n            this.findMinMax(series_1.xMin - this.paddingInterval, series_1.xMax + this.paddingInterval);\n          } else {\n            this.yAxisRange(axis, series_1);\n          }\n        }\n      }\n    }\n  };\n\n  Double.prototype.yAxisRange = function (axis, series) {\n    if (series.dragSettings.enable && this.chart.dragY) {\n      if (this.chart.dragY >= axis.visibleRange.max) {\n        series.yMax = this.chart.dragY + axis.visibleRange.interval;\n      }\n\n      if (this.chart.dragY <= axis.visibleRange.min) {\n        series.yMin = this.chart.dragY - axis.visibleRange.interval;\n      }\n    }\n\n    this.findMinMax(series.yMin, series.yMax);\n  };\n\n  Double.prototype.findMinMax = function (min, max) {\n    if (this.min === null || this.min > min) {\n      this.min = min;\n    }\n\n    if (this.max === null || this.max < max) {\n      this.max = max;\n    }\n  };\n  /**\n   * Apply padding for the range.\n   * @private\n   */\n\n\n  Double.prototype.applyRangePadding = function (axis, size) {\n    var range;\n    var start = axis.actualRange.min;\n    var end = axis.actualRange.max;\n\n    if (!setRange(axis)) {\n      var interval = axis.actualRange.interval;\n      var padding = axis.getRangePadding(this.chart);\n\n      if (padding === 'Additional' || padding === 'Round') {\n        this.findAdditional(axis, start, end, interval);\n      } else if (padding === 'Normal') {\n        this.findNormal(axis, start, end, interval, size);\n      } else {\n        this.updateActualRange(axis, start, end, interval);\n      }\n    }\n\n    axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;\n    this.calculateVisibleRange(size, axis);\n  };\n\n  Double.prototype.updateActualRange = function (axis, minimum, maximum, interval) {\n    axis.actualRange = {\n      min: axis.minimum != null ? axis.minimum : minimum,\n      max: axis.maximum != null ? axis.maximum : maximum,\n      interval: axis.interval != null ? axis.interval : interval,\n      delta: axis.actualRange.delta\n    };\n  };\n\n  Double.prototype.findAdditional = function (axis, start, end, interval) {\n    var minimum;\n    var maximum;\n    minimum = Math.floor(start / interval) * interval;\n    maximum = Math.ceil(end / interval) * interval;\n\n    if (axis.rangePadding === 'Additional') {\n      minimum -= interval;\n      maximum += interval;\n    }\n\n    this.updateActualRange(axis, minimum, maximum, interval);\n  };\n\n  Double.prototype.findNormal = function (axis, start, end, interval, size) {\n    var remaining;\n    var minimum;\n    var maximum;\n    var startValue = start;\n\n    if (start < 0) {\n      startValue = 0;\n      minimum = start + start * 0.05;\n      remaining = interval + minimum % interval;\n\n      if (0.365 * interval >= remaining) {\n        minimum -= interval;\n      }\n\n      if (minimum % interval < 0) {\n        minimum = minimum - interval - minimum % interval;\n      }\n    } else {\n      minimum = start < 5.0 / 6.0 * end ? 0 : start - (end - start) * 0.5;\n\n      if (minimum % interval > 0) {\n        minimum -= minimum % interval;\n      }\n    }\n\n    maximum = end > 0 ? end + (end - startValue) * 0.05 : end - (end - startValue) * 0.05;\n    remaining = interval - maximum % interval;\n\n    if (0.365 * interval >= remaining) {\n      maximum += interval;\n    }\n\n    if (maximum % interval > 0) {\n      maximum = maximum + interval - maximum % interval;\n    }\n\n    axis.doubleRange = new DoubleRange(minimum, maximum);\n\n    if (minimum === 0) {\n      interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n      maximum = Math.ceil(maximum / interval) * interval;\n    }\n\n    this.updateActualRange(axis, minimum, maximum, interval);\n  };\n  /**\n   * Calculate visible range for axis.\n   * @private\n   */\n\n\n  Double.prototype.calculateVisibleRange = function (size, axis) {\n    axis.visibleRange = {\n      max: axis.actualRange.max,\n      min: axis.actualRange.min,\n      delta: axis.actualRange.delta,\n      interval: axis.actualRange.interval\n    };\n    var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;\n\n    if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {\n      axis.calculateVisibleRange(size);\n      axis.visibleRange.interval = axis.enableAutoIntervalOnZooming && axis.valueType !== 'Category' ? this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size) : axis.visibleRange.interval;\n    }\n\n    axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n  };\n  /**\n   * Calculate label for the axis.\n   * @private\n   */\n\n\n  Double.prototype.calculateVisibleLabels = function (axis, chart) {\n    /*! Generate axis labels */\n    axis.visibleLabels = [];\n    var tempInterval = axis.visibleRange.min;\n    var labelStyle;\n\n    if (axis.zoomFactor < 1 || axis.zoomPosition > 0 || this.paddingInterval) {\n      tempInterval = axis.visibleRange.min - axis.visibleRange.min % axis.visibleRange.interval;\n    }\n\n    var format = this.getFormat(axis);\n    var isCustom = format.match('{value}') !== null;\n    var intervalDigits = 0;\n    var formatDigits = 0;\n\n    if (axis.labelFormat && axis.labelFormat.indexOf('n') > -1) {\n      formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);\n    }\n\n    axis.format = chart.intl.getNumberFormat({\n      format: isCustom ? '' : format,\n      useGrouping: chart.useGroupingSeparator\n    });\n    axis.startLabel = axis.format(axis.visibleRange.min);\n    axis.endLabel = axis.format(axis.visibleRange.max);\n\n    if (axis.visibleRange.interval && (axis.visibleRange.interval + '').indexOf('.') >= 0) {\n      intervalDigits = (axis.visibleRange.interval + '').split('.')[1].length;\n    }\n\n    labelStyle = extend({}, getValue('properties', axis.labelStyle), null, true);\n\n    for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {\n      if (withIn(tempInterval, axis.visibleRange)) {\n        triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n      }\n    }\n\n    if (tempInterval && (tempInterval + '').indexOf('.') >= 0 && (tempInterval + '').split('.')[1].length > 10) {\n      tempInterval = (tempInterval + '').split('.')[1].length > (formatDigits || intervalDigits) ? +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;\n\n      if (tempInterval <= axis.visibleRange.max) {\n        triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n      }\n    }\n\n    if (axis.getMaxLabelWidth) {\n      axis.getMaxLabelWidth(this.chart);\n    }\n  };\n  /**\n   * Format of the axis label.\n   * @private\n   */\n\n\n  Double.prototype.getFormat = function (axis) {\n    if (axis.labelFormat) {\n      return axis.labelFormat;\n    }\n\n    return axis.isStack100 ? '{value}%' : '';\n  };\n  /**\n   * Formatted the axis label.\n   * @private\n   */\n\n\n  Double.prototype.formatValue = function (axis, isCustom, format, tempInterval) {\n    return isCustom ? format.replace('{value}', axis.format(tempInterval)) : axis.format(tempInterval);\n  };\n\n  return Double;\n}();\n\nexport { Double };","map":null,"metadata":{},"sourceType":"module"}