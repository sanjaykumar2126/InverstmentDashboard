{"ast":null,"code":"import { Series, Points } from '../series/chart-series';\nimport { findClipRect, RectOption } from '../../common/utils/helper';\n/**\n * `Trendline` module is used to render 6 types of trendlines in chart.\n */\n\nvar Trendlines =\n/** @class */\nfunction () {\n  function Trendlines() {}\n  /**\n   * Defines the collection of series, that are used to represent a trendline\n   * @private\n   */\n\n\n  Trendlines.prototype.initSeriesCollection = function (trendline, chart) {\n    var trendLineSeries = new Series(trendline, 'targetSeries', {}, true);\n\n    if (trendline.type === 'Linear' || trendline.type === 'MovingAverage') {\n      trendLineSeries.type = 'Line';\n    } else {\n      trendLineSeries.type = 'Spline';\n    }\n\n    this.setSeriesProperties(trendLineSeries, trendline, trendline.type, trendline.fill, trendline.width, chart);\n  };\n  /**\n   * Initializes the properties of the trendline series\n   */\n\n\n  Trendlines.prototype.setSeriesProperties = function (series, trendline, name, fill, width, chart) {\n    series.name = trendline.name;\n    series.xName = 'x';\n    series.yName = 'y';\n    series.fill = fill || 'blue';\n    series.width = width;\n    series.clipRectElement = trendline.clipRectElement;\n    series.points = [];\n    series.enableTooltip = trendline.enableTooltip;\n    series.index = trendline.index;\n    series.sourceIndex = trendline.sourceIndex;\n    series.interior = series.fill;\n    series.animation = trendline.animation;\n    series.legendShape = 'HorizontalLine';\n    series.marker = trendline.marker;\n    series.category = 'TrendLine';\n    series.chart = chart;\n    series.xMin = Infinity;\n    series.xMax = -Infinity;\n    series.yMin = Infinity;\n    series.yMax = -Infinity;\n    series.xData = [];\n    series.yData = [];\n    trendline.targetSeries = series;\n  };\n  /**\n   * Creates the elements of a trendline\n   */\n\n\n  Trendlines.prototype.createTrendLineElements = function (chart, trendline, index, element, clipRectElement) {\n    trendline.trendLineElement = element;\n    trendline.targetSeries.clipRectElement = clipRectElement;\n    trendline.targetSeries.seriesElement = element;\n\n    if (chart.trendLineElements) {\n      chart.trendLineElements.appendChild(trendline.trendLineElement);\n    }\n  };\n  /**\n   * Defines the data point of trendline\n   */\n\n\n  Trendlines.prototype.getDataPoint = function (x, y, sourcePoint, series, index) {\n    var trendPoint = new Points();\n    trendPoint.x = series.xAxis.valueType === 'DateTime' ? new Date(Number(x)) : x;\n    trendPoint.y = y;\n    trendPoint.xValue = Number(x);\n    trendPoint.color = series.fill;\n    trendPoint.index = index;\n    trendPoint.yValue = Number(y);\n    trendPoint.visible = true;\n    series.xMin = Math.min(series.xMin, trendPoint.xValue);\n    series.yMin = Math.min(series.yMin, trendPoint.yValue);\n    series.xMax = Math.max(series.xMax, trendPoint.xValue);\n    series.yMax = Math.max(series.yMax, trendPoint.yValue);\n    series.xData.push(trendPoint.xValue);\n    return trendPoint;\n  };\n  /**\n   * Finds the slope and intercept of trendline\n   */\n\n\n  Trendlines.prototype.findSlopeIntercept = function (xValues, yValues, trendline, points) {\n    var xAvg = 0;\n    var yAvg = 0;\n    var xyAvg = 0;\n    var xxAvg = 0;\n    var yyAvg = 0;\n    var index = 0;\n    var slope = 0;\n    var intercept = 0;\n\n    while (index < points.length) {\n      // To fix trendline not rendered issue while Nan Value is provided for y values.\n      if (isNaN(yValues[index])) {\n        yValues[index] = (yValues[index - 1] + yValues[index + 1]) / 2;\n      }\n\n      xAvg += xValues[index];\n      yAvg += yValues[index];\n      xyAvg += xValues[index] * yValues[index];\n      xxAvg += xValues[index] * xValues[index];\n      yyAvg += yValues[index] * yValues[index];\n      index++;\n    }\n\n    var type = trendline.type;\n\n    if (trendline.intercept && (type === 'Linear' || type === 'Exponential')) {\n      intercept = trendline.intercept;\n\n      switch (type) {\n        case 'Linear':\n          slope = (xyAvg - trendline.intercept * xAvg) / xxAvg;\n          break;\n\n        case 'Exponential':\n          slope = (xyAvg - Math.log(Math.abs(trendline.intercept)) * xAvg) / xxAvg;\n          break;\n      }\n    } else {\n      slope = (points.length * xyAvg - xAvg * yAvg) / (points.length * xxAvg - xAvg * xAvg);\n\n      if (type === 'Exponential' || type === 'Power') {\n        intercept = Math.exp((yAvg - slope * xAvg) / points.length);\n      } else {\n        intercept = (yAvg - slope * xAvg) / points.length;\n      }\n    }\n\n    return {\n      slope: slope,\n      intercept: intercept\n    };\n  };\n  /**\n   * Defines the points to draw the trendlines\n   */\n\n\n  Trendlines.prototype.initDataSource = function (trendline, chart) {\n    var points = trendline.points;\n\n    if (points && points.length) {\n      //prepare data\n      var trendlineSeries = trendline.targetSeries;\n\n      switch (trendline.type) {\n        case 'Linear':\n          this.setLinearRange(points, trendline, trendlineSeries);\n          break;\n\n        case 'Exponential':\n          this.setExponentialRange(points, trendline, trendlineSeries);\n          break;\n\n        case 'MovingAverage':\n          this.setMovingAverageRange(points, trendline, trendlineSeries);\n          break;\n\n        case 'Polynomial':\n          this.setPolynomialRange(points, trendline, trendlineSeries);\n          break;\n\n        case 'Power':\n          this.setPowerRange(points, trendline, trendlineSeries);\n          break;\n\n        case 'Logarithmic':\n          this.setLogarithmicRange(points, trendline, trendlineSeries);\n          break;\n      }\n\n      if (trendline.type !== 'Linear' && trendline.type !== 'MovingAverage') {\n        trendlineSeries.chart.splineSeriesModule.findSplinePoint(trendlineSeries);\n      }\n    }\n  };\n  /**\n   * Calculation of exponential points\n   */\n\n\n  Trendlines.prototype.setExponentialRange = function (points, trendline, series) {\n    var xValue = [];\n    var yValue = [];\n    var index = 0;\n    var slopeIntercept;\n\n    while (index < points.length) {\n      var point = points[index];\n      xValue.push(point.xValue);\n      yValue.push(Math.log(point.yValue));\n      index++;\n    }\n\n    slopeIntercept = this.findSlopeIntercept(xValue, yValue, trendline, points);\n    series.points = this.getExponentialPoints(trendline, points, xValue, yValue, series, slopeIntercept);\n  };\n  /**\n   * Calculation of logarithmic points\n   */\n\n\n  Trendlines.prototype.setLogarithmicRange = function (points, trendline, series) {\n    var xLogValue = [];\n    var yLogValue = [];\n    var xPointsLgr = [];\n    var slopeIntercept;\n    var index = 0;\n\n    while (index < points.length) {\n      var point = points[index];\n      xPointsLgr.push(point.xValue);\n      xLogValue.push(Math.log(point.xValue));\n      yLogValue.push(point.yValue);\n      index++;\n    }\n\n    slopeIntercept = this.findSlopeIntercept(xLogValue, yLogValue, trendline, points);\n    series.points = this.getLogarithmicPoints(trendline, points, xPointsLgr, yLogValue, series, slopeIntercept);\n  };\n  /**\n   * Calculation of polynomial points\n   */\n\n\n  Trendlines.prototype.setPolynomialRange = function (points, trendline, series) {\n    var xPolyValues = [];\n    var yPolyValues = [];\n    var index = 0;\n\n    while (index < points.length) {\n      var point = points[index];\n      xPolyValues.push(point.xValue);\n      yPolyValues.push(point.yValue);\n      index++;\n    }\n\n    series.points = this.getPolynomialPoints(trendline, points, xPolyValues, yPolyValues, series);\n  };\n  /**\n   * Calculation of power points\n   */\n\n\n  Trendlines.prototype.setPowerRange = function (points, trendline, series) {\n    var xValues = [];\n    var yValues = [];\n    var powerPoints = [];\n    var slopeIntercept;\n    var index = 0;\n\n    while (index < points.length) {\n      var point = points[index];\n      powerPoints.push(point.xValue);\n      xValues.push(Math.log(point.xValue));\n      yValues.push(Math.log(point.yValue));\n      index++;\n    }\n\n    slopeIntercept = this.findSlopeIntercept(xValues, yValues, trendline, points);\n    series.points = this.getPowerPoints(trendline, points, powerPoints, yValues, series, slopeIntercept);\n  };\n  /**\n   * Calculation of linear points\n   */\n\n\n  Trendlines.prototype.setLinearRange = function (points, trendline, series) {\n    var xValues = [];\n    var yValues = [];\n    var slopeIntercept;\n    var index = 0;\n\n    while (index < points.length) {\n      var point = points[index];\n      xValues.push(point.xValue);\n      yValues.push(point.yValue);\n      index++;\n    }\n\n    slopeIntercept = this.findSlopeIntercept(xValues, yValues, trendline, points);\n    series.points = this.getLinearPoints(trendline, points, xValues, yValues, series, slopeIntercept);\n  };\n  /**\n   * Calculation of moving average points\n   */\n\n\n  Trendlines.prototype.setMovingAverageRange = function (points, trendline, series) {\n    var xValues = [];\n    var yValues = [];\n    var xAvgValues = [];\n    var index = 0;\n\n    while (index < points.length) {\n      var point = points[index];\n      xAvgValues.push(point.xValue);\n      xValues.push(index + 1);\n      yValues.push(point.yValue);\n      index++;\n    }\n\n    series.points = this.getMovingAveragePoints(trendline, points, xAvgValues, yValues, series);\n  };\n  /**\n   * Calculation of logarithmic points\n   */\n\n\n  Trendlines.prototype.getLogarithmicPoints = function (trendline, points, xValues, yValues, series, slopeInterceptLog) {\n    var midPoint = Math.round(points.length / 2);\n    var pts = [];\n    var x1Log = xValues[0] - trendline.backwardForecast;\n    var y1Log = slopeInterceptLog.intercept + slopeInterceptLog.slope * Math.log(x1Log);\n    var x2Log = xValues[midPoint - 1];\n    var y2Log = slopeInterceptLog.intercept + slopeInterceptLog.slope * Math.log(x2Log);\n    var x3Log = xValues[xValues.length - 1] + trendline.forwardForecast;\n    var y3Log = slopeInterceptLog.intercept + slopeInterceptLog.slope * Math.log(x3Log);\n    pts.push(this.getDataPoint(x1Log, y1Log, points[0], series, pts.length));\n    pts.push(this.getDataPoint(x2Log, y2Log, points[midPoint - 1], series, pts.length));\n    pts.push(this.getDataPoint(x3Log, y3Log, points[points.length - 1], series, pts.length));\n    return pts;\n  };\n  /**\n   * Defines the points based on data point\n   */\n\n\n  Trendlines.prototype.getPowerPoints = function (trendline, points, xValues, yValues, series, slopeInterceptPower) {\n    var midPoint = Math.round(points.length / 2);\n    var pts = [];\n    var x1 = xValues[0] - trendline.backwardForecast;\n    x1 = x1 > -1 ? x1 : 0;\n    var y1 = slopeInterceptPower.intercept * Math.pow(x1, slopeInterceptPower.slope);\n    var x2 = xValues[midPoint - 1];\n    var y2 = slopeInterceptPower.intercept * Math.pow(x2, slopeInterceptPower.slope);\n    var x3 = xValues[xValues.length - 1] + trendline.forwardForecast;\n    var y3 = slopeInterceptPower.intercept * Math.pow(x3, slopeInterceptPower.slope);\n    pts.push(this.getDataPoint(x1, y1, points[0], series, pts.length));\n    pts.push(this.getDataPoint(x2, y2, points[midPoint - 1], series, pts.length));\n    pts.push(this.getDataPoint(x3, y3, points[points.length - 1], series, pts.length));\n    return pts;\n  };\n  /**\n   * Get the polynomial points based on polynomial slopes\n   */\n\n\n  Trendlines.prototype.getPolynomialPoints = function (trendline, points, xValues, yValues, series) {\n    var midPoint = Math.round(points.length / 2);\n    var pts = [];\n    var polynomialOrder = points.length <= trendline.polynomialOrder ? points.length : trendline.polynomialOrder;\n    polynomialOrder = Math.max(2, polynomialOrder);\n    polynomialOrder = Math.min(6, polynomialOrder);\n    trendline.polynomialOrder = polynomialOrder;\n    trendline.polynomialSlopes = [];\n    trendline.polynomialSlopes.length = trendline.polynomialOrder + 1;\n    var index = 0;\n\n    while (index < xValues.length) {\n      var xVal = xValues[index];\n      var yVal = yValues[index];\n      var subIndex = 0;\n\n      while (subIndex <= trendline.polynomialOrder) {\n        if (!trendline.polynomialSlopes[subIndex]) {\n          trendline.polynomialSlopes[subIndex] = 0;\n        }\n\n        trendline.polynomialSlopes[subIndex] += Math.pow(xVal, subIndex) * yVal;\n        ++subIndex;\n      }\n\n      index++;\n    }\n\n    var numArray = [];\n    numArray.length = 1 + 2 * trendline.polynomialOrder;\n    var matrix = [];\n    matrix.length = trendline.polynomialOrder + 1;\n    var newIndex = 0;\n\n    while (newIndex < trendline.polynomialOrder + 1) {\n      matrix[newIndex] = [];\n      matrix[newIndex].length = 3;\n      newIndex++;\n    }\n\n    var nIndex = 0;\n    var num1 = 0;\n\n    while (nIndex < xValues.length) {\n      var d = xValues[nIndex];\n      var num2 = 1.0;\n      var nIndex2 = 0;\n\n      while (nIndex2 < numArray.length) {\n        if (!numArray[nIndex2]) {\n          numArray[nIndex2] = 0;\n        }\n\n        numArray[nIndex2] += num2;\n        num2 *= d;\n        ++num1;\n        ++nIndex2;\n      }\n\n      ++nIndex;\n    }\n\n    var nnIndex = 0;\n\n    while (nnIndex <= trendline.polynomialOrder) {\n      var nnIndex2 = 0;\n\n      while (nnIndex2 <= trendline.polynomialOrder) {\n        matrix[nnIndex][nnIndex2] = numArray[nnIndex + nnIndex2];\n        ++nnIndex2;\n      }\n\n      ++nnIndex;\n    }\n\n    if (!this.gaussJordanElimination(matrix, trendline.polynomialSlopes)) {\n      trendline.polynomialSlopes = null;\n    }\n\n    pts = this.getPoints(trendline, points, xValues, yValues, series);\n    return pts;\n  };\n  /**\n   * Defines the moving average points\n   */\n\n\n  Trendlines.prototype.getMovingAveragePoints = function (trendline, points, xValues, yValues, series) {\n    var pts = [];\n    var period = trendline.period >= points.length ? points.length - 1 : trendline.period;\n    period = Math.max(2, period);\n    var index = 0;\n    var y;\n    var x;\n    var count;\n    var nullCount;\n\n    while (index < points.length - 1) {\n      y = count = nullCount = 0;\n\n      for (var j = index; count < period; j++) {\n        count++;\n\n        if (!yValues[j]) {\n          nullCount++;\n        }\n\n        y += yValues[j];\n      }\n\n      y = period - nullCount <= 0 ? null : y / (period - nullCount);\n\n      if (y && !isNaN(y)) {\n        x = xValues[period - 1 + index];\n        pts.push(this.getDataPoint(x, y, points[period - 1 + index], series, pts.length));\n      }\n\n      index++;\n    }\n\n    return pts;\n  };\n  /**\n   * Defines the linear points\n   */\n\n\n  Trendlines.prototype.getLinearPoints = function (trendline, points, xValues, yValues, series, slopeInterceptLinear) {\n    var pts = [];\n    var x1Linear = xValues[0] - trendline.backwardForecast;\n    var y1Linear = slopeInterceptLinear.slope * x1Linear + slopeInterceptLinear.intercept;\n    var x2Linear = xValues[xValues.length - 1] + trendline.forwardForecast;\n    var y2Linear = slopeInterceptLinear.slope * x2Linear + slopeInterceptLinear.intercept;\n    pts.push(this.getDataPoint(x1Linear, y1Linear, points[0], series, pts.length));\n    pts.push(this.getDataPoint(x2Linear, y2Linear, points[points.length - 1], series, pts.length));\n    return pts;\n  };\n  /**\n   * Defines the exponential points\n   */\n\n\n  Trendlines.prototype.getExponentialPoints = function (trendline, points, xValues, yValues, series, slopeInterceptExp) {\n    var midPoint = Math.round(points.length / 2);\n    var ptsExp = [];\n    var x1 = xValues[0] - trendline.backwardForecast;\n    var y1 = slopeInterceptExp.intercept * Math.exp(slopeInterceptExp.slope * x1);\n    var x2 = xValues[midPoint - 1];\n    var y2 = slopeInterceptExp.intercept * Math.exp(slopeInterceptExp.slope * x2);\n    var x3 = xValues[xValues.length - 1] + trendline.forwardForecast;\n    var y3 = slopeInterceptExp.intercept * Math.exp(slopeInterceptExp.slope * x3);\n    ptsExp.push(this.getDataPoint(x1, y1, points[0], series, ptsExp.length));\n    ptsExp.push(this.getDataPoint(x2, y2, points[midPoint - 1], series, ptsExp.length));\n    ptsExp.push(this.getDataPoint(x3, y3, points[points.length - 1], series, ptsExp.length));\n    return ptsExp;\n  };\n  /**\n   * Defines the points based on data point\n   */\n\n\n  Trendlines.prototype.getPoints = function (trendline, points, xValues, yValues, series) {\n    var midPoint = Math.round(points.length / 2);\n    var polynomialSlopes = trendline.polynomialSlopes;\n    var pts = [];\n    var x1 = 1;\n    var index = 1;\n    var xValue;\n    var yValue;\n\n    while (index <= polynomialSlopes.length) {\n      if (index === 1) {\n        xValue = xValues[0] - trendline.backwardForecast;\n        yValue = this.getPolynomialYValue(polynomialSlopes, xValue);\n        pts.push(this.getDataPoint(xValue, yValue, points[0], series, pts.length));\n      } else if (index === polynomialSlopes.length) {\n        xValue = xValues[points.length - 1] + trendline.forwardForecast;\n        yValue = this.getPolynomialYValue(polynomialSlopes, xValue);\n        pts.push(this.getDataPoint(xValue, yValue, points[points.length - 1], series, pts.length));\n      } else {\n        x1 += (points.length + trendline.forwardForecast) / polynomialSlopes.length;\n        xValue = xValues[parseInt(x1.toString(), 10) - 1];\n        yValue = this.getPolynomialYValue(polynomialSlopes, xValue);\n        pts.push(this.getDataPoint(xValue, yValue, points[parseInt(x1.toString(), 10) - 1], series, pts.length));\n      }\n\n      index++;\n    }\n\n    return pts;\n  };\n  /**\n   * Defines the polynomial value of y\n   */\n\n\n  Trendlines.prototype.getPolynomialYValue = function (slopes, x) {\n    var sum = 0;\n    var index = 0;\n\n    while (index < slopes.length) {\n      sum += slopes[index] * Math.pow(x, index);\n      index++;\n    }\n\n    return sum;\n  };\n  /**\n   * Defines the gauss jordan elimination\n   */\n\n\n  Trendlines.prototype.gaussJordanElimination = function (matrix, polynomialSlopes) {\n    var length = matrix.length;\n    var numArray1 = [];\n    var numArray2 = [];\n    var numArray3 = [];\n    numArray1.length = length;\n    numArray2.length = length;\n    numArray3.length = length;\n    var index = 0;\n\n    while (index < length) {\n      numArray3[index] = 0;\n      ++index;\n    }\n\n    var index1 = 0;\n\n    while (index1 < length) {\n      var num1 = 0;\n      var index2 = 0;\n      var index3 = 0;\n      var index4 = 0;\n\n      while (index4 < length) {\n        if (numArray3[index4] !== 1) {\n          var index5 = 0;\n\n          while (index5 < length) {\n            if (numArray3[index5] === 0 && Math.abs(matrix[index4][index5]) >= num1) {\n              num1 = Math.abs(matrix[index4][index5]);\n              index2 = index4;\n              index3 = index5;\n            }\n\n            ++index5;\n          }\n        }\n\n        ++index4;\n      }\n\n      ++numArray3[index3];\n\n      if (index2 !== index3) {\n        var index4_1 = 0;\n\n        while (index4_1 < length) {\n          var num2 = matrix[index2][index4_1];\n          matrix[index2][index4_1] = matrix[index3][index4_1];\n          matrix[index3][index4_1] = num2;\n          ++index4_1;\n        }\n\n        var num3 = polynomialSlopes[index2];\n        polynomialSlopes[index2] = polynomialSlopes[index3];\n        polynomialSlopes[index3] = num3;\n      }\n\n      numArray2[index1] = index2;\n      numArray1[index1] = index3;\n\n      if (matrix[index3][index3] === 0.0) {\n        return false;\n      }\n\n      var num4 = 1.0 / matrix[index3][index3];\n      matrix[index3][index3] = 1.0;\n      var iindex4 = 0;\n\n      while (iindex4 < length) {\n        matrix[index3][iindex4] *= num4;\n        ++iindex4;\n      }\n\n      polynomialSlopes[index3] *= num4;\n      var iandex4 = 0;\n\n      while (iandex4 < length) {\n        if (iandex4 !== index3) {\n          var num2 = matrix[iandex4][index3];\n          matrix[iandex4][index3] = 0.0;\n          var index5 = 0;\n\n          while (index5 < length) {\n            matrix[iandex4][index5] -= matrix[index3][index5] * num2;\n            ++index5;\n          }\n\n          polynomialSlopes[iandex4] -= polynomialSlopes[index3] * num2;\n        }\n\n        ++iandex4;\n      }\n\n      ++index1;\n    }\n\n    var iindex1 = length - 1;\n\n    while (iindex1 >= 0) {\n      if (numArray2[iindex1] !== numArray1[iindex1]) {\n        var iindex2 = 0;\n\n        while (iindex2 < length) {\n          var num = matrix[iindex2][numArray2[iindex1]];\n          matrix[iindex2][numArray2[iindex1]] = matrix[iindex2][numArray1[iindex1]];\n          matrix[iindex2][numArray1[iindex1]] = num;\n          ++iindex2;\n        }\n      }\n\n      --iindex1;\n    }\n\n    return true;\n  };\n  /**\n   * Defines the trendline elements\n   */\n\n\n  Trendlines.prototype.getTrendLineElements = function (series, chart) {\n    findClipRect(series);\n    var clipRect = series.clipRect;\n    var clipRectElement = chart.renderer.drawClipPath(new RectOption(chart.element.id + '_ChartTrendlineClipRect_' + series.index, 'transparent', {\n      width: 1,\n      color: 'Gray'\n    }, 1, {\n      x: 0,\n      y: 0,\n      width: clipRect.width,\n      height: clipRect.height\n    }));\n    var element;\n    element = chart.renderer.createGroup({\n      'id': chart.element.id + 'TrendlineSeriesGroup' + series.index,\n      'transform': 'translate(' + clipRect.x + ',' + clipRect.y + ')',\n      'clip-path': 'url(#' + chart.element.id + '_ChartTrendlineClipRect_' + series.index + ')'\n    }); //defines the clip rect element\n\n    if (element) {\n      element.appendChild(clipRectElement);\n    }\n\n    for (var _i = 0, _a = series.trendlines; _i < _a.length; _i++) {\n      var trendline = _a[_i];\n      this.createTrendLineElements(chart, trendline, trendline.index, element, clipRectElement);\n    }\n  };\n  /**\n   * To destroy the trendline\n   */\n\n\n  Trendlines.prototype.destroy = function (chart) {\n    /**\n     * Destroys the Linear Trendline\n     */\n  };\n  /**\n   * Get module name\n   */\n\n\n  Trendlines.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'TrendLine';\n  };\n\n  return Trendlines;\n}();\n\nexport { Trendlines };","map":null,"metadata":{},"sourceType":"module"}