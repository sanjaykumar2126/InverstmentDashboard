{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { withInRange } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { subArraySum, getElement, appendChildElement, redrawElement } from '../../common/utils/helper';\nimport { ColumnBase } from './column-base';\n/**\n * `WaterfallSeries` module is used to render the waterfall series.\n */\n\nvar WaterfallSeries =\n/** @class */\nfunction (_super) {\n  __extends(WaterfallSeries, _super);\n\n  function WaterfallSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Render waterfall series.\n   * @return {void}\n   * @private\n   */\n\n\n  WaterfallSeries.prototype.render = function (series) {\n    var rect;\n    var sideBySideInfo = this.getSideBySideInfo(series);\n    var origin = Math.max(series.yAxis.visibleRange.min, 0);\n    var argsData;\n    var prevEndValue = 0;\n    var direction = '';\n    var currentEndValue = 0;\n    var originValue;\n    var prevRegion = null;\n    var y;\n    var isInversed = series.chart.requireInvertedAxis;\n    var intermediateOrigin = 0;\n    var redraw = series.chart.redraw;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n      point.symbolLocations = [];\n      point.regions = [];\n\n      if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {\n        //Calcute the current point value to render waterfall series.\n        var isSum = this.isIntermediateSum(series, point.index);\n        var totalSum = this.isSumIndex(series, point.index);\n        currentEndValue += isSum || totalSum === true ? 0 : point.yValue; //Calcute the origin value for points\n\n        originValue = isSum === true ? intermediateOrigin : prevEndValue !== null && !totalSum ? prevEndValue : origin;\n        rect = this.getRectangle(point.xValue + sideBySideInfo.start, currentEndValue, point.xValue + sideBySideInfo.end, originValue, series);\n        argsData = this.triggerPointRenderEvent(series, point); //intermediateOrigin is used only for imtermediate data \n\n        if (isSum) {\n          intermediateOrigin = currentEndValue;\n        }\n\n        prevEndValue = currentEndValue;\n\n        if (!argsData.cancel) {\n          this.updateSymbolLocation(point, rect, series);\n          this.drawRectangle(series, point, rect, argsData);\n        }\n\n        var currentRegion = point.regions[0];\n\n        if (prevRegion !== null) {\n          var prevLeft = isInversed ? prevRegion.x : prevRegion.y;\n          var currentLeft = isInversed ? currentRegion.x : currentRegion.y;\n          var prevBottom = isInversed ? prevRegion.x + prevRegion.width : prevRegion.y + prevRegion.height;\n          var currentBottom = isInversed ? currentRegion.x + currentRegion.width : currentRegion.y + currentRegion.height;\n\n          if (Math.round(prevLeft) === Math.round(currentLeft) || Math.round(prevBottom) === Math.round(currentLeft)) {\n            y = isInversed ? currentRegion.x : currentRegion.y;\n          } else {\n            y = currentBottom;\n          }\n\n          if (isInversed) {\n            direction = direction.concat('M' + ' ' + y + ' ' + (prevRegion.y + prevRegion.height) + ' ' + 'L' + ' ' + y + ' ' + currentRegion.y + ' ');\n          } else {\n            direction = direction.concat('M' + ' ' + prevRegion.x + ' ' + y + ' ' + 'L' + ' ' + (currentRegion.x + currentRegion.width) + ' ' + y + ' ');\n          }\n        }\n\n        prevRegion = point.regions[0];\n      }\n    }\n\n    var options = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Connector_', 'none', series.connector.width, series.connector.color, series.opacity, series.connector.dashArray, direction);\n\n    if (redraw && getElement(options.id)) {\n      direction = getElement(options.id).getAttribute('d');\n    }\n\n    var element = redrawElement(redraw, options.id, options, series.chart.renderer) || series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n    element.style.visibility = !series.chart.enableCanvas ? series.animation.enable && series.chart.animateSeries ? 'hidden' : 'visible' : null;\n    appendChildElement(series.chart.enableCanvas, series.seriesElement, element, redraw, true, null, null, null, direction);\n    this.renderMarker(series);\n  };\n  /**\n   * To check intermediateSumIndex in waterfall series.\n   * @return boolean\n   * @private\n   */\n\n\n  WaterfallSeries.prototype.isIntermediateSum = function (series, index) {\n    if (series.intermediateSumIndexes !== undefined && series.intermediateSumIndexes.indexOf(index) !== -1) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * To check sumIndex in waterfall series.\n   * @return boolean\n   * @private\n   */\n\n\n  WaterfallSeries.prototype.isSumIndex = function (series, index) {\n    if (series.sumIndexes !== undefined && series.sumIndexes.indexOf(index) !== -1) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * To trigger the point rendering event for waterfall series.\n   * @return IPointRenderEventArgs\n   * @private\n   */\n\n\n  WaterfallSeries.prototype.triggerPointRenderEvent = function (series, point) {\n    var color;\n    var isSum = this.isIntermediateSum(series, point.index);\n    var totalSum = this.isSumIndex(series, point.index);\n\n    if (isSum || totalSum) {\n      color = series.summaryFillColor;\n    } else if (point.y < 0) {\n      color = series.negativeFillColor;\n    } else {\n      color = series.interior;\n    }\n\n    return this.triggerEvent(series, point, color, {\n      color: series.border.color,\n      width: series.border.width\n    });\n  };\n  /**\n   * Add sumIndex and intermediateSumIndex data.\n   * @return {object[]}\n   * @private\n   */\n\n\n  WaterfallSeries.prototype.processInternalData = function (json, series) {\n    var data = json;\n    var length = json.length;\n    var index;\n    var intermediateSum = series.intermediateSumIndexes;\n    var sumIndex = series.sumIndexes;\n\n    if (intermediateSum !== undefined && intermediateSum.length > 0) {\n      for (var i = 0; i < intermediateSum.length; i++) {\n        for (var j = 0; j < data.length; j++) {\n          if (j === intermediateSum[i]) {\n            if (i === 0) {\n              index = subArraySum(data, -1, intermediateSum[i], null, series);\n            } else {\n              index = subArraySum(data, intermediateSum[i - 1], intermediateSum[i], null, series);\n            }\n\n            data[j][series.yName] = index;\n          }\n        }\n      }\n    }\n\n    if (sumIndex !== undefined && sumIndex.length > 0) {\n      for (var k = 0; k < sumIndex.length; k++) {\n        for (var j = 0; j < data.length; j++) {\n          if (j === sumIndex[k]) {\n            if (intermediateSum !== undefined) {\n              index = subArraySum(data, -1, sumIndex[k], sumIndex, series);\n            } else {\n              index = subArraySum(data, -1, sumIndex[k], null, series);\n            }\n\n            data[j][series.yName] = index;\n          }\n        }\n      }\n    }\n\n    return data;\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  WaterfallSeries.prototype.doAnimation = function (series) {\n    this.animate(series);\n  };\n  /**\n   * Get module name.\n   */\n\n\n  WaterfallSeries.prototype.getModuleName = function () {\n    return 'WaterfallSeries';\n    /**\n     * return the module name\n     */\n  };\n  /**\n   * To destroy the waterfall series.\n   * @return {void}\n   * @private\n   */\n\n\n  WaterfallSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroys the waterfall series.\n     */\n  };\n\n  return WaterfallSeries;\n}(ColumnBase);\n\nexport { WaterfallSeries };","map":null,"metadata":{},"sourceType":"module"}