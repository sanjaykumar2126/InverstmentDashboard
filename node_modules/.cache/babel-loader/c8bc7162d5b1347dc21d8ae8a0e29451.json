{"ast":null,"code":"/**\n * Methods for calculating coefficient.\n */\n\n/** @private */\nexport function rangeValueToCoefficient(value, range, inversed) {\n  var result = (value - range.min) / range.delta;\n  return inversed ? 1 - result : result;\n}\n/** @private */\n\nexport function getXLocation(x, range, size, inversed) {\n  x = rangeValueToCoefficient(x, range, inversed);\n  return x * size;\n}\n/** @private */\n\nexport function getRangeValueXByPoint(value, size, range, inversed) {\n  var actualValue = !inversed ? value / size : 1 - value / size;\n  return actualValue * range.delta + range.min;\n}\n/** @private */\n\nexport function getExactData(points, start, end) {\n  var selectedData = [];\n  points.map(function (point) {\n    if (point.xValue >= start && point.xValue <= end) {\n      selectedData.push({\n        'x': point.x,\n        'y': point.y\n      });\n    }\n  });\n  return selectedData;\n}\n/** @private */\n\nexport function getNearestValue(values, point) {\n  return values.reduce(function (prev, curr) {\n    return Math.abs(curr - point) < Math.abs(prev - point) ? curr : prev;\n  });\n}\n/**\n * Data point\n * @public\n */\n\nvar DataPoint =\n/** @class */\nfunction () {\n  function DataPoint(x, y, xValue, yValue, visible) {\n    if (visible === void 0) {\n      visible = true;\n    }\n\n    this.x = x;\n    this.y = y;\n    this.xValue = xValue;\n    this.visible = visible;\n  }\n\n  return DataPoint;\n}();\n\nexport { DataPoint };","map":null,"metadata":{},"sourceType":"module"}