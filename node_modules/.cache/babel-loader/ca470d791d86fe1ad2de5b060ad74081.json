{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Double } from '../axis/double-axis';\nimport { getActualDesiredIntervalsCount, triggerLabelRender } from '../../common/utils/helper';\nimport { logBase, withIn } from '../../common/utils/helper';\nimport { extend, getValue, isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * `Logarithmic` module is used to render log axis.\n */\n\nvar Logarithmic =\n/** @class */\nfunction (_super) {\n  __extends(Logarithmic, _super);\n  /**\n   * Constructor for the logerithmic module.\n   * @private\n   */\n\n\n  function Logarithmic(chart) {\n    return _super.call(this, chart) || this;\n  }\n  /**\n   * The method to calculate the range and labels for the axis.\n   * @return {void}\n   */\n\n\n  Logarithmic.prototype.calculateRangeAndInterval = function (size, axis) {\n    this.calculateRange(axis, size);\n    this.getActualRange(axis, size);\n    this.calculateVisibleRange(size, axis);\n    this.calculateVisibleLabels(axis, this.chart);\n  };\n  /**\n   * Calculates actual range for the axis.\n   * @private\n   */\n\n\n  Logarithmic.prototype.getActualRange = function (axis, size) {\n    this.initializeDoubleRange(axis);\n    this.min = this.min < 0 ? 0 : this.min;\n    var logStart = logBase(this.min, axis.logBase);\n    logStart = isFinite(logStart) ? logStart : this.min;\n    var logEnd = logBase(this.max, axis.logBase);\n    logEnd = isFinite(logStart) ? logEnd : this.max;\n    this.min = Math.floor(logStart / 1);\n    this.max = Math.ceil(logEnd / 1);\n    axis.actualRange.interval = axis.interval || this.calculateLogNiceInterval(this.max - this.min, size, axis);\n    axis.actualRange.min = this.min;\n    axis.actualRange.max = this.max;\n    axis.actualRange.delta = this.max - this.min;\n  };\n  /**\n   * Calculates visible range for the axis.\n   * @private\n   */\n\n\n  Logarithmic.prototype.calculateVisibleRange = function (size, axis) {\n    axis.visibleRange = {\n      interval: axis.actualRange.interval,\n      max: axis.actualRange.max,\n      min: axis.actualRange.min,\n      delta: axis.actualRange.delta\n    };\n    var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;\n\n    if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {\n      axis.calculateVisibleRange(size);\n      axis.visibleRange.interval = axis.enableAutoIntervalOnZooming ? this.calculateLogNiceInterval(axis.doubleRange.delta, size, axis) : axis.visibleRange.interval;\n      axis.visibleRange.interval = Math.floor(axis.visibleRange.interval) === 0 ? 1 : Math.floor(axis.visibleRange.interval);\n      axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n    }\n  };\n  /**\n   * Calculates log iInteval for the axis.\n   * @private\n   */\n\n\n  Logarithmic.prototype.calculateLogNiceInterval = function (delta, size, axis) {\n    var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);\n    var niceInterval = delta;\n    var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));\n\n    for (var j = 0, len = axis.intervalDivs.length; j < len; j++) {\n      var currentInterval = minInterval * axis.intervalDivs[j];\n\n      if (actualDesiredIntervalsCount < delta / currentInterval) {\n        break;\n      }\n\n      niceInterval = currentInterval;\n    }\n\n    return niceInterval;\n  };\n  /**\n   * Calculates labels for the axis.\n   * @private\n   */\n\n\n  Logarithmic.prototype.calculateVisibleLabels = function (axis, chart) {\n    /*! Generate axis labels */\n    var tempInterval = axis.visibleRange.min;\n    axis.visibleLabels = [];\n    var labelStyle;\n\n    if (axis.zoomFactor < 1 || axis.zoomPosition > 0) {\n      tempInterval = axis.visibleRange.min - axis.visibleRange.min % axis.visibleRange.interval;\n    }\n\n    var axisFormat = this.getFormat(axis);\n    var isCustomFormat = axisFormat.match('{value}') !== null;\n    axis.format = chart.intl.getNumberFormat({\n      format: isCustomFormat ? '' : axisFormat,\n      useGrouping: chart.useGroupingSeparator\n    });\n    axis.startLabel = axis.format(Math.pow(axis.logBase, axis.visibleRange.min));\n    axis.endLabel = axis.format(Math.pow(axis.logBase, axis.visibleRange.max));\n\n    for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {\n      labelStyle = extend({}, getValue('properties', axis.labelStyle), null, true);\n\n      if (withIn(tempInterval, axis.visibleRange)) {\n        triggerLabelRender(this.chart, tempInterval, this.formatValue(axis, isCustomFormat, axisFormat, Math.pow(axis.logBase, tempInterval)), labelStyle, axis);\n      }\n    }\n\n    if (axis.getMaxLabelWidth) {\n      axis.getMaxLabelWidth(this.chart);\n    }\n  };\n  /**\n   * Get module name\n   */\n\n\n  Logarithmic.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'Logarithmic';\n  };\n  /**\n   * To destroy the category axis.\n   * @return {void}\n   * @private\n   */\n\n\n  Logarithmic.prototype.destroy = function (chart) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return Logarithmic;\n}(Double);\n\nexport { Logarithmic };","map":null,"metadata":{},"sourceType":"module"}