{"ast":null,"code":"import { ChartLocation, RectOption, isCollide } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint } from '../../common/utils/helper';\n/**\n * `DataLabel` module is used to render data label for the data point.\n */\n\nvar DataLabel =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the data label module.\n   * @private\n   */\n  function DataLabel(chart) {\n    this.errorHeight = 0;\n    this.chart = chart;\n  }\n\n  DataLabel.prototype.initPrivateVariables = function (series, marker) {\n    var transform;\n    var render = series.chart.renderer;\n    var index = series.index === undefined ? series.category : series.index;\n    transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')' : '';\n\n    if (marker.dataLabel.visible) {\n      series.shapeElement = render.createGroup({\n        'id': this.chart.element.id + 'ShapeGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n      });\n      series.textElement = render.createGroup({\n        'id': this.chart.element.id + 'TextGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n      });\n    }\n\n    this.markerHeight = series.type === 'Scatter' || marker.visible ? marker.height / 2 : 0;\n    this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n    this.calculateErrorHeight(series, series.marker.dataLabel.position);\n    this.chartBackground = this.chart.chartArea.background === 'trasparent' ? this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n  };\n\n  DataLabel.prototype.calculateErrorHeight = function (series, position) {\n    if (!series.errorBar.visible) {\n      return null;\n    } else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n      var direction = series.errorBar.direction;\n      var positiveHeight = this.chart.errorBarModule.positiveHeight;\n      var negativeHeight = this.chart.errorBarModule.negativeHeight;\n\n      if (this.isRectSeries(series)) {\n        if (position === 'Top' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n\n        if (position === 'Outer' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Plus') {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      } else {\n        if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n          if ((direction === 'Both' || direction === 'Plus') && !series.chart.isTransposed) {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n\n        if (position === 'Bottom' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      }\n    } else {\n      this.errorHeight = 0;\n    }\n  };\n\n  DataLabel.prototype.isRectSeries = function (series) {\n    return series.isRectSeries || series.type === 'RangeArea';\n  };\n  /**\n   * Render the data label for series.\n   * @return {void}\n   */\n\n\n  DataLabel.prototype.render = function (series, chart, dataLabel) {\n    var _this = this; // initialize the private variable\n\n\n    this.initPrivateVariables(series, series.marker);\n    var rect;\n    var rgbValue;\n    var contrast;\n    var argsData;\n    var border;\n    var textSize;\n    this.inverted = chart.requireInvertedAxis;\n    this.yAxisInversed = series.yAxis.isInversed;\n    var redraw = chart.redraw;\n    var templateId = chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n    var element = createElement('div', {\n      id: templateId\n    }); // Data label point iteration started\n\n    series.points.map(function (point, index) {\n      _this.margin = dataLabel.margin;\n      var labelText = [];\n      var labelLength;\n      var clip = series.clipRect;\n      var shapeRect;\n      border = {\n        width: dataLabel.border.width,\n        color: dataLabel.border.color\n      };\n      var argsFont = extend({}, getValue('properties', dataLabel.font), null, true);\n\n      if (point.symbolLocations.length && point.symbolLocations[0] || series.type === 'BoxAndWhisker' && point.regions.length) {\n        labelText = getLabelText(point, series, chart);\n        labelLength = labelText.length;\n\n        for (var i = 0; i < labelLength; i++) {\n          argsData = {\n            cancel: false,\n            name: textRender,\n            series: series,\n            point: point,\n            text: labelText[i],\n            border: border,\n            color: dataLabel.fill,\n            template: dataLabel.template,\n            font: argsFont\n          };\n          chart.trigger(textRender, argsData);\n\n          if (!argsData.cancel) {\n            _this.fontBackground = argsData.color;\n\n            _this.isDataLabelShape(argsData);\n\n            _this.markerHeight = series.type === 'Bubble' ? point.regions[0].height / 2 : _this.markerHeight;\n\n            if (argsData.template !== null) {\n              _this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i, redraw);\n            } else {\n              textSize = measureText(argsData.text, dataLabel.font);\n              rect = _this.calculateTextPosition(point, series, textSize, dataLabel, i);\n\n              if (!isCollide(rect, chart.dataLabelCollections, clip)) {\n                chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n\n                if (_this.isShape) {\n                  shapeRect = chart.renderer.drawRectangle(new RectOption(_this.commonId + index + '_TextShape_' + i, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));\n\n                  if (series.shapeElement) {\n                    series.shapeElement.appendChild(shapeRect);\n                  }\n                } // Checking the font color\n\n\n                rgbValue = convertHexToColor(colorNameToHex(_this.fontBackground));\n                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                textElement(chart.renderer, new TextOption(_this.commonId + index + '_Text_' + i, rect.x + _this.margin.left + textSize.width / 2, rect.y + _this.margin.top + textSize.height * 3 / 4, 'middle', argsData.text, 'rotate(0,' + rect.x + ',' + rect.y + ')', 'auto'), argsData.font, argsData.font.color || (contrast >= 128 || series.type === 'Hilo' ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect);\n              }\n            }\n          }\n        }\n      }\n    });\n\n    if (element.childElementCount) {\n      appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, false, 'x', 'y', null, '', false, false, null, chart.duration);\n    }\n  };\n  /**\n   * Render the data label template.\n   * @return {void}\n   * @private\n   */\n\n\n  DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n    this.margin = {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    };\n    var clip = series.clipRect;\n    var childElement = createTemplate(createElement('div', {\n      id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_' + point.index + (labelIndex ? '_' + labelIndex : ''),\n      styles: 'position: absolute;background-color:' + data.color + ';' + getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n    }), point.index, data.template, this.chart, point, series);\n    var elementRect = measureElementRect(childElement, redraw);\n    var rect = this.calculateTextPosition(point, series, {\n      width: elementRect.width,\n      height: elementRect.height\n    }, dataLabel, labelIndex);\n    childElement.style.left = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x + 'px';\n    childElement.style.top = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + 'px';\n    var rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n    var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n    var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n    childElement.style.color = dataLabel.font.color || (Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000) >= 128 ? 'black' : 'white');\n\n    if (childElement.childElementCount && !isCollide(rect, this.chart.dataLabelCollections, clip) && (series.seriesType !== 'XY' || point.yValue === undefined || withIn(point.yValue, series.yAxis.visibleRange) || series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange)) && withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y && parseFloat(childElement.style.left) >= hAxis.rect.x && parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height && parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n      this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n      appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n\n      if (series.animation.enable && this.chart.animateSeries) {\n        this.doDataLabelAnimation(series, childElement);\n      }\n    }\n  };\n\n  DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n    var labelRegion = labelIndex > 1 ? series.type === 'Candle' ? point.regions[1] : point.regions[0] : point.regions[0];\n\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n\n    var location;\n    location = this.getLabelLocation(point, series, textSize, labelIndex);\n    var padding = 5;\n    var clipRect = series.clipRect;\n    var rect; // calculating alignment\n\n    if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n      this.locationX = location.x;\n      var alignmentValue = textSize.height + this.borderWidth * 2 + this.markerHeight + this.margin.bottom + this.margin.top + padding;\n      location.y = dataLabel.position === 'Auto' ? location.y : this.calculateAlignment(alignmentValue, location.y, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false); // calculating position\n\n      location.y = !this.isRectSeries(series) || series.type === 'BoxAndWhisker' ? this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) : this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n\n      if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n        location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex);\n      }\n    } else {\n      this.locationY = location.y;\n      var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n      location.x = dataLabel.position === 'Auto' ? location.x : this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n      location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n    }\n\n    rect = calculateRect(location, textSize, this.margin); // Checking the condition whether data Label has been exist the clip rect\n\n    if (!(rect.y > clipRect.height || rect.x > clipRect.width || rect.x + rect.width < 0 || rect.y + rect.height < 0)) {\n      rect.x = rect.x < 0 ? padding : rect.x;\n      rect.y = rect.y < 0 ? padding : rect.y;\n      rect.x -= rect.x + rect.width > clipRect.width ? rect.x + rect.width - clipRect.width + padding : 0;\n      rect.y -= rect.y + rect.height > clipRect.height ? rect.y + rect.height - clipRect.height + padding : 0;\n      this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n    }\n\n    return rect;\n  }; // Calculation label location for polar column draw types\n\n\n  DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex) {\n    var padding = 5;\n    var columnRadius;\n    var angle = point.regionData.startAngle - 0.5 * Math.PI + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n\n    if (labelIndex === 0) {\n      columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    } else {\n      columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    }\n\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n\n    if (series.drawType.indexOf('Stacking') > -1) {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.drawType.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    }\n\n    if (position === 'Outer') {\n      columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight : columnRadius - 2 * padding - this.markerHeight;\n    } else if (position === 'Middle') {\n      columnRadius = columnRadius / 2 + padding;\n    } else if (position === 'Top') {\n      columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight : columnRadius + 2 * padding + this.markerHeight;\n    } else if (position === 'Bottom') {\n      columnRadius = padding;\n    } else {\n      if (labelIndex === 0) {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding : series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n      } else {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n      }\n    }\n\n    location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);\n    location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n    return location;\n  };\n  /**\n   * Get the label location\n   */\n\n\n  DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n    var location = new ChartLocation(0, 0);\n    var labelRegion = series.type === 'Candle' && labelIndex > 1 ? point.regions[1] : point.regions[0];\n\n    if (series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n\n    var xAxis = series.xAxis;\n    var yAxis = series.yAxis;\n    var isInverted = series.chart.requireInvertedAxis;\n\n    if (series.type === 'BoxAndWhisker') {\n      this.markerHeight = 0;\n\n      switch (labelIndex) {\n        case 0:\n          location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n          break;\n\n        case 1:\n          location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n          break;\n\n        case 2:\n          location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n          break;\n\n        case 3:\n          location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n          break;\n\n        case 4:\n          location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n          break;\n\n        default:\n          {\n            location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n            this.markerHeight = series.marker.height / 2;\n            break;\n          }\n      }\n\n      if (isInverted) {\n        location.y = point.regions[0].y + point.regions[0].height / 2;\n      } else {\n        location.x = point.regions[0].x + point.regions[0].width / 2;\n      }\n    } else if (labelIndex === 0 || labelIndex === 1) {\n      location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n    } else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n      location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n    } else if (isInverted) {\n      location = {\n        x: labelRegion.x + labelRegion.width / 2,\n        y: labelRegion.y\n      };\n    } else {\n      location = {\n        x: labelRegion.x + labelRegion.width,\n        y: labelRegion.y + labelRegion.height / 2\n      };\n    } //Aligning the label at the beginning of the tick, when tick size is less than text size\n\n\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      if (series.chart.requireInvertedAxis) {\n        var height = labelRegion.height;\n        location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      } else {\n        var width = labelRegion.width;\n        location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      }\n    }\n\n    return location;\n  };\n\n  DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n    if (series.chart.chartAreaType === 'PolarRadar') {\n      return null;\n    }\n\n    var padding = 5;\n    var margin = this.margin;\n    var textLength = !this.inverted ? textSize.height : textSize.width;\n    var extraSpace = this.borderWidth + textLength / 2 + padding;\n\n    if (series.type.indexOf('Stacking') > -1) {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.type.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    } else if (series.type === 'Waterfall') {\n      position = position === 'Auto' ? 'Middle' : position;\n    }\n\n    switch (position) {\n      case 'Bottom':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height + extraSpace + margin.top : labelLocation + rect.height - extraSpace - margin.bottom : isMinus ? labelLocation + rect.width - extraSpace - margin.left : labelLocation - rect.width + extraSpace + margin.right;\n        break;\n\n      case 'Middle':\n        labelLocation = labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height / 2 : labelLocation + rect.height / 2 : isMinus ? labelLocation + rect.width / 2 : labelLocation - rect.width / 2;\n        break;\n\n      case 'Auto':\n        labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n        break;\n\n      default:\n        extraSpace += this.errorHeight;\n        labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);\n        break;\n    }\n\n    var check = !this.inverted ? labelLocation < rect.y || labelLocation > rect.y + rect.height : labelLocation < rect.x || labelLocation > rect.x + rect.width;\n    this.fontBackground = check ? this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground : this.fontBackground === 'transparent' ? point.color || series.interior : this.fontBackground;\n    return labelLocation;\n  };\n\n  DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n    var padding = 5;\n\n    if (series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n      position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n    }\n\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n\n    switch (position) {\n      case 'Top':\n      case 'Outer':\n        labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding - this.errorHeight;\n        break;\n\n      case 'Bottom':\n        labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding + this.errorHeight;\n        break;\n\n      case 'Auto':\n        labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n        break;\n    }\n\n    return labelLocation;\n  };\n\n  DataLabel.prototype.isDataLabelShape = function (style) {\n    this.isShape = style.color !== 'transparent' || style.border.width > 0;\n    this.borderWidth = style.border.width;\n\n    if (!this.isShape) {\n      this.margin = {\n        left: 0,\n        right: 0,\n        bottom: 0,\n        top: 0\n      };\n    }\n  };\n\n  DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n    var location;\n    var labelRect;\n    var isOverLap = true;\n    var position = 0;\n    var collection = this.chart.dataLabelCollections;\n    var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n\n    while (isOverLap && position < finalPosition) {\n      location = this.calculateRectPosition(labelLocation, rect, isMinus, this.getPosition(position), series, size, labelIndex, point);\n\n      if (!this.inverted) {\n        labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n        isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n      } else {\n        labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n        isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.x + labelRect.width > series.clipRect.width;\n      }\n\n      position++;\n    }\n\n    return location;\n  }; // alignment calculation assigned here\n\n\n  DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n    switch (alignment) {\n      case 'Far':\n        labelLocation = !this.inverted ? isMinus ? labelLocation + value : labelLocation - value : isMinus ? labelLocation - value : labelLocation + value;\n        break;\n\n      case 'Near':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - value : labelLocation + value : isMinus ? labelLocation + value : labelLocation - value;\n        break;\n\n      case 'Center':\n        labelLocation = labelLocation;\n        break;\n    }\n\n    return labelLocation;\n  }; //calculation for top and outer position of datalabel for rect series\n\n\n  DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {\n    var margin = this.margin;\n    var top;\n\n    switch (series.type) {\n      case 'RangeColumn':\n      case 'RangeArea':\n      case 'Hilo':\n        top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        break;\n\n      case 'Candle':\n        top = (index === 0 || index === 2) && !this.yAxisInversed || (index === 1 || index === 3) && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n        break;\n\n      case 'HiloOpenClose':\n        if (index <= 1) {\n          top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n          location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        } else {\n          if (this.yAxisInversed) {\n            location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n          } else {\n            location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n          }\n        }\n\n        break;\n\n      default:\n        if (isMinus && position === 'Top' || !isMinus && position === 'Outer') {\n          location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.left + this.markerHeight;\n        } else {\n          location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n        }\n\n        break;\n    }\n\n    return location;\n  };\n  /**\n   * Updates the label location\n   */\n\n\n  DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n    if (inside === void 0) {\n      inside = false;\n    }\n\n    if (!this.inverted) {\n      if (top) {\n        location = position === 'Outer' && !inside ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.top + this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location + rect.height + extraSpace + margin.top + this.markerHeight : location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n      }\n    } else {\n      if (top) {\n        location = position === 'Outer' && !inside ? location + extraSpace + margin.left + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location - rect.width - extraSpace - margin.right - this.markerHeight : location - rect.width + extraSpace + margin.left + this.markerHeight;\n      }\n    }\n\n    return location;\n  };\n\n  DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n    var points = series.points;\n    var index = point.index;\n    var yValue = points[index].yValue;\n    var position;\n    var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n    var previousPoint = index > 0 ? points[index - 1] : null;\n    var yLocation;\n    var isOverLap = true;\n    var labelRect;\n    var isBottom;\n    var positionIndex;\n    var collection = this.chart.dataLabelCollections;\n\n    if (series.type === 'Bubble') {\n      position = 'Top';\n    } else if (series.type.indexOf('Step') > -1) {\n      position = 'Top';\n\n      if (index) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue !== this.yAxisInversed || yValue === previousPoint.yValue ? 'Top' : 'Bottom';\n      }\n    } else if (series.type === 'BoxAndWhisker') {\n      if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n        position = series.yAxis.isInversed ? 'Bottom' : 'Top';\n      } else if (labelIndex === 2 || labelIndex === 4) {\n        position = series.yAxis.isInversed ? 'Top' : 'Bottom';\n      } else {\n        isOverLap = false;\n        position = 'Middle';\n        yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n      }\n    } else {\n      if (index === 0) {\n        position = !nextPoint || !nextPoint.visible || yValue > nextPoint.yValue || yValue < nextPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else if (index === points.length - 1) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue || yValue < previousPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else {\n        if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n          position = 'Top';\n        } else if (!nextPoint.visible || !previousPoint) {\n          position = nextPoint.yValue > yValue || previousPoint && previousPoint.yValue > yValue ? 'Bottom' : 'Top';\n        } else {\n          var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n          var intersectY = slope * index + (nextPoint.yValue - slope * (index + 1));\n          position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' : intersectY < yValue ? 'Bottom' : 'Top';\n        }\n      }\n    }\n\n    isBottom = position === 'Bottom';\n    positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n\n    while (isOverLap && positionIndex < 4) {\n      yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n      labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n      isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y + labelRect.height > series.clipRect.height;\n      positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n      isBottom = false;\n    }\n\n    return yLocation;\n  };\n  /**\n   * Animates the data label.\n   * @param  {Series} series - Data label of the series gets animated.\n   * @return {void}\n   */\n\n\n  DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n    var shapeElements = series.shapeElement.childNodes;\n    var textNode = series.textElement.childNodes;\n    var delay = series.animation.delay + series.animation.duration;\n    var duration = series.chart.animated ? series.chart.duration : 200;\n    var location;\n    var length = element ? 1 : textNode.length;\n    var tempElement;\n\n    for (var i = 0; i < length; i++) {\n      tempElement = textNode[i];\n\n      if (element) {\n        element.style.visibility = 'hidden';\n        templateAnimate(element, delay, duration, 'ZoomIn');\n      } else {\n        location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n        markerAnimate(tempElement, delay, duration, series, null, location, true);\n\n        if (shapeElements[i]) {\n          tempElement = shapeElements[i];\n          location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n          markerAnimate(tempElement, delay, duration, series, null, location, true);\n        }\n      }\n    }\n  };\n\n  DataLabel.prototype.getPosition = function (index) {\n    return ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index];\n  };\n  /**\n   * Get module name.\n   */\n\n\n  DataLabel.prototype.getModuleName = function () {\n    // Returns the module name\n    return 'DataLabel';\n  };\n  /**\n   * To destroy the dataLabel for series.\n   * @return {void}\n   * @private\n   */\n\n\n  DataLabel.prototype.destroy = function (chart) {// Destroy method performed here\n  };\n\n  return DataLabel;\n}();\n\nexport { DataLabel };","map":null,"metadata":{},"sourceType":"module"}