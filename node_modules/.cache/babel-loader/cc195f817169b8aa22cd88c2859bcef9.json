{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport PieSegment from './pie-segment';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport { ChartElement, Ring, Box, Point } from '../../core';\nimport { OUTSIDE_END, FADEIN, COLUMN } from '../constants';\nimport { bindSegments, evalOptions } from '../utils';\nimport { CIRCLE, RIGHT, CENTER } from '../../common/constants';\nimport { deepExtend, defined, isFunction, last, round, setDefaultOptions, valueOrDefault } from '../../common';\nvar PIE_SECTOR_ANIM_DELAY = 70;\n\nvar PieChart = function (ChartElement) {\n  function PieChart(plotArea, options) {\n    ChartElement.call(this, options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this.points = [];\n    this.legendItems = [];\n    this.render();\n  }\n\n  if (ChartElement) PieChart.__proto__ = ChartElement;\n  PieChart.prototype = Object.create(ChartElement && ChartElement.prototype);\n  PieChart.prototype.constructor = PieChart;\n\n  PieChart.prototype.render = function render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  };\n\n  PieChart.prototype.traverseDataPoints = function traverseDataPoints(callback) {\n    var this$1 = this;\n    var ref = this;\n    var options = ref.options;\n    var seriesColors = ref.plotArea.options.seriesColors;\n    if (seriesColors === void 0) seriesColors = [];\n    var colorsCount = seriesColors.length;\n    var series = options.series;\n    var seriesCount = series.length;\n\n    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      var currentSeries = series[seriesIx];\n      var data = currentSeries.data;\n      var ref$1 = bindSegments(currentSeries);\n      var total = ref$1.total;\n      var points = ref$1.points;\n      var count = ref$1.count;\n      var anglePerValue = 360 / total;\n      var constantAngle = void 0;\n\n      if (!isFinite(anglePerValue)) {\n        constantAngle = 360 / count;\n      }\n\n      var currentAngle = void 0;\n\n      if (defined(currentSeries.startAngle)) {\n        currentAngle = currentSeries.startAngle;\n      } else {\n        currentAngle = options.startAngle;\n      }\n\n      if (seriesIx !== seriesCount - 1) {\n        if (currentSeries.labels.position === OUTSIDE_END) {\n          currentSeries.labels.position = CENTER;\n        }\n      }\n\n      for (var i = 0; i < points.length; i++) {\n        var pointData = points[i];\n\n        if (!pointData) {\n          continue;\n        }\n\n        var fields = pointData.fields;\n        var value = pointData.value;\n        var visible = pointData.visible;\n        var angle = value !== 0 ? constantAngle || value * anglePerValue : 0;\n        var explode = data.length !== 1 && Boolean(fields.explode);\n\n        if (!isFunction(currentSeries.color)) {\n          currentSeries.color = fields.color || seriesColors[i % colorsCount];\n        }\n\n        callback(pointData.valueFields.value, new Ring(null, 0, 0, currentAngle, angle), {\n          owner: this$1,\n          category: defined(fields.category) ? fields.category : \"\",\n          index: i,\n          series: currentSeries,\n          seriesIx: seriesIx,\n          dataItem: data[i],\n          percentage: total !== 0 ? value / total : 0,\n          explode: explode,\n          visibleInLegend: fields.visibleInLegend,\n          visible: visible,\n          zIndex: seriesCount - seriesIx,\n          animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)\n        });\n\n        if (visible !== false) {\n          currentAngle += angle;\n        }\n      }\n    }\n  };\n\n  PieChart.prototype.evalSegmentOptions = function evalSegmentOptions(options, value, fields) {\n    var series = fields.series;\n    evalOptions(options, {\n      value: value,\n      series: series,\n      dataItem: fields.dataItem,\n      category: fields.category,\n      percentage: fields.percentage\n    }, {\n      defaults: series._defaults,\n      excluded: [\"data\", \"content\", \"template\", \"visual\", \"toggle\"]\n    });\n  };\n\n  PieChart.prototype.addValue = function addValue(value, sector, fields) {\n    var segmentOptions = deepExtend({}, fields.series, {\n      index: fields.index\n    });\n    this.evalSegmentOptions(segmentOptions, value, fields);\n    this.createLegendItem(value, segmentOptions, fields);\n\n    if (fields.visible === false) {\n      return;\n    }\n\n    var segment = new PieSegment(value, sector, segmentOptions);\n    Object.assign(segment, fields);\n    this.append(segment);\n    this.points.push(segment);\n  };\n\n  PieChart.prototype.reflow = function reflow(targetBox) {\n    var ref = this;\n    var options = ref.options;\n    var points = ref.points;\n    var seriesConfigs = ref.seriesConfigs;\n    if (seriesConfigs === void 0) seriesConfigs = [];\n    var count = points.length;\n    var box = targetBox.clone();\n    var space = 5;\n    var minWidth = Math.min(box.width(), box.height());\n    var halfMinWidth = minWidth / 2;\n    var defaultPadding = minWidth - minWidth * 0.85;\n    var newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n    var newBoxCenter = newBox.center();\n    var boxCenter = box.center();\n    var seriesCount = options.series.length;\n    var leftSideLabels = [];\n    var rightSideLabels = [];\n    var padding = valueOrDefault(options.padding, defaultPadding);\n    this.targetBox = targetBox;\n    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n    var radius = halfMinWidth - padding;\n    var center = new Point(radius + newBox.x1 + padding, radius + newBox.y1 + padding);\n\n    for (var i = 0; i < count; i++) {\n      var segment = points[i];\n      var sector = segment.sector;\n      var seriesIndex = segment.seriesIx;\n      sector.radius = radius;\n      sector.center = center;\n\n      if (seriesConfigs.length) {\n        var seriesConfig = seriesConfigs[seriesIndex];\n        sector.innerRadius = seriesConfig.innerRadius;\n        sector.radius = seriesConfig.radius;\n      }\n\n      if (seriesIndex === seriesCount - 1 && segment.explode) {\n        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n      }\n\n      segment.reflow(newBox);\n      var label = segment.label;\n\n      if (label) {\n        if (label.options.position === OUTSIDE_END) {\n          if (seriesIndex === seriesCount - 1) {\n            if (label.orientation === RIGHT) {\n              rightSideLabels.push(label);\n            } else {\n              leftSideLabels.push(label);\n            }\n          }\n        }\n      }\n    }\n\n    if (leftSideLabels.length > 0) {\n      leftSideLabels.sort(this.labelComparator(true));\n      this.leftLabelsReflow(leftSideLabels);\n    }\n\n    if (rightSideLabels.length > 0) {\n      rightSideLabels.sort(this.labelComparator(false));\n      this.rightLabelsReflow(rightSideLabels);\n    }\n\n    this.box = newBox;\n  };\n\n  PieChart.prototype.leftLabelsReflow = function leftLabelsReflow(labels) {\n    var distances = this.distanceBetweenLabels(labels);\n    this.distributeLabels(distances, labels);\n  };\n\n  PieChart.prototype.rightLabelsReflow = function rightLabelsReflow(labels) {\n    var distances = this.distanceBetweenLabels(labels);\n    this.distributeLabels(distances, labels);\n  };\n\n  PieChart.prototype.distanceBetweenLabels = function distanceBetweenLabels(labels) {\n    var segment = last(this.points);\n    var sector = segment.sector;\n    var count = labels.length - 1;\n    var lr = sector.radius + segment.options.labels.distance;\n    var distances = [];\n    var firstBox = labels[0].box;\n    var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n    distances.push(distance);\n\n    for (var i = 0; i < count; i++) {\n      var secondBox = labels[i + 1].box;\n      firstBox = labels[i].box;\n      distance = round(secondBox.y1 - firstBox.y2);\n      distances.push(distance);\n    }\n\n    distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n    distances.push(distance);\n    return distances;\n  };\n\n  PieChart.prototype.distributeLabels = function distributeLabels(distances, labels) {\n    var this$1 = this;\n    var count = distances.length;\n    var left, right, remaining;\n\n    for (var i = 0; i < count; i++) {\n      remaining = -distances[i];\n      left = right = i;\n\n      while (remaining > 0 && (left >= 0 || right < count)) {\n        remaining = this$1._takeDistance(distances, i, --left, remaining);\n        remaining = this$1._takeDistance(distances, i, ++right, remaining);\n      }\n    }\n\n    this.reflowLabels(distances, labels);\n  };\n\n  PieChart.prototype._takeDistance = function _takeDistance(distances, anchor, position, amount) {\n    var result = amount;\n\n    if (distances[position] > 0) {\n      var available = Math.min(distances[position], result);\n      result -= available;\n      distances[position] -= available;\n      distances[anchor] += available;\n    }\n\n    return result;\n  };\n\n  PieChart.prototype.reflowLabels = function reflowLabels(distances, labels) {\n    var this$1 = this;\n    var segment = last(this.points);\n    var sector = segment.sector;\n    var labelOptions = segment.options.labels;\n    var labelsCount = labels.length;\n    var labelDistance = labelOptions.distance;\n    var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n    var boxX;\n    distances[0] += 2;\n\n    for (var i = 0; i < labelsCount; i++) {\n      var label = labels[i];\n      var box = label.box;\n      boxY += distances[i];\n      boxX = this$1.hAlignLabel(box.x2, sector.clone().expand(labelDistance), boxY, boxY + box.height(), label.orientation === RIGHT);\n\n      if (label.orientation === RIGHT) {\n        if (labelOptions.align !== CIRCLE) {\n          boxX = sector.radius + sector.center.x + labelDistance;\n        }\n\n        label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n      } else {\n        if (labelOptions.align !== CIRCLE) {\n          boxX = sector.center.x - sector.radius - labelDistance;\n        }\n\n        label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n      }\n\n      boxY += box.height();\n    }\n  };\n\n  PieChart.prototype.createVisual = function createVisual() {\n    var this$1 = this;\n    var ref = this;\n    var connectors = ref.options.connectors;\n    var points = ref.points;\n    var count = points.length;\n    var space = 4;\n    ChartElement.prototype.createVisual.call(this);\n    this._connectorLines = [];\n\n    for (var i = 0; i < count; i++) {\n      var segment = points[i];\n      var sector = segment.sector;\n      var label = segment.label;\n      var angle = sector.middle();\n      var connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n\n      if (label) {\n        var connectorLine = new draw.Path({\n          stroke: {\n            color: connectorsColor,\n            width: connectors.width\n          },\n          animation: {\n            type: FADEIN,\n            delay: segment.animationDelay\n          }\n        });\n\n        if (label.options.position === OUTSIDE_END) {\n          var box = label.box;\n          var centerPoint = sector.center;\n          var start = sector.point(angle);\n          var middle = new Point(box.x1, box.center().y);\n          var sr = void 0,\n              end = void 0,\n              crossing = void 0;\n          start = sector.clone().expand(connectors.padding).point(angle);\n          connectorLine.moveTo(start.x, start.y); // TODO: Extract into a method to remove duplication\n\n          if (label.orientation === RIGHT) {\n            end = new Point(box.x1 - connectors.padding, box.center().y);\n            crossing = intersection(centerPoint, start, middle, end);\n            middle = new Point(end.x - space, end.y);\n            crossing = crossing || middle;\n            crossing.x = Math.min(crossing.x, middle.x);\n\n            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {\n              sr = sector.center.x + sector.radius + space;\n\n              if (segment.options.labels.align !== COLUMN) {\n                if (sr < middle.x) {\n                  connectorLine.lineTo(sr, start.y);\n                } else {\n                  connectorLine.lineTo(start.x + space * 2, start.y);\n                }\n              } else {\n                connectorLine.lineTo(sr, start.y);\n              }\n\n              connectorLine.lineTo(middle.x, end.y);\n            } else {\n              crossing.y = end.y;\n              connectorLine.lineTo(crossing.x, crossing.y);\n            }\n          } else {\n            end = new Point(box.x2 + connectors.padding, box.center().y);\n            crossing = intersection(centerPoint, start, middle, end);\n            middle = new Point(end.x + space, end.y);\n            crossing = crossing || middle;\n            crossing.x = Math.max(crossing.x, middle.x);\n\n            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {\n              sr = sector.center.x - sector.radius - space;\n\n              if (segment.options.labels.align !== COLUMN) {\n                if (sr > middle.x) {\n                  connectorLine.lineTo(sr, start.y);\n                } else {\n                  connectorLine.lineTo(start.x - space * 2, start.y);\n                }\n              } else {\n                connectorLine.lineTo(sr, start.y);\n              }\n\n              connectorLine.lineTo(middle.x, end.y);\n            } else {\n              crossing.y = end.y;\n              connectorLine.lineTo(crossing.x, crossing.y);\n            }\n          }\n\n          connectorLine.lineTo(end.x, end.y);\n\n          this$1._connectorLines.push(connectorLine);\n\n          this$1.visual.append(connectorLine);\n        }\n      }\n    }\n  };\n\n  PieChart.prototype.renderVisual = function renderVisual() {\n    ChartElement.prototype.renderVisual.call(this);\n\n    if (this.options.series.find(function (options) {\n      return options.autoFit;\n    })) {\n      var rect = this.targetBox.toRect();\n      draw.fit(this.visual, rect);\n      var transform = this.visual.transform();\n\n      if (transform) {\n        draw.align([this.visual], rect, 'center');\n        var pieBox = this.box.toRect().transformCopy(transform); //transformed pie box\n\n        transform.matrix().f += rect.center().y - pieBox.center().y; // move to targetbox center\n      }\n    }\n  };\n\n  PieChart.prototype.labelComparator = function labelComparator(reverse) {\n    var reverseValue = reverse ? -1 : 1;\n    return function (a, b) {\n      var first = (a.parent.sector.middle() + 270) % 360;\n      var second = (b.parent.sector.middle() + 270) % 360;\n      return (first - second) * reverseValue;\n    };\n  };\n\n  PieChart.prototype.hAlignLabel = function hAlignLabel(originalX, sector, y1, y2, direction) {\n    var radius = sector.radius;\n    var sector_center = sector.center;\n    var cx = sector_center.x;\n    var cy = sector_center.y;\n    var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n\n    if (t > radius) {\n      return originalX;\n    }\n\n    return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);\n  };\n\n  PieChart.prototype.pointInCircle = function pointInCircle(point, center, radius) {\n    return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n  };\n\n  PieChart.prototype.formatPointValue = function formatPointValue(point, format) {\n    return this.chartService.format.auto(format, point.value);\n  };\n\n  PieChart.prototype.animationDelay = function animationDelay(categoryIndex) {\n    return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n  };\n\n  PieChart.prototype.stackRoot = function stackRoot() {\n    return this;\n  };\n\n  return PieChart;\n}(ChartElement);\n\nfunction intersection(a1, a2, b1, b2) {\n  var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n  var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n  var result;\n\n  if (ub !== 0) {\n    var ua = uat / ub;\n    result = new Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y));\n  }\n\n  return result;\n}\n\nsetDefaultOptions(PieChart, {\n  startAngle: 90,\n  connectors: {\n    width: 2,\n    color: \"#939393\",\n    padding: 8\n  },\n  inactiveItems: {\n    markers: {},\n    labels: {}\n  }\n});\ndeepExtend(PieChart.prototype, PieChartMixin);\nPieChart.prototype.isStackRoot = true;\nexport default PieChart;","map":null,"metadata":{},"sourceType":"module"}