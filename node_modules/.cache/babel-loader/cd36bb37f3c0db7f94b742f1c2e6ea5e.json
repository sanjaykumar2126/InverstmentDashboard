{"ast":null,"code":"import Box from './box';\nimport Point from './point';\nimport { COORD_PRECISION, MAX_VALUE, MIN_VALUE } from '../common/constants';\nimport { Class, clockwise, rad, round } from '../common';\n\nvar Ring = function (Class) {\n  function Ring(center, innerRadius, radius, startAngle, angle) {\n    Class.call(this);\n    this.center = center;\n    this.innerRadius = innerRadius;\n    this.radius = radius;\n    this.startAngle = startAngle;\n    this.angle = angle;\n  }\n\n  if (Class) Ring.__proto__ = Class;\n  Ring.prototype = Object.create(Class && Class.prototype);\n  Ring.prototype.constructor = Ring;\n\n  Ring.prototype.clone = function clone() {\n    return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n  };\n\n  Ring.prototype.middle = function middle() {\n    return this.startAngle + this.angle / 2;\n  };\n\n  Ring.prototype.setRadius = function setRadius(newRadius, innerRadius) {\n    if (innerRadius) {\n      this.innerRadius = newRadius;\n    } else {\n      this.radius = newRadius;\n    }\n\n    return this;\n  }; // TODO: Remove and replace with Point.onCircle\n\n\n  Ring.prototype.point = function point(angle, innerRadius) {\n    var radianAngle = rad(angle);\n    var ax = Math.cos(radianAngle);\n    var ay = Math.sin(radianAngle);\n    var radius = innerRadius ? this.innerRadius : this.radius;\n    var x = round(this.center.x - ax * radius, COORD_PRECISION);\n    var y = round(this.center.y - ay * radius, COORD_PRECISION);\n    return new Point(x, y);\n  };\n\n  Ring.prototype.adjacentBox = function adjacentBox(distance, width, height) {\n    var sector = this.clone().expand(distance);\n    var midAndle = sector.middle();\n    var midPoint = sector.point(midAndle);\n    var hw = width / 2;\n    var hh = height / 2;\n    var sa = Math.sin(rad(midAndle));\n    var ca = Math.cos(rad(midAndle));\n    var x = midPoint.x - hw;\n    var y = midPoint.y - hh;\n\n    if (Math.abs(sa) < 0.9) {\n      x += hw * -ca / Math.abs(ca);\n    }\n\n    if (Math.abs(ca) < 0.9) {\n      y += hh * -sa / Math.abs(sa);\n    }\n\n    return new Box(x, y, x + width, y + height);\n  };\n\n  Ring.prototype.containsPoint = function containsPoint(p) {\n    var center = this.center;\n    var innerRadius = this.innerRadius;\n    var radius = this.radius;\n    var startAngle = this.startAngle;\n    var endAngle = this.startAngle + this.angle;\n    var dx = p.x - center.x;\n    var dy = p.y - center.y;\n    var vector = new Point(dx, dy);\n    var startPoint = this.point(startAngle);\n    var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n    var endPoint = this.point(endAngle);\n    var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n    var dist = round(dx * dx + dy * dy, COORD_PRECISION);\n    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;\n  };\n\n  Ring.prototype.getBBox = function getBBox() {\n    var this$1 = this;\n    var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n    var startAngle = round(this.startAngle % 360);\n    var endAngle = round((startAngle + this.angle) % 360);\n    var innerRadius = this.innerRadius;\n    var allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);\n    var startAngleIndex = allAngles.indexOf(startAngle);\n    var endAngleIndex = allAngles.indexOf(endAngle);\n    var angles;\n\n    if (startAngle === endAngle) {\n      angles = allAngles;\n    } else {\n      if (startAngleIndex < endAngleIndex) {\n        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n      } else {\n        angles = [].concat(allAngles.slice(0, endAngleIndex + 1), allAngles.slice(startAngleIndex, allAngles.length));\n      }\n    }\n\n    for (var i = 0; i < angles.length; i++) {\n      var point = this$1.point(angles[i]);\n      box.wrapPoint(point);\n      box.wrapPoint(point, innerRadius);\n    }\n\n    if (!innerRadius) {\n      box.wrapPoint(this.center);\n    }\n\n    return box;\n  };\n\n  Ring.prototype.expand = function expand(value) {\n    this.radius += value;\n    return this;\n  };\n\n  return Ring;\n}(Class);\n\nfunction numericComparer(a, b) {\n  return a - b;\n}\n\nexport default Ring;","map":null,"metadata":{},"sourceType":"module"}