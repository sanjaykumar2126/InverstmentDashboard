{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Component, Complex, NotifyPropertyChanges, Property } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined, Browser } from '@syncfusion/ej2-base';\nimport { createElement, remove, Event, EventHandler } from '@syncfusion/ej2-base';\nimport { createSvg, RectOption, measureText, TextOption, renderTextElement } from '../smithchart/utils/helper';\nimport { removeElement, textTrim } from '../smithchart/utils/helper';\nimport { SmithchartRect } from '../smithchart/utils/utils';\nimport { SmithchartMargin, SmithchartBorder, SmithchartFont } from '../smithchart/utils/utils';\nimport { getThemeColor } from '../smithchart/model/theme';\nimport { SmithchartLegendSettings } from '../smithchart/legend/legend';\nimport { SmithchartAxis } from '../smithchart/axis/axis';\nimport { Title } from '../smithchart/title/title';\nimport { SmithchartSeries } from '../smithchart/series/series';\nimport { AreaBounds } from '../smithchart/utils/area';\nimport { AxisRender } from '../smithchart/axis/axisrender';\nimport { SeriesRender } from '../smithchart/series/seriesrender';\nimport { Collection } from '@syncfusion/ej2-base';\nimport { getSeriesColor } from '../smithchart/model/theme';\nimport { ExportUtils } from '../smithchart/utils/export';\nimport { titleRender, subtitleRender } from '../smithchart/model/constant';\n/* tslint:disable:no-string-literal */\n\n/**\n * Represents the Smithchart control.\n * ```html\n * <div id=\"smithchart\"/>\n * <script>\n *   var chartObj = new Smithchart({ isResponsive : true });\n *   chartObj.appendTo(\"#smithchart\");\n * </script>\n * ```\n */\n\nvar Smithchart =\n/** @class */\nfunction (_super) {\n  __extends(Smithchart, _super);\n  /**\n   * Constructor for creating the Smithchart widget\n   */\n\n\n  function Smithchart(options, element) {\n    return _super.call(this, options, element) || this;\n  }\n  /**\n   * Get component name\n   */\n\n\n  Smithchart.prototype.getModuleName = function () {\n    return 'smithchart';\n  };\n  /**\n   * Get the properties to be maintained in the persisted state.\n   * @private\n   */\n\n\n  Smithchart.prototype.getPersistData = function () {\n    return '';\n  };\n  /**\n   * Method to create SVG element.\n   */\n\n\n  Smithchart.prototype.createChartSvg = function () {\n    this.removeSvg();\n    createSvg(this);\n  };\n\n  Smithchart.prototype.renderTitle = function (title, type, groupEle) {\n    var font = title.font ? title.font : title.textStyle;\n    var textSize = measureText(title.text, font);\n    var x;\n    var y;\n    var textAlignment = title.textAlignment;\n    var titleText = title.text;\n    var maxTitleWidth = isNullOrUndefined(title.maximumWidth) ? Math.abs(this.margin.left + this.margin.right - this.availableSize.width) : title.maximumWidth;\n    var titleWidthEnable = textSize.width > maxTitleWidth ? true : false;\n\n    if (textSize.width > this.availableSize.width) {\n      x = this.margin.left + this.border.width;\n    } else {\n      x = textAlignment === 'Center' ? this.availableSize.width / 2 - textSize['width'] / 2 : textAlignment === 'Near' ? this.margin.left + this.elementSpacing + this.border.width : this.availableSize.width - textSize['width'] - (this.margin.right + this.elementSpacing + this.border.width);\n    }\n\n    y = this.margin.top + textSize['height'] / 2 + this.elementSpacing;\n\n    if (title.enableTrim && titleWidthEnable) {\n      titleText = textTrim(maxTitleWidth, title.text, font);\n      textSize = measureText(titleText, font);\n    }\n\n    groupEle = this.renderer.createGroup({\n      id: this.element.id + '_Title_Group'\n    });\n    var titleEventArgs = {\n      text: titleText,\n      x: x,\n      y: y,\n      name: 'titleRender',\n      cancel: false\n    };\n    this.trigger(titleRender, titleEventArgs);\n    var options = new TextOption(this.element.id + '_Smithchart_' + type, titleEventArgs.x, titleEventArgs.y, 'start', titleEventArgs.text);\n    font.fontFamily = this.themeStyle.fontFamily || title.textStyle.fontFamily;\n    font.size = this.themeStyle.fontSize || title.textStyle.size;\n    var element = renderTextElement(options, font, this.themeStyle.chartTitle, groupEle);\n    element.setAttribute('aria-label', title.description || title.text);\n    var titleLocation = {\n      x: x,\n      y: y,\n      textSize: textSize\n    };\n    this.svgObject.appendChild(groupEle);\n\n    if (title.subtitle.text !== '' && title.subtitle.visible) {\n      this.renderSubtitle(title, type, textSize, this.availableSize, titleLocation, groupEle);\n    }\n  };\n\n  Smithchart.prototype.renderSubtitle = function (title, type, textSize, size, titleLocation, groupEle) {\n    var x;\n    var y;\n    var font = title.subtitle.textStyle;\n    var subTitle = title.subtitle;\n    var subTitleSize = measureText(subTitle.text, font);\n    var textAnchor;\n    var subTitleText = subTitle.text;\n    var maxSubTitleWidth = isNullOrUndefined(subTitle.maximumWidth) ? this.bounds.width * 0.75 : subTitle.maximumWidth;\n\n    if (subTitle.enableTrim && subTitleSize.width > maxSubTitleWidth) {\n      subTitleText = textTrim(maxSubTitleWidth, subTitle.text, font);\n    }\n\n    x = title['subtitle'].textAlignment === 'Far' ? titleLocation.x + titleLocation.textSize.width : title['subtitle'].textAlignment === 'Near' ? titleLocation.x : titleLocation.x + titleLocation.textSize.width / 2;\n    y = titleLocation.y + 2 * this.elementSpacing;\n    textAnchor = title['subtitle'].textAlignment === 'Far' ? 'end' : title['subtitle'].textAlignment === 'Near' ? 'start' : 'middle';\n    var subtitleEventArgs = {\n      text: subTitleText,\n      x: x,\n      y: y,\n      name: 'subtitleRender',\n      cancel: false\n    };\n    this.trigger(subtitleRender, subtitleEventArgs);\n    var options = new TextOption(this.element.id + '_Smithchart_' + type, subtitleEventArgs.x, subtitleEventArgs.y, textAnchor, subtitleEventArgs.text);\n    var element = renderTextElement(options, font, this.themeStyle.chartTitle, groupEle);\n    element.setAttribute('aria-label', subTitle.description || subTitle.text);\n    groupEle.appendChild(element);\n  };\n  /**\n   * @private\n   * Render the smithchart border\n   */\n\n\n  Smithchart.prototype.renderBorder = function () {\n    var border = this.border;\n    var color = this.theme.toLowerCase() === 'highcontrast' ? '#000000' : '#FFFFFF';\n    this.background = this.background ? this.background : this.themeStyle.background;\n    var borderRect = new RectOption(this.element.id + '_SmithchartBorder', this.background, border, 1, new SmithchartRect(border.width / 2, border.width / 2, this.availableSize.width - border.width, this.availableSize.height - border.width));\n    this.svgObject.appendChild(this.renderer.drawRectangle(borderRect));\n  };\n  /**\n   * Called internally if any of the property value changed.\n   * @private\n   */\n\n\n  Smithchart.prototype.onPropertyChanged = function (newProp, oldProp) {\n    var renderer = false;\n\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'background':\n        case 'border':\n        case 'series':\n        case 'legendSettings':\n        case 'radius':\n          renderer = true;\n          break;\n\n        case 'size':\n          this.createChartSvg();\n          renderer = true;\n          break;\n\n        case 'theme':\n        case 'renderType':\n          this.animateSeries = true;\n          renderer = true;\n          break;\n      }\n    }\n\n    if (renderer) {\n      this.render();\n    }\n  };\n  /**\n   * Initialize the event handler.\n   */\n\n\n  Smithchart.prototype.preRender = function () {\n    var blazor = 'Blazor';\n    this.isBlazor = window[blazor];\n    this.trigger('load', {\n      smithchart: this\n    });\n    this.unWireEVents();\n    this.initPrivateVariable();\n    this.wireEVents();\n  };\n\n  Smithchart.prototype.initPrivateVariable = function () {\n    this.animateSeries = true;\n  };\n  /**\n   * To Initialize the control rendering.\n   */\n\n\n  Smithchart.prototype.setTheme = function () {\n    /*! Set theme */\n    this.themeStyle = getThemeColor(this.theme);\n    this.seriesColors = getSeriesColor(this.theme); // let count: number = colors.length;\n    // for (let i: number = 0; i < this.series.length; i++) {\n    //     this.series[i].fill = this.series[i].fill ? this.series[i].fill : colors[i % count];\n    // }\n  };\n\n  Smithchart.prototype.render = function () {\n    this.createChartSvg();\n    this.element.appendChild(this.svgObject);\n    this.setTheme();\n    this.createSecondaryElement();\n    this.renderBorder();\n\n    if (this.smithchartLegendModule && this.legendSettings.visible) {\n      this.legendBounds = this.smithchartLegendModule.renderLegend(this);\n    }\n\n    this.legendBounds = this.legendBounds ? this.legendBounds : {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    var areaBounds = new AreaBounds();\n    this.bounds = areaBounds.calculateAreaBounds(this, this.title, this.legendBounds);\n\n    if (this.title.text !== '' && this.title.visible) {\n      this.renderTitle(this.title, 'title', null);\n    }\n\n    var axisRender = new AxisRender();\n    axisRender.renderArea(this, this.bounds);\n    this.seriesrender = new SeriesRender();\n    this.seriesrender.draw(this, axisRender, this.bounds);\n    this.renderComplete();\n    this.trigger('loaded', {\n      smithchart: this.isBlazor ? null : this\n    });\n  };\n\n  Smithchart.prototype.createSecondaryElement = function () {\n    if (isNullOrUndefined(document.getElementById(this.element.id + '_Secondary_Element'))) {\n      var secondaryElement = createElement('div', {\n        id: this.element.id + '_Secondary_Element',\n        styles: 'position: absolute;z-index:1;'\n      });\n      this.element.appendChild(secondaryElement);\n      var rect = this.element.getBoundingClientRect();\n      var svgRect = document.getElementById(this.element.id + '_svg');\n\n      if (svgRect) {\n        var svgClientRect = svgRect.getBoundingClientRect();\n        secondaryElement.style.left = Math.max(svgClientRect.left - rect.left, 0) + 'px';\n        secondaryElement.style.top = Math.max(svgClientRect.top - rect.top, 0) + 'px';\n      }\n    } else {\n      removeElement(this.element.id + '_Secondary_Element');\n    }\n  };\n  /**\n   * To destroy the widget\n   * @method destroy\n   * @return {void}.\n   * @member of smithChart\n   */\n\n\n  Smithchart.prototype.destroy = function () {\n    this.unWireEVents();\n\n    _super.prototype.destroy.call(this);\n\n    this.element.classList.remove('e-smithchart');\n  };\n  /**\n   * To bind event handlers for smithchart.\n   */\n\n\n  Smithchart.prototype.wireEVents = function () {\n    EventHandler.add(this.element, 'click', this.smithchartOnClick, this);\n    EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMove, this);\n    EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEnd, this);\n    window.addEventListener(Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.smithchartOnResize.bind(this));\n  };\n\n  Smithchart.prototype.mouseMove = function (e) {\n    if (e.type === 'touchmove') {\n      this.isTouch = true;\n    } else {\n      this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;\n    }\n\n    if (this.tooltipRenderModule && !this.isTouch) {\n      this.tooltipRenderModule.smithchartMouseMove(this, e);\n    }\n  };\n\n  Smithchart.prototype.mouseEnd = function (e) {\n    if (e.type === 'touchend') {\n      this.isTouch = true;\n    } else {\n      this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';\n    }\n\n    if (this.tooltipRenderModule && this.isTouch) {\n      var tooltipElement_1 = this.tooltipRenderModule.smithchartMouseMove(this, e);\n\n      if (tooltipElement_1) {\n        this.fadeoutTo = setTimeout(function () {\n          tooltipElement_1.fadeOut();\n        }, 2000);\n      }\n    }\n  };\n  /**\n   * To handle the click event for the smithchart.\n   */\n\n  /* tslint:disable:no-string-literal */\n\n\n  Smithchart.prototype.smithchartOnClick = function (e) {\n    var targetEle = e.target;\n    var targetId = targetEle.id;\n    var parentElement = document.getElementById(targetId).parentElement;\n    var grpElement = document.getElementById(parentElement.id).parentElement;\n\n    if (grpElement.id === 'containerlegendItem_Group' && this.legendSettings.toggleVisibility) {\n      var childElement = parentElement.childNodes[1];\n      var circleElement = parentElement.childNodes[0];\n      var legendText = childElement.textContent;\n      var seriesIndex = void 0;\n      var fill = void 0;\n\n      for (var i = 0; i < this.smithchartLegendModule.legendSeries.length; i++) {\n        if (legendText === this.smithchartLegendModule.legendSeries[i]['text']) {\n          seriesIndex = this.smithchartLegendModule.legendSeries[i].seriesIndex;\n          fill = this.smithchartLegendModule.legendSeries[i].fill;\n        }\n      }\n\n      var seriesElement = document.getElementById(this.element.id + '_svg' + '_seriesCollection' + seriesIndex);\n\n      if (seriesElement.getAttribute('visibility') === 'visible') {\n        circleElement.setAttribute('fill', 'gray');\n        seriesElement.setAttribute('visibility', 'hidden');\n        this.series[seriesIndex].visibility = 'hidden';\n      } else {\n        circleElement.setAttribute('fill', fill);\n        seriesElement.setAttribute('visibility', 'visible');\n        this.series[seriesIndex].visibility = 'visible';\n      }\n    }\n  };\n  /**\n   * To unbind event handlers from smithchart.\n   */\n\n\n  Smithchart.prototype.unWireEVents = function () {\n    EventHandler.remove(this.element, 'click', this.smithchartOnClick);\n    EventHandler.remove(this.element, Browser.touchMoveEvent, this.mouseMove);\n    EventHandler.remove(this.element, Browser.touchEndEvent, this.mouseEnd);\n    window.removeEventListener(Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.smithchartOnResize);\n  };\n\n  Smithchart.prototype.print = function (id) {\n    var exportChart = new ExportUtils(this);\n    exportChart.print(id);\n  };\n  /**\n   * Handles the export method for chart control.\n   * @param type\n   * @param fileName\n   */\n\n\n  Smithchart.prototype.export = function (type, fileName, orientation) {\n    var exportMap = new ExportUtils(this);\n    exportMap.export(type, fileName, orientation);\n  };\n  /**\n   * To handle the window resize event on smithchart.\n   */\n\n\n  Smithchart.prototype.smithchartOnResize = function (e) {\n    var _this = this;\n\n    this.animateSeries = false;\n\n    if (this.resizeTo) {\n      clearTimeout(this.resizeTo);\n    }\n\n    this.resizeTo = setTimeout(function () {\n      _this.render();\n    }, 500);\n    return false;\n  };\n  /**\n   * To provide the array of modules needed for smithchart rendering\n   * @return {ModuleDeclaration[]}\n   * @private\n   */\n\n\n  Smithchart.prototype.requiredModules = function () {\n    var modules = [];\n\n    if (this.legendSettings.visible) {\n      modules.push({\n        member: 'SmithchartLegend',\n        args: [this]\n      });\n    }\n\n    for (var i = 0; i < this.series.length; i++) {\n      if (this.series[i].tooltip.visible) {\n        modules.push({\n          member: 'TooltipRender',\n          args: [this]\n        });\n        break;\n      }\n    }\n\n    return modules;\n  };\n  /**\n   * To Remove the SVG.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Smithchart.prototype.removeSvg = function () {\n    removeElement(this.element.id + '_Secondary_Element');\n    var removeLength = 0;\n\n    if (this.svgObject) {\n      while (this.svgObject.childNodes.length > removeLength) {\n        this.svgObject.removeChild(this.svgObject.firstChild);\n      }\n\n      if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {\n        remove(this.svgObject);\n      }\n    }\n  };\n\n  __decorate([Property('Impedance')], Smithchart.prototype, \"renderType\", void 0);\n\n  __decorate([Property('')], Smithchart.prototype, \"width\", void 0);\n\n  __decorate([Property('')], Smithchart.prototype, \"height\", void 0);\n\n  __decorate([Property('Material')], Smithchart.prototype, \"theme\", void 0);\n\n  __decorate([Complex({}, SmithchartMargin)], Smithchart.prototype, \"margin\", void 0);\n\n  __decorate([Complex({}, SmithchartFont)], Smithchart.prototype, \"font\", void 0);\n\n  __decorate([Complex({}, SmithchartBorder)], Smithchart.prototype, \"border\", void 0);\n\n  __decorate([Complex({}, Title)], Smithchart.prototype, \"title\", void 0);\n\n  __decorate([Collection([{}], SmithchartSeries)], Smithchart.prototype, \"series\", void 0);\n\n  __decorate([Complex({}, SmithchartLegendSettings)], Smithchart.prototype, \"legendSettings\", void 0);\n\n  __decorate([Complex({}, SmithchartAxis)], Smithchart.prototype, \"horizontalAxis\", void 0);\n\n  __decorate([Complex({}, SmithchartAxis)], Smithchart.prototype, \"radialAxis\", void 0);\n\n  __decorate([Property(null)], Smithchart.prototype, \"background\", void 0);\n\n  __decorate([Property(10)], Smithchart.prototype, \"elementSpacing\", void 0);\n\n  __decorate([Property(1)], Smithchart.prototype, \"radius\", void 0);\n\n  __decorate([Event()], Smithchart.prototype, \"beforePrint\", void 0);\n\n  __decorate([Event()], Smithchart.prototype, \"animationComplete\", void 0);\n\n  __decorate([Event()], Smithchart.prototype, \"load\", void 0);\n\n  __decorate([Event()], Smithchart.prototype, \"loaded\", void 0);\n\n  __decorate([Event()], Smithchart.prototype, \"legendRender\", void 0);\n\n  __decorate([Event()], Smithchart.prototype, \"titleRender\", void 0);\n\n  __decorate([Event()], Smithchart.prototype, \"subtitleRender\", void 0);\n\n  __decorate([Event()], Smithchart.prototype, \"textRender\", void 0);\n\n  __decorate([Event()], Smithchart.prototype, \"axisLabelRender\", void 0);\n\n  __decorate([Event()], Smithchart.prototype, \"seriesRender\", void 0);\n\n  Smithchart = __decorate([NotifyPropertyChanges], Smithchart);\n  return Smithchart;\n}(Component);\n\nexport { Smithchart };","map":null,"metadata":{},"sourceType":"module"}