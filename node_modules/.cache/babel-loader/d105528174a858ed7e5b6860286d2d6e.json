{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { getPoint, withInRange, ChartLocation } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { MultiColoredSeries } from './multi-colored-base';\n/**\n * `MultiColoredAreaSeries` module used to render the area series with multi color.\n */\n\nvar MultiColoredAreaSeries =\n/** @class */\nfunction (_super) {\n  __extends(MultiColoredAreaSeries, _super);\n\n  function MultiColoredAreaSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Render Area series.\n   * @return {void}\n   * @private\n   */\n\n\n  MultiColoredAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n    var _this = this;\n\n    var firstPoint;\n    var startPoint = null;\n    var direction = '';\n    var origin = Math.max(series.yAxis.visibleRange.min, 0);\n    var options = [];\n    var startRegion;\n    var previous;\n    var rendered;\n    var segments = this.sortSegments(series, series.segments);\n    series.points.map(function (point, i, seriesPoints) {\n      point.symbolLocations = [];\n      point.regions = [];\n      rendered = false;\n\n      if (point.visible && withInRange(seriesPoints[i - 1], point, seriesPoints[i + 1], series)) {\n        direction += _this.getAreaPathDirection(point.xValue, origin, series, isInverted, getPoint, startPoint, 'M');\n        startPoint = startPoint || new ChartLocation(point.xValue, origin);\n        firstPoint = getPoint(point.xValue, point.yValue, xAxis, yAxis, isInverted, series);\n\n        if (previous && _this.setPointColor(point, previous, series, series.segmentAxis === 'X', segments)) {\n          rendered = true;\n          startRegion = getPoint(startPoint.x, origin, xAxis, yAxis, isInverted, series);\n          direction += 'L' + ' ' + firstPoint.x + ' ' + firstPoint.y + ' ';\n          direction += 'L' + ' ' + firstPoint.x + ' ' + startRegion.y + ' ';\n\n          _this.generatePathOption(options, series, previous, direction, '_Point_' + previous.index);\n\n          direction = 'M' + ' ' + firstPoint.x + ' ' + startRegion.y + ' ' + 'L' + ' ' + firstPoint.x + ' ' + firstPoint.y + ' ';\n        } else {\n          direction += 'L' + ' ' + firstPoint.x + ' ' + firstPoint.y + ' ';\n\n          _this.setPointColor(point, null, series, series.segmentAxis === 'X', segments);\n        }\n\n        if (seriesPoints[i + 1] && !seriesPoints[i + 1].visible && series.emptyPointSettings.mode !== 'Drop') {\n          direction += _this.getAreaEmptyDirection({\n            'x': point.xValue,\n            'y': origin\n          }, startPoint, series, isInverted, getPoint);\n          startPoint = null;\n        }\n\n        previous = point;\n\n        _this.storePointLocation(point, series, isInverted, getPoint);\n      }\n    });\n\n    if (!rendered) {\n      direction = series.points.length > 1 ? direction + this.getAreaPathDirection(previous.xValue, origin, series, isInverted, getPoint, null, 'L') : '';\n      this.generatePathOption(options, series, previous, direction, '');\n    }\n\n    this.applySegmentAxis(series, options, segments);\n    this.renderMarker(series);\n  };\n  /**\n   * To Store the path directions of the area\n   */\n\n\n  MultiColoredAreaSeries.prototype.generatePathOption = function (options, series, point, direction, id) {\n    options.push(new PathOption(series.chart.element.id + '_Series_' + series.index + id, series.setPointColor(point, series.interior), series.border.width, series.border.color, series.opacity, series.dashArray, direction));\n  };\n  /**\n   * To destroy the area series.\n   * @return {void}\n   * @private\n   */\n\n\n  MultiColoredAreaSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroy method calling here\n     */\n  };\n  /**\n   * Get module name\n   */\n\n\n  MultiColoredAreaSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'MultiColoredAreaSeries';\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  MultiColoredAreaSeries.prototype.doAnimation = function (series) {\n    this.doLinearAnimation(series, series.animation);\n  };\n\n  return MultiColoredAreaSeries;\n}(MultiColoredSeries);\n\nexport { MultiColoredAreaSeries };","map":null,"metadata":{},"sourceType":"module"}