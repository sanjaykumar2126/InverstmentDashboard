{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { getPoint, withInRange, ChartLocation, TransformToVisible } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { MultiColoredSeries } from './multi-colored-base';\n/**\n * `AreaSeries` module is used to render the area series.\n */\n\nvar AreaSeries =\n/** @class */\nfunction (_super) {\n  __extends(AreaSeries, _super);\n\n  function AreaSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Render Area series.\n   * @return {void}\n   * @private\n   */\n\n\n  AreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n    var _this = this;\n\n    var startPoint = null;\n    var direction = '';\n    var origin = series.chart.chartAreaType === 'PolarRadar' ? series.points[0].yValue : Math.max(series.yAxis.visibleRange.min, 0);\n    var currentXValue;\n    var isPolar = series.chart && series.chart.chartAreaType === 'PolarRadar';\n    var isDropMode = series.emptyPointSettings && series.emptyPointSettings.mode === 'Drop';\n    var borderWidth = series.border ? series.border.width : 0;\n    var borderColor = series.border ? series.border.color : 'transparent';\n    var getCoordinate = series.chart.chartAreaType === 'PolarRadar' ? TransformToVisible : getPoint;\n    series.points.map(function (point, i, seriesPoints) {\n      currentXValue = point.xValue;\n      point.symbolLocations = [];\n      point.regions = [];\n\n      if (point.visible && withInRange(seriesPoints[i - 1], point, seriesPoints[i + 1], series)) {\n        direction += _this.getAreaPathDirection(currentXValue, origin, series, isInverted, getCoordinate, startPoint, 'M');\n        startPoint = startPoint || new ChartLocation(currentXValue, origin); // First Point to draw the area path\n\n        direction += _this.getAreaPathDirection(currentXValue, point.yValue, series, isInverted, getCoordinate, null, 'L');\n\n        if (seriesPoints[i + 1] && !seriesPoints[i + 1].visible && !isDropMode) {\n          direction += _this.getAreaEmptyDirection({\n            'x': currentXValue,\n            'y': origin\n          }, startPoint, series, isInverted, getCoordinate);\n          startPoint = null;\n        }\n\n        _this.storePointLocation(point, series, isInverted, getCoordinate);\n      }\n    });\n\n    if (isPolar) {\n      direction = direction.concat(direction + ' ' + 'Z');\n    }\n\n    this.appendLinePath(new PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, borderWidth, borderColor, series.opacity, series.dashArray, series.points.length > 1 && direction !== '' ? direction + this.getAreaPathDirection(series.points[series.points.length - 1].xValue, series.chart.chartAreaType === 'PolarRadar' ? series.points[series.points.length - 1].yValue : origin, series, isInverted, getCoordinate, null, 'L') : ''), series, '');\n    this.renderMarker(series);\n  };\n  /**\n   * To destroy the area series.\n   * @return {void}\n   * @private\n   */\n\n\n  AreaSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroy method calling here\n     */\n  };\n  /**\n   * Get module name\n   */\n\n\n  AreaSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'AreaSeries';\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  AreaSeries.prototype.doAnimation = function (series) {\n    var option = series.animation;\n    this.doLinearAnimation(series, option);\n  };\n\n  return AreaSeries;\n}(MultiColoredSeries);\n\nexport { AreaSeries };","map":null,"metadata":{},"sourceType":"module"}