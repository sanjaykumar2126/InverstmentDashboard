{"ast":null,"code":"import { withInRange, getPoint, drawSymbol, getElement } from '../../common/utils/helper';\nimport { markerAnimate, TransformToVisible, appendChildElement } from '../../common/utils/helper';\nimport { PathOption, Rect, Size } from '@syncfusion/ej2-svg-base';\nimport { pointRender } from '../../common/model/constants';\n/**\n * `ScatterSeries` module is used to render the scatter series.\n */\n\nvar ScatterSeries =\n/** @class */\nfunction () {\n  function ScatterSeries() {}\n  /**\n   * Render the scatter series.\n   * @return {void}\n   * @private\n   */\n\n\n  ScatterSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n    var marker = series.marker;\n    var visiblePoints = series.points;\n    var argsData;\n    var getCoordinate = series.chart.chartAreaType === 'PolarRadar' ? TransformToVisible : getPoint;\n    var startLocation;\n    var redraw = series.chart.redraw;\n\n    for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {\n      var point = visiblePoints_1[_i];\n      startLocation = redraw && point.symbolLocations ? point.symbolLocations[0] : null;\n      point.symbolLocations = [];\n      point.regions = [];\n\n      if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {\n        argsData = {\n          cancel: false,\n          name: pointRender,\n          series: series,\n          point: point,\n          fill: series.setPointColor(point, series.interior),\n          border: series.setBorderColor(point, {\n            width: series.border.width,\n            color: series.border.color\n          }),\n          height: marker.height,\n          width: marker.width,\n          shape: marker.shape\n        };\n        series.chart.trigger(pointRender, argsData);\n\n        if (!argsData.cancel) {\n          point.symbolLocations.push(getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series));\n          point.color = argsData.fill;\n          this.refresh(series, point, argsData, startLocation);\n        } else {\n          point.marker = {\n            visible: true\n          };\n        }\n      }\n    }\n  };\n  /**\n   * To append scatter element\n   * @param series\n   * @param point\n   * @param argsData\n   * @param startLocation\n   */\n\n\n  ScatterSeries.prototype.refresh = function (series, point, argsData, startLocation) {\n    var chart = series.chart;\n    var circlePath;\n    var previousPath;\n    var marker = series.marker;\n    var shapeOption = new PathOption(chart.element.id + '_Series_' + series.index + '_Point_' + point.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, null);\n\n    if (chart.redraw && getElement(shapeOption.id)) {\n      circlePath = argsData.shape === 'Circle' ? 'c' : '';\n      previousPath = getElement(shapeOption.id).getAttribute('d');\n    }\n\n    appendChildElement(false, series.seriesElement, drawSymbol(point.symbolLocations[0], argsData.shape, new Size(argsData.width, argsData.height), marker.imageUrl, shapeOption, point.x.toString() + ':' + point.yValue.toString(), series.chart.svgRenderer, series.clipRect), chart.redraw, true, circlePath + 'x', circlePath + 'y', startLocation, previousPath);\n    point.regions.push(new Rect(point.symbolLocations[0].x - marker.width, point.symbolLocations[0].y - marker.height, 2 * marker.width, 2 * marker.height));\n    point.marker = {\n      border: argsData.border,\n      fill: argsData.fill,\n      height: argsData.height,\n      visible: true,\n      width: argsData.width,\n      shape: argsData.shape\n    };\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  ScatterSeries.prototype.doAnimation = function (series) {\n    var duration = series.animation.duration;\n    var delay = series.animation.delay;\n    var rectElements = series.seriesElement.childNodes;\n    var count = 1;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      if (!point.symbolLocations.length || !rectElements[count]) {\n        continue;\n      }\n\n      markerAnimate(rectElements[count], delay, duration, series, point.index, point.symbolLocations[0], false);\n      count++;\n    }\n  };\n  /**\n   * Get module name.\n   */\n\n\n  ScatterSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'ScatterSeries';\n  };\n  /**\n   * To destroy the scatter.\n   * @return {void}\n   */\n\n\n  ScatterSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroy method calling here\n     */\n  };\n\n  return ScatterSeries;\n}();\n\nexport { ScatterSeries };","map":null,"metadata":{},"sourceType":"module"}