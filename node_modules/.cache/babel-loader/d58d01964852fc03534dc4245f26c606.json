{"ast":null,"code":"import { Mean, RectOption, pathAnimation, getElement, appendChildElement, appendClipElement } from '../../common/utils/helper';\nimport { getPoint, sum, templateAnimate } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\n/**\n * `ErrorBar` module is used to render the error bar for series.\n */\n\nvar ErrorBar =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the error bar module.\n   * @private\n   */\n  function ErrorBar(chart) {\n    this.chart = chart;\n  }\n  /**\n   * Render the error bar for series.\n   * @return {void}\n   */\n\n\n  ErrorBar.prototype.render = function (series) {\n    if (this.chart.chartAreaType === 'PolarRadar') {\n      return null;\n    }\n\n    this.createElement(series, this.chart);\n    this.renderErrorBar(series);\n  };\n\n  ErrorBar.prototype.renderErrorBar = function (series) {\n    var seriesIndex = series.index;\n    var symbolId;\n    var capId;\n    var errorbar = series.errorBar;\n    var errorBarCap = series.errorBar.errorBarCap;\n    var errorDirection = ['', ''];\n    var redraw = series.chart.redraw;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      if (point.visible && point.symbolLocations[0]) {\n        var errorX = 0;\n        var errorY = 0;\n\n        switch (errorbar.mode) {\n          case 'Vertical':\n            errorY = errorbar.verticalError;\n            break;\n\n          case 'Horizontal':\n            errorX = errorbar.horizontalError;\n            break;\n\n          case 'Both':\n            errorX = errorbar.horizontalError;\n            errorY = errorbar.verticalError;\n            break;\n        }\n\n        errorDirection = this['calculate' + errorbar.type + 'Value'](point, series, this.chart.requireInvertedAxis, errorX, errorY);\n        symbolId = this.chart.element.id + '_Series_' + '_ErrorBarGroup_' + seriesIndex + '_Point_' + point.index;\n        capId = this.chart.element.id + '_Series_' + '_ErrorBarCap_' + seriesIndex + '_Point_' + point.index;\n        var shapeOption = new PathOption(symbolId, '', errorbar.width, errorbar.color || this.chart.themeStyle.errorBar, null, '', errorDirection[0]);\n        var element = getElement(shapeOption.id);\n        var previousDirection = element ? element.getAttribute('d') : null;\n        series.errorBarElement.appendChild(this.chart.renderer.drawPath(shapeOption));\n        pathAnimation(element, errorDirection[0], redraw, previousDirection);\n        var capOption = new PathOption(capId, '', errorBarCap.width, errorBarCap.color || this.chart.themeStyle.errorBar, null, '', errorDirection[1]);\n        element = getElement(capOption.id);\n        previousDirection = element ? element.getAttribute('d') : null;\n        appendChildElement(this.chart.enableCanvas, series.errorBarElement, this.chart.renderer.drawPath(capOption), redraw);\n        pathAnimation(element, errorDirection[1], redraw, previousDirection);\n      }\n    }\n  }; // path calculation for error bar\n\n\n  ErrorBar.prototype.findLocation = function (point, series, isInverted, x1, y1) {\n    var errorbar = series.errorBar;\n    var direction = errorbar.direction;\n    var location = [];\n    var stackedValue = series.stackedValues;\n    var yValue = series.type.indexOf('Stacking') > -1 ? series.stackedValues.endValues[point.index] : series.seriesType === 'HighLow' || series.seriesType === 'HighLowOpenClose' ? series.points[point.index].high : point.yValue;\n    var startPoint = getPoint(point.xValue + (direction === 'Plus' || direction === 'Both' ? errorbar.type === 'Custom' && (errorbar.mode === 'Horizontal' || errorbar.mode === 'Both') ? x1 = errorbar.horizontalPositiveError : x1 : 0), yValue + (direction === 'Plus' || direction === 'Both' ? errorbar.type === 'Custom' && (errorbar.mode === 'Vertical' || errorbar.mode === 'Both') ? y1 = errorbar.verticalPositiveError : y1 : 0), series.xAxis, series.yAxis, isInverted);\n    location.push(startPoint);\n\n    if (series.isRectSeries) {\n      var midPoint = point.symbolLocations[0];\n      location.push(midPoint);\n    } else {\n      var midPoint = getPoint(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted);\n      location.push(midPoint);\n    }\n\n    var endPoint = getPoint(point.xValue - (direction === 'Minus' || direction === 'Both' ? errorbar.type === 'Custom' && (errorbar.mode === 'Horizontal' || errorbar.mode === 'Both') ? x1 = errorbar.horizontalNegativeError : x1 : 0), yValue - (direction === 'Minus' || direction === 'Both' ? errorbar.type === 'Custom' && (errorbar.mode === 'Vertical' || errorbar.mode === 'Both') ? y1 = errorbar.verticalNegativeError : y1 : 0), series.xAxis, series.yAxis, isInverted);\n    location.push(endPoint); // calculate error height for datalabel position alignment\n\n    point.error = errorbar.mode === 'Vertical' ? errorbar.verticalError : errorbar.horizontalError;\n    this.negativeHeight = errorbar.mode === 'Vertical' || errorbar.mode === 'Both' ? isInverted ? location[1].x - location[2].x : location[2].y - location[1].y : 0;\n    this.positiveHeight = errorbar.mode === 'Vertical' || errorbar.mode === 'Both' ? isInverted ? location[0].x - location[1].x : location[1].y - location[0].y : 0;\n    return this.getErrorDirection(location[0], location[1], location[2], series, isInverted);\n  }; // calculations for eror bar types\n\n\n  ErrorBar.prototype.calculateFixedValue = function (point, series, isInverted, errorX, errorY, xAxis, yAxis) {\n    var errorbar = series.errorBar;\n    return this.findLocation(point, series, isInverted, errorX, errorY);\n  };\n\n  ErrorBar.prototype.calculatePercentageValue = function (point, series, isInverted, errorX, errorY, xAxis, yAxis) {\n    errorX = errorX / 100 * point.xValue;\n    errorY = errorY / 100 * point.yValue;\n    return this.findLocation(point, series, isInverted, errorX, errorY);\n  };\n\n  ErrorBar.prototype.calculateStandardDeviationValue = function (point, series, isInverted, errorX, errorY, xAxis, yAxis) {\n    var getMean = this.meanCalculation(series, series.errorBar.mode);\n    errorX = errorX * (getMean.horizontalSquareRoot + getMean.horizontalMean);\n    errorY = errorY * (getMean.verticalSquareRoot + getMean.verticalMean);\n    return this.findLocation(point, series, isInverted, errorX, errorY);\n  };\n\n  ErrorBar.prototype.calculateStandardErrorValue = function (point, series, isInverted, errorX, errorY, xAxis, yAxis) {\n    var length = series.points.length;\n    var getMean = this.meanCalculation(series, series.errorBar.mode);\n    errorX = errorX * getMean.horizontalSquareRoot / Math.sqrt(length);\n    errorY = errorY * getMean.verticalSquareRoot / Math.sqrt(length);\n    return this.findLocation(point, series, isInverted, errorX, errorY);\n  };\n\n  ErrorBar.prototype.calculateCustomValue = function (point, series, isInverted, errorX, errorY, xAxis, yAxis) {\n    var errorbar = series.errorBar;\n    return this.findLocation(point, series, isInverted, errorX, errorY);\n  };\n\n  ErrorBar.prototype.getHorizontalDirection = function (start, mid, end, direction, errorMode, capLength) {\n    var path = '';\n    var capDirection = '';\n    path += 'M ' + start.x + ' ' + mid.y + ' L ' + end.x + ' ' + mid.y;\n    capDirection += direction === 'Plus' || direction === 'Both' ? 'M ' + start.x + ' ' + (mid.y - capLength) + ' L ' + start.x + ' ' + (mid.y + capLength) : '';\n    capDirection += direction === 'Minus' || direction === 'Both' ? 'M ' + end.x + ' ' + (mid.y - capLength) + ' L ' + end.x + ' ' + (mid.y + capLength) : ' ';\n    return [path, capDirection];\n  };\n\n  ErrorBar.prototype.getVerticalDirection = function (start, mid, end, direction, errorMode, capLength) {\n    var path = '';\n    var capDirection = '';\n    path += 'M ' + mid.x + ' ' + start.y + ' L ' + mid.x + ' ' + end.y;\n    capDirection += direction === 'Plus' || direction === 'Both' ? 'M ' + (mid.x - capLength) + ' ' + start.y + ' L ' + (mid.x + capLength) + ' ' + start.y : '';\n    capDirection += direction === 'Minus' || direction === 'Both' ? 'M ' + (mid.x - capLength) + ' ' + end.y + ' L ' + (mid.x + capLength) + ' ' + end.y : '';\n    return [path, capDirection];\n  };\n\n  ErrorBar.prototype.getBothDirection = function (start, mid, end, direction, errorMode, capLength) {\n    var capDirection = '';\n    var path = '';\n    var pathH = this.getHorizontalDirection(start, mid, end, direction, errorMode, capLength);\n    var pathV = this.getVerticalDirection(start, mid, end, direction, errorMode, capLength);\n    path = pathH[0].concat(pathV[0]);\n    capDirection = pathH[1].concat(pathV[1]);\n    return [path, capDirection];\n  };\n\n  ErrorBar.prototype.getErrorDirection = function (start, mid, end, series, isInverted) {\n    var direction = series.errorBar.direction;\n    var mode = series.errorBar.mode;\n    var capLength = series.errorBar.errorBarCap.length;\n    var path = '';\n    var paths;\n    var capDirection = '';\n    var errorMode = mode;\n\n    switch (mode) {\n      case 'Both':\n        errorMode = mode;\n        break;\n\n      case 'Horizontal':\n        errorMode = isInverted ? 'Vertical' : mode;\n        break;\n\n      case 'Vertical':\n        errorMode = isInverted ? 'Horizontal' : mode;\n        break;\n    }\n\n    switch (errorMode) {\n      case 'Horizontal':\n        paths = this.getHorizontalDirection(start, mid, end, direction, errorMode, capLength);\n        break;\n\n      case 'Vertical':\n        paths = this.getVerticalDirection(start, mid, end, direction, errorMode, capLength);\n        break;\n\n      case 'Both':\n        paths = this.getBothDirection(start, mid, end, direction, errorMode, capLength);\n        break;\n    }\n\n    return [paths[0], paths[1]];\n  }; // mean calculation for standard deviation and standard error\n\n\n  ErrorBar.prototype.meanCalculation = function (series, mode) {\n    var sumOfX = 0;\n    var sumOfY = 0;\n    var verticalMean = 0;\n    var horizontalMean = 0;\n    var verStandardMean;\n    var horStandardMean;\n    var verSquareRoot;\n    var horSquareRoot;\n    var length = series.points.length;\n\n    switch (mode) {\n      case 'Vertical':\n        sumOfY = sum(series.yData);\n        verticalMean = sumOfY / length;\n        break;\n\n      case 'Horizontal':\n        sumOfX = sum(series.xData);\n        horizontalMean = sumOfX / length;\n        break;\n\n      case 'Both':\n        sumOfY = sum(series.yData);\n        verticalMean = sumOfY / length;\n        sumOfX = sum(series.xData);\n        horizontalMean = sumOfX / length;\n    }\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      if (mode === 'Vertical') {\n        sumOfY = sumOfY + Math.pow(point.yValue - verticalMean, 2);\n      } else if (mode === 'Horizontal') {\n        sumOfX = sumOfX + Math.pow(point.xValue - horizontalMean, 2);\n      } else {\n        sumOfY = sumOfY + Math.pow(point.yValue - verticalMean, 2);\n        sumOfX = sumOfX + Math.pow(point.xValue - horizontalMean, 2);\n      }\n    }\n\n    verStandardMean = sumOfY / (length - 1);\n    verSquareRoot = Math.sqrt(sumOfY / (length - 1));\n    horStandardMean = sumOfX / (length - 1);\n    horSquareRoot = Math.sqrt(sumOfX / (length - 1));\n    return new Mean(verStandardMean, verSquareRoot, horStandardMean, horSquareRoot, verticalMean, horizontalMean);\n  };\n\n  ErrorBar.prototype.createElement = function (series, chart) {\n    var explodeValue = 5;\n    var transform = chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')' : '';\n    var markerHeight = (series.marker.height + explodeValue) / 2;\n    var markerWidth = (series.marker.width + explodeValue) / 2;\n\n    if (chart.chartAreaType === 'Cartesian') {\n      var options = new RectOption(chart.element.id + '_ChartErrorBarClipRect_' + series.index, 'transparent', {\n        width: 1,\n        color: 'Gray'\n      }, 1, {\n        x: -markerWidth,\n        y: -markerHeight,\n        width: series.clipRect.width + markerWidth * 2,\n        height: series.clipRect.height + markerHeight * 2\n      });\n      series.errorBarElement = chart.renderer.createGroup({\n        'id': chart.element.id + 'ErrorBarGroup' + series.index,\n        'transform': transform,\n        'clip-path': 'url(#' + chart.element.id + '_ChartErrorBarClipRect_' + series.index + ')'\n      });\n      series.errorBarElement.appendChild(appendClipElement(chart.redraw, options, chart.renderer));\n    }\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  ErrorBar.prototype.doErrorBarAnimation = function (series) {\n    var errorBarElements = series.errorBarElement.childNodes;\n\n    if (!errorBarElements) {\n      return null;\n    }\n\n    var delay = series.animation.delay + series.animation.duration;\n    var j = 1;\n\n    while (j < errorBarElements.length) {\n      for (var i = 0; i < series.points.length; i++) {\n        if (!series.points[i].symbolLocations[0]) {\n          continue;\n        }\n\n        errorBarElements[j].style.visibility = 'hidden';\n        templateAnimate(errorBarElements[j], delay, 350, series.chart.requireInvertedAxis ? 'SlideLeftIn' : 'SlideBottomIn', false);\n      }\n\n      j++;\n    }\n  };\n  /**\n   * Get module name.\n   */\n\n\n  ErrorBar.prototype.getModuleName = function () {\n    // Returns the module name\n    return 'ErrorBar';\n  };\n  /**\n   * To destroy the errorBar for series.\n   * @return {void}\n   * @private\n   */\n\n\n  ErrorBar.prototype.destroy = function (chart) {// Destroy method performed here\n  };\n\n  return ErrorBar;\n}();\n\nexport { ErrorBar };","map":null,"metadata":{},"sourceType":"module"}