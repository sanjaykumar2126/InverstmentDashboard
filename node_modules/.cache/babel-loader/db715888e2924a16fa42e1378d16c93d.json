{"ast":null,"code":"import { INTERPOLATE, ZERO } from '../constants';\nimport { convertableToNumber } from '../../common';\nimport SeriesBinder from '../series-binder';\nvar AREA_REGEX = /area/i;\n\nfunction seriesMissingValues(series) {\n  if (series.missingValues) {\n    return series.missingValues;\n  }\n\n  return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n}\n\nfunction hasValue(series, item) {\n  var fields = SeriesBinder.current.bindPoint(series, null, item);\n  var valueFields = fields.valueFields;\n\n  for (var field in valueFields) {\n    if (convertableToNumber(valueFields[field])) {\n      return true;\n    }\n  }\n}\n\nfunction findNext(ref) {\n  var start = ref.start;\n  var dir = ref.dir;\n  var min = ref.min;\n  var max = ref.max;\n  var getter = ref.getter;\n  var hasItem = ref.hasItem;\n  var series = ref.series;\n  var pointHasValue, outPoint;\n  var idx = start;\n\n  do {\n    idx += dir; //aggregating and binding the item takes too much time for large number of categories\n    //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n\n    if (hasItem(idx)) {\n      outPoint = getter(idx);\n      pointHasValue = hasValue(series, outPoint.item);\n    }\n  } while (min <= idx && idx <= max && !pointHasValue);\n\n  if (pointHasValue) {\n    return outPoint;\n  }\n}\n\nexport default function createOutOfRangePoints(series, range, count, getter, hasItem) {\n  var min = range.min;\n  var max = range.max;\n  var hasMinPoint = min > 0 && min < count;\n  var hasMaxPoint = max + 1 < count;\n\n  if (hasMinPoint || hasMaxPoint) {\n    var missingValues = seriesMissingValues(series);\n    var minPoint, maxPoint;\n\n    if (missingValues !== INTERPOLATE) {\n      if (hasMinPoint) {\n        minPoint = getter(min - 1);\n      }\n\n      if (hasMaxPoint) {\n        maxPoint = getter(max + 1);\n      }\n    } else {\n      var outPoint, pointHasValue;\n\n      if (hasMinPoint) {\n        outPoint = getter(min - 1);\n        pointHasValue = hasValue(series, outPoint.item);\n\n        if (!pointHasValue) {\n          minPoint = findNext({\n            start: min,\n            dir: -1,\n            min: 0,\n            max: count - 1,\n            getter: getter,\n            hasItem: hasItem,\n            series: series\n          });\n        } else {\n          minPoint = outPoint;\n        }\n      }\n\n      if (hasMaxPoint) {\n        outPoint = getter(max + 1);\n        pointHasValue = hasValue(series, outPoint.item);\n\n        if (!pointHasValue) {\n          maxPoint = findNext({\n            start: max,\n            dir: 1,\n            min: 0,\n            max: count - 1,\n            getter: getter,\n            hasItem: hasItem,\n            series: series\n          });\n        } else {\n          maxPoint = outPoint;\n        }\n      }\n    }\n\n    if (minPoint) {\n      series._outOfRangeMinPoint = minPoint;\n    }\n\n    if (maxPoint) {\n      series._outOfRangeMaxPoint = maxPoint;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}