{"ast":null,"code":"import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\nimport GridLinesMixin from './mixins/grid-lines-mixin';\nimport CategoryAxis from './category-axis';\nimport ShapeBuilder from './shape-builder';\nimport Ring from './ring';\nimport Box from './box';\nimport { COORD_PRECISION, ARC } from '../common/constants';\nimport { deepExtend, getSpacing, inArray, limitValue, map, rad, round, setDefaultOptions } from '../common';\n\nvar RadarCategoryAxis = function (CategoryAxis) {\n  function RadarCategoryAxis() {\n    CategoryAxis.apply(this, arguments);\n  }\n\n  if (CategoryAxis) RadarCategoryAxis.__proto__ = CategoryAxis;\n  RadarCategoryAxis.prototype = Object.create(CategoryAxis && CategoryAxis.prototype);\n  RadarCategoryAxis.prototype.constructor = RadarCategoryAxis;\n\n  RadarCategoryAxis.prototype.range = function range() {\n    return {\n      min: 0,\n      max: this.options.categories.length\n    };\n  };\n\n  RadarCategoryAxis.prototype.reflow = function reflow(box) {\n    this.box = box;\n    this.reflowLabels();\n  };\n\n  RadarCategoryAxis.prototype.lineBox = function lineBox() {\n    return this.box;\n  };\n\n  RadarCategoryAxis.prototype.reflowLabels = function reflowLabels() {\n    var this$1 = this;\n    var ref = this;\n    var labels = ref.labels;\n    var labelOptions = ref.options.labels;\n    var skip = labelOptions.skip || 0;\n    var step = labelOptions.step || 1;\n    var measureBox = new Box();\n\n    for (var i = 0; i < labels.length; i++) {\n      labels[i].reflow(measureBox);\n      var labelBox = labels[i].box;\n      labels[i].reflow(this$1.getSlot(skip + i * step).adjacentBox(0, labelBox.width(), labelBox.height()));\n    }\n  };\n\n  RadarCategoryAxis.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {\n    if (skipAngles === void 0) skipAngles = false;\n    var options = this.options;\n    var categories = options.categories.length;\n    var divCount = categories / size || 1;\n    var divAngle = 360 / divCount;\n    var skip = skipOption || 0;\n    var step = stepOption || 1;\n    var divs = [];\n    var angle = 0;\n\n    for (var i = skip; i < divCount; i += step) {\n      if (options.reverse) {\n        angle = 360 - i * divAngle;\n      } else {\n        angle = i * divAngle;\n      }\n\n      angle = round(angle, COORD_PRECISION) % 360;\n\n      if (!(skipAngles && inArray(angle, skipAngles))) {\n        divs.push(angle);\n      }\n    }\n\n    return divs;\n  };\n\n  RadarCategoryAxis.prototype.majorIntervals = function majorIntervals() {\n    return this.intervals(1);\n  };\n\n  RadarCategoryAxis.prototype.minorIntervals = function minorIntervals() {\n    return this.intervals(0.5);\n  };\n\n  RadarCategoryAxis.prototype.intervalAngle = function intervalAngle(interval) {\n    return (360 + interval + this.options.startAngle) % 360;\n  };\n\n  RadarCategoryAxis.prototype.majorAngles = function majorAngles() {\n    var this$1 = this;\n    return map(this.majorIntervals(), function (interval) {\n      return this$1.intervalAngle(interval);\n    });\n  };\n\n  RadarCategoryAxis.prototype.createLine = function createLine() {\n    return [];\n  };\n\n  RadarCategoryAxis.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {\n    var majorGridLines = this.options.majorGridLines;\n    return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);\n  };\n\n  RadarCategoryAxis.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {\n    var ref = this.options;\n    var minorGridLines = ref.minorGridLines;\n    var majorGridLines = ref.majorGridLines;\n    var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;\n    return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n  };\n\n  RadarCategoryAxis.prototype.radiusCallback = function radiusCallback(radius, altAxis, skipMajor) {\n    if (altAxis.options.type !== ARC) {\n      var minorAngle = rad(360 / (this.options.categories.length * 2));\n      var minorRadius = Math.cos(minorAngle) * radius;\n      var majorAngles = this.majorAngles();\n\n      var radiusCallback = function (angle) {\n        if (!skipMajor && inArray(angle, majorAngles)) {\n          return radius;\n        }\n\n        return minorRadius;\n      };\n\n      return radiusCallback;\n    }\n  };\n\n  RadarCategoryAxis.prototype.createPlotBands = function createPlotBands() {\n    var this$1 = this;\n    var plotBands = this.options.plotBands || [];\n    var group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n\n    for (var i = 0; i < plotBands.length; i++) {\n      var band = plotBands[i];\n      var slot = this$1.plotBandSlot(band);\n      var singleSlot = this$1.getSlot(band.from);\n      var head = band.from - Math.floor(band.from);\n      slot.startAngle += head * singleSlot.angle;\n      var tail = Math.ceil(band.to) - band.to;\n      slot.angle -= (tail + head) * singleSlot.angle;\n      var ring = ShapeBuilder.current.createRing(slot, {\n        fill: {\n          color: band.color,\n          opacity: band.opacity\n        },\n        stroke: {\n          opacity: band.opacity\n        }\n      });\n      group.append(ring);\n    }\n\n    this.appendVisual(group);\n  };\n\n  RadarCategoryAxis.prototype.plotBandSlot = function plotBandSlot(band) {\n    return this.getSlot(band.from, band.to - 1);\n  };\n\n  RadarCategoryAxis.prototype.getSlot = function getSlot(from, to) {\n    var options = this.options;\n    var justified = options.justified;\n    var box = this.box;\n    var divs = this.majorAngles();\n    var totalDivs = divs.length;\n    var slotAngle = 360 / totalDivs;\n    var fromValue = from;\n\n    if (options.reverse && !justified) {\n      fromValue = (fromValue + 1) % totalDivs;\n    }\n\n    fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);\n    var slotStart = divs[fromValue];\n\n    if (justified) {\n      slotStart = slotStart - slotAngle / 2;\n\n      if (slotStart < 0) {\n        slotStart += 360;\n      }\n    }\n\n    var toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);\n    var slots = toValue - fromValue + 1;\n    var angle = slotAngle * slots;\n    return new Ring(box.center(), 0, box.height() / 2, slotStart, angle);\n  };\n\n  RadarCategoryAxis.prototype.slot = function slot(from, to) {\n    var slot = this.getSlot(from, to);\n    var startAngle = slot.startAngle + 180;\n    var endAngle = startAngle + slot.angle;\n    return new geom.Arc([slot.center.x, slot.center.y], {\n      startAngle: startAngle,\n      endAngle: endAngle,\n      radiusX: slot.radius,\n      radiusY: slot.radius\n    });\n  };\n\n  RadarCategoryAxis.prototype.pointCategoryIndex = function pointCategoryIndex(point) {\n    var this$1 = this;\n    var length = this.options.categories.length;\n    var index = null;\n\n    for (var i = 0; i < length; i++) {\n      var slot = this$1.getSlot(i);\n\n      if (slot.containsPoint(point)) {\n        index = i;\n        break;\n      }\n    }\n\n    return index;\n  };\n\n  return RadarCategoryAxis;\n}(CategoryAxis);\n\nsetDefaultOptions(RadarCategoryAxis, {\n  startAngle: 90,\n  labels: {\n    margin: getSpacing(10)\n  },\n  majorGridLines: {\n    visible: true\n  },\n  justified: true\n});\ndeepExtend(RadarCategoryAxis.prototype, GridLinesMixin);\nexport default RadarCategoryAxis;","map":null,"metadata":{},"sourceType":"module"}