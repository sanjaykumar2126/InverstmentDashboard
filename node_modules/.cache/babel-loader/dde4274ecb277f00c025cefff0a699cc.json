{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { setDefaultOptions, deepExtend, defined } from '../../common';\nimport { BLACK } from '../../common/constants';\nimport { NumericAxis } from '../../core';\nimport { DEFAULT_LINE_WIDTH, INSIDE } from '../constants';\nimport { autoMajorUnit } from '../../core';\nimport { buildLabelElement, getRange } from '../utils';\nvar Path = drawing.Path;\nvar Group = drawing.Group;\nvar Point = geo.Point;\n\nfunction renderAxisTick(tickRenderOptions, tickOptions) {\n  var position = tickRenderOptions.position;\n  var tickX = tickRenderOptions.tickX;\n  var tickY = tickRenderOptions.tickY;\n  var start, end;\n\n  if (tickRenderOptions.vertical) {\n    start = new Point(tickX, position);\n    end = new Point(tickX + tickOptions.size, position);\n  } else {\n    start = new Point(position, tickY);\n    end = new Point(position, tickY + tickOptions.size);\n  }\n\n  var tickPath = new Path({\n    stroke: {\n      color: tickOptions.color,\n      width: tickOptions.width\n    }\n  }).moveTo(start).lineTo(end);\n  return tickPath;\n}\n\nfunction renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {\n  var count = tickPositions.length;\n\n  if (tickOptions.visible) {\n    var mirror = tickRenderOptions.mirror;\n    var lineBox = tickRenderOptions.lineBox;\n\n    for (var i = tickOptions.skip; i < count; i += tickOptions.step) {\n      if (i % tickOptions.skipUnit === 0) {\n        continue;\n      }\n\n      tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n      tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n      tickRenderOptions.position = tickPositions[i];\n      tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));\n    }\n  }\n}\n\nvar LinearScale = function (NumericAxis) {\n  function LinearScale(options, service) {\n    var scaleOptions = options || {};\n\n    if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {\n      scaleOptions = Object.assign({}, scaleOptions, {\n        reverse: true\n      });\n    }\n\n    NumericAxis.call(this, 0, 1, scaleOptions, service);\n    this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;\n  }\n\n  if (NumericAxis) LinearScale.__proto__ = NumericAxis;\n  LinearScale.prototype = Object.create(NumericAxis && NumericAxis.prototype);\n  LinearScale.prototype.constructor = LinearScale;\n\n  LinearScale.prototype.initUserOptions = function initUserOptions(options) {\n    var scaleOptions = deepExtend({}, this.options, options);\n    scaleOptions = deepExtend({}, scaleOptions, {\n      labels: {\n        mirror: scaleOptions.mirror\n      }\n    });\n    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);\n    return scaleOptions;\n  };\n\n  LinearScale.prototype.initFields = function initFields() {};\n\n  LinearScale.prototype.render = function render() {\n    var elements = this.elements = new Group();\n    var labels = this.renderLabels();\n    var scaleLine = this.renderLine();\n    var scaleTicks = this.renderTicks();\n    var ranges = this.renderRanges();\n    elements.append(scaleLine, labels, scaleTicks, ranges);\n    return elements;\n  };\n\n  LinearScale.prototype.renderRanges = function renderRanges() {\n    var this$1 = this;\n    var options = this.options;\n    var min = options.min;\n    var max = options.max;\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var ranges = options.ranges || [];\n    var elements = new Group();\n    var count = ranges.length;\n    var rangeSize = options.rangeSize || options.minorTicks.size / 2;\n\n    for (var i = 0; i < count; i++) {\n      var range = getRange(ranges[i], min, max);\n      var slot = this$1.getSlot(range.from, range.to);\n      var slotX = vertical ? this$1.lineBox() : slot;\n      var slotY = vertical ? slot : this$1.lineBox();\n\n      if (vertical) {\n        slotX.x1 -= rangeSize * (mirror ? -1 : 1);\n      } else {\n        slotY.y2 += rangeSize * (mirror ? -1 : 1);\n      }\n\n      elements.append(Path.fromRect(new geo.Rect([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {\n        fill: {\n          color: range.color,\n          opacity: range.opacity\n        },\n        stroke: {}\n      }));\n    }\n\n    return elements;\n  };\n\n  LinearScale.prototype.renderLabels = function renderLabels() {\n    var ref = this;\n    var labels = ref.labels;\n    var options = ref.options;\n    var elements = new Group();\n\n    for (var i = 0; i < labels.length; i++) {\n      elements.append(buildLabelElement(labels[i], options.labels));\n    }\n\n    return elements;\n  };\n\n  LinearScale.prototype.renderLine = function renderLine() {\n    var line = this.options.line;\n    var lineBox = this.lineBox();\n    var elements = new Group();\n\n    if (line.width > 0 && line.visible) {\n      var linePath = new Path({\n        stroke: {\n          color: line.color,\n          dashType: line.dashType,\n          width: line.width\n        }\n      });\n      linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n      elements.append(linePath);\n    }\n\n    return elements;\n  };\n\n  LinearScale.prototype.renderTicks = function renderTicks$1() {\n    var ticks = new Group();\n    var options = this.options;\n    var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n    var tickRenderOptions = {\n      vertical: options.vertical,\n      mirror: options.labels.mirror,\n      lineBox: this.lineBox()\n    };\n    renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);\n    renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {\n      skipUnit: majorUnit / options.minorUnit\n    }, options.minorTicks));\n    return ticks;\n  };\n\n  return LinearScale;\n}(NumericAxis);\n\nsetDefaultOptions(LinearScale, {\n  min: 0,\n  max: 50,\n  majorTicks: {\n    size: 15,\n    align: INSIDE,\n    color: BLACK,\n    width: DEFAULT_LINE_WIDTH,\n    visible: true\n  },\n  minorTicks: {\n    size: 10,\n    align: INSIDE,\n    color: BLACK,\n    width: DEFAULT_LINE_WIDTH,\n    visible: true\n  },\n  line: {\n    width: DEFAULT_LINE_WIDTH\n  },\n  labels: {\n    position: INSIDE,\n    padding: 2\n  },\n  mirror: false,\n  _alignLines: false\n});\nexport default LinearScale;","map":null,"metadata":{},"sourceType":"module"}