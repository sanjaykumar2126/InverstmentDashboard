{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { deepExtend, defined } from '../../common';\nimport { X, Y } from '../../common/constants';\nimport LinearPointer from './linear-pointer';\nimport BarLinearPointerAnimation from './bar-linear-pointer-animation';\nvar Group = drawing.Group;\nvar Path = drawing.Path;\n\nvar BarLinearPointer = function (LinearPointer) {\n  function BarLinearPointer(scale, options) {\n    LinearPointer.call(this, scale, options);\n\n    if (!defined(this.options.size)) {\n      this.options.size = this.scale.options.majorTicks.size * 0.3;\n    }\n  }\n\n  if (LinearPointer) BarLinearPointer.__proto__ = LinearPointer;\n  BarLinearPointer.prototype = Object.create(LinearPointer && LinearPointer.prototype);\n  BarLinearPointer.prototype.constructor = BarLinearPointer;\n\n  BarLinearPointer.prototype.pointerShape = function pointerShape(value) {\n    var ref = this;\n    var scale = ref.scale;\n    var options = ref.options;\n    var ref$1 = scale.options;\n    var mirror = ref$1.mirror;\n    var vertical = ref$1.vertical;\n    var dir = mirror === vertical ? -1 : 1;\n    var size = options.size * dir;\n    var minSlot = scale.getSlot(scale.options.min);\n    var slot = scale.getSlot(value);\n    var axis = vertical ? Y : X;\n    var sizeAxis = vertical ? X : Y;\n    var margin = this._margin() * dir;\n    var p1 = new geo.Point();\n    p1[axis] = minSlot[axis + \"1\"];\n    p1[sizeAxis] = minSlot[sizeAxis + \"1\"];\n    var p2 = new geo.Point();\n    p2[axis] = slot[axis + \"1\"];\n    p2[sizeAxis] = slot[sizeAxis + \"1\"];\n\n    if (vertical) {\n      p1.translate(margin, 0);\n      p2.translate(margin, 0);\n    } else {\n      p1.translate(0, margin);\n      p2.translate(0, margin);\n    }\n\n    var p3 = p2.clone();\n    var p4 = p1.clone();\n\n    if (vertical) {\n      p3.translate(size, 0);\n      p4.translate(size, 0);\n    } else {\n      p3.translate(0, size);\n      p4.translate(0, size);\n    }\n\n    return [p1, p2, p3, p4];\n  };\n\n  BarLinearPointer.prototype.repaint = function repaint() {\n    var ref = this;\n    var scale = ref.scale;\n    var options = ref.options;\n    var shape = this.pointerShape(options.value);\n    var pointerPath = this.pointerPath;\n    var oldShape = this.pointerShape(options._oldValue);\n    pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();\n    var animation = new BarLinearPointerAnimation(pointerPath, deepExtend(options.animation, {\n      reverse: scale.options.reverse,\n      vertical: scale.options.vertical,\n      oldPoints: [oldShape[1], oldShape[2]],\n      newPoints: [shape[1], shape[2]]\n    }));\n\n    if (options.animation.transitions === false) {\n      animation.options.duration = 0;\n    }\n\n    animation.setup();\n    animation.play();\n  };\n\n  BarLinearPointer.prototype.render = function render() {\n    var group = new Group();\n    var elementOptions = this.getElementOptions();\n\n    if (this.options.track.visible) {\n      group.append(this.renderTrack());\n    }\n\n    var pointer = this.pointerPath = new Path({\n      stroke: elementOptions.stroke,\n      fill: elementOptions.fill\n    });\n    group.append(pointer);\n    this.elements = group;\n    return group;\n  };\n\n  BarLinearPointer.prototype.renderTrack = function renderTrack() {\n    var trackOptions = this.options.track;\n    var border = trackOptions.border || {};\n    var trackBox = this.trackBox.clone().pad(border.width || 0);\n    return new Path.fromRect(trackBox.toRect(), {\n      fill: {\n        color: trackOptions.color,\n        opacity: trackOptions.opacity\n      },\n      stroke: {\n        color: border.width ? border.color || trackOptions.color : \"\",\n        width: border.width,\n        dashType: border.dashType\n      }\n    });\n  };\n\n  return BarLinearPointer;\n}(LinearPointer);\n\nexport default BarLinearPointer;","map":null,"metadata":{},"sourceType":"module"}