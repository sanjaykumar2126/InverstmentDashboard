{"ast":null,"code":"/**\n * Defines the behavior of a pyramid series\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { removeElement } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement } from '../../common/utils/helper';\nimport { TriangularBase } from './triangular-base';\n/**\n * PyramidSeries module used to render `Pyramid` Series.\n */\n\nvar PyramidSeries =\n/** @class */\nfunction (_super) {\n  __extends(PyramidSeries, _super);\n\n  function PyramidSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Defines the path of a pyramid segment\n   */\n\n\n  PyramidSeries.prototype.getSegmentData = function (point, series, chart) {\n    var area = series.triangleSize; //top of th series\n\n    var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2;\n    var points = []; //consider, if the point is exploded\n\n    var offset = 0;\n    var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;\n    var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x; //top and bottom\n\n    var top = point.yRatio;\n    var bottom = point.yRatio + point.heightRatio; //width of the top and bottom edge\n\n    var topRadius = 0.5 * (1 - point.yRatio);\n    var bottomRadius = 0.5 * (1 - bottom);\n    top += seriesTop / area.height;\n    bottom += seriesTop / area.height;\n    var line1 = {\n      x: emptySpaceAtLeft + offset + topRadius * area.width,\n      y: top * area.height\n    };\n    var line2 = {\n      x: emptySpaceAtLeft + offset + (1 - topRadius) * area.width,\n      y: top * area.height\n    };\n    var line3 = {\n      x: emptySpaceAtLeft + offset + (1 - bottomRadius) * area.width,\n      y: bottom * area.height\n    };\n    var line4 = {\n      x: emptySpaceAtLeft + offset + bottomRadius * area.width,\n      y: bottom * area.height\n    };\n    var polygon = [line1, line2, line3, line4];\n    this.setLabelLocation(series, point, polygon);\n    var direction = this.findPath(polygon);\n    return direction;\n  };\n  /**\n   * Initializes the size of the pyramid segments\n   * @private\n   */\n\n\n  PyramidSeries.prototype.initializeSizeRatio = function (points, series) {\n    if (series.pyramidMode === 'Linear') {\n      _super.prototype.initializeSizeRatio.call(this, points, series, true);\n    } else {\n      this.calculateSurfaceSegments(series);\n    }\n  };\n  /**\n   * Defines the size of the pyramid segments, the surface of that will reflect the values\n   */\n\n\n  PyramidSeries.prototype.calculateSurfaceSegments = function (series) {\n    var count = series.points.length;\n    var sumOfValues = series.sumOfPoints;\n    var yRatio = 0;\n    var y = [];\n    var height = [];\n    var gapRatio = Math.min(0, Math.max(series.gapRatio, 1));\n    var gapHeight = gapRatio / (count - 1);\n    var preSum = this.getSurfaceHeight(0, sumOfValues);\n    var currY = 0;\n\n    for (var i = 0; i < count; i++) {\n      if (series.points[i].visible) {\n        y[i] = currY;\n        height[i] = this.getSurfaceHeight(currY, Math.abs(series.points[i].y));\n        currY += height[i] + gapHeight * preSum;\n      }\n    }\n\n    var coef = 1 / (currY - gapHeight * preSum);\n\n    for (var i = 0; i < count; i++) {\n      if (series.points[i].visible) {\n        series.points[i].yRatio = coef * y[i];\n        series.points[i].heightRatio = coef * height[i];\n      }\n    }\n  };\n  /**\n   * Finds the height of pyramid segment\n   */\n\n\n  PyramidSeries.prototype.getSurfaceHeight = function (y, surface) {\n    var result = this.solveQuadraticEquation(1, 2 * y, -surface);\n    return result;\n  };\n  /**\n   * Solves quadratic equation\n   */\n\n\n  PyramidSeries.prototype.solveQuadraticEquation = function (a, b, c) {\n    var root1;\n    var root2;\n    var d = b * b - 4 * a * c;\n\n    if (d >= 0) {\n      var sd = Math.sqrt(d);\n      root1 = (-b - sd) / (2 * a);\n      root2 = (-b + sd) / (2 * a);\n      return Math.max(root1, root2);\n    }\n\n    return 0;\n  };\n  /**\n   * Renders a pyramid segment\n   */\n\n\n  PyramidSeries.prototype.renderPoint = function (point, series, chart, options, seriesGroup, redraw) {\n    if (!point.visible) {\n      removeElement(options.id);\n      return null;\n    }\n\n    options.d = this.getSegmentData(point, series, chart);\n    point.midAngle = 0;\n    appendChildElement(false, seriesGroup, chart.renderer.drawPath(options), redraw);\n\n    if (point.isExplode) {\n      chart.accBaseModule.explodePoints(point.index, chart, true);\n    }\n  };\n  /**\n   * To get the module name of the Pyramid series.\n   */\n\n\n  PyramidSeries.prototype.getModuleName = function () {\n    return 'PyramidSeries';\n  };\n  /**\n   * To destroy the pyramid series\n   * @return {void}\n   * @private\n   */\n\n\n  PyramidSeries.prototype.destroy = function (accumulation) {\n    /**\n     * Destroys the pyramid series\n     */\n  };\n\n  return PyramidSeries;\n}(TriangularBase);\n\nexport { PyramidSeries };","map":null,"metadata":{},"sourceType":"module"}