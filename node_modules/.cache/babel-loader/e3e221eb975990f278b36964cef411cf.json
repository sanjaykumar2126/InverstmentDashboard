{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { setRange, triggerLabelRender } from '../../common/utils/helper';\nimport { DoubleRange } from '../utils/double-range';\nimport { withIn, firstToLowerCase } from '../../common/utils/helper';\nimport { DataUtil } from '@syncfusion/ej2-data';\nimport { NiceInterval } from '../axis/axis-helper';\nimport { extend, getValue, isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * `DateTime` module is used to render datetime axis.\n */\n\nvar DateTime =\n/** @class */\nfunction (_super) {\n  __extends(DateTime, _super);\n  /**\n   * Constructor for the dateTime module.\n   * @private\n   */\n\n\n  function DateTime(chart) {\n    return _super.call(this, chart) || this;\n  }\n  /**\n   * The function to calculate the range and labels for the axis.\n   * @return {void}\n   */\n\n\n  DateTime.prototype.calculateRangeAndInterval = function (size, axis) {\n    this.calculateRange(axis, size);\n    this.getActualRange(axis, size);\n    this.applyRangePadding(axis, size);\n    this.calculateVisibleLabels(axis, this.chart);\n  };\n  /**\n   * Actual Range for the axis.\n   * @private\n   */\n\n\n  DateTime.prototype.getActualRange = function (axis, size) {\n    var option = {\n      skeleton: 'full',\n      type: 'dateTime'\n    };\n    var dateParser = this.chart.intl.getDateParser(option);\n    var dateFormatter = this.chart.intl.getDateFormat(option); // Axis min\n\n    if (axis.minimum !== null) {\n      this.min = Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n        val: axis.minimum\n      }).val))));\n    } else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {\n      this.min = Date.parse(dateParser(dateFormatter(new Date(1970, 1, 1))));\n    } // Axis Max\n\n\n    if (axis.maximum !== null) {\n      this.max = Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n        val: axis.maximum\n      }).val))));\n    } else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {\n      this.max = Date.parse(dateParser(dateFormatter(new Date(1970, 5, 1))));\n    }\n\n    if (this.min === this.max) {\n      this.max = this.max + 2592000000;\n      this.min = this.min - 2592000000;\n    }\n\n    axis.actualRange = {};\n    axis.doubleRange = new DoubleRange(this.min, this.max);\n    var datetimeInterval = this.calculateDateTimeNiceInterval(axis, size, axis.doubleRange.start, axis.doubleRange.end);\n\n    if (!axis.interval) {\n      axis.actualRange.interval = datetimeInterval;\n    } else {\n      axis.actualRange.interval = axis.interval;\n    }\n\n    axis.actualRange.min = axis.doubleRange.start;\n    axis.actualRange.max = axis.doubleRange.end;\n  };\n  /**\n   * Apply padding for the range.\n   * @private\n   */\n\n\n  DateTime.prototype.applyRangePadding = function (axis, size) {\n    this.min = axis.actualRange.min;\n    this.max = axis.actualRange.max;\n    var minimum;\n    var maximum;\n    var interval = axis.actualRange.interval;\n\n    if (!setRange(axis)) {\n      var rangePadding = axis.getRangePadding(this.chart);\n      minimum = new Date(this.min);\n      maximum = new Date(this.max);\n      var intervalType = axis.actualIntervalType;\n\n      if (rangePadding === 'None') {\n        this.min = minimum.getTime();\n        this.max = maximum.getTime();\n      } else if (rangePadding === 'Additional' || rangePadding === 'Round') {\n        switch (intervalType) {\n          case 'Years':\n            this.getYear(minimum, maximum, rangePadding, interval);\n            break;\n\n          case 'Months':\n            this.getMonth(minimum, maximum, rangePadding, interval);\n            break;\n\n          case 'Days':\n            this.getDay(minimum, maximum, rangePadding, interval);\n            break;\n\n          case 'Hours':\n            this.getHour(minimum, maximum, rangePadding, interval);\n            break;\n\n          case 'Minutes':\n            var minute = minimum.getMinutes() / interval * interval;\n            var endMinute = maximum.getMinutes() + (minimum.getMinutes() - minute);\n\n            if (rangePadding === 'Round') {\n              this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute, 0).getTime();\n              this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute, 59).getTime();\n            } else {\n              this.min = new Date(minimum.getFullYear(), maximum.getMonth(), minimum.getDate(), minimum.getHours(), minute + -interval, 0).getTime();\n              this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute + interval, 0).getTime();\n            }\n\n            break;\n\n          case 'Seconds':\n            var second = minimum.getSeconds() / interval * interval;\n            var endSecond = maximum.getSeconds() + (minimum.getSeconds() - second);\n\n            if (rangePadding === 'Round') {\n              this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second, 0).getTime();\n              this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond, 0).getTime();\n            } else {\n              this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second + -interval, 0).getTime();\n              this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond + interval, 0).getTime();\n            }\n\n            break;\n        }\n      }\n    }\n\n    axis.actualRange.min = axis.minimum != null ? this.min : this.min;\n    axis.actualRange.max = axis.maximum != null ? this.max : this.max;\n    axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;\n    axis.doubleRange = new DoubleRange(axis.actualRange.min, axis.actualRange.max);\n    this.calculateVisibleRange(size, axis);\n  };\n\n  DateTime.prototype.getYear = function (minimum, maximum, rangePadding, interval) {\n    var startYear = minimum.getFullYear();\n    var endYear = maximum.getFullYear();\n\n    if (rangePadding === 'Additional') {\n      this.min = new Date(startYear - interval, 1, 1, 0, 0, 0).getTime();\n      this.max = new Date(endYear + interval, 1, 1, 0, 0, 0).getTime();\n    } else {\n      this.min = new Date(startYear, 0, 0, 0, 0, 0).getTime();\n      this.max = new Date(endYear, 11, 30, 23, 59, 59).getTime();\n    }\n  };\n\n  DateTime.prototype.getMonth = function (minimum, maximum, rangePadding, interval) {\n    var month = minimum.getMonth();\n    var endMonth = maximum.getMonth();\n\n    if (rangePadding === 'Round') {\n      this.min = new Date(minimum.getFullYear(), month, 0, 0, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), endMonth, new Date(maximum.getFullYear(), maximum.getMonth(), 0).getDate(), 23, 59, 59).getTime();\n    } else {\n      this.min = new Date(minimum.getFullYear(), month + -interval, 1, 0, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), endMonth + interval, endMonth === 2 ? 28 : 30, 0, 0, 0).getTime();\n    }\n  };\n\n  DateTime.prototype.getDay = function (minimum, maximum, rangePadding, interval) {\n    var day = minimum.getDate();\n    var endDay = maximum.getDate();\n\n    if (rangePadding === 'Round') {\n      this.min = new Date(minimum.getFullYear(), minimum.getMonth(), day, 0, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), maximum.getMonth(), endDay, 23, 59, 59).getTime();\n    } else {\n      this.min = new Date(minimum.getFullYear(), minimum.getMonth(), day + -interval, 0, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), maximum.getMonth(), endDay + interval, 0, 0, 0).getTime();\n    }\n  };\n\n  DateTime.prototype.getHour = function (minimum, maximum, rangePadding, interval) {\n    var hour = minimum.getHours() / interval * interval;\n    var endHour = maximum.getHours() + (minimum.getHours() - hour);\n\n    if (rangePadding === 'Round') {\n      this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour, 59, 59).getTime();\n    } else {\n      this.min = new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour + -interval, 0, 0).getTime();\n      this.max = new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour + interval, 0, 0).getTime();\n    }\n  };\n  /**\n   * Calculate visible range for axis.\n   * @private\n   */\n\n\n  DateTime.prototype.calculateVisibleRange = function (size, axis) {\n    axis.visibleRange = {\n      min: axis.actualRange.min,\n      max: axis.actualRange.max,\n      interval: axis.actualRange.interval,\n      delta: axis.actualRange.delta\n    };\n    var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;\n\n    if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {\n      axis.calculateVisibleRange(size);\n      axis.visibleRange.interval = axis.enableAutoIntervalOnZooming ? this.calculateDateTimeNiceInterval(axis, size, axis.visibleRange.min, axis.visibleRange.max) : axis.visibleRange.interval;\n    }\n\n    axis.dateTimeInterval = this.increaseDateTimeInterval(axis, axis.visibleRange.min, axis.visibleRange.interval).getTime() - axis.visibleRange.min;\n    axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n  };\n  /**\n   * Calculate visible labels for the axis.\n   * @param axis\n   * @param chart\n   * @private\n   */\n\n\n  DateTime.prototype.calculateVisibleLabels = function (axis, chart) {\n    axis.visibleLabels = [];\n    var tempInterval = axis.visibleRange.min;\n    var labelStyle;\n    var previousValue;\n    var axisLabels = axis.visibleLabels;\n\n    if (!setRange(axis)) {\n      tempInterval = this.alignRangeStart(axis, tempInterval, axis.visibleRange.interval, axis.actualIntervalType).getTime();\n    }\n\n    while (tempInterval <= axis.visibleRange.max) {\n      labelStyle = extend({}, getValue('properties', axis.labelStyle), null, true);\n      previousValue = axisLabels.length ? axis.visibleLabels[axisLabels.length - 1].value : tempInterval;\n      axis.format = chart.intl.getDateFormat({\n        format: this.findCustomFormats(axis, tempInterval, previousValue),\n        type: firstToLowerCase(axis.skeletonType),\n        skeleton: this.getSkeleton(axis, tempInterval, previousValue)\n      });\n      axis.startLabel = axis.format(new Date(axis.visibleRange.min));\n      axis.endLabel = axis.format(new Date(axis.visibleRange.max));\n\n      if (withIn(tempInterval, axis.visibleRange)) {\n        triggerLabelRender(chart, tempInterval, axis.format(new Date(tempInterval)), labelStyle, axis);\n      }\n\n      tempInterval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();\n    } //tooltip and crosshair formats for 'Months' and 'Days' interval types\n\n\n    if ((axis.actualIntervalType === 'Months' || axis.actualIntervalType === 'Days') && axis.isChart) {\n      axis.format = chart.intl.getDateFormat({\n        format: axis.labelFormat || (axis.actualIntervalType === 'Months' && !axis.skeleton ? 'y MMM' : ''),\n        type: firstToLowerCase(axis.skeletonType),\n        skeleton: axis.skeleton || (axis.actualIntervalType === 'Days' ? 'MMMd' : '')\n      });\n    }\n\n    if (axis.getMaxLabelWidth) {\n      axis.getMaxLabelWidth(this.chart);\n    }\n  };\n  /** @private */\n\n\n  DateTime.prototype.increaseDateTimeInterval = function (axis, value, interval) {\n    var result = new Date(value);\n    interval = Math.ceil(interval);\n    axis.visibleRange.interval = interval;\n    var intervalType = axis.actualIntervalType;\n\n    switch (intervalType) {\n      case 'Years':\n        result.setFullYear(result.getFullYear() + interval);\n        return result;\n\n      case 'Quarter':\n        result.setMonth(result.getMonth() + 3 * interval);\n        return result;\n\n      case 'Months':\n        result.setMonth(result.getMonth() + interval);\n        return result;\n\n      case 'Weeks':\n        result.setDate(result.getDate() + interval * 7);\n        return result;\n\n      case 'Days':\n        result.setDate(result.getDate() + interval);\n        return result;\n\n      case 'Hours':\n        result.setHours(result.getHours() + interval);\n        return result;\n\n      case 'Minutes':\n        result.setMinutes(result.getMinutes() + interval);\n        return result;\n\n      case 'Seconds':\n        result.setSeconds(result.getSeconds() + interval);\n        return result;\n    }\n\n    return result;\n  };\n\n  DateTime.prototype.alignRangeStart = function (axis, sDate, intervalSize, intervalType) {\n    var sResult = new Date(sDate);\n\n    switch (axis.actualIntervalType) {\n      case 'Years':\n        var year = Math.floor(Math.floor(sResult.getFullYear() / intervalSize) * intervalSize);\n        sResult = new Date(year, sResult.getMonth(), sResult.getDate(), 0, 0, 0);\n        return sResult;\n\n      case 'Months':\n        var month = Math.floor(Math.floor(sResult.getMonth() / intervalSize) * intervalSize);\n        sResult = new Date(sResult.getFullYear(), month, sResult.getDate(), 0, 0, 0);\n        return sResult;\n\n      case 'Days':\n        var day = Math.floor(Math.floor(sResult.getDate() / intervalSize) * intervalSize);\n        sResult = new Date(sResult.getFullYear(), sResult.getMonth(), day, 0, 0, 0);\n        return sResult;\n\n      case 'Hours':\n        var hour = Math.floor(Math.floor(sResult.getHours() / intervalSize) * intervalSize);\n        sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), hour, 0, 0);\n        return sResult;\n\n      case 'Minutes':\n        var minutes = Math.floor(Math.floor(sResult.getMinutes() / intervalSize) * intervalSize);\n        sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), minutes, 0, 0);\n        return sResult;\n\n      case 'Seconds':\n        var seconds = Math.floor(Math.floor(sResult.getSeconds() / intervalSize) * intervalSize);\n        sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), sResult.getMinutes(), seconds, 0);\n        return sResult;\n    }\n\n    return sResult;\n  };\n  /**\n   * Get module name\n   */\n\n\n  DateTime.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'DateTime';\n  };\n  /**\n   * To destroy the category axis.\n   * @return {void}\n   * @private\n   */\n\n\n  DateTime.prototype.destroy = function (chart) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return DateTime;\n}(NiceInterval);\n\nexport { DateTime };","map":null,"metadata":{},"sourceType":"module"}