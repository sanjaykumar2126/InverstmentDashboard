{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { withInRange, logBase, markerAnimate, PolarArc, valueToCoefficient, firstToLowerCase } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { PolarRadarPanel } from '../axis/polar-radar-panel';\nimport { pointRender } from '../../common/model/constants';\nimport { Animation } from '@syncfusion/ej2-base';\n/**\n * `PolarSeries` module is used to render the polar series.\n */\n\nvar PolarSeries =\n/** @class */\nfunction (_super) {\n  __extends(PolarSeries, _super);\n\n  function PolarSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Render Polar Series.\n   * @return {void}.\n   * @private\n   */\n\n\n  PolarSeries.prototype.render = function (series, xAxis, yAxis, inverted) {\n    var seriesType = firstToLowerCase(series.drawType);\n\n    if (series.drawType.indexOf('Column') > -1) {\n      this.columnDrawTypeRender(series, xAxis, yAxis);\n    } else {\n      series.chart[seriesType + 'SeriesModule'].render(series, xAxis, yAxis, inverted);\n    }\n  };\n  /**\n   * Render Column DrawType.\n   * @return {void}.\n   * @private\n   */\n\n\n  PolarSeries.prototype.columnDrawTypeRender = function (series, xAxis, yAxis) {\n    var options;\n    var argsData;\n    var startAngle;\n    var endAngle;\n    var itemCurrentXPos;\n    var radius;\n    var inversedValue;\n    var pointStartAngle;\n    var pointEndAngle;\n    var x1;\n    var x2;\n    var y1;\n    var y2;\n    var startValue;\n    var endValue;\n    var innerRadius;\n    var min = xAxis.actualRange.min;\n    var centerX = series.clipRect.width / 2 + series.clipRect.x;\n    var dStartX;\n    var dStartY;\n    var centerY = series.clipRect.height / 2 + series.clipRect.y;\n    var dEndX;\n    var dEndY;\n    var isRangeColumn = series.drawType === 'RangeColumn';\n    var isPolar = series.type === 'Polar';\n    var isLogAxis = yAxis.valueType === 'Logarithmic';\n    var isStacking = series.drawType === 'StackingColumn';\n    var direction = '';\n    var sumofYValues = 0;\n    var interval = (series.points[1] ? series.points[1].xValue : 2 * series.points[0].xValue) - series.points[0].xValue;\n    var ticks = xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks' ? 0 : interval / 2;\n    var rangeInterval = xAxis.valueType === 'DateTime' ? xAxis.dateTimeInterval : 1;\n    this.getSeriesPosition(series);\n    var position = xAxis.isInversed ? series.rectCount - 1 - series.position : series.position;\n\n    do {\n      sumofYValues += rangeInterval;\n      min += rangeInterval;\n    } while (min <= xAxis.actualRange.max - (xAxis.valueType === 'Category' ? 0 : 1));\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n      point.symbolLocations = [];\n      point.regions = [];\n\n      if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {\n        inversedValue = xAxis.isInversed ? xAxis.visibleRange.max - point.xValue : point.xValue - xAxis.visibleRange.min;\n        itemCurrentXPos = inversedValue + (interval / series.rectCount * position - ticks) + sumofYValues / 360 * xAxis.startAngle;\n        itemCurrentXPos = itemCurrentXPos / sumofYValues;\n        startAngle = 2 * Math.PI * (itemCurrentXPos + xAxis.startAngle);\n        endAngle = 2 * Math.PI * (itemCurrentXPos + xAxis.startAngle + interval / series.rectCount / sumofYValues);\n        pointStartAngle = startAngle;\n        pointEndAngle = endAngle;\n        startAngle = startAngle - 0.5 * Math.PI;\n        endAngle = endAngle - 0.5 * Math.PI - 0.000001;\n\n        if (isStacking || isRangeColumn) {\n          startValue = isRangeColumn ? point.low : series.stackedValues.startValues[point.index];\n          endValue = isRangeColumn ? point.high : series.stackedValues.endValues[point.index];\n          endValue = isLogAxis ? logBase(endValue === 0 ? 1 : endValue, yAxis.logBase) : endValue;\n          endValue = endValue > yAxis.actualRange.max ? yAxis.actualRange.max : endValue;\n          radius = startValue === endValue ? 0 : series.chart.radius * valueToCoefficient(endValue, yAxis);\n          x1 = centerX + radius * Math.cos(startAngle);\n          x2 = centerX + radius * Math.cos(endAngle);\n          y1 = centerY + radius * Math.sin(startAngle);\n          y2 = centerY + radius * Math.sin(endAngle);\n          innerRadius = series.chart.radius * valueToCoefficient(startValue === 0 && yAxis.visibleRange.min !== 0 ? yAxis.visibleRange.min : startValue, yAxis);\n          dStartX = centerX + innerRadius * Math.cos(startAngle);\n          dStartY = centerY + innerRadius * Math.sin(startAngle);\n          dEndX = centerX + innerRadius * Math.cos(endAngle);\n          dEndY = centerY + innerRadius * Math.sin(endAngle);\n\n          if (isPolar) {\n            direction = 'M' + ' ' + x1 + ' ' + y1 + ' ' + 'A' + ' ' + radius + ' ' + radius + ' ' + '0' + ' ' + '0' + ' ' + 1 + ' ' + x2 + ' ' + y2 + ' ' + 'L' + ' ' + dEndX + ' ' + dEndY + ' ' + 'A' + ' ' + innerRadius + ' ' + innerRadius + ' ' + '1' + ' ' + '0' + ' ' + '0' + ' ' + dStartX + ' ' + dStartY + ' ' + 'Z';\n          } else {\n            direction = 'M' + ' ' + x1 + ' ' + y1 + ' ' + 'L' + ' ' + x2 + ' ' + y2 + ' ' + 'L ' + dEndX + ' ' + dEndY + ' ' + 'L' + ' ' + dStartX + ' ' + dStartY + ' ' + 'Z';\n          }\n\n          point.regionData = new PolarArc(pointStartAngle, pointEndAngle, innerRadius, radius, itemCurrentXPos);\n        } else {\n          endValue = point.yValue > yAxis.actualRange.max ? yAxis.actualRange.max : point.yValue;\n          radius = series.chart.radius * valueToCoefficient(isLogAxis ? logBase(endValue, yAxis.logBase) : endValue, yAxis);\n          x1 = centerX + radius * Math.cos(startAngle);\n          x2 = centerX + radius * Math.cos(endAngle);\n          y1 = centerY + radius * Math.sin(startAngle);\n          y2 = centerY + radius * Math.sin(endAngle);\n\n          if (isPolar) {\n            direction = 'M' + ' ' + x1 + ' ' + y1 + ' ' + 'A' + ' ' + radius + ' ' + radius + ' ' + '0' + ' ' + '0' + ' ' + 1 + ' ' + x2 + ' ' + y2 + ' ' + 'L' + ' ' + centerX + ' ' + centerY + ' ' + 'Z';\n          } else {\n            direction = 'M' + ' ' + x1 + ' ' + y1 + ' ' + 'L' + ' ' + x2 + ' ' + y2 + ' ' + 'L' + ' ' + centerX + ' ' + centerY + ' ' + 'Z';\n          }\n\n          point.regionData = new PolarArc(pointStartAngle, pointEndAngle, 0, radius, itemCurrentXPos);\n        }\n\n        argsData = this.triggerEvent(series.chart, series, point);\n        options = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);\n\n        if (!argsData.cancel) {\n          this.appendLinePath(options, series, '');\n\n          if (isPolar) {\n            point.symbolLocations.push({\n              x: centerX + radius * Math.cos(startAngle + (endAngle - startAngle) / 2),\n              y: centerY + radius * Math.sin(startAngle + (endAngle - startAngle) / 2)\n            });\n\n            if (isRangeColumn) {\n              point.symbolLocations.push({\n                x: centerX + innerRadius * Math.cos(startAngle + (endAngle - startAngle) / 2),\n                y: centerY + innerRadius * Math.sin(startAngle + (endAngle - startAngle) / 2)\n              });\n            }\n          } else {\n            point.symbolLocations.push({\n              x: (x1 + x2) / 2,\n              y: (y1 + y2) / 2\n            });\n\n            if (isRangeColumn) {\n              point.symbolLocations.push({\n                x: (dEndX + dStartX) / 2,\n                y: (dEndY + dStartY) / 2\n              });\n            }\n          }\n        }\n      }\n    }\n\n    this.renderMarker(series);\n    series.isRectSeries = true;\n  };\n  /**\n   * To trigger the point rendering event.\n   * @return {void}\n   * @private\n   */\n\n\n  PolarSeries.prototype.triggerEvent = function (chart, series, point) {\n    var argsData = {\n      cancel: false,\n      name: pointRender,\n      series: series,\n      point: point,\n      fill: series.setPointColor(point, series.interior),\n      border: series.setBorderColor(point, {\n        width: series.border.width,\n        color: series.border.color\n      })\n    };\n    chart.trigger(pointRender, argsData);\n    point.color = argsData.fill;\n    return argsData;\n  };\n  /** get position for column drawtypes\n   * @return {void}.\n   * @private\n   */\n\n\n  PolarSeries.prototype.getSeriesPosition = function (series) {\n    var chart = series.chart;\n    var seriesCollection = [];\n    var stackingGroup = [];\n    var vSeries = {\n      rectCount: 0,\n      position: null\n    };\n\n    for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n      var series_1 = _a[_i];\n\n      if (series_1.visible && (series_1.type === 'Polar' || series_1.type === 'Radar') && series_1.drawType.indexOf('Column') !== -1) {\n        seriesCollection.push(series_1);\n      }\n    }\n\n    seriesCollection.forEach(function (series) {\n      if (series.drawType.indexOf('Stacking') !== -1) {\n        if (series.stackingGroup) {\n          if (stackingGroup[series.stackingGroup] === undefined) {\n            series.position = vSeries.rectCount;\n            stackingGroup[series.stackingGroup] = vSeries.rectCount++;\n          } else {\n            series.position = stackingGroup[series.stackingGroup];\n          }\n        } else {\n          if (vSeries.position === null) {\n            series.position = vSeries.rectCount;\n            vSeries.position = vSeries.rectCount++;\n          } else {\n            series.position = vSeries.position;\n          }\n        }\n      } else {\n        series.position = vSeries.rectCount++;\n      }\n    });\n    seriesCollection.forEach(function (value) {\n      value.rectCount = vSeries.rectCount;\n    });\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  PolarSeries.prototype.doAnimation = function (series) {\n    var option = series.animation;\n    var duration = series.animation.duration;\n    var delay = series.animation.delay;\n    var rectElements = series.seriesElement.childNodes;\n    var count = 1;\n\n    if (series.drawType === 'Scatter') {\n      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n        var point = _a[_i];\n\n        if (!point.symbolLocations.length || !rectElements[count]) {\n          continue;\n        }\n\n        markerAnimate(rectElements[count], delay, duration, series, point.index, point.symbolLocations[0], false);\n        count++;\n      }\n    } else {\n      for (count = 1; count < rectElements.length; count++) {\n        this.doPolarRadarAnimation(rectElements[count], delay, duration, series);\n      }\n    }\n  };\n  /**\n   * To do the Polar Radar draw type column animation.\n   * @return {void}\n   * @private\n   */\n\n\n  PolarSeries.prototype.doPolarRadarAnimation = function (animateElement, delay, duration, series) {\n    var chartcenterX = series.clipRect.width / 2 + series.clipRect.x;\n    var chartcenterY = series.clipRect.height / 2 + series.clipRect.y;\n    var elementHeight = 0;\n    animateElement.style.visibility = 'hidden';\n    new Animation({}).animate(animateElement, {\n      duration: duration,\n      delay: delay,\n      progress: function (args) {\n        if (args.timeStamp > args.delay) {\n          args.element.style.visibility = 'visible';\n          elementHeight = (args.timeStamp - args.delay) / args.duration;\n          animateElement.setAttribute('transform', 'translate(' + chartcenterX + ' ' + chartcenterY + ') scale(' + elementHeight + ') translate(' + -chartcenterX + ' ' + -chartcenterY + ')');\n        }\n      },\n      end: function (model) {\n        animateElement.style.visibility = 'visible';\n        animateElement.removeAttribute('transform');\n        series.chart.trigger('animationComplete', {\n          series: series.chart.isBlazor ? {} : series\n        });\n      }\n    });\n  };\n  /**\n   * Get module name.\n   */\n\n\n  PolarSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'PolarSeries';\n  };\n  /**\n   * To destroy the polar series.\n   * @return {void}\n   * @private\n   */\n\n\n  PolarSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return PolarSeries;\n}(PolarRadarPanel);\n\nexport { PolarSeries };","map":null,"metadata":{},"sourceType":"module"}