{"ast":null,"code":"import { EventHandler, Browser, remove } from '@syncfusion/ej2-base';\nimport { ScrollElements, createScrollSvg } from './scrollbar-elements';\nimport { getElement, minMax, logBase } from '../utils/helper';\nimport { getScrollbarThemeColor } from '../model/theme';\nimport { scrollChanged, scrollEnd, scrollStart } from '../model/constants';\n/**\n * Scrollbar Base\n */\n\nvar ScrollBar =\n/** @class */\nfunction () {\n  /**\n   * Constructor for creating scrollbar\n   * @param component\n   * @param axis\n   */\n  function ScrollBar(component, axis) {\n    /** @private */\n    this.scrollRange = {\n      max: null,\n      min: null,\n      interval: null,\n      delta: null\n    };\n    this.component = component;\n    this.elements = [];\n    this.scrollElements = new ScrollElements(component);\n    this.axis = axis;\n    this.mouseMoveListener = this.scrollMouseMove.bind(this);\n    this.mouseUpListener = this.scrollMouseUp.bind(this);\n    this.animateDuration = 500;\n    this.isPointer = Browser.isPointer;\n    this.browserName = Browser.info.name;\n  }\n  /**\n   * To Mouse x and y position\n   * @param e\n   */\n\n\n  ScrollBar.prototype.getMouseXY = function (e) {\n    var pageX;\n    var pageY;\n    var touchArg;\n\n    if (e.type.indexOf('touch') > -1) {\n      touchArg = e;\n      pageX = touchArg.changedTouches[0].clientX;\n      pageY = touchArg.changedTouches[0].clientY;\n    } else {\n      pageX = e.clientX;\n      pageY = e.clientY;\n    }\n\n    var svgRect = getElement(this.component.element.id + '_scrollBar_svg' + this.axis.name).getBoundingClientRect();\n    this.mouseX = pageX - Math.max(svgRect.left, 0);\n    this.mouseY = pageY - Math.max(svgRect.top, 0);\n  };\n  /**\n   * Method to bind events for scrollbar svg object\n   * @param element\n   */\n\n\n  ScrollBar.prototype.wireEvents = function (element) {\n    EventHandler.add(element, Browser.touchStartEvent, this.scrollMouseDown, this);\n    EventHandler.add(element, Browser.touchMoveEvent, this.scrollMouseMove, this);\n    EventHandler.add(element, Browser.touchEndEvent, this.scrollMouseUp, this);\n    EventHandler.add(element, 'mousewheel', this.scrollMouseWheel, this);\n    window.addEventListener('mousemove', this.mouseMoveListener, false);\n    window.addEventListener('mouseup', this.mouseUpListener, false);\n  };\n  /**\n   * Method to remove events for srcollbar svg object\n   * @param element\n   */\n\n\n  ScrollBar.prototype.unWireEvents = function (element) {\n    EventHandler.remove(element, Browser.touchStartEvent, this.scrollMouseDown);\n    EventHandler.remove(element, Browser.touchMoveEvent, this.scrollMouseMove);\n    EventHandler.remove(element, Browser.touchEndEvent, this.scrollMouseUp);\n    EventHandler.remove(element, 'mousewheel', this.scrollMouseWheel);\n    window.removeEventListener('mousemove', this.mouseMoveListener, false);\n    window.removeEventListener('mouseup', this.mouseUpListener, false);\n  };\n  /**\n   * Handles the mouse down on scrollbar\n   * @param e\n   */\n\n\n  ScrollBar.prototype.scrollMouseDown = function (e) {\n    var id = e.target.id;\n    var elem = this.scrollElements;\n    this.getMouseXY(e);\n    this.isResizeLeft = this.isExist(id, '_leftCircle_') || this.isExist(id, '_leftArrow_');\n    this.isResizeRight = this.isExist(id, '_rightCircle_') || this.isExist(id, '_rightArrow_'); //  this.previousXY = this.isVertical ? this.mouseY : this.mouseX;\n\n    this.previousXY = this.isVertical && this.axis.isInversed ? this.mouseY : this.isVertical ? this.width - this.mouseY : this.axis.isInversed ? this.width - this.mouseX : this.mouseX;\n    this.previousWidth = elem.thumbRectWidth;\n    this.previousRectX = elem.thumbRectX;\n    this.startZoomPosition = this.axis.zoomPosition;\n    this.startZoomFactor = this.axis.zoomFactor;\n    this.startRange = this.axis.visibleRange;\n    this.scrollStarted = true;\n    this.component.trigger(scrollStart, this.getArgs(scrollStart));\n\n    if (this.isExist(id, 'scrollBarThumb_')) {\n      this.isThumbDrag = true;\n      this.svgObject.style.cursor = '-webkit-grabbing';\n    } else if (this.isExist(id, 'scrollBarBackRect_')) {\n      var currentX = this.moveLength(this.previousXY, this.previousRectX);\n      elem.thumbRectX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;\n      this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);\n      this.setZoomFactorPosition(elem.thumbRectX, elem.thumbRectWidth);\n\n      if (this.isLazyLoad) {\n        var thumbMove = elem.thumbRectX > this.previousRectX ? 'RightMove' : 'LeftMove';\n        var args = this.calculateLazyRange(elem.thumbRectX, elem.thumbRectWidth, thumbMove);\n\n        if (args) {\n          this.component.trigger(scrollEnd, args);\n        }\n      }\n    }\n    /**\n     * Customer issue\n     * Task ID - EJ2-28898\n     * Issue: While element's height is smaller than chart'height, html scroll bar presents. On that case while moving chart scrollbar,\n     * html scrollbar goes up due to chart's svg removed from the dom when zoomFactor and zoomPosition chnaged\n     * Fix: Only for scrolling purpose, height for element is set to chart's available height\n     */\n\n\n    if (this.component.element.style.height === '') {\n      this.isCustomHeight = true;\n      this.component.element.style.height = this.component.availableSize.height + 'px';\n    }\n  };\n  /**\n   * To check the matched string\n   * @param id\n   * @param match\n   */\n\n\n  ScrollBar.prototype.isExist = function (id, match) {\n    return id.indexOf(match) > -1;\n  };\n  /**\n   * To check current poisition is within scrollbar region\n   * @param currentX\n   */\n\n\n  ScrollBar.prototype.isWithIn = function (currentX) {\n    var circleRadius = 8;\n    return currentX - circleRadius >= 0 && currentX + this.scrollElements.thumbRectWidth + circleRadius <= this.width;\n  };\n  /**\n   * Method to find move length of thumb\n   * @param mouseXY\n   * @param thumbX\n   * @param circleRadius\n   */\n\n\n  ScrollBar.prototype.moveLength = function (mouseXY, thumbX, circleRadius) {\n    if (circleRadius === void 0) {\n      circleRadius = 8;\n    }\n\n    var moveLength = 10 / 100 * (this.width - circleRadius * 2);\n\n    if (mouseXY < thumbX) {\n      moveLength = thumbX - (thumbX - moveLength > circleRadius ? moveLength : circleRadius);\n    } else {\n      moveLength = thumbX + (thumbX + this.scrollElements.thumbRectWidth + moveLength < this.width - circleRadius ? moveLength : circleRadius);\n    }\n\n    return moveLength;\n  };\n  /**\n   * Method to calculate zoom factor and position\n   * @param currentX\n   * @param currentWidth\n   */\n\n\n  ScrollBar.prototype.setZoomFactorPosition = function (currentX, currentWidth) {\n    var axis = this.axis;\n    this.isScrollUI = true;\n    var circleRadius = 8;\n    var circleWidth = 1;\n    var currentScrollWidth = currentX + currentWidth + circleRadius + circleWidth;\n    var currentZPWidth = circleRadius + circleWidth / 2;\n    this.zoomPosition = (currentX - (currentX - currentZPWidth <= 0 ? currentZPWidth : 0)) / (this.isVertical ? axis.rect.height : this.width);\n    this.zoomFactor = (currentWidth + (currentScrollWidth >= this.width ? circleRadius + circleWidth : 0)) / (this.isVertical ? axis.rect.height : this.width);\n    axis.zoomPosition = this.zoomPosition;\n    axis.zoomFactor = this.zoomFactor;\n  };\n  /**\n   * Handles the mouse move on scrollbar\n   * @param e\n   */\n\n\n  ScrollBar.prototype.scrollMouseMove = function (e) {\n    var target = e.target;\n    var elem = this.scrollElements;\n    this.getMouseXY(e);\n    this.setCursor(target);\n    this.setTheme(target); //let mouseXY: number = this.isVertical ? this.mouseY : this.mouseX;\n\n    var mouseXY = this.isVertical && this.axis.isInversed ? this.width - this.mouseY : this.isVertical ? this.mouseY : this.mouseX;\n    var range = this.axis.visibleRange;\n    var zoomPosition = this.zoomPosition;\n    var zoomFactor = this.zoomFactor;\n\n    if (this.isThumbDrag) {\n      this.component.isScrolling = this.isThumbDrag;\n      mouseXY = this.isVertical || this.axis.isInversed ? this.width - mouseXY : mouseXY;\n      var currentX = elem.thumbRectX + (mouseXY - this.previousXY);\n\n      if (mouseXY >= currentX + elem.thumbRectWidth) {\n        this.setCursor(target);\n      } else {\n        this.svgObject.style.cursor = '-webkit-grabbing';\n      }\n\n      if (mouseXY >= 0 && mouseXY <= currentX + elem.thumbRectWidth) {\n        elem.thumbRectX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;\n        this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);\n        this.previousXY = mouseXY;\n        this.setZoomFactorPosition(currentX, elem.thumbRectWidth);\n      }\n\n      this.component.trigger(scrollChanged, this.getArgs(scrollChanged, range, zoomPosition, zoomFactor));\n    } else if (this.isResizeLeft || this.isResizeRight) {\n      this.resizeThumb(e);\n      this.component.trigger(scrollChanged, this.getArgs(scrollChanged, range, zoomPosition, zoomFactor));\n    }\n  };\n  /**\n   * Handles the mouse wheel on scrollbar\n   * @param e\n   */\n\n\n  ScrollBar.prototype.scrollMouseWheel = function (e) {\n    var svgRect = getElement(this.component.element.id + '_scrollBar_svg' + this.axis.name).getBoundingClientRect();\n    this.mouseX = e.clientX - Math.max(svgRect.left, 0);\n    this.mouseY = e.clientY - Math.max(svgRect.top, 0);\n    var origin = 0.5;\n    var elem = this.scrollElements;\n    var axis = this.axis;\n    var direction = this.browserName === 'mozilla' && !this.isPointer ? -e.detail / 3 > 0 ? 1 : -1 : e.wheelDelta / 120 > 0 ? 1 : -1;\n    var cumulative;\n    cumulative = Math.max(Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1) + 0.25 * direction, 1);\n    var range = this.axis.visibleRange;\n    var zoomPosition = this.zoomPosition;\n    var zoomFactor = this.zoomFactor;\n    var args;\n\n    if (cumulative >= 1) {\n      origin = axis.orientation === 'Horizontal' ? this.mouseX / axis.rect.width : 1 - this.mouseY / axis.rect.height;\n      origin = origin > 1 ? 1 : origin < 0 ? 0 : origin;\n      this.zoomFactor = cumulative === 1 ? 1 : minMax(1 / cumulative, 0, 1);\n      this.zoomPosition = cumulative === 1 ? 0 : axis.zoomPosition + (axis.zoomFactor - this.zoomFactor) * origin;\n    }\n\n    elem.thumbRectX = this.isWithIn(this.zoomPosition * this.width) ? this.zoomPosition * this.width : elem.thumbRectX;\n    this.isScrollUI = true;\n    this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);\n\n    if (this.isLazyLoad) {\n      this.setZoomFactorPosition(elem.thumbRectX, elem.thumbRectWidth);\n    }\n\n    axis.zoomFactor = this.zoomFactor;\n    axis.zoomPosition = this.zoomPosition;\n\n    if (this.isLazyLoad) {\n      args = this.calculateMouseWheelRange(elem.thumbRectX, elem.thumbRectWidth);\n\n      if (args) {\n        if (args.currentRange.minimum !== args.previousAxisRange.minimum && args.currentRange.maximum !== args.previousAxisRange.maximum) {\n          this.component.trigger(scrollEnd, args);\n          this.isScrollEnd = false;\n        }\n      }\n    }\n\n    if (!this.isLazyLoad) {\n      this.component.trigger(scrollChanged, this.getArgs(scrollChanged, range, zoomPosition, zoomFactor));\n    }\n  };\n  /**\n   * Handles the mouse up on scrollbar\n   * @param e\n   */\n\n\n  ScrollBar.prototype.scrollMouseUp = function (e) {\n    var circleRadius = 8;\n    var circleWidth = 1;\n    var args;\n    this.startX = this.scrollElements.thumbRectX;\n    var currentScrollWidth = this.startX + this.scrollElements.thumbRectWidth + circleRadius + circleWidth;\n    var currentZPWidth = circleRadius + circleWidth / 2;\n\n    if ((this.isResizeLeft || this.isResizeRight) && !this.isLazyLoad) {\n      this.axis.zoomFactor = currentScrollWidth >= this.width - 1 && this.startX - currentZPWidth <= 0 ? 1 : this.zoomFactor;\n    }\n\n    if (this.isLazyLoad) {\n      var moveLength = this.previousRectX - this.startX;\n\n      if ((moveLength > 0 || moveLength < 0) && this.isThumbDrag) {\n        var thumbMove = moveLength < 0 ? 'RightMove' : 'LeftMove';\n\n        if (thumbMove === 'RightMove') {\n          this.startX = this.startX + Math.abs(moveLength) < this.width - circleRadius ? this.startX : this.width - circleRadius - this.scrollElements.thumbRectWidth;\n        } else {\n          this.startX = this.startX + this.scrollElements.thumbRectWidth - Math.abs(moveLength) > circleRadius ? this.startX : circleRadius;\n        }\n\n        args = this.calculateLazyRange(this.startX, this.scrollElements.thumbRectWidth, thumbMove);\n\n        if (args) {\n          this.component.trigger(scrollEnd, args);\n          this.scrollStarted = false;\n        }\n      }\n\n      if (this.isResizeLeft || this.isResizeRight) {\n        args = this.calculateLazyRange(this.startX, this.scrollElements.thumbRectWidth);\n\n        if (args) {\n          this.component.trigger(scrollEnd, args);\n          this.scrollStarted = false;\n        }\n      }\n    }\n\n    this.isThumbDrag = false;\n    this.isResizeLeft = false;\n    this.isResizeRight = false;\n    this.isScrollEnd = false;\n    this.component.isScrolling = false;\n\n    if (this.scrollStarted && !this.isLazyLoad) {\n      this.component.trigger(scrollEnd, this.getArgs(scrollChanged, this.startRange, this.startZoomPosition, this.startZoomFactor));\n      this.scrollStarted = false;\n    }\n    /**\n     * Customer issue\n     * Task ID - EJ2-28898\n     * Chart's height setted is removed here.\n     */\n\n\n    if (this.isCustomHeight) {\n      this.component.element.style.height = null;\n    }\n  };\n\n  ScrollBar.prototype.calculateMouseWheelRange = function (scrollThumbX, scrollThumbWidth) {\n    var zoomFactor;\n    var zoomPosition;\n    var currentStart;\n    var currentEnd;\n    var args;\n    var range = this.scrollRange;\n    var previousRange = this.getStartEnd(this.previousStart, this.previousEnd, false);\n    var circleRadius = 8;\n\n    if (scrollThumbX + scrollThumbWidth + circleRadius <= this.width) {\n      zoomPosition = (scrollThumbX - circleRadius) / this.width;\n      zoomFactor = scrollThumbWidth / this.width;\n    }\n\n    currentStart = range.min + zoomPosition * range.delta;\n    currentEnd = currentStart + zoomFactor * range.delta;\n\n    if (currentEnd) {\n      args = {\n        axis: this.axis,\n        currentRange: this.getStartEnd(currentStart, currentEnd, true),\n        previousAxisRange: previousRange\n      };\n    }\n\n    return args;\n  };\n\n  ;\n  /**\n   * Range calculation for lazy loading\n   */\n\n  ScrollBar.prototype.calculateLazyRange = function (scrollThumbX, scrollThumbWidth, thumbMove) {\n    var currentScrollWidth = scrollThumbWidth;\n    var zoomFactor;\n    var zoomPosition;\n    var currentStart;\n    var currentEnd;\n    var args;\n    var range = this.scrollRange;\n    var previousRange = this.getStartEnd(this.previousStart, this.previousEnd, false);\n    var circleRadius = 8;\n    var circleWidth = 16;\n\n    if (this.isResizeRight || thumbMove === 'RightMove') {\n      currentScrollWidth = this.isResizeRight ? currentScrollWidth + circleWidth : currentScrollWidth;\n      zoomFactor = currentScrollWidth / this.width;\n      zoomPosition = thumbMove === 'RightMove' ? (scrollThumbX + circleRadius) / this.width : this.axis.zoomPosition;\n      currentStart = thumbMove === 'RightMove' ? range.min + zoomPosition * range.delta : this.previousStart;\n      currentEnd = currentStart + zoomFactor * range.delta;\n    } else if (this.isResizeLeft || thumbMove === 'LeftMove') {\n      zoomPosition = (scrollThumbX - circleRadius) / this.width;\n      zoomFactor = currentScrollWidth / this.width;\n      currentStart = range.min + zoomPosition * range.delta;\n      currentStart = currentStart >= range.min ? currentStart : range.min;\n      currentEnd = thumbMove === 'LeftMove' ? currentStart + zoomFactor * range.delta : this.previousEnd;\n    } else if (this.isThumbDrag) {\n      zoomPosition = thumbMove === 'RightMove' ? (scrollThumbX + circleRadius) / this.width : (scrollThumbX - circleRadius) / this.width;\n      zoomFactor = this.scrollElements.thumbRectWidth / this.width;\n      currentStart = range.min + zoomPosition * range.delta;\n      currentStart = currentStart >= range.min ? currentStart : range.min;\n      currentEnd = currentStart + zoomFactor * range.delta;\n    }\n\n    if (currentEnd) {\n      args = {\n        axis: this.component.isBlazor ? {} : this.axis,\n        currentRange: this.getStartEnd(currentStart, currentEnd, true),\n        previousAxisRange: previousRange\n      };\n    }\n\n    return args;\n  };\n  /**\n   * Get start and end values\n   */\n\n\n  ScrollBar.prototype.getStartEnd = function (start, end, isCurrentStartEnd) {\n    var range;\n    var valueType = this.valueType;\n\n    if ((valueType === 'DateTime' || valueType === 'DateTimeCategory') && isCurrentStartEnd) {\n      this.previousStart = start;\n      this.previousEnd = end;\n    } else if (isCurrentStartEnd) {\n      this.previousStart = Math.ceil(start);\n      this.previousEnd = Math.ceil(end);\n    }\n\n    switch (valueType) {\n      case 'Double':\n      case 'Category':\n      case 'Logarithmic':\n        start = Math.ceil(start);\n        end = Math.ceil(end);\n        break;\n\n      case 'DateTime':\n      case 'DateTimeCategory':\n        start = new Date(start);\n        end = new Date(end);\n        break;\n    }\n\n    return range = {\n      minimum: start,\n      maximum: end\n    };\n  };\n  /**\n   * To render scroll bar\n   * @private\n   */\n\n\n  ScrollBar.prototype.render = function (isScrollExist) {\n    if (this.component.zoomModule || isScrollExist && this.axis.scrollbarSettings.enable) {\n      this.getDefaults();\n    }\n\n    this.getTheme();\n    this.removeScrollSvg();\n    createScrollSvg(this, this.component.svgRenderer);\n    this.wireEvents(this.svgObject);\n    this.svgObject.appendChild(this.scrollElements.renderElements(this, this.component.svgRenderer));\n    return this.svgObject;\n  };\n  /**\n   * Theming for scrollabr\n   */\n\n\n  ScrollBar.prototype.getTheme = function () {\n    this.scrollbarThemeStyle = getScrollbarThemeColor(this.component.theme);\n  };\n  /**\n   * Method to remove existing scrollbar\n   */\n\n\n  ScrollBar.prototype.removeScrollSvg = function () {\n    if (document.getElementById(this.component.element.id + '_scrollBar_svg' + this.axis.name)) {\n      remove(document.getElementById(this.component.element.id + '_scrollBar_svg' + this.axis.name));\n    }\n  };\n  /**\n   * Method to set cursor fpr scrollbar\n   * @param target\n   */\n\n\n  ScrollBar.prototype.setCursor = function (target) {\n    var id = target.id;\n    this.svgObject.style.cursor = id.indexOf('scrollBarThumb_') > -1 || id.indexOf('_gripCircle') > -1 ? '-webkit-grab' : id.indexOf('Circle_') > -1 || id.indexOf('Arrow_') > -1 ? this.isVertical ? 'ns-resize' : 'ew-resize' : 'auto';\n  };\n  /**\n   * Method to set theme for sollbar\n   * @param target\n   */\n\n\n  ScrollBar.prototype.setTheme = function (target) {\n    var id = target.id;\n    var isLeftHover = id.indexOf('_leftCircle_') > -1 || id.indexOf('_leftArrow_') > -1;\n    var isRightHover = id.indexOf('_rightCircle_') > -1 || id.indexOf('_rightArrow_') > -1;\n    var style = this.scrollbarThemeStyle;\n    var leftArrowEle = this.scrollElements.leftArrowEle;\n    var rightArrowEle = this.scrollElements.rightArrowEle;\n    var leftCircleEle = this.scrollElements.leftCircleEle;\n    var rightCircleEle = this.scrollElements.rightCircleEle;\n    var isAxis = this.isCurrentAxis(target, leftArrowEle);\n    leftCircleEle.style.fill = isLeftHover && isAxis ? style.circleHover : style.circle;\n    rightCircleEle.style.fill = isRightHover && isAxis ? style.circleHover : style.circle;\n    leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;\n    rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;\n\n    if (this.component.theme === 'HighContrastLight') {\n      leftArrowEle.style.fill = isLeftHover && isAxis ? style.arrowHover : style.arrow;\n      leftArrowEle.style.stroke = isLeftHover && isAxis ? style.arrowHover : style.arrow;\n      rightArrowEle.style.fill = isRightHover && isAxis ? style.arrowHover : style.arrow;\n      rightArrowEle.style.stroke = isRightHover && isAxis ? style.arrowHover : style.arrow;\n      leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;\n      rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;\n    }\n  };\n  /**\n   * To check current axis\n   * @param target\n   * @param ele\n   */\n\n\n  ScrollBar.prototype.isCurrentAxis = function (target, ele) {\n    return target.id.split('_')[2] === ele.id.split('_')[2];\n  };\n  /**\n   * Method to resize thumb\n   * @param e\n   */\n\n\n  ScrollBar.prototype.resizeThumb = function (e) {\n    var currentWidth;\n    var circleRadius = 8;\n    var padding = 5;\n    var gripWidth = 14;\n    var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;\n    var thumbX = this.previousRectX; // let mouseXY: number = this.isVertical ? this.mouseY : this.mouseX;\n\n    var mouseXY = this.isVertical && this.axis.isInversed ? this.mouseY : this.isVertical ? this.width - this.mouseY : this.axis.isInversed ? this.width - this.mouseX : this.mouseX;\n    var diff = Math.abs(this.previousXY - mouseXY);\n\n    if (this.isResizeLeft && mouseXY >= 0) {\n      var currentX = thumbX + (mouseXY > this.previousXY ? diff : -diff);\n      currentWidth = currentX - circleRadius >= 0 ? this.previousWidth + (mouseXY > this.previousXY ? -diff : diff) : this.previousWidth;\n      currentX = currentX - circleRadius >= 0 ? currentX : thumbX;\n\n      if (currentWidth >= minThumbWidth && mouseXY < currentX + currentWidth) {\n        this.scrollElements.thumbRectX = this.previousRectX = currentX;\n        this.scrollElements.thumbRectWidth = this.previousWidth = currentWidth;\n        this.previousXY = mouseXY;\n        this.positionThumb(currentX, currentWidth);\n        this.setZoomFactorPosition(currentX, currentWidth);\n      }\n    } else if (this.isResizeRight) {\n      currentWidth = mouseXY >= minThumbWidth + this.scrollElements.thumbRectX && mouseXY <= this.width - circleRadius ? mouseXY - this.scrollElements.thumbRectX : this.previousWidth;\n      this.scrollElements.thumbRectWidth = this.previousWidth = currentWidth;\n      this.previousXY = mouseXY;\n      this.positionThumb(this.startX, currentWidth);\n      this.setZoomFactorPosition(this.startX, currentWidth);\n\n      if (!this.isLazyLoad) {\n        this.setZoomFactorPosition(this.startX, currentWidth);\n      }\n    }\n  };\n  /**\n   * Method to position the scrollbar thumb\n   * @param currentX\n   * @param currentWidth\n   */\n\n\n  ScrollBar.prototype.positionThumb = function (currentX, currentWidth) {\n    var circlePadding = 3;\n    var elem = this.scrollElements;\n    var gripWidth = 14;\n    var gripCircleDiameter = 2;\n    var padding = gripWidth / 2 - gripCircleDiameter;\n    elem.slider.setAttribute('x', currentX.toString());\n    elem.slider.setAttribute('width', currentWidth.toString());\n    elem.leftCircleEle.setAttribute('cx', currentX.toString());\n    elem.rightCircleEle.setAttribute('cx', (currentX + currentWidth).toString());\n    elem.setArrowDirection(currentX, currentWidth, this.height);\n    elem.gripCircle.setAttribute('transform', 'translate(' + (currentX + currentWidth / 2 + (this.isVertical ? 1 : -1) * padding) + ',' + (this.isVertical ? '10' : '5') + ') rotate(' + (this.isVertical ? '180' : '0') + ')');\n  };\n  /**\n   * Method to get default values\n   */\n\n\n  ScrollBar.prototype.getDefaults = function () {\n    var axis = this.axis;\n\n    if (this.axis.scrollbarSettings.enable) {\n      this.isLazyLoad = true;\n      this.getLazyDefaults(axis);\n    }\n\n    var circleRadius = 8;\n    var padding = 5;\n    var gripWidth = 14;\n    var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;\n    this.isVertical = axis.orientation === 'Vertical';\n    var lazyRange = axis.scrollbarSettings.range;\n    this.zoomFactor = this.isLazyLoad ? this.zoomFactor : axis.zoomFactor;\n    this.zoomPosition = this.isLazyLoad ? this.zoomPosition : axis.zoomPosition;\n    var currentWidth = this.zoomFactor * (this.isVertical ? axis.rect.height : axis.rect.width);\n    currentWidth = currentWidth > minThumbWidth ? currentWidth : minThumbWidth;\n    this.scrollX = axis.rect.x;\n    this.scrollY = axis.rect.y;\n    this.width = this.isVertical ? axis.rect.height : axis.rect.width;\n    this.height = 16;\n    var currentX = this.zoomPosition * (this.isVertical ? axis.rect.height : this.width);\n    var minThumbX = this.width - minThumbWidth - circleRadius;\n    this.scrollElements.thumbRectX = currentX > minThumbX ? minThumbX : currentX < circleRadius ? circleRadius : currentX;\n    this.scrollElements.thumbRectWidth = currentWidth + this.scrollElements.thumbRectX < this.width - circleRadius * 2 ? currentWidth : this.width - this.scrollElements.thumbRectX - circleRadius;\n  };\n  /**\n   * Lazy load default values\n   */\n\n\n  ScrollBar.prototype.getLazyDefaults = function (axis) {\n    var start;\n    var end;\n    var valueType = axis.valueType;\n    var scrollbarSettings = axis.scrollbarSettings;\n    this.valueType = valueType = (!scrollbarSettings.range.minimum || !scrollbarSettings.range.maximum) && scrollbarSettings.pointsLength ? 'Double' : valueType;\n    var range = axis.scrollbarSettings.range;\n    var visibleRange = axis.visibleRange;\n    var pointsLength = axis.scrollbarSettings.pointsLength;\n    var zoomFactor;\n    var zoomPosition;\n    var option = {\n      skeleton: 'full',\n      type: 'dateTime'\n    };\n    var dateParser = this.component.intl.getDateParser(option);\n    var dateFormatter = this.component.intl.getDateFormat(option);\n\n    switch (valueType) {\n      case 'Double':\n      case 'Category':\n      case 'Logarithmic':\n        start = range.minimum ? range.minimum : pointsLength ? 0 : visibleRange.min;\n        end = range.maximum ? range.maximum : pointsLength ? pointsLength - 1 : visibleRange.max;\n        break;\n\n      case 'DateTime':\n      case 'DateTimeCategory':\n        start = range.minimum ? Date.parse(dateParser(dateFormatter(range.minimum))) : visibleRange.min;\n        end = range.maximum ? Date.parse(dateParser(dateFormatter(range.maximum))) : visibleRange.max;\n        break;\n    }\n\n    start = Math.min(start, visibleRange.min);\n    end = Math.max(end, visibleRange.max);\n    zoomFactor = (visibleRange.max - visibleRange.min) / (end - start);\n    zoomPosition = (visibleRange.min - start) / (end - start);\n    this.zoomFactor = range.minimum || range.maximum ? zoomFactor : this.axis.maxPointLength / axis.scrollbarSettings.pointsLength;\n    this.zoomPosition = range.minimum || range.maximum ? zoomPosition : axis.zoomPosition;\n    this.scrollRange.min = start;\n    this.scrollRange.max = end;\n    this.scrollRange.delta = end - start;\n    this.previousStart = visibleRange.min;\n    this.previousEnd = visibleRange.max;\n  };\n  /**\n   * Method to get log range\n   */\n\n\n  ScrollBar.prototype.getLogRange = function (axis) {\n    var logRange;\n    var range = axis.scrollbarSettings.range;\n    var start = logBase(range.minimum, axis.logBase);\n    start = isFinite(start) ? start : range.minimum;\n    var end = logBase(range.maximum, axis.logBase);\n    end = isFinite(start) ? end : range.maximum;\n    logRange = {\n      minimum: Math.floor(start / 1),\n      maximum: Math.ceil(end / 1)\n    };\n    return logRange;\n  };\n  /**\n   * Method for injecting scrollbar module\n   * @param axis\n   * @param component\n   */\n\n\n  ScrollBar.prototype.injectTo = function (axis, component) {\n    axis.zoomingScrollBar = new ScrollBar(component, axis);\n  };\n  /**\n   * Method to destroy scrollbar\n   */\n\n\n  ScrollBar.prototype.destroy = function () {\n    var _this = this;\n\n    if (this.axes) {\n      this.axes.map(function (axis) {\n        axis.zoomingScrollBar.destroy();\n      });\n    } else {\n      this.elements.map(function (element) {\n        _this.unWireEvents(element);\n\n        remove(element.firstChild);\n      });\n      this.elements = [];\n    }\n  };\n  /**\n   * Method to get scrollbar module name\n   */\n\n\n  ScrollBar.prototype.getModuleName = function () {\n    return 'ScrollBar';\n  };\n\n  ScrollBar.prototype.getArgs = function (eventName, range, zoomPosition, zoomFactor) {\n    var scrollArgs = {\n      axis: this.component.isBlazor ? {} : this.axis,\n      name: eventName,\n      range: this.axis.visibleRange,\n      zoomFactor: this.axis.zoomFactor,\n      zoomPosition: this.axis.zoomPosition,\n      previousRange: range,\n      previousZoomFactor: zoomFactor,\n      previousZoomPosition: zoomPosition\n    };\n    return scrollArgs;\n  };\n\n  return ScrollBar;\n}();\n\nexport { ScrollBar };","map":null,"metadata":{},"sourceType":"module"}