{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport { ChartElement, Box } from '../../core';\nimport Crosshair from '../crosshair/crosshair';\nimport Pane from '../pane';\nimport { hasValue } from '../utils';\nimport { WHITE, BLACK, X, Y, COORD_PRECISION, TOP, BOTTOM, LEFT, RIGHT, START, END } from '../../common/constants';\nimport { append, deepExtend, defined, getSpacing, getTemplate, inArray, isFunction, isString, limitValue, round, setDefaultOptions } from '../../common';\n\nvar PlotAreaBase = function (ChartElement) {\n  function PlotAreaBase(series, options, chartService) {\n    ChartElement.call(this, options);\n    this.initFields(series, options);\n    this.series = series;\n    this.initSeries();\n    this.charts = [];\n    this.options.legend = this.options.legend || {};\n    this.options.legend.items = [];\n    this.axes = [];\n    this.crosshairs = [];\n    this.chartService = chartService;\n    this.originalOptions = options;\n    this.createPanes();\n    this.render();\n    this.createCrosshairs();\n  }\n\n  if (ChartElement) PlotAreaBase.__proto__ = ChartElement;\n  PlotAreaBase.prototype = Object.create(ChartElement && ChartElement.prototype);\n  PlotAreaBase.prototype.constructor = PlotAreaBase;\n\n  PlotAreaBase.prototype.initFields = function initFields() {};\n\n  PlotAreaBase.prototype.initSeries = function initSeries() {\n    var series = this.series;\n\n    for (var i = 0; i < series.length; i++) {\n      series[i].index = i;\n    }\n  };\n\n  PlotAreaBase.prototype.createPanes = function createPanes() {\n    var this$1 = this;\n    var defaults = {\n      title: {\n        color: (this.options.title || {}).color\n      }\n    };\n    var panes = [];\n    var paneOptions = this.options.panes || [];\n    var panesLength = Math.max(paneOptions.length, 1);\n\n    function setTitle(options, defaults) {\n      if (isString(options.title)) {\n        options.title = {\n          text: options.title\n        };\n      }\n\n      options.title = deepExtend({}, defaults.title, options.title);\n    }\n\n    for (var i = 0; i < panesLength; i++) {\n      var options = paneOptions[i] || {};\n      setTitle(options, defaults);\n      var currentPane = new Pane(options);\n      currentPane.paneIndex = i;\n      panes.push(currentPane);\n      this$1.append(currentPane);\n    }\n\n    this.panes = panes;\n  };\n\n  PlotAreaBase.prototype.createCrosshairs = function createCrosshairs(panes) {\n    var this$1 = this;\n    if (panes === void 0) panes = this.panes;\n\n    for (var i = 0; i < panes.length; i++) {\n      var pane = panes[i];\n\n      for (var j = 0; j < pane.axes.length; j++) {\n        var axis = pane.axes[j];\n\n        if (axis.options.crosshair && axis.options.crosshair.visible) {\n          var currentCrosshair = new Crosshair(this$1.chartService, axis, axis.options.crosshair);\n          this$1.crosshairs.push(currentCrosshair);\n          pane.content.append(currentCrosshair);\n        }\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.removeCrosshairs = function removeCrosshairs(pane) {\n    var crosshairs = this.crosshairs;\n    var axes = pane.axes;\n\n    for (var i = crosshairs.length - 1; i >= 0; i--) {\n      for (var j = 0; j < axes.length; j++) {\n        if (crosshairs[i].axis === axes[j]) {\n          crosshairs.splice(i, 1);\n          break;\n        }\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.hideCrosshairs = function hideCrosshairs() {\n    var crosshairs = this.crosshairs;\n\n    for (var idx = 0; idx < crosshairs.length; idx++) {\n      crosshairs[idx].hide();\n    }\n  };\n\n  PlotAreaBase.prototype.findPane = function findPane(name) {\n    var panes = this.panes;\n    var matchingPane;\n\n    for (var i = 0; i < panes.length; i++) {\n      if (panes[i].options.name === name) {\n        matchingPane = panes[i];\n        break;\n      }\n    }\n\n    return matchingPane || panes[0];\n  };\n\n  PlotAreaBase.prototype.findPointPane = function findPointPane(point) {\n    var panes = this.panes;\n    var matchingPane;\n\n    for (var i = 0; i < panes.length; i++) {\n      if (panes[i].box.containsPoint(point)) {\n        matchingPane = panes[i];\n        break;\n      }\n    }\n\n    return matchingPane;\n  };\n\n  PlotAreaBase.prototype.appendAxis = function appendAxis(axis) {\n    var pane = this.findPane(axis.options.pane);\n    pane.appendAxis(axis);\n    this.axes.push(axis);\n    axis.plotArea = this;\n  };\n\n  PlotAreaBase.prototype.removeAxis = function removeAxis(axisToRemove) {\n    var this$1 = this;\n    var filteredAxes = [];\n\n    for (var i = 0; i < this.axes.length; i++) {\n      var axis = this$1.axes[i];\n\n      if (axisToRemove !== axis) {\n        filteredAxes.push(axis);\n      } else {\n        axis.destroy();\n      }\n    }\n\n    this.axes = filteredAxes;\n  };\n\n  PlotAreaBase.prototype.appendChart = function appendChart(chart, pane) {\n    this.charts.push(chart);\n\n    if (pane) {\n      pane.appendChart(chart);\n    } else {\n      this.append(chart);\n    }\n  };\n\n  PlotAreaBase.prototype.removeChart = function removeChart(chartToRemove) {\n    var this$1 = this;\n    var filteredCharts = [];\n\n    for (var i = 0; i < this.charts.length; i++) {\n      var chart = this$1.charts[i];\n\n      if (chart !== chartToRemove) {\n        filteredCharts.push(chart);\n      } else {\n        chart.destroy();\n      }\n    }\n\n    this.charts = filteredCharts;\n  };\n\n  PlotAreaBase.prototype.addToLegend = function addToLegend(series) {\n    var count = series.length;\n    var legend = this.options.legend;\n    var labels = legend.labels || {};\n    var inactiveItems = legend.inactiveItems || {};\n    var inactiveItemsLabels = inactiveItems.labels || {};\n    var data = [];\n\n    for (var i = 0; i < count; i++) {\n      var currentSeries = series[i];\n      var seriesVisible = currentSeries.visible !== false;\n\n      if (currentSeries.visibleInLegend === false) {\n        continue;\n      }\n\n      var text = currentSeries.name;\n      var labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);\n\n      if (labelTemplate) {\n        text = labelTemplate({\n          text: hasValue(text) ? text : \"\",\n          series: currentSeries\n        });\n      }\n\n      var defaults = currentSeries._defaults;\n      var color = currentSeries.color;\n\n      if (isFunction(color) && defaults) {\n        color = defaults.color;\n      }\n\n      var itemLabelOptions = void 0,\n          markerColor = void 0;\n\n      if (seriesVisible) {\n        itemLabelOptions = {};\n        markerColor = color;\n      } else {\n        itemLabelOptions = {\n          color: inactiveItemsLabels.color,\n          font: inactiveItemsLabels.font\n        };\n        markerColor = inactiveItems.markers.color;\n      }\n\n      if (hasValue(text) && text !== \"\") {\n        data.push({\n          text: text,\n          labels: itemLabelOptions,\n          markerColor: markerColor,\n          series: currentSeries,\n          active: seriesVisible\n        });\n      }\n    }\n\n    append(legend.items, data);\n  };\n\n  PlotAreaBase.prototype.groupAxes = function groupAxes(panes) {\n    var xAxes = [];\n    var yAxes = [];\n\n    for (var paneIx = 0; paneIx < panes.length; paneIx++) {\n      var paneAxes = panes[paneIx].axes;\n\n      for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {\n        var axis = paneAxes[axisIx];\n\n        if (axis.options.vertical) {\n          yAxes.push(axis);\n        } else {\n          xAxes.push(axis);\n        }\n      }\n    }\n\n    return {\n      x: xAxes,\n      y: yAxes,\n      any: xAxes.concat(yAxes)\n    };\n  };\n\n  PlotAreaBase.prototype.groupSeriesByPane = function groupSeriesByPane() {\n    var this$1 = this;\n    var series = this.series;\n    var seriesByPane = {};\n\n    for (var i = 0; i < series.length; i++) {\n      var currentSeries = series[i];\n      var pane = this$1.seriesPaneName(currentSeries);\n\n      if (seriesByPane[pane]) {\n        seriesByPane[pane].push(currentSeries);\n      } else {\n        seriesByPane[pane] = [currentSeries];\n      }\n    }\n\n    return seriesByPane;\n  };\n\n  PlotAreaBase.prototype.filterVisibleSeries = function filterVisibleSeries(series) {\n    var result = [];\n\n    for (var i = 0; i < series.length; i++) {\n      var currentSeries = series[i];\n\n      if (currentSeries.visible !== false) {\n        result.push(currentSeries);\n      }\n    }\n\n    return result;\n  };\n\n  PlotAreaBase.prototype.reflow = function reflow(targetBox) {\n    var options = this.options.plotArea;\n    var panes = this.panes;\n    var margin = getSpacing(options.margin);\n    this.box = targetBox.clone().unpad(margin);\n    this.reflowPanes();\n    this.detachLabels();\n    this.reflowAxes(panes);\n    this.reflowCharts(panes);\n  };\n\n  PlotAreaBase.prototype.redraw = function redraw(panes) {\n    var this$1 = this;\n    var panesArray = [].concat(panes);\n    this.initSeries(); //prevents leak during partial redraws. the cached gradients observers retain reference to the destroyed elements.\n\n    var root = this.getRoot();\n\n    if (root) {\n      root.cleanGradients();\n    }\n\n    for (var i = 0; i < panesArray.length; i++) {\n      this$1.removeCrosshairs(panesArray[i]);\n      panesArray[i].empty();\n    }\n\n    this.render(panesArray);\n    this.detachLabels();\n    this.reflowAxes(this.panes);\n    this.reflowCharts(panesArray);\n    this.createCrosshairs(panesArray);\n\n    for (var i$1 = 0; i$1 < panesArray.length; i$1++) {\n      panesArray[i$1].refresh();\n    }\n  };\n\n  PlotAreaBase.prototype.axisCrossingValues = function axisCrossingValues(axis, crossingAxes) {\n    var options = axis.options;\n    var crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);\n    var valuesToAdd = crossingAxes.length - crossingValues.length;\n    var defaultValue = crossingValues[0] || 0;\n\n    for (var i = 0; i < valuesToAdd; i++) {\n      crossingValues.push(defaultValue);\n    }\n\n    return crossingValues;\n  };\n\n  PlotAreaBase.prototype.alignAxisTo = function alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {\n    var slot = axis.getSlot(crossingValue, crossingValue, true);\n    var slotEdge = axis.options.reverse ? 2 : 1;\n    var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);\n    var targetEdge = targetAxis.options.reverse ? 2 : 1;\n    var axisBox = axis.box.translate(targetSlot[X + targetEdge] - slot[X + slotEdge], targetSlot[Y + targetEdge] - slot[Y + slotEdge]);\n\n    if (axis.pane !== targetAxis.pane) {\n      axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);\n    }\n\n    axis.reflow(axisBox);\n  };\n\n  PlotAreaBase.prototype.alignAxes = function alignAxes(xAxes, yAxes) {\n    var this$1 = this;\n    var xAnchor = xAxes[0];\n    var yAnchor = yAxes[0];\n    var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);\n    var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);\n    var leftAnchors = {};\n    var rightAnchors = {};\n    var topAnchors = {};\n    var bottomAnchors = {};\n\n    for (var i = 0; i < yAxes.length; i++) {\n      var axis = yAxes[i];\n      var pane = axis.pane;\n      var paneId = pane.id;\n      var visible = axis.options.visible !== false; // Locate pane anchor, if any, and use its axisCrossingValues\n\n      var anchor = paneAnchor(xAxes, pane) || xAnchor;\n      var anchorCrossings = xAnchorCrossings;\n\n      if (anchor !== xAnchor) {\n        anchorCrossings = this$1.axisCrossingValues(anchor, yAxes);\n      }\n\n      this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n      if (axis.options._overlap) {\n        continue;\n      }\n\n      if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {\n        // Push the axis to the left the previous y-axis so they don't overlap\n        if (leftAnchors[paneId]) {\n          axis.reflow(axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0));\n        }\n\n        if (visible) {\n          leftAnchors[paneId] = axis;\n        }\n      }\n\n      if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {\n        // Flip the labels on the right if we're at the right end of the pane\n        if (!axis._mirrored) {\n          axis.options.labels.mirror = !axis.options.labels.mirror;\n          axis._mirrored = true;\n        }\n\n        this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]); // Push the axis to the right the previous y-axis so they don't overlap\n\n        if (rightAnchors[paneId]) {\n          axis.reflow(axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0));\n        }\n\n        if (visible) {\n          rightAnchors[paneId] = axis;\n        }\n      }\n\n      if (i !== 0 && yAnchor.pane === axis.pane) {\n        axis.alignTo(yAnchor);\n        axis.reflow(axis.box);\n      }\n    }\n\n    for (var i$1 = 0; i$1 < xAxes.length; i$1++) {\n      var axis$1 = xAxes[i$1];\n      var pane$1 = axis$1.pane;\n      var paneId$1 = pane$1.id;\n      var visible$1 = axis$1.options.visible !== false; // Locate pane anchor and use its axisCrossingValues\n\n      var anchor$1 = paneAnchor(yAxes, pane$1) || yAnchor;\n      var anchorCrossings$1 = yAnchorCrossings;\n\n      if (anchor$1 !== yAnchor) {\n        anchorCrossings$1 = this$1.axisCrossingValues(anchor$1, xAxes);\n      }\n\n      this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);\n\n      if (axis$1.options._overlap) {\n        continue;\n      }\n\n      if (round(axis$1.lineBox().y1) === round(anchor$1.lineBox().y1)) {\n        // Flip the labels on top if we're at the top of the pane\n        if (!axis$1._mirrored) {\n          axis$1.options.labels.mirror = !axis$1.options.labels.mirror;\n          axis$1._mirrored = true;\n        }\n\n        this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]); // Push the axis above the previous x-axis so they don't overlap\n\n        if (topAnchors[paneId$1]) {\n          axis$1.reflow(axis$1.box.alignTo(topAnchors[paneId$1].box, TOP).translate(0, -axis$1.options.margin));\n        }\n\n        if (visible$1) {\n          topAnchors[paneId$1] = axis$1;\n        }\n      }\n\n      if (round(axis$1.lineBox().y2, COORD_PRECISION) === round(anchor$1.lineBox().y2, COORD_PRECISION)) {\n        // Push the axis below the previous x-axis so they don't overlap\n        if (bottomAnchors[paneId$1]) {\n          axis$1.reflow(axis$1.box.alignTo(bottomAnchors[paneId$1].box, BOTTOM).translate(0, axis$1.options.margin));\n        }\n\n        if (visible$1) {\n          bottomAnchors[paneId$1] = axis$1;\n        }\n      }\n\n      if (i$1 !== 0) {\n        axis$1.alignTo(xAnchor);\n        axis$1.reflow(axis$1.box);\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.shrinkAxisWidth = function shrinkAxisWidth(panes) {\n    var axes = this.groupAxes(panes).any;\n    var axisBox = axisGroupBox(axes);\n    var overflowX = 0;\n\n    for (var i = 0; i < panes.length; i++) {\n      var currentPane = panes[i];\n\n      if (currentPane.axes.length > 0) {\n        overflowX = Math.max(overflowX, axisBox.width() - currentPane.contentBox.width());\n      }\n    }\n\n    if (overflowX !== 0) {\n      for (var i$1 = 0; i$1 < axes.length; i$1++) {\n        var currentAxis = axes[i$1];\n\n        if (!currentAxis.options.vertical) {\n          currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));\n        }\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.shrinkAxisHeight = function shrinkAxisHeight(panes) {\n    var shrinked;\n\n    for (var i = 0; i < panes.length; i++) {\n      var currentPane = panes[i];\n      var axes = currentPane.axes;\n      var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());\n\n      if (overflowY !== 0) {\n        for (var j = 0; j < axes.length; j++) {\n          var currentAxis = axes[j];\n\n          if (currentAxis.options.vertical) {\n            currentAxis.reflow(currentAxis.box.shrink(0, overflowY));\n          }\n        }\n\n        shrinked = true;\n      }\n    }\n\n    return shrinked;\n  };\n\n  PlotAreaBase.prototype.fitAxes = function fitAxes(panes) {\n    var axes = this.groupAxes(panes).any;\n    var offsetX = 0;\n\n    for (var i = 0; i < panes.length; i++) {\n      var currentPane = panes[i];\n      var paneAxes = currentPane.axes;\n      var paneBox = currentPane.contentBox;\n\n      if (paneAxes.length > 0) {\n        var axisBox = axisGroupBox(paneAxes); // OffsetY is calculated and applied per pane\n\n        var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2); // OffsetX is calculated and applied globally\n\n        offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);\n\n        for (var j = 0; j < paneAxes.length; j++) {\n          var currentAxis = paneAxes[j];\n          currentAxis.reflow(currentAxis.box.translate(0, offsetY));\n        }\n      }\n    }\n\n    for (var i$1 = 0; i$1 < axes.length; i$1++) {\n      var currentAxis$1 = axes[i$1];\n      currentAxis$1.reflow(currentAxis$1.box.translate(offsetX, 0));\n    }\n  };\n\n  PlotAreaBase.prototype.reflowAxes = function reflowAxes(panes) {\n    var this$1 = this;\n    var axes = this.groupAxes(panes);\n\n    for (var i = 0; i < panes.length; i++) {\n      this$1.reflowPaneAxes(panes[i]);\n    }\n\n    if (axes.x.length > 0 && axes.y.length > 0) {\n      this.alignAxes(axes.x, axes.y);\n      this.shrinkAxisWidth(panes);\n      this.autoRotateAxisLabels(axes);\n      this.alignAxes(axes.x, axes.y);\n\n      if (this.shrinkAxisWidth(panes)) {\n        this.alignAxes(axes.x, axes.y);\n      }\n\n      this.shrinkAxisHeight(panes);\n      this.alignAxes(axes.x, axes.y);\n\n      if (this.shrinkAxisHeight(panes)) {\n        this.alignAxes(axes.x, axes.y);\n      }\n\n      this.fitAxes(panes);\n    }\n  };\n\n  PlotAreaBase.prototype.autoRotateAxisLabels = function autoRotateAxisLabels(groupedAxes) {\n    var this$1 = this;\n    var ref = this;\n    var panes = ref.panes;\n    var axes = allPaneAxes(panes);\n    var rotated;\n\n    for (var idx = 0; idx < axes.length; idx++) {\n      var axis = axes[idx];\n\n      if (axis.autoRotateLabels()) {\n        rotated = true;\n      }\n    }\n\n    if (rotated) {\n      for (var idx$1 = 0; idx$1 < panes.length; idx$1++) {\n        this$1.reflowPaneAxes(panes[idx$1]);\n      }\n\n      if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {\n        this.alignAxes(groupedAxes.x, groupedAxes.y);\n        this.shrinkAxisWidth(panes);\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.reflowPaneAxes = function reflowPaneAxes(pane) {\n    var axes = pane.axes;\n    var length = axes.length;\n\n    if (length > 0) {\n      for (var i = 0; i < length; i++) {\n        axes[i].reflow(pane.contentBox);\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.reflowCharts = function reflowCharts(panes) {\n    var charts = this.charts;\n    var count = charts.length;\n    var box = this.box;\n\n    for (var i = 0; i < count; i++) {\n      var chartPane = charts[i].pane;\n\n      if (!chartPane || inArray(chartPane, panes)) {\n        charts[i].reflow(box);\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.reflowPanes = function reflowPanes() {\n    var ref = this;\n    var box = ref.box;\n    var panes = ref.panes;\n    var panesLength = panes.length;\n    var remainingHeight = box.height();\n    var remainingPanes = panesLength;\n    var autoHeightPanes = 0;\n    var top = box.y1;\n\n    for (var i = 0; i < panesLength; i++) {\n      var currentPane = panes[i];\n      var height = currentPane.options.height;\n      currentPane.options.width = box.width();\n\n      if (!currentPane.options.height) {\n        autoHeightPanes++;\n      } else {\n        if (height.indexOf && height.indexOf(\"%\")) {\n          var percents = parseInt(height, 10) / 100;\n          currentPane.options.height = percents * box.height();\n        }\n\n        currentPane.reflow(box.clone());\n        remainingHeight -= currentPane.options.height;\n      }\n    }\n\n    for (var i$1 = 0; i$1 < panesLength; i$1++) {\n      var currentPane$1 = panes[i$1];\n\n      if (!currentPane$1.options.height) {\n        currentPane$1.options.height = remainingHeight / autoHeightPanes;\n      }\n    }\n\n    for (var i$2 = 0; i$2 < panesLength; i$2++) {\n      var currentPane$2 = panes[i$2];\n      var paneBox = box.clone().move(box.x1, top);\n      currentPane$2.reflow(paneBox);\n      remainingPanes--;\n      top += currentPane$2.options.height;\n    }\n  };\n\n  PlotAreaBase.prototype.backgroundBox = function backgroundBox() {\n    var axes = this.axes;\n    var axesCount = axes.length;\n    var box;\n\n    for (var i = 0; i < axesCount; i++) {\n      var axisA = axes[i];\n\n      for (var j = 0; j < axesCount; j++) {\n        var axisB = axes[j];\n\n        if (axisA.options.vertical !== axisB.options.vertical) {\n          var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());\n\n          if (!box) {\n            box = lineBox;\n          } else {\n            box = box.wrap(lineBox);\n          }\n        }\n      }\n    }\n\n    return box || this.box;\n  };\n\n  PlotAreaBase.prototype.chartsBoxes = function chartsBoxes() {\n    var panes = this.panes;\n    var boxes = [];\n\n    for (var idx = 0; idx < panes.length; idx++) {\n      boxes.push(panes[idx].chartsBox());\n    }\n\n    return boxes;\n  };\n\n  PlotAreaBase.prototype.addBackgroundPaths = function addBackgroundPaths(multipath) {\n    var boxes = this.chartsBoxes();\n\n    for (var idx = 0; idx < boxes.length; idx++) {\n      multipath.paths.push(draw.Path.fromRect(boxes[idx].toRect()));\n    }\n  };\n\n  PlotAreaBase.prototype.backgroundContainsPoint = function backgroundContainsPoint(point) {\n    var boxes = this.chartsBoxes();\n\n    for (var idx = 0; idx < boxes.length; idx++) {\n      if (boxes[idx].containsPoint(point)) {\n        return true;\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.createVisual = function createVisual() {\n    ChartElement.prototype.createVisual.call(this);\n    var options = this.options.plotArea;\n    var opacity = options.opacity;\n    var background = options.background;\n    var border = options.border;\n    if (border === void 0) border = {};\n\n    if (isTransparent(background)) {\n      background = WHITE;\n      opacity = 0;\n    }\n\n    var bg = this._bgVisual = new draw.MultiPath({\n      fill: {\n        color: background,\n        opacity: opacity\n      },\n      stroke: {\n        color: border.width ? border.color : \"\",\n        width: border.width,\n        dashType: border.dashType\n      },\n      zIndex: -1\n    });\n    this.addBackgroundPaths(bg);\n    this.appendVisual(bg);\n  };\n\n  PlotAreaBase.prototype.pointsByCategoryIndex = function pointsByCategoryIndex(categoryIndex) {\n    var charts = this.charts;\n    var result = [];\n\n    if (categoryIndex !== null) {\n      for (var i = 0; i < charts.length; i++) {\n        var chart = charts[i];\n\n        if (chart.pane.options.name === \"_navigator\") {\n          continue;\n        }\n\n        var points = charts[i].categoryPoints[categoryIndex];\n\n        if (points && points.length) {\n          for (var j = 0; j < points.length; j++) {\n            var point = points[j];\n\n            if (point && defined(point.value) && point.value !== null) {\n              result.push(point);\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  };\n\n  PlotAreaBase.prototype.pointsBySeriesIndex = function pointsBySeriesIndex(seriesIndex) {\n    return this.filterPoints(function (point) {\n      return point.series.index === seriesIndex;\n    });\n  };\n\n  PlotAreaBase.prototype.pointsBySeriesName = function pointsBySeriesName(name) {\n    return this.filterPoints(function (point) {\n      return point.series.name === name;\n    });\n  };\n\n  PlotAreaBase.prototype.filterPoints = function filterPoints(callback) {\n    var charts = this.charts;\n    var result = [];\n\n    for (var i = 0; i < charts.length; i++) {\n      var chart = charts[i];\n      var points = chart.points;\n\n      for (var j = 0; j < points.length; j++) {\n        var point = points[j];\n\n        if (point && point.visible !== false && callback(point)) {\n          result.push(point);\n        }\n      }\n    }\n\n    return result;\n  };\n\n  PlotAreaBase.prototype.findPoint = function findPoint(callback) {\n    var charts = this.charts;\n\n    for (var i = 0; i < charts.length; i++) {\n      var chart = charts[i];\n      var points = chart.points;\n\n      for (var j = 0; j < points.length; j++) {\n        var point = points[j];\n\n        if (point && point.visible !== false && callback(point)) {\n          return point;\n        }\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.paneByPoint = function paneByPoint(point) {\n    var panes = this.panes;\n\n    for (var i = 0; i < panes.length; i++) {\n      var pane = panes[i];\n\n      if (pane.box.containsPoint(point)) {\n        return pane;\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.detachLabels = function detachLabels() {\n    var axes = this.groupAxes(this.panes);\n    var xAxes = axes.x;\n    var yAxes = axes.y;\n    this.detachAxisGroupLabels(yAxes, xAxes);\n    this.detachAxisGroupLabels(xAxes, yAxes);\n  };\n\n  PlotAreaBase.prototype.detachAxisGroupLabels = function detachAxisGroupLabels(axes, crossingAxes) {\n    var this$1 = this;\n    var labelAxisCount = 0;\n\n    for (var i = 0; i < axes.length; i++) {\n      var axis = axes[i];\n      var pane = axis.pane;\n      var anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];\n      var axisIndex = i + labelAxisCount;\n      var labelAxis = this$1.createLabelAxis(axis, axisIndex, anchor);\n\n      if (labelAxis) {\n        labelAxisCount++;\n        var pos = pane.axes.indexOf(axis) + labelAxisCount;\n        pane.appendAxisAt(labelAxis, pos);\n      }\n    }\n  };\n\n  PlotAreaBase.prototype.createLabelAxis = function createLabelAxis(axis, axisIndex, anchor) {\n    var labelOptions = axis.options.labels;\n    var position = labelOptions.position;\n    var onAxis = position !== END && position !== START;\n    var visible = labelOptions.visible;\n\n    if (onAxis || visible === false) {\n      return null;\n    }\n\n    var allAxes = this.groupAxes(this.panes);\n    var crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;\n    var anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);\n    var end = position === END;\n    var range = anchor.range();\n    var edge = end ? range.max : range.min;\n    var crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);\n\n    if (crossingValue - edge === 0) {\n      return null;\n    }\n\n    anchorCrossings.splice(axisIndex + 1, 0, edge);\n    anchor.options.axisCrossingValues = anchorCrossings;\n    var labelAxis = axis.clone();\n    axis.clear();\n    labelAxis.options.name = undefined;\n    labelAxis.options.line.visible = false;\n    labelAxis.options.crosshair = undefined;\n    labelAxis.options.notes = undefined;\n    labelAxis.options.plotBands = undefined;\n    return labelAxis;\n  };\n\n  return PlotAreaBase;\n}(ChartElement);\n\nfunction axisGroupBox(axes) {\n  var length = axes.length;\n  var box;\n\n  if (length > 0) {\n    for (var i = 0; i < length; i++) {\n      var axisBox = axes[i].contentBox();\n\n      if (!box) {\n        box = axisBox.clone();\n      } else {\n        box.wrap(axisBox);\n      }\n    }\n  }\n\n  return box || new Box();\n}\n\nfunction paneAnchor(axes, pane) {\n  for (var i = 0; i < axes.length; i++) {\n    var anchor = axes[i];\n\n    if (anchor && anchor.pane === pane) {\n      return anchor;\n    }\n  }\n}\n\nfunction isTransparent(color) {\n  return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !defined(color);\n}\n\nvar allPaneAxes = function (panes) {\n  return panes.reduce(function (acc, pane) {\n    return acc.concat(pane.axes);\n  }, []);\n};\n\nsetDefaultOptions(PlotAreaBase, {\n  series: [],\n  plotArea: {\n    margin: {}\n  },\n  background: \"\",\n  border: {\n    color: BLACK,\n    width: 0\n  },\n  legend: {\n    inactiveItems: {\n      labels: {\n        color: \"#919191\"\n      },\n      markers: {\n        color: \"#919191\"\n      }\n    }\n  }\n});\nexport default PlotAreaBase;","map":null,"metadata":{},"sourceType":"module"}