{"ast":null,"code":"import { Marker } from './marker';\nimport { TextOption, renderTextElement } from '../../smithchart/utils/helper';\nimport { SmithchartRect, LineSegment, PointRegion, DataLabelTextOptions } from '../../smithchart/utils/utils';\nimport { _getEpsilonValue, PathOption, RectOption, getAnimationFunction, templateAnimate } from '../../smithchart/utils/helper';\nimport { animationComplete } from '../../smithchart/model/constant';\nimport { DataLabel } from '../../smithchart/series/datalabel';\nimport { Animation } from '@syncfusion/ej2-base';\n/* tslint:disable:no-string-literal */\n\nvar SeriesRender =\n/** @class */\nfunction () {\n  function SeriesRender() {\n    this.xValues = [];\n    this.yValues = [];\n    this.pointsRegion = [];\n    this.lineSegments = [];\n    this.location = [];\n    this.dataLabel = new DataLabel();\n  }\n\n  SeriesRender.prototype.processData = function (series) {\n    var dataArray = series.dataSource;\n    var resistance = series.resistance;\n    var reactance = series.reactance;\n    series.points = [];\n\n    for (var i = 0; i < dataArray.length; i++) {\n      series.points.push({\n        resistance: dataArray[i][resistance],\n        reactance: dataArray[i][reactance]\n      });\n    }\n  }; // tslint:disable:max-func-body-length\n\n\n  SeriesRender.prototype.draw = function (smithchart, axisRender, bounds) {\n    var groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_seriesCollections'\n    });\n    var resistantCx;\n    var reactanceCy;\n    var series = smithchart.series;\n    var seriesLength = series.length;\n    var chartAreaRadius = axisRender.areaRadius;\n    var interSectPoint;\n    var index;\n\n    for (var m = 0; m < seriesLength; m++) {\n      var seriesIndex = m;\n\n      if (series[m].dataSource && series[m].resistance && series[m].reactance) {\n        this.processData(series[m]);\n      }\n\n      this.pointsRegion[m] = [];\n      this.location[m] = [];\n\n      for (var j = 0; j < series[m].points.length; j++) {\n        this.xValues[j] = series[m].points[j]['resistance'];\n        this.yValues[j] = series[m].points[j]['reactance'];\n      }\n\n      var chartAreaCx = axisRender.circleCenterX;\n      var chartAreaCy = axisRender.circleCenterY;\n      var diameter = axisRender.areaRadius * 2;\n      var reactanceStartPoint = {\n        x: chartAreaCx + (smithchart.renderType === 'Impedance' ? chartAreaRadius : -chartAreaRadius),\n        y: chartAreaCy\n      };\n      var resistantCy = chartAreaCy;\n      var reactanceCx = reactanceStartPoint.x;\n\n      for (var k = 0; k < series[m].points.length; k++) {\n        var resistance = this.xValues[k];\n        var resistantR = diameter * (1 / (resistance + 1)) / 2;\n        var reactance = this.yValues[k];\n        var reactanceR = Math.abs(1 / reactance * diameter / 2);\n\n        if (smithchart.renderType === 'Impedance') {\n          reactanceCy = reactance > 0 ? chartAreaCy - reactanceR : chartAreaCy + reactanceR;\n          resistantCx = axisRender.circleLeftX + diameter - resistantR;\n        } else {\n          reactanceCy = reactance < 0 ? chartAreaCy - reactanceR : chartAreaCy + reactanceR;\n          resistantCx = axisRender.circleLeftX + resistantR;\n        }\n\n        interSectPoint = axisRender.intersectingCirclePoints(reactanceCx, reactanceCy, reactanceR, resistantCx, resistantCy, resistantR, smithchart.renderType);\n\n        var epsilon = _getEpsilonValue();\n\n        if (Math.abs(reactance) < epsilon) {\n          interSectPoint.x = smithchart.renderType === 'Impedance' ? resistantCx - resistantR : resistantCx + resistantR;\n          interSectPoint.y = chartAreaCy;\n        }\n\n        this.pointsRegion[m][k] = new PointRegion();\n        this.pointsRegion[m][k] = {\n          point: interSectPoint,\n          x: resistance,\n          y: reactance\n        };\n        this.location[m][k] = {\n          x: interSectPoint.x,\n          y: interSectPoint.y\n        };\n      }\n\n      for (var i = 0; i < series[m].points.length - 1; i++) {\n        index = i + 1;\n        this.lineSegments[i] = new LineSegment();\n        this.lineSegments[i] = {\n          x1: this.xValues[i],\n          y1: this.yValues[i],\n          x2: this.xValues[index],\n          y2: this.yValues[index]\n        };\n      }\n\n      smithchart.svgObject.appendChild(groupElement);\n      this.drawSeries(smithchart, seriesIndex, groupElement, bounds);\n    }\n\n    for (var j = 0; j < smithchart.series.length; j++) {\n      if (smithchart.series[j].enableSmartLabels && smithchart.series[j].marker.dataLabel.visible) {\n        var gdlcEle = smithchart.renderer.createGroup({\n          'id': smithchart.element.id + '_svg' + '_series' + j + '_Datalabel' + '_connectorLines'\n        });\n        var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + j);\n\n        if (element) {\n          element.appendChild(gdlcEle);\n        }\n\n        this.dataLabel.calculateSmartLabels(this.dataLabel.labelOptions[j], j);\n\n        for (var k = 0; k < smithchart.series[j].points.length; k++) {\n          var currentPoint = this.dataLabel.labelOptions[j]['textOptions'][k];\n\n          if (currentPoint.xPosition + currentPoint.width > smithchart.chartArea.x + smithchart.chartArea.width || currentPoint.xPosition < smithchart.chartArea.x || currentPoint.yPosition < smithchart.chartArea.y || currentPoint.yPosition + currentPoint.height > smithchart.chartArea.y + smithchart.chartArea.height) {\n            this.dataLabel.labelOptions[j].textOptions[k].connectorFlag = false;\n            this.dataLabel.labelOptions[j].textOptions[k].visible = false;\n          }\n\n          if (currentPoint['connectorFlag']) {\n            this.dataLabel.drawConnectorLines(smithchart, j, k, currentPoint, gdlcEle);\n          }\n        }\n      }\n    }\n\n    for (var j = 0; j < smithchart.series.length; j++) {\n      var dataLabel = smithchart.series[j].marker.dataLabel;\n\n      if (smithchart.series[j].marker.dataLabel.visible) {\n        var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + j);\n        var gdEle = smithchart.renderer.createGroup({\n          'id': smithchart.element.id + '_svg' + '_series' + j + '_Datalabel'\n        });\n\n        if (element) {\n          element.appendChild(gdEle);\n        }\n\n        for (var k = 0; k < smithchart.series[j].points.length; k++) {\n          var currentPoint = this.dataLabel.labelOptions[j]['textOptions'][k];\n\n          if (!dataLabel.template && currentPoint.visible) {\n            var options = new DataLabelTextOptions();\n            options = this.dataLabel.labelOptions[j]['textOptions'][k];\n            var font = dataLabel.textStyle;\n            var x = options['xPosition'];\n            var y = options['yPosition'];\n            var id = smithchart.element.id + '_Series' + j + '_Points' + k + '_dataLabel' + '_symbol' + k;\n            var fill = dataLabel['fill'] ? dataLabel['fill'] : smithchart.series[j].fill || smithchart.seriesColors[j % smithchart.seriesColors.length];\n            var border = smithchart.series[j].marker.dataLabel.border;\n            var rectOptions = new RectOption(id, fill, border, options['opacity'], new SmithchartRect(x, y, options['width'], options['height']));\n            var dataEle = smithchart.renderer.drawRectangle(rectOptions);\n            gdEle.appendChild(dataEle);\n            var textRenderEventArgs = {\n              text: options['text'],\n              x: options['x'],\n              y: options['y'],\n              seriesIndex: j,\n              pointIndex: k,\n              name: 'textRender',\n              cancel: false\n            };\n            smithchart.trigger('textRender', textRenderEventArgs);\n            var textoptions = new TextOption(options['id'], textRenderEventArgs.x, textRenderEventArgs.y, 'start', textRenderEventArgs.text);\n            var color = font.color ? font.color : smithchart.themeStyle.dataLabel;\n            var element_1 = renderTextElement(textoptions, font, color, gdEle);\n            gdEle.appendChild(element_1);\n          } else if (dataLabel.template) {\n            var element_2 = document.getElementById(dataLabel.template + '_seriesIndex' + j + '_pointIndex' + k + smithchart.element.id);\n            element_2.style.left = this.dataLabel.labelOptions[j]['textOptions'][k].xPosition + 'px';\n            element_2.style.top = this.dataLabel.labelOptions[j]['textOptions'][k].yPosition + 'px';\n          }\n        }\n      }\n    }\n\n    for (var i = 0; i < smithchart.series.length; i++) {\n      if (smithchart.series[i].enableAnimation && smithchart.animateSeries) {\n        if (smithchart.series[i].marker.dataLabel.template) {\n          this.animateDataLabelTemplate(i, smithchart);\n        }\n\n        var element = document.getElementById(smithchart.element.id + '_svg' + '_seriesCollection' + i);\n        this.performAnimation(smithchart, element, i);\n      }\n    }\n  };\n\n  SeriesRender.prototype.drawSeries = function (smithchart, seriesindex, groupElement, bounds) {\n    var gsEle = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_seriesCollection' + seriesindex,\n      'clip-path': 'url(#' + smithchart.element.id + '_ChartSeriesClipRect_' + seriesindex + ')'\n    });\n    gsEle.setAttribute('visibility', smithchart.series[seriesindex].visibility);\n    groupElement.appendChild(gsEle);\n    var sb = '';\n    var path;\n    var marker = smithchart.series[seriesindex].marker;\n    var element;\n    var count = smithchart.series[seriesindex].points.length - 1;\n\n    for (var i = 0; i < count; i++) {\n      var point1 = this.pointsRegion[seriesindex][i]['point'];\n      var point2 = this.pointsRegion[seriesindex][i + 1]['point'];\n      sb = sb + ('M' + ' ' + point1.x + ' ' + point1.y + ' ' + 'L' + ' ' + point2.x + ' ' + point2.y + ' ');\n    }\n\n    path = sb.toString();\n    var fill = smithchart.series[seriesindex].fill || smithchart.seriesColors[seriesindex % smithchart.seriesColors.length];\n    var seriesEventArgs = {\n      text: smithchart.series[seriesindex].name,\n      fill: fill,\n      name: 'seriesRender',\n      cancel: false\n    };\n    smithchart.trigger('seriesRender', seriesEventArgs);\n    var options = new PathOption(smithchart.element.id + '_series' + seriesindex + '_points', 'none', smithchart.series[seriesindex].width, seriesEventArgs.fill, smithchart.series[seriesindex].opacity, 'none', path);\n    this.clipRectElement = smithchart.renderer.drawClipPath(new RectOption(smithchart.element.id + '_ChartSeriesClipRect_' + seriesindex, 'transparent', {\n      width: 1,\n      color: 'Gray'\n    }, 1, {\n      x: bounds.x,\n      y: bounds.y,\n      width: smithchart.availableSize.width,\n      height: smithchart.availableSize.height\n    }));\n    gsEle.appendChild(this.clipRectElement);\n    var gspEle = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + seriesindex\n    });\n    element = smithchart.renderer.drawPath(options);\n    gspEle.appendChild(element);\n    gsEle.appendChild(gspEle);\n    var markerrender = new Marker();\n    markerrender.drawMarker(smithchart, seriesindex, gsEle, this.pointsRegion[seriesindex]);\n    this.dataLabel.drawDataLabel(smithchart, seriesindex, gsEle, this.pointsRegion[seriesindex], bounds);\n  };\n\n  SeriesRender.prototype.animateDataLabelTemplate = function (seriesindex, smithchart) {\n    var length = smithchart.series[seriesindex].points.length;\n    var opacity = 0;\n    var delay = 0;\n    var duration = parseFloat(smithchart.series[seriesindex].animationDuration);\n\n    for (var i = 0; i < length; i++) {\n      var element = document.getElementById(smithchart.series[seriesindex].marker.dataLabel.template + '_seriesIndex' + seriesindex + '_pointIndex' + i + smithchart.element.id);\n      element.style.visibility = 'hidden';\n      templateAnimate(smithchart, element, delay, duration, 'FadeIn'); // this.fadein(element);\n    }\n  };\n  /*private fadein(element: HTMLElement): void {\n    let op: number = 0.1;\n    element.style.display = 'block';\n    let timer: number = setInterval( (): void => {\n          if (op >= 1) {\n              clearInterval(timer);\n          }\n          element.style.opacity = op.toString();\n          element.style.filter = 'alpha(opacity=' + op * 100 + ')';\n          op += op * 0.1;\n  }, 50);\n  \n  }*/\n\n\n  SeriesRender.prototype.performAnimation = function (smithchart, gsEle, seriesIndex) {\n    var animation = new Animation({});\n    var element = document.getElementById('container_svg_seriesCollections');\n    var clipRect = gsEle.childNodes[0].childNodes[0].childNodes[0];\n    var effect = getAnimationFunction('Linear');\n    var reveffect = getAnimationFunction('Reverse');\n    var width = +clipRect.getAttribute('width');\n    var x = +clipRect.getAttribute('x');\n    var value;\n    animation.animate(clipRect, {\n      duration: parseFloat(smithchart.series[seriesIndex].animationDuration),\n      progress: function (args) {\n        if (smithchart.renderType === 'Impedance') {\n          value = effect(args.timeStamp - args.delay, 0, width, args.duration);\n          clipRect.setAttribute('width', value.toString());\n        } else {\n          value = reveffect(args.timeStamp - args.delay, width, 0, args.duration);\n          clipRect.setAttribute('x', value.toString());\n        }\n      },\n      end: function (model) {\n        if (smithchart.renderType === 'Impedance') {\n          clipRect.setAttribute('width', width.toString());\n        } else {\n          clipRect.setAttribute('x', x.toString());\n        }\n\n        var event = {\n          cancel: false,\n          name: animationComplete,\n          smithchart: smithchart.isBlazor ? null : smithchart\n        };\n        smithchart.trigger(animationComplete, event);\n      }\n    });\n  };\n\n  SeriesRender.prototype.getLocation = function (seriesindex, pointIndex) {\n    var x;\n    var y;\n    x = this.location[seriesindex][pointIndex].x;\n    y = this.location[seriesindex][pointIndex].y;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  return SeriesRender;\n}();\n\nexport { SeriesRender };","map":null,"metadata":{},"sourceType":"module"}