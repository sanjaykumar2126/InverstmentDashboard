{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport BoxElement from './box-element';\nimport FloatElement from './float-element';\nimport Text from './text';\nimport Box from './box';\nimport rectToBox from './utils/rect-to-box';\nimport { getSpacing, deepExtend, defined } from '../common';\nimport { X, Y } from '../common/constants';\nvar ROWS_SPLIT_REGEX = /\\n/m;\n\nvar TextBox = function (BoxElement) {\n  function TextBox(content, options, data) {\n    BoxElement.call(this, options);\n    this.content = content;\n    this.data = data;\n\n    this._initContainer();\n\n    if (this.options._autoReflow !== false) {\n      this.reflow(new Box());\n    }\n  }\n\n  if (BoxElement) TextBox.__proto__ = BoxElement;\n  TextBox.prototype = Object.create(BoxElement && BoxElement.prototype);\n  TextBox.prototype.constructor = TextBox;\n\n  TextBox.prototype._initContainer = function _initContainer() {\n    var options = this.options;\n    var rows = String(this.content).split(ROWS_SPLIT_REGEX);\n    var floatElement = new FloatElement({\n      vertical: true,\n      align: options.align,\n      wrap: false\n    });\n    var textOptions = deepExtend({}, options, {\n      opacity: 1,\n      animation: null\n    });\n    this.container = floatElement;\n    this.append(floatElement);\n\n    for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {\n      var text = new Text(rows[rowIdx].trim(), textOptions);\n      floatElement.append(text);\n    }\n  };\n\n  TextBox.prototype.reflow = function reflow(targetBox) {\n    var options = this.options;\n    var visualFn = options.visual;\n    this.container.options.align = options.align;\n\n    if (visualFn && !this._boxReflow) {\n      var visualBox = targetBox;\n\n      if (!visualBox.hasSize()) {\n        this._boxReflow = true;\n        this.reflow(visualBox);\n        this._boxReflow = false;\n        visualBox = this.box;\n      }\n\n      var visual = this.visual = visualFn(this.visualContext(visualBox));\n\n      if (visual) {\n        visualBox = rectToBox(visual.clippedBBox() || new geom.Rect());\n        visual.options.zIndex = options.zIndex;\n      }\n\n      this.box = this.contentBox = this.paddingBox = visualBox;\n    } else {\n      BoxElement.prototype.reflow.call(this, targetBox);\n\n      if (options.rotation) {\n        var margin = getSpacing(options.margin);\n        var box = this.box.unpad(margin);\n        this.targetBox = targetBox;\n        this.normalBox = box.clone();\n        box = this.rotate();\n        box.translate(margin.left - margin.right, margin.top - margin.bottom);\n        this.rotatedBox = box.clone();\n        box.pad(margin);\n      }\n    }\n  };\n\n  TextBox.prototype.createVisual = function createVisual() {\n    var options = this.options;\n    this.visual = new draw.Group({\n      transform: this.rotationTransform(),\n      zIndex: options.zIndex,\n      noclip: options.noclip\n    });\n\n    if (this.hasBox()) {\n      var box = draw.Path.fromRect(this.paddingBox.toRect(), this.visualStyle());\n      this.visual.append(box);\n    }\n  };\n\n  TextBox.prototype.renderVisual = function renderVisual() {\n    if (!this.options.visible) {\n      return;\n    }\n\n    if (this.options.visual) {\n      var visual = this.visual;\n\n      if (visual && !defined(visual.options.noclip)) {\n        visual.options.noclip = this.options.noclip;\n      }\n\n      this.addVisual();\n      this.createAnimation();\n    } else {\n      BoxElement.prototype.renderVisual.call(this);\n    }\n  };\n\n  TextBox.prototype.visualContext = function visualContext(targetBox) {\n    var this$1 = this;\n    var context = {\n      text: this.content,\n      rect: targetBox.toRect(),\n      sender: this.getSender(),\n      options: this.options,\n      createVisual: function () {\n        this$1._boxReflow = true;\n        this$1.reflow(targetBox);\n        this$1._boxReflow = false;\n        return this$1.getDefaultVisual();\n      }\n    };\n\n    if (this.data) {\n      Object.assign(context, this.data);\n    }\n\n    return context;\n  };\n\n  TextBox.prototype.getDefaultVisual = function getDefaultVisual() {\n    this.createVisual();\n    this.renderChildren();\n    var visual = this.visual;\n    delete this.visual;\n    return visual;\n  };\n\n  TextBox.prototype.rotate = function rotate() {\n    var options = this.options;\n    this.box.rotate(options.rotation);\n    this.align(this.targetBox, X, options.align);\n    this.align(this.targetBox, Y, options.vAlign);\n    return this.box;\n  };\n\n  TextBox.prototype.rotationTransform = function rotationTransform() {\n    var rotation = this.options.rotation;\n\n    if (!rotation) {\n      return null;\n    }\n\n    var ref = this.normalBox.center();\n    var cx = ref.x;\n    var cy = ref.y;\n    var boxCenter = this.rotatedBox.center();\n    return geom.transform().translate(boxCenter.x - cx, boxCenter.y - cy).rotate(rotation, [cx, cy]);\n  };\n\n  return TextBox;\n}(BoxElement);\n\nexport default TextBox;","map":null,"metadata":{},"sourceType":"module"}