{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { valueToCoefficient, inside } from '../../common/utils/helper';\nimport { appendChildElement } from '../../common/utils/helper';\nimport { CircleOption } from '../../common/utils/helper';\nimport { Size, measureText, TextOption, PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { LineBase } from '../series/line-base';\nimport { textElement, ChartLocation, valueToPolarCoefficient, CoefficientToVector, getElement } from '../../common/utils/helper';\n/**\n * Specifies the Polar Axis Layout.\n */\n\nvar axisPadding = 10;\n\nvar PolarRadarPanel =\n/** @class */\nfunction (_super) {\n  __extends(PolarRadarPanel, _super);\n\n  function PolarRadarPanel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Measure the polar radar axis size.\n   * @return {void}\n   * @private\n   */\n\n\n  PolarRadarPanel.prototype.measureAxis = function (rect) {\n    var chart = this.chart;\n    this.initialClipRect = rect;\n    this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height); //Measure axis size calculation\n\n    this.measureRowAxis(chart, this.initialClipRect);\n    this.measureColumnAxis(chart, this.initialClipRect);\n    this.calculateAxisSize();\n  };\n\n  PolarRadarPanel.prototype.measureRowAxis = function (chart, rect) {\n    this.calculateRowSize(rect);\n    var row = chart.rows[0];\n    this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight), rect);\n  };\n\n  PolarRadarPanel.prototype.measureColumnAxis = function (chart, rect) {\n    this.calculateColumnSize(rect);\n    var column = chart.columns[0];\n    this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height), rect);\n  };\n  /**\n   * Measure the column and row in chart.\n   * @return {void}\n   * @private\n   */\n\n\n  PolarRadarPanel.prototype.measureDefinition = function (definition, chart, size, clipRect) {\n    for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {\n      var axis = _a[_i];\n      axis.getModule(chart);\n      axis.baseModule.calculateRangeAndInterval(size, axis);\n    }\n  };\n  /**\n   * Measure the axis.\n   * @return {void}\n   * @private\n   */\n\n\n  PolarRadarPanel.prototype.calculateAxisSize = function () {\n    var chart = this.chart;\n    var axis;\n    var padding = 5;\n    this.centerX = this.initialClipRect.width * 0.5 + this.initialClipRect.x;\n    this.centerY = this.initialClipRect.height * 0.5 + this.initialClipRect.y;\n    chart.radius = Math.min(this.initialClipRect.width, this.initialClipRect.height) / 2 - padding - chart.primaryXAxis.majorTickLines.height - chart.primaryXAxis.maxLabelSize.height;\n    chart.radius = chart.primaryXAxis.coefficient * chart.radius / 100;\n    this.seriesClipRect.y = this.centerY - chart.radius;\n    this.seriesClipRect.x = this.centerX - chart.radius;\n    this.seriesClipRect.height = 2 * chart.radius;\n    this.seriesClipRect.width = 2 * chart.radius;\n    this.calculateRowSize(this.seriesClipRect);\n    axis = chart.primaryYAxis;\n    axis.rect = this.seriesClipRect;\n    this.calculateColumnSize(this.seriesClipRect);\n    axis = chart.primaryXAxis;\n    axis.rect = this.seriesClipRect;\n  };\n  /**\n   * Measure the axis.\n   * @return {void}\n   * @private\n   */\n\n\n  PolarRadarPanel.prototype.measure = function () {\n    var chart = this.chart;\n    chart.verticalAxes.push(chart.primaryYAxis);\n    var row = chart.rows[0];\n    row.axes[0] = chart.primaryYAxis;\n    chart.rows[0] = row;\n    chart.horizontalAxes.push(chart.primaryXAxis);\n    var column = chart.columns[0];\n    column.axes[0] = chart.primaryXAxis;\n    chart.columns[0] = column;\n  };\n  /**\n   * Measure the row size.\n   * @return {void}\n   */\n\n\n  PolarRadarPanel.prototype.calculateRowSize = function (rect) {\n    /*! Calculate row size */\n    var chart = this.chart;\n    var row = chart.rows[0];\n    row.computedHeight = rect.height / 2;\n    row.computedTop = rect.y;\n    chart.rows[0] = row;\n  };\n  /**\n   * Measure the row size.\n   * @return {void}\n   */\n\n\n  PolarRadarPanel.prototype.calculateColumnSize = function (rect) {\n    /*! Calculate column size */\n    var chart = this.chart;\n    var column = chart.columns[0];\n    column.computedLeft = rect.x;\n    column.computedWidth = rect.width;\n    chart.columns[0] = column;\n  };\n  /**\n   * To render the axis element.\n   * @return {void}\n   * @private\n   */\n\n\n  PolarRadarPanel.prototype.renderAxes = function () {\n    var axis;\n    var chart = this.chart;\n    this.startAngle = chart.primaryXAxis.startAngle;\n    var axisElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisCollection'\n    });\n    var axisLineElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisOutsideCollection'\n    });\n\n    for (var i = 0, len = chart.axisCollections.length; i < len; i++) {\n      this.element = chart.renderer.createGroup({\n        id: chart.element.id + 'AxisGroup' + i\n      });\n      axis = chart.axisCollections[i];\n\n      if (axis.orientation === 'Horizontal') {\n        if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\n          this.drawXAxisGridLine(axis, i);\n        }\n\n        if (axis.visible) {\n          this.drawXAxisLabels(axis, i);\n        }\n      } else {\n        this.drawYAxisGridLine(axis, i);\n\n        if (axis.lineStyle.width > 0) {\n          this.drawYAxisLine(axis, i, axis.plotOffset, 0);\n        }\n\n        if (axis.visible) {\n          this.drawYAxisLabels(axis, i);\n        }\n      }\n\n      axisElement.appendChild(this.element);\n    }\n\n    axisElement.appendChild(this.element);\n    appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);\n    return axisLineElement;\n  };\n\n  PolarRadarPanel.prototype.drawYAxisLine = function (axis, index, plotX, plotY) {\n    var chart = this.chart;\n    var optionsLine = {};\n    var vector = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[0].value, axis), this.startAngle);\n    var axisLine = 'M ' + this.centerX + ' ' + this.centerY + 'L ' + (this.centerX + chart.radius * vector.x) + ' ' + (this.centerY + chart.radius * vector.y);\n    optionsLine = {\n      'id': chart.element.id + 'AxisLine_' + index,\n      'd': axisLine,\n      'stroke-dasharray': axis.lineStyle.dashArray,\n      'stroke-width': axis.lineStyle.width,\n      'stroke': axis.lineStyle.color || chart.themeStyle.axisLine\n    };\n    chart.yAxisElements.appendChild(chart.renderer.drawPath(optionsLine));\n  };\n\n  PolarRadarPanel.prototype.drawYAxisLabels = function (axis, index) {\n    var chart = this.chart;\n    var elementSize;\n    var options;\n    var pointX = 0;\n    var pointY = 0;\n    var vector;\n    var angle = this.startAngle < 0 ? this.startAngle + 360 : this.startAngle;\n    var anchor = 'middle';\n    var radius;\n    var padding = 5;\n    var labelElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels' + index\n    });\n    vector = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[0].value, axis), this.startAngle);\n\n    for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n      radius = chart.radius * valueToCoefficient(axis.visibleLabels[i].value, axis);\n      elementSize = axis.visibleLabels[i].size;\n      radius = chart.radius * valueToCoefficient(axis.visibleLabels[i].value, axis);\n      pointX = this.centerX + radius * vector.x + (axis.majorTickLines.height + elementSize.width / 2 + padding / 2) * Math.cos(angle * Math.PI / 180) * (axis.labelPosition === 'Inside' ? 1 : -1);\n      pointY = this.centerY + radius * vector.y + (axis.majorTickLines.height + elementSize.height / 2) * Math.sin(angle * Math.PI / 180) * (axis.labelPosition === 'Inside' ? 1 : -1);\n      options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY + elementSize.height / 4, anchor, axis.visibleLabels[i].text);\n      textElement(chart.renderer, options, axis.labelStyle, axis.labelStyle.color || chart.themeStyle.axisLabel, labelElement, false, chart.redraw, true, true);\n    }\n\n    chart.yAxisElements.appendChild(labelElement);\n  };\n\n  PolarRadarPanel.prototype.drawYAxisGridLine = function (axis, index) {\n    var chart = this.chart;\n    var options;\n    var radius;\n    var majorTick = '';\n    var majorGrid = '';\n    var vector;\n    var vector2;\n    var angle = this.startAngle < 0 ? this.startAngle + 360 : this.startAngle;\n    var rect = axis.rect;\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    var border = {\n      color: axis.majorGridLines.color || chart.themeStyle.majorGridLine,\n      width: axis.majorGridLines.width\n    };\n    var previousValue;\n    var element;\n\n    if (axis.majorGridLines.width > 0) {\n      if (chart.visibleSeries[0].type === 'Polar') {\n        for (var j = 0; j < axis.visibleLabels.length; j++) {\n          element = getElement(chart.element.id + '_MajorGridLine_' + index + '_' + j);\n          previousValue = element ? element.getAttribute('r') : null;\n          radius = chart.radius * valueToCoefficient(axis.visibleLabels[j].value, axis);\n          options = new CircleOption(chart.element.id + '_MajorGridLine_' + index + '_' + j, 'transparent', border, axis.majorGridLines.width, this.centerX, this.centerY, radius);\n          appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawCircle(options), chart.redraw, true, 'r', 'r', new ChartLocation(+previousValue, +previousValue), null, true);\n        }\n      } else {\n        for (var j = 0; j < axis.visibleLabels.length; j++) {\n          radius = chart.radius * valueToCoefficient(axis.visibleLabels[j].value, axis);\n          majorGrid = '';\n\n          for (var i = 0, len = chart.primaryXAxis.visibleLabels.length; i < len; i++) {\n            vector = CoefficientToVector(valueToPolarCoefficient(chart.primaryXAxis.visibleLabels[i].value, chart.primaryXAxis), this.startAngle);\n\n            if (i + 1 < len) {\n              vector2 = CoefficientToVector(valueToPolarCoefficient(chart.primaryXAxis.visibleLabels[i + 1].value, chart.primaryXAxis), this.startAngle);\n            } else {\n              vector2 = CoefficientToVector(valueToPolarCoefficient(chart.primaryXAxis.visibleLabels[0].value, chart.primaryXAxis), this.startAngle);\n            }\n\n            x1 = this.centerX + radius * vector.x;\n            y1 = this.centerY + radius * vector.y;\n            x2 = this.centerX + radius * vector2.x;\n            y2 = this.centerY + radius * vector2.y;\n            majorGrid = majorGrid.concat((i ? 'L ' : 'M ') + ' ' + x1 + ' ' + y1 + ' ' + 'L ' + ' ' + x2 + ' ' + y2 + ' ');\n          }\n\n          element = getElement(chart.element.id + '_MajorGridLine_' + index + '_' + j);\n          previousValue = element ? element.getAttribute('d') : null;\n          options = new PathOption(chart.element.id + '_MajorGridLine_' + index + '_' + j, 'transparent', axis.majorGridLines.width, axis.majorGridLines.color || chart.themeStyle.majorGridLine, null, null, majorGrid);\n          appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(options), chart.redraw, true, 'x', 'y', null, previousValue, true);\n        }\n      }\n    }\n\n    if (axis.majorTickLines.width > 0) {\n      vector = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[0].value, axis), this.startAngle);\n\n      for (var i = 0; i < axis.visibleLabels.length; i++) {\n        radius = chart.radius * valueToCoefficient(axis.visibleLabels[i].value, axis);\n        x1 = this.centerX + radius * vector.x;\n        y1 = this.centerY + radius * vector.y;\n        x2 = x1 + axis.majorTickLines.height * Math.cos(angle * Math.PI / 180) * (axis.tickPosition === 'Inside' ? 1 : -1);\n        y2 = y1 + axis.majorTickLines.height * Math.sin(angle * Math.PI / 180) * (axis.tickPosition === 'Inside' ? 1 : -1);\n        majorTick = 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2;\n        this.renderTickLine(axis, index, majorTick, '', i);\n      }\n    }\n  };\n\n  PolarRadarPanel.prototype.drawXAxisGridLine = function (axis, index) {\n    var chart = this.chart;\n    var tempInterval;\n    var vector;\n    var majorGrid = '';\n    var majorTick = '';\n    var minorGirdLine = '';\n    var minorTickLine = '';\n    var x1 = this.centerX;\n    var x2;\n    var y1 = this.centerY;\n    var y2;\n    var minorDirection;\n    var tickSize = axis.majorTickLines.height;\n    var rect = axis.rect;\n    var length = axis.visibleLabels.length; //Gridlines\n\n    for (var i = 0; i < length; i++) {\n      tempInterval = axis.visibleLabels[i].value;\n      vector = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[i].value, axis), this.startAngle);\n      x2 = this.centerX + chart.radius * vector.x;\n      y2 = this.centerY + chart.radius * vector.y;\n      var xLoc = x2 + axis.majorTickLines.height * vector.x * (axis.tickPosition === 'Inside' ? -1 : 1);\n      var yLoc = y2 + axis.majorTickLines.height * vector.y * (axis.tickPosition === 'Inside' ? -1 : 1);\n      majorGrid = 'M ' + x1 + ' ' + y1 + ' ' + 'L ' + x2 + ' ' + y2;\n      majorTick = 'M ' + x2 + ' ' + y2 + ' L ' + xLoc + ' ' + yLoc;\n\n      if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0) && axis.valueType !== 'Category' && chart.visibleSeries[0].type !== 'Radar') {\n        minorDirection = this.drawAxisMinorLine(axis, tempInterval, minorGirdLine, minorTickLine);\n        minorGirdLine = minorDirection[0];\n        minorTickLine = minorDirection[1];\n      }\n\n      this.renderTickLine(axis, index, majorTick, minorTickLine, i);\n      this.renderGridLine(axis, index, majorGrid, minorGirdLine, i);\n    }\n  };\n\n  PolarRadarPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, minorGird, minorTick) {\n    var value = tempInterval;\n    var x;\n    var y;\n    var vector;\n    var range = axis.visibleRange;\n    var direction = [];\n\n    for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n      value += (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval) / (axis.minorTicksPerInterval + 1);\n\n      if (inside(value, range)) {\n        vector = CoefficientToVector(valueToPolarCoefficient(value, axis), this.startAngle);\n        x = this.centerX + this.chart.radius * vector.x;\n        y = this.centerY + this.chart.radius * vector.y;\n        var tickXSize = x + axis.minorTickLines.height * vector.x * (axis.tickPosition === 'Inside' ? -1 : 1);\n        var tickYSize = y + axis.minorTickLines.height * vector.y * (axis.tickPosition === 'Inside' ? -1 : 1);\n        minorGird = minorGird.concat('M' + ' ' + this.centerX + ' ' + this.centerY + 'L ' + x + ' ' + y);\n        minorTick = minorTick.concat('M' + ' ' + x + ' ' + y + 'L' + ' ' + tickXSize + ' ' + tickYSize);\n      }\n    }\n\n    direction.push(minorGird);\n    direction.push(minorTick);\n    return direction;\n  };\n  /**\n   * To render the axis label.\n   * @return {void}\n   * @private\n   */\n\n\n  PolarRadarPanel.prototype.drawXAxisLabels = function (axis, index) {\n    var chart = this.chart;\n    var pointX = 0;\n    var pointY = 0;\n    var labelElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels' + index\n    });\n    var options;\n    var vector;\n    var labelText;\n    var firstLabelX;\n    var islabelInside = axis.labelPosition === 'Inside';\n    var padding = 5;\n    var lastLabelX;\n    var label;\n    var textAnchor = '';\n    var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' && chart.visibleSeries[0].type !== 'Radar' ? 0.5 : 0;\n    var radius = chart.radius + axis.majorTickLines.height;\n    radius = islabelInside ? -radius : radius;\n\n    for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n      vector = CoefficientToVector(valueToPolarCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis), this.startAngle);\n\n      if (!isNaN(vector.x) && !isNaN(vector.y)) {\n        pointX = this.centerX + (radius + axis.majorTickLines.height + padding) * vector.x;\n        pointY = this.centerY + (radius + axis.majorTickLines.height + padding) * vector.y;\n        textAnchor = parseFloat(pointX.toFixed(1)) === parseFloat(this.centerX.toFixed(1)) ? 'middle' : pointX < this.centerX && !islabelInside || pointX > this.centerX && islabelInside ? 'end' : 'start';\n      }\n\n      labelText = axis.visibleLabels[i].text; // fix for label style not working in axisLabelRender event issue\n\n      label = axis.visibleLabels[i];\n\n      if (i === 0) {\n        firstLabelX = pointX;\n      } else if (i === axis.visibleLabels.length - 1 && axis.valueType !== 'Category') {\n        lastLabelX = measureText(labelText, axis.labelStyle).height;\n        lastLabelX += pointX;\n        labelText = lastLabelX > firstLabelX ? '' : labelText;\n      }\n\n      options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, textAnchor, labelText, '', 'central');\n      textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabel, labelElement, false, chart.redraw, true, true);\n    }\n\n    this.element.appendChild(labelElement);\n  };\n\n  PolarRadarPanel.prototype.renderTickLine = function (axis, index, majorTickLine, minorTickLine, gridIndex) {\n    var tickOptions;\n    var chart = this.chart;\n    var direction;\n    var element;\n\n    if (axis.majorTickLines.width > 0) {\n      element = getElement(chart.element.id + '_MajorTickLine_' + index + '_' + gridIndex);\n      direction = element ? element.getAttribute('d') : null;\n      tickOptions = new PathOption(chart.element.id + '_MajorTickLine_' + index + '_' + gridIndex, 'transparent', axis.majorTickLines.width, axis.majorTickLines.color || chart.themeStyle.majorTickLine, null, null, majorTickLine);\n      appendChildElement(chart.enableCanvas, chart.yAxisElements, chart.renderer.drawPath(tickOptions), chart.redraw, true, 'x', 'y', null, direction);\n    }\n\n    if (axis.minorTickLines.width > 0) {\n      element = getElement(chart.element.id + '_MinorTickLine_' + index + '_' + gridIndex);\n      direction = element ? element.getAttribute('d') : null;\n      tickOptions = new PathOption(chart.element.id + '_MinorTickLine_' + index + '_' + gridIndex, 'transparent', axis.minorTickLines.width, axis.minorTickLines.color || chart.themeStyle.minorTickLine, null, null, minorTickLine);\n      appendChildElement(chart.enableCanvas, chart.yAxisElements, chart.renderer.drawPath(tickOptions), chart.redraw, true, 'x', 'y', null, direction);\n    }\n  };\n\n  PolarRadarPanel.prototype.renderGridLine = function (axis, index, majorGrid, minorGird, gridIndex) {\n    var chart = this.chart;\n    var gridOptions;\n    var direction;\n    var element;\n\n    if (axis.majorGridLines.width > 0) {\n      element = getElement(chart.element.id + '_MajorGridLine_' + index + '_' + gridIndex);\n      direction = element ? element.getAttribute('d') : null;\n      gridOptions = new PathOption(chart.element.id + '_MajorGridLine_' + index + '_' + gridIndex, 'transparent', axis.majorGridLines.width, axis.majorGridLines.color || chart.themeStyle.majorGridLine, null, axis.majorGridLines.dashArray, majorGrid);\n      appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(gridOptions), chart.redraw, true, 'x', 'y', null, direction);\n    }\n\n    if (axis.minorGridLines.width > 0) {\n      element = getElement(chart.element.id + '_MinorGridLine_' + index + '_' + gridIndex);\n      direction = element ? element.getAttribute('d') : null;\n      gridOptions = new PathOption(chart.element.id + '_MinorGridLine_' + index + '_' + gridIndex, 'transparent', axis.minorGridLines.width, axis.minorGridLines.color || chart.themeStyle.minorGridLine, null, axis.minorGridLines.dashArray, minorGird);\n      appendChildElement(chart.enableCanvas, this.element, chart.renderer.drawPath(gridOptions), chart.redraw, true, 'x', 'y', null, direction);\n    }\n  };\n\n  return PolarRadarPanel;\n}(LineBase);\n\nexport { PolarRadarPanel };","map":null,"metadata":{},"sourceType":"module"}