{"ast":null,"code":"import { Animation } from '@syncfusion/ej2-base';\nimport { DoubleRange } from '../utils/double-range';\nimport { appendChildElement, redrawElement, pathAnimation, valueToCoefficient } from '../../common/utils/helper';\nimport { getAnimationFunction, getPoint, getMinPointsDelta } from '../../common/utils/helper';\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { pointRender } from '../../common/model/constants';\n/**\n * Column Series Base\n */\n\nvar ColumnBase =\n/** @class */\nfunction () {\n  function ColumnBase() {}\n  /**\n   * To get the position of the column series.\n   * @return {DoubleRange}\n   * @private\n   */\n\n\n  ColumnBase.prototype.getSideBySideInfo = function (series) {\n    if (series.chart.enableSideBySidePlacement && !series.position) {\n      this.getSideBySidePositions(series);\n    }\n\n    var position = !series.chart.enableSideBySidePlacement ? 0 : series.position;\n    var rectCount = !series.chart.enableSideBySidePlacement ? 1 : series.rectCount;\n    series.isRectSeries = true;\n    var visibleSeries = series.chart.visibleSeries;\n    var seriesSpacing = series.chart.enableSideBySidePlacement ? series.columnSpacing : 0; // Column Spacing\n\n    var pointSpacing = series.columnWidth === null ? series.type === 'Histogram' ? 1 : 0.7 : series.columnWidth; // Column width\n\n    var minimumPointDelta = getMinPointsDelta(series.xAxis, visibleSeries);\n    var width = minimumPointDelta * pointSpacing;\n    var radius;\n    var location = position / rectCount - 0.5;\n    var doubleRange = new DoubleRange(location, location + 1 / rectCount);\n\n    if (!(isNaN(doubleRange.start) || isNaN(doubleRange.end))) {\n      doubleRange = new DoubleRange(doubleRange.start * width, doubleRange.end * width);\n      radius = seriesSpacing * doubleRange.delta;\n      doubleRange = new DoubleRange(doubleRange.start + radius / 2, doubleRange.end - radius / 2);\n    }\n\n    return doubleRange;\n  };\n  /**\n   * To get the rect values.\n   * @return {Rect}\n   * @private\n   */\n\n\n  ColumnBase.prototype.getRectangle = function (x1, y1, x2, y2, series) {\n    var point1 = getPoint(x1, y1, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n    var point2 = getPoint(x2, y2, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n    return new Rect(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y), Math.abs(point2.x - point1.x), Math.abs(point2.y - point1.y));\n  };\n  /**\n   * To get the position of each series.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.getSideBySidePositions = function (series) {\n    var chart = series.chart;\n\n    for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n      var columnItem = _a[_i];\n\n      for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {\n        var item = _c[_b];\n        this.findRectPosition(series.findSeriesCollection(columnItem, item, false));\n      }\n    }\n  };\n\n  ColumnBase.prototype.findRectPosition = function (seriesCollection) {\n    var stackingGroup = [];\n    var vSeries = {\n      rectCount: 0,\n      position: null\n    };\n    seriesCollection.forEach(function (value) {\n      if (value.type.indexOf('Stacking') !== -1) {\n        if (value.stackingGroup) {\n          if (stackingGroup[value.stackingGroup] === undefined) {\n            value.position = vSeries.rectCount;\n            stackingGroup[value.stackingGroup] = vSeries.rectCount++;\n          } else {\n            value.position = stackingGroup[value.stackingGroup];\n          }\n        } else {\n          if (vSeries.position === null) {\n            value.position = vSeries.rectCount;\n            vSeries.position = vSeries.rectCount++;\n          } else {\n            value.position = vSeries.position;\n          }\n        }\n      } else {\n        value.position = vSeries.rectCount++;\n      }\n    });\n    seriesCollection.forEach(function (value) {\n      value.rectCount = vSeries.rectCount;\n    });\n  };\n  /**\n   * Updates the symbollocation for points\n   * @return void\n   * @private\n   */\n\n\n  ColumnBase.prototype.updateSymbolLocation = function (point, rect, series) {\n    if (!series.chart.requireInvertedAxis) {\n      this.updateXRegion(point, rect, series);\n    } else {\n      this.updateYRegion(point, rect, series);\n    }\n\n    if (series.type === 'Histogram') {\n      point.minimum = +point.x - series.histogramValues.binWidth / 2;\n      point.maximum = +point.x + series.histogramValues.binWidth / 2;\n    }\n  };\n  /**\n   * Update the region for the point.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.updateXRegion = function (point, rect, series) {\n    point.regions.push(rect);\n    point.symbolLocations.push({\n      x: rect.x + rect.width / 2,\n      y: series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 || point.yValue >= 0 === !series.yAxis.isInversed ? rect.y : rect.y + rect.height\n    });\n\n    if (series.type === 'RangeColumn') {\n      point.symbolLocations.push({\n        x: rect.x + rect.width / 2,\n        y: rect.y + rect.height\n      });\n    }\n  };\n  /**\n   * Update the region for the point in bar series.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.updateYRegion = function (point, rect, series) {\n    point.regions.push(rect);\n    point.symbolLocations.push({\n      x: series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 || point.yValue >= 0 === !series.yAxis.isInversed ? rect.x + rect.width : rect.x,\n      y: rect.y + rect.height / 2\n    });\n\n    if (series.type === 'RangeColumn') {\n      point.symbolLocations.push({\n        x: rect.x,\n        y: rect.y + rect.height / 2\n      });\n    }\n  };\n  /**\n   * To render the marker for the series.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.renderMarker = function (series) {\n    if (series.marker && series.marker.visible) {\n      series.chart.markerRender.render(series);\n    }\n  };\n  /**\n   * To trigger the point rendering event.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.triggerEvent = function (series, point, fill, border) {\n    var argsData = {\n      cancel: false,\n      name: pointRender,\n      series: series,\n      point: point,\n      fill: series.setPointColor(point, fill),\n      border: series.setBorderColor(point, border)\n    };\n    series.chart.trigger(pointRender, argsData);\n    point.color = argsData.fill;\n    return argsData;\n  };\n  /**\n   * To draw the rectangle for points.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.drawRectangle = function (series, point, rect, argsData) {\n    var chart = series.chart;\n    var check = chart.requireInvertedAxis ? rect.height : rect.width;\n\n    if (check <= 0) {\n      return null;\n    }\n\n    var direction = this.calculateRoundedRectPath(rect, series.cornerRadius.topLeft, series.cornerRadius.topRight, series.cornerRadius.bottomLeft, series.cornerRadius.bottomRight);\n    var name = series.category === 'Indicator' ? chart.element.id + '_Indicator_' + series.index + '_' + series.name + '_Point_' + point.index : chart.element.id + '_Series_' + series.index + '_Point_' + point.index;\n    var previousElement = redrawElement(chart.redraw, name);\n    var previousDirection = previousElement ? previousElement.getAttribute('d') : '';\n    var options = new PathOption(name, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);\n    var element = chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n\n    switch (series.seriesType) {\n      case 'XY':\n        element.setAttribute('aria-label', point.x.toString() + ':' + point.yValue.toString());\n        break;\n\n      case 'HighLow':\n        element.setAttribute('aria-label', point.x.toString() + ':' + point.high.toString() + ':' + point.low.toString());\n        break;\n    }\n\n    appendChildElement(series.chart.enableCanvas, series.seriesElement, element, chart.redraw);\n\n    if (!series.chart.enableCanvas) {\n      pathAnimation(element, direction, chart.redraw, previousDirection, chart.duration);\n    }\n  };\n  /**\n   * To animate the series.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.animate = function (series) {\n    var rectElements = series.seriesElement.childNodes;\n    var count = series.category === 'Indicator' ? 0 : 1;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      if (!point.symbolLocations.length && !(series.type === 'BoxAndWhisker' && point.regions.length)) {\n        continue;\n      }\n\n      this.animateRect(rectElements[count], series, point);\n      count++;\n    }\n  };\n  /**\n   * To animate the series.\n   * @return {void}\n   * @private\n   */\n\n\n  ColumnBase.prototype.animateRect = function (element, series, point) {\n    var option = series.animation;\n    var duration = series.chart.animated ? series.chart.duration : option.duration;\n    var effect = getAnimationFunction('Linear');\n    var isPlot = point.yValue < 0;\n    var x;\n    var y;\n    var elementHeight = +point.regions[0].height;\n    var elementWidth = +point.regions[0].width;\n    var centerX;\n    var centerY;\n\n    if (!series.chart.requireInvertedAxis) {\n      x = +point.regions[0].x;\n\n      if (series.type.indexOf('Stacking') > -1) {\n        y = (1 - valueToCoefficient(0, series.yAxis)) * series.yAxis.rect.height;\n        centerX = x;\n        centerY = y;\n      } else {\n        y = +point.regions[0].y;\n        centerY = series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1 ? y + elementHeight / 2 : isPlot !== series.yAxis.isInversed ? y : y + elementHeight;\n        centerX = isPlot ? x : x + elementWidth;\n      }\n    } else {\n      y = +point.regions[0].y;\n\n      if (series.type.indexOf('Stacking') > -1) {\n        x = valueToCoefficient(0, series.yAxis) * series.yAxis.rect.width;\n        centerX = x;\n        centerY = y;\n      } else {\n        x = +point.regions[0].x;\n        centerY = isPlot ? y : y + elementHeight;\n        centerX = series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1 ? x + elementWidth / 2 : isPlot !== series.yAxis.isInversed ? x + elementWidth : x;\n      }\n    }\n\n    var value;\n    element.style.visibility = 'hidden';\n    new Animation({}).animate(element, {\n      duration: duration,\n      delay: option.delay,\n      progress: function (args) {\n        if (args.timeStamp >= args.delay) {\n          element.style.visibility = 'visible';\n\n          if (!series.chart.requireInvertedAxis) {\n            elementHeight = elementHeight ? elementHeight : 1;\n            value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);\n            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(1,' + value / elementHeight + ') translate(' + -centerX + ' ' + -centerY + ')');\n          } else {\n            elementWidth = elementWidth ? elementWidth : 1;\n            value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);\n            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(' + value / elementWidth + ', 1) translate(' + -centerX + ' ' + -centerY + ')');\n          }\n        }\n      },\n      end: function (model) {\n        element.setAttribute('transform', 'translate(0,0)');\n        var seriesElement = series.seriesElement;\n\n        if (element === seriesElement.lastElementChild || point.index === series.points.length - 1 || series.type === 'Waterfall' && element === seriesElement.children[seriesElement.childElementCount - 2]) {\n          series.chart.trigger('animationComplete', {\n            series: series.chart.isBlazor ? {} : series\n          });\n\n          if (series.type === 'Waterfall') {\n            var rectElements = seriesElement.childNodes;\n\n            for (var i = 0; i < rectElements.length; i++) {\n              if (rectElements[i].id.indexOf('Connector') !== -1) {\n                rectElements[i].style.visibility = 'visible';\n                rectElements[i].setAttribute('transform', 'translate(0,0)');\n              }\n            }\n          }\n        }\n      }\n    });\n  };\n  /**\n   * To get rounded rect path direction\n   */\n\n\n  ColumnBase.prototype.calculateRoundedRectPath = function (rect, topLeft, topRight, bottomLeft, bottomRight) {\n    return 'M' + ' ' + rect.x + ' ' + (topLeft + rect.y) + ' Q ' + rect.x + ' ' + rect.y + ' ' + (rect.x + topLeft) + ' ' + rect.y + ' ' + 'L' + ' ' + (rect.x + rect.width - topRight) + ' ' + rect.y + ' Q ' + (rect.x + rect.width) + ' ' + rect.y + ' ' + (rect.x + rect.width) + ' ' + (rect.y + topRight) + ' ' + 'L ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height - bottomRight) + ' Q ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height) + ' ' + (rect.x + rect.width - bottomRight) + ' ' + (rect.y + rect.height) + ' ' + 'L ' + (rect.x + bottomLeft) + ' ' + (rect.y + rect.height) + ' Q ' + rect.x + ' ' + (rect.y + rect.height) + ' ' + rect.x + ' ' + (rect.y + rect.height - bottomLeft) + ' ' + 'L' + ' ' + rect.x + ' ' + (topLeft + rect.y) + ' ' + 'Z';\n  };\n\n  return ColumnBase;\n}();\n\nexport { ColumnBase };","map":null,"metadata":{},"sourceType":"module"}