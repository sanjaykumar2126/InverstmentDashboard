{"ast":null,"code":"import { getAnimationFunction, pathAnimation, getElement } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { Animation } from '@syncfusion/ej2-base';\n/**\n * Base for line type series.\n */\n\nvar LineBase =\n/** @class */\nfunction () {\n  /** @private */\n  function LineBase(chartModule) {\n    this.chart = chartModule;\n  }\n  /**\n   * To improve the chart performance.\n   * @return {void}\n   * @private\n   */\n\n\n  LineBase.prototype.enableComplexProperty = function (series) {\n    var tempPoints = [];\n    var xVisibleRange = series.xAxis.visibleRange;\n    var yVisibleRange = series.yAxis.visibleRange;\n    var seriesPoints = series.points;\n    var areaBounds = series.clipRect;\n    var xTolerance = Math.abs(xVisibleRange.delta / areaBounds.width);\n    var yTolerance = Math.abs(yVisibleRange.delta / areaBounds.height);\n    var prevXValue = seriesPoints[0] && seriesPoints[0].x > xTolerance ? 0 : xTolerance;\n    var prevYValue = seriesPoints[0] && seriesPoints[0].y > yTolerance ? 0 : yTolerance;\n    var xVal = 0;\n    var yVal = 0;\n\n    for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {\n      var currentPoint = seriesPoints_1[_i];\n      currentPoint.symbolLocations = [];\n      xVal = currentPoint.xValue ? currentPoint.xValue : xVisibleRange.min;\n      yVal = currentPoint.yValue ? currentPoint.yValue : yVisibleRange.min;\n\n      if (Math.abs(prevXValue - xVal) >= xTolerance || Math.abs(prevYValue - yVal) >= yTolerance) {\n        tempPoints.push(currentPoint);\n        prevXValue = xVal;\n        prevYValue = yVal;\n      }\n    }\n\n    return tempPoints;\n  };\n  /**\n   * To generate the line path direction\n   * @param firstPoint\n   * @param secondPoint\n   * @param series\n   * @param isInverted\n   * @param getPointLocation\n   * @param startPoint\n   */\n\n\n  LineBase.prototype.getLineDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation, startPoint) {\n    var direction = '';\n\n    if (firstPoint != null) {\n      var point1 = getPointLocation(firstPoint.xValue, firstPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n      var point2 = getPointLocation(secondPoint.xValue, secondPoint.yValue, series.xAxis, series.yAxis, isInverted, series);\n      direction = startPoint + ' ' + point1.x + ' ' + point1.y + ' ' + 'L' + ' ' + point2.x + ' ' + point2.y + ' ';\n    }\n\n    return direction;\n  };\n  /**\n   * To append the line path.\n   * @return {void}\n   * @private\n   */\n\n\n  LineBase.prototype.appendLinePath = function (options, series, clipRect) {\n    var element = getElement(options.id);\n    var chart = series.chart;\n    var previousDirection = element ? element.getAttribute('d') : null;\n    var htmlObject = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n\n    if (htmlObject) {\n      htmlObject.setAttribute('clip-path', clipRect);\n    }\n\n    series.pathElement = htmlObject;\n\n    if (!series.chart.enableCanvas) {\n      series.seriesElement.appendChild(htmlObject);\n    }\n\n    series.isRectSeries = false;\n    pathAnimation(element, options.d, series.chart.redraw, previousDirection, chart.duration);\n  };\n  /**\n   * To render the marker for the series.\n   * @return {void}\n   * @private\n   */\n\n\n  LineBase.prototype.renderMarker = function (series) {\n    if (series.marker && series.marker.visible) {\n      series.chart.markerRender.render(series);\n    }\n  };\n  /**\n   * To do the progressive animation.\n   * @return {void}\n   * @private\n   */\n\n\n  LineBase.prototype.doProgressiveAnimation = function (series, option) {\n    var animation = new Animation({});\n    var path = series.pathElement;\n    var strokeDashArray = path.getAttribute('stroke-dasharray');\n    var pathLength = series.pathElement.getTotalLength();\n    var currentTime;\n    path.style.visibility = 'hidden';\n    animation.animate(path, {\n      duration: option.duration,\n      delay: option.delay,\n      progress: function (args) {\n        if (args.timeStamp >= args.delay) {\n          path.style.visibility = 'visible';\n          currentTime = Math.abs(Math.round((args.timeStamp - args.delay) * pathLength / args.duration));\n          path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);\n        }\n      },\n      end: function (model) {\n        path.setAttribute('stroke-dasharray', strokeDashArray);\n        series.chart.trigger('animationComplete', {\n          series: series.chart.isBlazor ? {} : series\n        });\n      }\n    });\n  };\n  /**\n   * To store the symbol location and region\n   * @param point\n   * @param series\n   * @param isInverted\n   * @param getLocation\n   */\n\n\n  LineBase.prototype.storePointLocation = function (point, series, isInverted, getLocation) {\n    var markerWidth = series.marker && series.marker.width ? series.marker.width : 0;\n    var markerHeight = series.marker && series.marker.height ? series.marker.height : 0;\n    point.symbolLocations.push(getLocation(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted, series));\n    point.regions.push(new Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n  };\n  /**\n   * To do the linear animation.\n   * @return {void}\n   * @private\n   */\n\n\n  LineBase.prototype.doLinearAnimation = function (series, animation) {\n    var clipRect = series.clipRectElement.childNodes[0].childNodes[0];\n    var duration = series.chart.animated ? series.chart.duration : animation.duration;\n    var effect = getAnimationFunction('Linear');\n    var elementHeight = +clipRect.getAttribute('height');\n    var elementWidth = +clipRect.getAttribute('width');\n    var xCenter = +clipRect.getAttribute('x');\n    var yCenter = series.chart.requireInvertedAxis ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') : +clipRect.getAttribute('y');\n    var value;\n    clipRect.style.visibility = 'hidden';\n    new Animation({}).animate(clipRect, {\n      duration: duration,\n      delay: animation.delay,\n      progress: function (args) {\n        if (args.timeStamp >= args.delay) {\n          clipRect.style.visibility = 'visible';\n\n          if (series.chart.requireInvertedAxis) {\n            value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);\n            clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter + ') scale(1,' + value / elementHeight + ') translate(' + -xCenter + ' ' + -yCenter + ')');\n          } else {\n            value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);\n            clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter + ') scale(' + value / elementWidth + ', 1) translate(' + -xCenter + ' ' + -yCenter + ')');\n          }\n        }\n      },\n      end: function (model) {\n        clipRect.setAttribute('transform', 'translate(0,0)');\n        series.chart.trigger('animationComplete', {\n          series: series.chart.isBlazor ? {} : series\n        });\n      }\n    });\n  };\n\n  return LineBase;\n}();\n\nexport { LineBase };","map":null,"metadata":{},"sourceType":"module"}