{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { sum, getPoint, templateAnimate } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { ColumnSeries } from './column-series';\n/**\n * `HistogramSeries` Module used to render the histogram series.\n */\n\nvar HistogramSeries =\n/** @class */\nfunction (_super) {\n  __extends(HistogramSeries, _super);\n\n  function HistogramSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Render Histogram series.\n   * @return {void}\n   * @private\n   */\n\n\n  HistogramSeries.prototype.render = function (series) {\n    _super.prototype.render.call(this, series);\n\n    if (series.showNormalDistribution) {\n      this.renderNormalDistribution(series);\n    }\n  };\n  /**\n   * To calculate bin interval for Histogram series.\n   * @return number\n   * @private\n   */\n\n\n  HistogramSeries.prototype.calculateBinInterval = function (yValues, series) {\n    var mean = sum(yValues) / yValues.length;\n    var sumValue = 0;\n\n    for (var _i = 0, yValues_1 = yValues; _i < yValues_1.length; _i++) {\n      var value = yValues_1[_i];\n      sumValue += (value - mean) * (value - mean);\n    }\n\n    series.histogramValues.mean = mean;\n    series.histogramValues.sDValue = Math.round(Math.sqrt(sumValue / yValues.length - 1));\n    series.histogramValues.binWidth = series.binInterval || Math.round(3.5 * series.histogramValues.sDValue / Math.pow(yValues.length, 1 / 3));\n  };\n  /**\n   * Add data points for Histogram series.\n   * @return {object[]}\n   * @private\n   */\n\n\n  HistogramSeries.prototype.processInternalData = function (data, series) {\n    var _a;\n\n    var updatedData = [];\n    var yValues = [];\n    var binWidth;\n    Object.keys(data).forEach(function (key) {\n      yValues.push(data[key][series.yName]);\n    });\n    series.histogramValues = {\n      yValues: yValues\n    };\n    var min = Math.min.apply(Math, series.histogramValues.yValues);\n    this.calculateBinInterval(series.histogramValues.yValues, series);\n    binWidth = series.histogramValues.binWidth;\n    var yCount;\n\n    for (var j = 0; j < data.length;) {\n      yCount = yValues.filter(function (y) {\n        return y >= min && y < min + binWidth;\n      }).length;\n      updatedData.push((_a = {\n        'x': min + binWidth / 2\n      }, _a[series.yName] = yCount, _a));\n      min = min + binWidth;\n      j += yCount;\n    }\n\n    return updatedData;\n  };\n  /**\n   * Render Normal Distribution for Histogram series.\n   * @return {void}\n   * @private\n   */\n\n\n  HistogramSeries.prototype.renderNormalDistribution = function (series) {\n    var min = series.xAxis.actualRange.min;\n    var max = series.xAxis.actualRange.max;\n    var xValue;\n    var pointLocation;\n    var yValue;\n    var direction = '';\n    var startPoint = 'M';\n    var yValuesCount = series.histogramValues.yValues.length;\n    var binWidth = series.histogramValues.binWidth;\n    var mean = series.histogramValues.mean;\n    var sDValue = series.histogramValues.sDValue;\n    var pointsCount = 500;\n    var del = (max - min) / (pointsCount - 1);\n    var distributionLine;\n\n    for (var i = 0; i < pointsCount; i++) {\n      xValue = min + i * del;\n      yValue = Math.exp(-(xValue - mean) * (xValue - mean) / (2 * sDValue * sDValue)) / (sDValue * Math.sqrt(2 * Math.PI));\n      pointLocation = getPoint(xValue, yValue * binWidth * yValuesCount, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, series);\n      direction += startPoint + ' ' + pointLocation.x + ' ' + pointLocation.y + ' ';\n      startPoint = 'L';\n    }\n\n    distributionLine = series.chart.renderer.drawPath(new PathOption(series.chart.element.id + '_Series_' + series.index + '_NDLine', 'transparent', 2, series.chart.themeStyle.errorBar, series.opacity, series.dashArray, direction), new Int32Array([series.clipRect.x, series.clipRect.y]));\n    distributionLine.style.visibility = !series.chart.enableCanvas ? series.animation.enable && series.chart.animateSeries ? 'hidden' : 'visible' : null;\n\n    if (!series.chart.enableCanvas) {\n      series.seriesElement.appendChild(distributionLine);\n    }\n  };\n  /**\n   * Animates the series.\n   * @param  {Series} series - Defines the series to animate.\n   * @return {void}\n   */\n\n\n  HistogramSeries.prototype.doAnimation = function (series) {\n    _super.prototype.doAnimation.call(this, series);\n\n    if (series.showNormalDistribution) {\n      templateAnimate(series.seriesElement.lastElementChild, series.animation.duration, 500, 'FadeIn');\n    }\n  };\n  /**\n   * Get module name.\n   */\n\n\n  HistogramSeries.prototype.getModuleName = function () {\n    return 'HistogramSeries';\n    /**\n     * return the module name\n     */\n  };\n  /**\n   * To destroy the histogram series.\n   * @return {void}\n   * @private\n   */\n\n\n  HistogramSeries.prototype.destroy = function (chart) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return HistogramSeries;\n}(ColumnSeries);\n\nexport { HistogramSeries };","map":null,"metadata":{},"sourceType":"module"}