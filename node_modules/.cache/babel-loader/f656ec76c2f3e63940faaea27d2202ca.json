{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * Accumulation charts base file\n */\n\n\nimport { Animation, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { stringToNumber, ChartLocation, degreeToLocation, getAnimationFunction, getElement } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { animationComplete } from '../../common/model/constants';\nimport { AccumulationBase } from './accumulation-base';\n/**\n * PieBase class used to do pie base calculations.\n */\n\nvar PieBase =\n/** @class */\nfunction (_super) {\n  __extends(PieBase, _super);\n\n  function PieBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * To initialize the property values.\n   * @private\n   */\n\n\n  PieBase.prototype.initProperties = function (chart, series) {\n    this.accumulation = chart;\n    this.size = Math.min(chart.initialClipRect.width, chart.initialClipRect.height);\n    this.initAngles(series);\n    var r = parseInt(series.radius, 10);\n\n    if ((series.radius.indexOf('%') !== -1 || typeof r === 'number') && !isNaN(r)) {\n      this.isRadiusMapped = false;\n      this.radius = stringToNumber(series.radius, this.size / 2);\n      this.innerRadius = stringToNumber(series.innerRadius, this.radius);\n      this.labelRadius = series.dataLabel.position === 'Inside' ? (this.radius - this.innerRadius) / 2 + this.innerRadius : this.radius + stringToNumber(series.dataLabel.connectorStyle.length || '4%', this.size / 2);\n    } else {\n      var radiusCollection = [];\n      this.isRadiusMapped = true;\n\n      for (var i = 0; i < Object.keys(series.points).length; i++) {\n        if (series.points[i].sliceRadius.indexOf('%') !== -1) {\n          radiusCollection[i] = stringToNumber(series.points[i].sliceRadius, this.size / 2);\n        } else {\n          radiusCollection[i] = parseInt(series.points[i].sliceRadius, 10);\n        }\n      }\n\n      var minRadius = Math.min.apply(null, radiusCollection);\n      var maxRadius = Math.max.apply(null, radiusCollection);\n      this.radius = this.seriesRadius = maxRadius;\n      this.innerRadius = stringToNumber(series.innerRadius, this.seriesRadius);\n      this.innerRadius = this.innerRadius > minRadius ? this.innerRadius / 2 : this.innerRadius;\n    } // this.radius = stringToNumber(series.radius, size / 2);\n    // this.innerRadius = stringToNumber(series.innerRadius, this.radius);\n    // this.labelRadius = series.dataLabel.position === 'Inside' ? (((this.radius - this.innerRadius) / 2) + this.innerRadius) :\n    //     (this.radius + stringToNumber(series.dataLabel.connectorStyle.length || '4%', size / 2));\n\n\n    chart.explodeDistance = series.explode ? stringToNumber(series.explodeOffset, this.radius) : 0;\n    this.findCenter(chart, series);\n    this.defaultLabelBound(series, series.dataLabel.visible, series.dataLabel.position);\n    this.totalAngle -= 0.001;\n  };\n  /*\n   * To get label radius of the pie.\n   * @private\n   */\n\n\n  PieBase.prototype.getLabelRadius = function (series, point) {\n    return series.dataLabel.position === 'Inside' ? (stringToNumber(point.sliceRadius, this.radius) - this.innerRadius) / 2 + this.innerRadius : stringToNumber(point.sliceRadius, this.seriesRadius) + stringToNumber(series.dataLabel.connectorStyle.length || '4%', this.size / 2);\n  };\n  /**\n   * To find the center of the accumulation.\n   * @private\n   */\n\n\n  PieBase.prototype.findCenter = function (accumulation, series) {\n    this.accumulation = accumulation;\n    this.center = {\n      x: stringToNumber(accumulation.center.x, accumulation.initialClipRect.width) + accumulation.initialClipRect.x,\n      y: stringToNumber(accumulation.center.y, accumulation.initialClipRect.height) + accumulation.initialClipRect.y\n    };\n    var accumulationRect = this.getSeriesBound(series);\n    var accumulationRectCenter = new ChartLocation(accumulationRect.x + accumulationRect.width / 2, accumulationRect.y + accumulationRect.height / 2);\n    this.center.x += this.center.x - accumulationRectCenter.x;\n    this.center.y += this.center.y - accumulationRectCenter.y;\n    this.accumulation.origin = this.center;\n  };\n  /**\n   * To find angles from series.\n   */\n\n\n  PieBase.prototype.initAngles = function (series) {\n    var endAngle = isNullOrUndefined(series.endAngle) ? series.startAngle : series.endAngle;\n    this.totalAngle = (endAngle - series.startAngle) % 360;\n    this.startAngle = series.startAngle - 90;\n    this.totalAngle = this.totalAngle <= 0 ? 360 + this.totalAngle : this.totalAngle;\n    this.startAngle = (this.startAngle < 0 ? this.startAngle + 360 : this.startAngle) % 360;\n  };\n  /**\n   * To calculate data-label bound\n   * @private\n   */\n\n\n  PieBase.prototype.defaultLabelBound = function (series, visible, position) {\n    var accumulationBound = this.getSeriesBound(series);\n    series.accumulationBound = accumulationBound;\n    series.labelBound = new Rect(accumulationBound.x, accumulationBound.y, accumulationBound.width + accumulationBound.x, accumulationBound.height + accumulationBound.y);\n\n    if (visible && position === 'Outside') {\n      series.labelBound = new Rect(Infinity, Infinity, -Infinity, -Infinity);\n    }\n  };\n  /**\n   * To calculate series bound\n   * @private\n   */\n\n\n  PieBase.prototype.getSeriesBound = function (series) {\n    var rect = new Rect(Infinity, Infinity, -Infinity, -Infinity);\n    this.initAngles(series);\n    var start = this.startAngle;\n    var total = this.totalAngle;\n    var end = (this.startAngle + total) % 360;\n    end = end === 0 ? 360 : end;\n    series.findMaxBounds(rect, this.getRectFromAngle(start));\n    series.findMaxBounds(rect, this.getRectFromAngle(end));\n    series.findMaxBounds(rect, new Rect(this.center.x, this.center.y, 0, 0));\n    var nextQuandrant = (Math.floor(start / 90) * 90 + 90) % 360;\n    var lastQuadrant = Math.floor(end / 90) * 90 % 360;\n    lastQuadrant = lastQuadrant === 0 ? 360 : lastQuadrant;\n\n    if (total >= 90 || lastQuadrant === nextQuandrant) {\n      series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));\n      series.findMaxBounds(rect, this.getRectFromAngle(lastQuadrant));\n    }\n\n    if (start === 0 || start + total >= 360) {\n      series.findMaxBounds(rect, this.getRectFromAngle(0));\n    }\n\n    var length = nextQuandrant === lastQuadrant ? 0 : Math.floor(total / 90);\n\n    for (var i = 1; i < length; i++) {\n      nextQuandrant = nextQuandrant + 90;\n\n      if (nextQuandrant < lastQuadrant || end < start || total === 360) {\n        series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));\n      }\n    }\n\n    rect.width -= rect.x;\n    rect.height -= rect.y;\n    return rect;\n  };\n  /**\n   * To get rect location size from angle\n   */\n\n\n  PieBase.prototype.getRectFromAngle = function (angle) {\n    var location = degreeToLocation(angle, this.radius, this.center);\n    return new Rect(location.x, location.y, 0, 0);\n  };\n  /**\n   * To get path arc direction\n   */\n\n\n  PieBase.prototype.getPathArc = function (center, start, end, radius, innerRadius) {\n    var degree = end - start;\n    degree = degree < 0 ? degree + 360 : degree;\n    var flag = degree < 180 ? 0 : 1;\n\n    if (!innerRadius && innerRadius === 0) {\n      return this.getPiePath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, flag);\n    } else {\n      return this.getDoughnutPath(center, degreeToLocation(start, radius, center), degreeToLocation(end, radius, center), radius, degreeToLocation(start, innerRadius, center), degreeToLocation(end, innerRadius, center), innerRadius, flag);\n    }\n  };\n  /**\n   * To get pie direction\n   */\n\n\n  PieBase.prototype.getPiePath = function (center, start, end, radius, clockWise) {\n    return 'M ' + center.x + ' ' + center.y + ' L ' + start.x + ' ' + start.y + ' A ' + radius + ' ' + radius + ' 0 ' + clockWise + ' 1 ' + end.x + ' ' + end.y + ' Z';\n  };\n  /**\n   * To get doughnut direction\n   */\n\n\n  PieBase.prototype.getDoughnutPath = function (center, start, end, radius, innerStart, innerEnd, innerRadius, clockWise) {\n    return 'M ' + start.x + ' ' + start.y + ' A ' + radius + ' ' + radius + ' 0 ' + clockWise + ' 1 ' + end.x + ' ' + end.y + ' L ' + innerEnd.x + ' ' + innerEnd.y + ' A ' + innerRadius + ' ' + innerRadius + ' 0 ' + clockWise + ',0 ' + innerStart.x + ' ' + innerStart.y + ' Z';\n  };\n  /**\n   * Method to start animation for pie series.\n   */\n\n\n  PieBase.prototype.doAnimation = function (slice, series) {\n    var _this = this;\n\n    var startAngle = series.startAngle - 90;\n    var duration = this.accumulation.duration ? this.accumulation.duration : series.animation.duration;\n    var value;\n    this.center.x += 1;\n    var radius = Math.max(this.accumulation.availableSize.height, this.accumulation.availableSize.width) * 0.75;\n    radius += radius * 0.414; // formula r + r / 2 * (1.414 -1)\n\n    var effect = getAnimationFunction('Linear'); // need to check animation type\n\n    new Animation({}).animate(slice, {\n      duration: duration,\n      delay: series.animation.delay,\n      progress: function (args) {\n        value = effect(args.timeStamp, startAngle, _this.totalAngle, args.duration);\n        slice.setAttribute('d', _this.getPathArc(_this.center, startAngle, value, radius, 0));\n      },\n      end: function (args) {\n        _this.center.x -= 1;\n        slice.setAttribute('d', _this.getPathArc(_this.center, 0, 359.99999, radius, 0));\n\n        _this.accumulation.trigger(animationComplete, _this.accumulation.isBlazor ? {} : {\n          series: series,\n          accumulation: _this.accumulation,\n          chart: _this.accumulation\n        });\n\n        var datalabelGroup = getElement(_this.accumulation.element.id + '_datalabel_Series_' + series.index);\n        datalabelGroup.style.visibility = _this.accumulation.isDestroyed ? 'hidden' : 'visible';\n      }\n    });\n  };\n\n  return PieBase;\n}(AccumulationBase);\n\nexport { PieBase };","map":null,"metadata":{},"sourceType":"module"}