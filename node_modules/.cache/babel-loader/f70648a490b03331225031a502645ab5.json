{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport ChartElement from './chart-element';\nimport Box from './box';\nimport { BLACK, LEFT, TOP, X, Y } from '../common/constants';\nimport { getSpacing, setDefaultOptions, valueOrDefault } from '../common';\n\nvar BoxElement = function (ChartElement) {\n  function BoxElement(options) {\n    ChartElement.call(this, options);\n    this.options.margin = getSpacing(this.options.margin);\n    this.options.padding = getSpacing(this.options.padding);\n  }\n\n  if (ChartElement) BoxElement.__proto__ = ChartElement;\n  BoxElement.prototype = Object.create(ChartElement && ChartElement.prototype);\n  BoxElement.prototype.constructor = BoxElement;\n\n  BoxElement.prototype.reflow = function reflow(targetBox) {\n    var this$1 = this;\n    var options = this.options;\n    var width = options.width;\n    var height = options.height;\n    var shrinkToFit = options.shrinkToFit;\n    var hasSetSize = width && height;\n    var margin = options.margin;\n    var padding = options.padding;\n    var borderWidth = options.border.width;\n    var box;\n\n    var reflowPaddingBox = function () {\n      this$1.align(targetBox, X, options.align);\n      this$1.align(targetBox, Y, options.vAlign);\n      this$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);\n    };\n\n    var contentBox = targetBox.clone();\n\n    if (hasSetSize) {\n      contentBox.x2 = contentBox.x1 + width;\n      contentBox.y2 = contentBox.y1 + height;\n    }\n\n    if (shrinkToFit) {\n      contentBox.unpad(margin).unpad(borderWidth).unpad(padding);\n    }\n\n    ChartElement.prototype.reflow.call(this, contentBox);\n\n    if (hasSetSize) {\n      box = this.box = new Box(0, 0, width, height);\n    } else {\n      box = this.box;\n    }\n\n    if (shrinkToFit && hasSetSize) {\n      reflowPaddingBox();\n      contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);\n    } else {\n      contentBox = this.contentBox = box.clone();\n      box.pad(padding).pad(borderWidth).pad(margin);\n      reflowPaddingBox();\n    }\n\n    this.translateChildren(box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left, box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top);\n    var children = this.children;\n\n    for (var i = 0; i < children.length; i++) {\n      var item = children[i];\n      item.reflow(item.box);\n    }\n  };\n\n  BoxElement.prototype.align = function align(targetBox, axis, alignment) {\n    this.box.align(targetBox, axis, alignment);\n  };\n\n  BoxElement.prototype.hasBox = function hasBox() {\n    var options = this.options;\n    return options.border.width || options.background;\n  };\n\n  BoxElement.prototype.createVisual = function createVisual() {\n    ChartElement.prototype.createVisual.call(this);\n    var options = this.options;\n\n    if (options.visible && this.hasBox()) {\n      this.visual.append(draw.Path.fromRect(this.paddingBox.toRect(), this.visualStyle()));\n    }\n  };\n\n  BoxElement.prototype.visualStyle = function visualStyle() {\n    var options = this.options;\n    var border = options.border || {};\n    return {\n      stroke: {\n        width: border.width,\n        color: border.color,\n        opacity: valueOrDefault(border.opacity, options.opacity),\n        dashType: border.dashType\n      },\n      fill: {\n        color: options.background,\n        opacity: options.opacity\n      },\n      cursor: options.cursor\n    };\n  };\n\n  return BoxElement;\n}(ChartElement);\n\nsetDefaultOptions(BoxElement, {\n  align: LEFT,\n  vAlign: TOP,\n  margin: {},\n  padding: {},\n  border: {\n    color: BLACK,\n    width: 0\n  },\n  background: \"\",\n  shrinkToFit: false,\n  width: 0,\n  height: 0,\n  visible: true\n});\nexport default BoxElement;","map":null,"metadata":{},"sourceType":"module"}