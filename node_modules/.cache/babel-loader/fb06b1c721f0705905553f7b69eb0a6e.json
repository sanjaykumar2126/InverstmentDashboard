{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { degreeToLocation, getElement, linear, stringToNumber } from '../../common/utils/helper';\nimport { PieBase } from '../renderer/pie-base';\nimport { Animation, createElement } from '@syncfusion/ej2-base';\n/**\n * PieSeries module used to render `Pie` Series.\n */\n\nvar PieSeries =\n/** @class */\nfunction (_super) {\n  __extends(PieSeries, _super);\n\n  function PieSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * To get path option, degree, symbolLocation from the point.\n   * @private\n   */\n\n\n  PieSeries.prototype.renderPoint = function (point, series, chart, option, seriesGroup, redraw) {\n    var sum = series.sumOfPoints;\n    var yValue = point.visible ? point.y : 0;\n    var degree = sum ? Math.abs(yValue) / sum * this.totalAngle : null;\n    var start = Math.PI / 180 * (90 - (360 - this.startAngle) - 90);\n    this.radius = this.isRadiusMapped ? stringToNumber(point.sliceRadius, this.seriesRadius) : this.radius;\n    option.d = this.getPathOption(point, degree, this.startAngle % 360, yValue);\n    point.midAngle = (this.startAngle - degree / 2) % 360;\n    point.endAngle = this.startAngle % 360;\n    point.symbolLocation = degreeToLocation(point.midAngle, (this.radius + this.innerRadius) / 2, this.center);\n\n    if (!redraw) {\n      seriesGroup.appendChild(chart.renderer.drawPath(option));\n      point.degree = degree;\n      point.start = start;\n    } else {\n      this.refresh(point, degree, start, chart, option, seriesGroup);\n    }\n  };\n\n  PieSeries.prototype.refresh = function (point, degree, start, chart, option, seriesGroup) {\n    var _this = this;\n\n    var seriesElement = getElement(option.id);\n    var duration = chart.duration ? chart.duration : 300;\n    var currentStartAngle;\n    var curentDegree;\n    new Animation({}).animate(createElement('div'), {\n      duration: duration,\n      delay: 0,\n      progress: function (args) {\n        curentDegree = linear(args.timeStamp, point.degree, degree - point.degree, args.duration);\n        currentStartAngle = linear(args.timeStamp, point.start, start - point.start, args.duration);\n        currentStartAngle = (currentStartAngle / (Math.PI / 180) + 360) % 360;\n        seriesElement.setAttribute('d', _this.getPathOption(point, curentDegree, currentStartAngle, point.y));\n\n        if (point.isExplode) {\n          chart.accBaseModule.explodePoints(point.index, chart, true);\n        }\n\n        seriesElement.style.visibility = 'visible';\n      },\n      end: function (args) {\n        seriesElement.style.visibility = point.visible ? 'visible' : 'hidden';\n        seriesElement.setAttribute('d', option.d);\n        point.degree = degree;\n        point.start = start;\n      }\n    });\n  };\n  /**\n   * To get path option from the point.\n   */\n\n\n  PieSeries.prototype.getPathOption = function (point, degree, startAngle, yValue) {\n    if (!degree) {\n      return '';\n    }\n\n    var path = this.getPathArc(this.center, startAngle % 360, (startAngle + degree) % 360, this.isRadiusMapped ? stringToNumber(point.sliceRadius, this.seriesRadius) : this.radius, this.innerRadius); //let path: string = this.getPathArc(this.center, startAngle % 360, (startAngle + degree) % 360, this.radius, this.innerRadius);\n\n    this.startAngle += degree;\n    return path;\n  };\n  /**\n   * To animate the pie series.\n   * @private\n   */\n\n\n  PieSeries.prototype.animateSeries = function (accumulation, option, series, slice) {\n    var groupId = accumulation.element.id + 'SeriesGroup' + series.index;\n\n    if (series.animation.enable && accumulation.animateSeries) {\n      var clippath = accumulation.renderer.createClipPath({\n        id: groupId + '_clipPath'\n      });\n      var path = new PathOption(groupId + '_slice', 'transparent', 1, 'transparent', 1, '', '');\n      var clipslice = accumulation.renderer.drawPath(path);\n      clippath.appendChild(clipslice);\n      accumulation.svgObject.appendChild(clippath);\n      slice.setAttribute('style', 'clip-path:url(#' + clippath.id + ')');\n      this.doAnimation(clipslice, series);\n    }\n  };\n  /**\n   * To get the module name of the Pie series.\n   */\n\n\n  PieSeries.prototype.getModuleName = function () {\n    return 'PieSeries';\n  };\n  /**\n   * To destroy the pie series.\n   * @return {void}\n   * @private\n   */\n\n\n  PieSeries.prototype.destroy = function (accumulation) {\n    /**\n     * Destroy method calling here\n     */\n  };\n\n  return PieSeries;\n}(PieBase);\n\nexport { PieSeries };","map":null,"metadata":{},"sourceType":"module"}