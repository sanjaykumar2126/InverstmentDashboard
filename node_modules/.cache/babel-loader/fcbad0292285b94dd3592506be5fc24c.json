{"ast":null,"code":"import { measureText } from '../../smithchart/utils/helper';\nimport { HorizontalLabelCollection, LabelRegion, Point, Direction } from '../../smithchart/utils/utils';\nimport { GridArcPoints, RadialLabelCollections } from '../../smithchart/utils/utils';\nimport { PathOption, TextOption, renderTextElement, _getEpsilonValue } from '../../smithchart/utils/helper';\n/* tslint:disable:no-string-literal */\n\nvar AxisRender =\n/** @class */\nfunction () {\n  function AxisRender() {\n    this.radialLabels = [-50, -20, -10, -5, -4, -3, -2, -1.5, -1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1, 1.5, 2, 3, 4, 5, 10, 20, 50];\n    this.radialLabelCollections = [];\n    this.horizontalLabelCollections = [];\n    this.labelCollections = [];\n    this.direction = new Direction();\n  }\n\n  AxisRender.prototype.renderArea = function (smithchart, bounds) {\n    this.calculateChartArea(smithchart, bounds);\n    this.calculateCircleMargin(smithchart, bounds);\n    this.calculateXAxisRange(smithchart);\n    this.calculateRAxisRange(smithchart);\n    this.measureHorizontalAxis(smithchart);\n    this.measureRadialAxis(smithchart);\n\n    if (smithchart.horizontalAxis.visible) {\n      this.updateHAxis(smithchart);\n    }\n\n    if (smithchart.radialAxis.visible) {\n      this.updateRAxis(smithchart);\n    }\n\n    if (smithchart.horizontalAxis.visible) {\n      this.drawHAxisLabels(smithchart);\n    }\n\n    if (smithchart.radialAxis.visible) {\n      this.drawRAxisLabels(smithchart);\n    }\n  };\n\n  AxisRender.prototype.updateHAxis = function (smithchart) {\n    var majorGridLines = smithchart.horizontalAxis.majorGridLines;\n    var minorGridLines = smithchart.horizontalAxis.minorGridLines;\n    var axisLine = smithchart.horizontalAxis.axisLine;\n\n    if (majorGridLines.visible) {\n      this.updateHMajorGridLines(smithchart);\n    }\n\n    if (minorGridLines.visible) {\n      this.updateHMinorGridLines(smithchart);\n    }\n\n    if (axisLine.visible) {\n      this.updateHAxisLine(smithchart);\n    }\n  };\n\n  AxisRender.prototype.updateRAxis = function (smithchart) {\n    var majorGridLines = smithchart.radialAxis.majorGridLines;\n    var minorGridLines = smithchart.radialAxis.minorGridLines;\n    var axisLine = smithchart.radialAxis.axisLine;\n\n    if (majorGridLines.visible) {\n      this.updateRMajorGridLines(smithchart);\n    }\n\n    if (minorGridLines.visible) {\n      this.updateRMinorGridLines(smithchart);\n    }\n\n    if (axisLine.visible) {\n      this.updateRAxisLine(smithchart);\n    }\n  };\n\n  AxisRender.prototype.measureHorizontalAxis = function (smithchart) {\n    var majorGridLines = smithchart.horizontalAxis.majorGridLines;\n    var minorGridLines = smithchart.horizontalAxis.minorGridLines;\n    this.measureHMajorGridLines(smithchart);\n\n    if (minorGridLines.visible) {\n      this.measureHMinorGridLines(smithchart);\n    }\n  };\n\n  AxisRender.prototype.measureRadialAxis = function (smithchart) {\n    var majorGridLines = smithchart.radialAxis.majorGridLines;\n    var minorGridLines = smithchart.radialAxis.minorGridLines;\n    this.measureRMajorGridLines(smithchart);\n\n    if (minorGridLines.visible) {\n      this.measureRMinorGridLines(smithchart);\n    }\n  };\n\n  AxisRender.prototype.calculateChartArea = function (smithchart, bounds) {\n    var chartAreaWidth;\n    var chartAreaHeight;\n    var width = smithchart.availableSize.width;\n    var height = smithchart.availableSize.height;\n    var x;\n    var y;\n    width = bounds.width;\n    height = bounds.height;\n    chartAreaWidth = Math.min(width, height);\n    chartAreaHeight = Math.min(width, height);\n    x = bounds.x + (bounds.width / 2 - chartAreaWidth / 2);\n    y = bounds.y + ((height - chartAreaHeight) / 2 > 0 ? (height - chartAreaHeight) / 2 : 0);\n    smithchart.chartArea = {\n      x: x,\n      y: y,\n      width: chartAreaWidth,\n      height: chartAreaHeight\n    };\n  };\n\n  AxisRender.prototype.calculateCircleMargin = function (smithchart, bounds) {\n    var padding = 10;\n    var maxLabelWidth = 0;\n    var width = smithchart.chartArea.width;\n    var radius = smithchart.radius;\n    maxLabelWidth = this.maximumLabelLength(smithchart);\n    var labelMargin = smithchart.radialAxis.labelPosition === 'Outside' ? maxLabelWidth + padding : padding;\n    var diameter = width - labelMargin * 2 > 0 ? width - labelMargin * 2 : 0;\n    var actualRadius = diameter / 2;\n    var circleCoefficient = radius > 1 ? 1 : radius < 0.1 ? 0.1 : radius;\n    this.areaRadius = actualRadius * circleCoefficient;\n    this.circleLeftX = smithchart.chartArea.x + labelMargin + actualRadius * (1 - circleCoefficient);\n    this.circleTopY = smithchart.chartArea.y + labelMargin + actualRadius * (1 - circleCoefficient);\n    this.circleCenterX = this.circleLeftX + this.areaRadius;\n    this.circleCenterY = bounds.y + bounds.height / 2;\n  };\n\n  AxisRender.prototype.maximumLabelLength = function (smithchart) {\n    var maximumLabelLength = 0;\n    var font = smithchart.horizontalAxis.labelStyle;\n    var label;\n    var textSize;\n\n    for (var i = 0; i < this.radialLabels.length; i++) {\n      label = this.radialLabels[i].toString();\n      textSize = measureText(label, font);\n\n      if (maximumLabelLength < textSize.width) {\n        maximumLabelLength = textSize.width;\n      }\n    }\n\n    return maximumLabelLength;\n  };\n\n  AxisRender.prototype.calculateAxisLabels = function () {\n    var spacingBetweenGridLines = 30;\n    var previousR = 0;\n    var j = 0;\n    var labels = [];\n    var diameter = this.areaRadius * 2;\n\n    for (var i = 0; i < 2; i = i + 0.1) {\n      i = Math.round(i * 10) / 10;\n      var coeff = 1 / (i + 1);\n      var isOverlap1 = false;\n      var isOverlap2 = false;\n      var radius = diameter * coeff / 2 * 2;\n\n      if (previousR === 0.0 || i === 1) {\n        previousR = radius;\n        labels[j] = i;\n        j++;\n        continue;\n      }\n\n      if (i < 1) {\n        isOverlap1 = this.isOverlap(1, diameter, radius, spacingBetweenGridLines);\n      }\n\n      if (i > 1) {\n        isOverlap2 = this.isOverlap(2, diameter, radius, spacingBetweenGridLines);\n      }\n\n      if (isOverlap1 || isOverlap2) {\n        continue;\n      }\n\n      if (previousR - radius >= spacingBetweenGridLines) {\n        labels[j] = i;\n        j++;\n        previousR = radius;\n      }\n    }\n\n    var staticlabels = [2, 3, 4, 5, 10, 20, 50];\n\n    for (var k = 0; k < staticlabels.length; k++) {\n      labels[j] = staticlabels[k];\n      j++;\n    }\n\n    return labels;\n  };\n\n  AxisRender.prototype.isOverlap = function (x, d, previousR, spacingBetweenGridLines) {\n    var coeff;\n    var radius;\n    coeff = 1 / (x + 1); // (1 / 1+r) find the radius for the x value\n\n    radius = d * coeff / 2 * 2;\n    return previousR - radius < spacingBetweenGridLines;\n  };\n\n  AxisRender.prototype.calculateXAxisRange = function (smithchart) {\n    var previousR = 0;\n    var x;\n    var coeff;\n    var radius;\n    var cx;\n    var diameter = this.areaRadius * 2;\n    var horizontalAxisLabels = this.calculateAxisLabels();\n    var cy = this.circleCenterY;\n    var circleStartX = this.circleLeftX;\n    var leftX = this.circleLeftX;\n\n    for (var i = 0; i < horizontalAxisLabels.length; i++) {\n      x = horizontalAxisLabels[i];\n      coeff = 1 / (x + 1);\n      radius = diameter * coeff / 2;\n\n      if (smithchart.renderType === 'Impedance') {\n        leftX = circleStartX + diameter - radius * 2;\n      }\n\n      cx = leftX + radius;\n      this.horizontalLabelCollections.push({\n        centerX: cx,\n        centerY: cy,\n        radius: radius,\n        value: x,\n        region: null\n      });\n    }\n  };\n\n  AxisRender.prototype.calculateRAxisRange = function (smithchart) {\n    var arcCy;\n    var arcRadius;\n    var diameter = this.areaRadius * 2;\n    var y;\n    var point = new Point();\n\n    if (smithchart.renderType === 'Impedance') {\n      point.x = this.circleLeftX + diameter;\n      point.y = this.circleTopY + this.areaRadius;\n    } else {\n      point.x = this.circleLeftX;\n      point.y = this.circleTopY + this.areaRadius;\n    }\n\n    for (var i = 0; i < this.radialLabels.length; i++) {\n      y = this.radialLabels[i];\n      arcRadius = Math.abs(1 / y * diameter / 2);\n\n      if (smithchart.renderType === 'Impedance') {\n        arcCy = y > 0 ? point.y - arcRadius : point.y + arcRadius;\n      } else {\n        arcCy = y < 0 ? point.y - arcRadius : point.y + arcRadius;\n      }\n\n      this.radialLabelCollections.push({\n        centerX: point.x,\n        centerY: arcCy,\n        radius: arcRadius,\n        value: y\n      });\n    }\n  };\n\n  AxisRender.prototype.measureHMajorGridLines = function (smithchart) {\n    var arcPoints = [];\n    var startPoint;\n    var endPoint;\n    var radialPoint1;\n    var radialPoint2;\n    var size;\n    this.majorHGridArcPoints = [];\n\n    for (var i = 0; i < this.horizontalLabelCollections.length; i++) {\n      var circlePoint = new HorizontalLabelCollection();\n      circlePoint = this.horizontalLabelCollections[i];\n      arcPoints = this.calculateHMajorArcStartEndPoints(circlePoint.value);\n\n      if (smithchart.renderType === 'Impedance') {\n        radialPoint1 = arcPoints[0];\n        radialPoint2 = arcPoints[1];\n      } else {\n        radialPoint1 = arcPoints[1];\n        radialPoint2 = arcPoints[0];\n      }\n\n      size = {\n        width: circlePoint.radius,\n        height: circlePoint.radius\n      };\n\n      if (circlePoint.value !== 0.0 && circlePoint.value !== 50.0) {\n        startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);\n        endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);\n        this.majorHGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          rotationAngle: 2 * Math.PI,\n          sweepDirection: smithchart.renderType === 'Impedance' ? this.direction['counterclockwise'] : this.direction['clockwise'],\n          isLargeArc: true,\n          size: size\n        });\n      } else {\n        startPoint = {\n          x: circlePoint.centerX + circlePoint.radius,\n          y: circlePoint.centerY\n        };\n        endPoint = {\n          x: circlePoint.centerX + circlePoint.radius,\n          y: circlePoint.centerY - 0.05\n        };\n        this.majorHGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          rotationAngle: 2 * Math.PI,\n          sweepDirection: this.direction['clockwise'],\n          isLargeArc: true,\n          size: size\n        });\n      }\n    }\n  };\n\n  AxisRender.prototype.measureRMajorGridLines = function (smithchart) {\n    var epsilon;\n    var radialPoint;\n    var y;\n    var arcPoints = [];\n    var innerInterSectPoint;\n    var outerInterSectPoint;\n    var outterInterSectRadian;\n    var outterInterSectAngle;\n    var startPoint;\n    var endPoint;\n    var size;\n    var sweepDirection;\n    this.majorRGridArcPoints = [];\n    this.labelCollections = [];\n    epsilon = _getEpsilonValue();\n\n    for (var i = 0; i < this.radialLabelCollections.length; i++) {\n      radialPoint = this.radialLabelCollections[i];\n\n      if (radialPoint.radius <= epsilon) {\n        continue;\n      }\n\n      y = radialPoint.value;\n      arcPoints = this.calculateMajorArcStartEndPoints(radialPoint, Math.abs(y), smithchart);\n      innerInterSectPoint = arcPoints[0];\n      outerInterSectPoint = arcPoints[1];\n      outterInterSectRadian = this.circleXYRadianValue(this.circleCenterX, this.circleCenterY, outerInterSectPoint.x, outerInterSectPoint.y);\n      outterInterSectAngle = outterInterSectRadian * (180 / Math.PI);\n\n      if (y !== 0.0) {\n        startPoint = {\n          x: innerInterSectPoint.x,\n          y: innerInterSectPoint.y\n        };\n        endPoint = {\n          x: outerInterSectPoint.x,\n          y: outerInterSectPoint.y\n        };\n        size = {\n          width: radialPoint.radius,\n          height: radialPoint.radius\n        };\n        sweepDirection = y > 0 ? this.direction['clockwise'] : this.direction['counterclockwise'];\n        this.majorRGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          size: size,\n          rotationAngle: 2 * Math.PI,\n          isLargeArc: false,\n          sweepDirection: sweepDirection\n        });\n        this.labelCollections.push({\n          centerX: outerInterSectPoint.x,\n          centerY: outerInterSectPoint.y,\n          angle: outterInterSectAngle,\n          value: y,\n          radius: this.areaRadius,\n          region: null\n        });\n      } else {\n        startPoint = {\n          x: this.circleLeftX,\n          y: this.circleCenterY\n        };\n        endPoint = {\n          x: this.circleCenterX + this.areaRadius,\n          y: this.circleCenterY\n        };\n        this.majorRGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          size: null,\n          rotationAngle: null,\n          isLargeArc: null,\n          sweepDirection: null\n        });\n        this.labelCollections.push({\n          centerX: smithchart.renderType === 'Impedance' ? this.circleCenterX - this.areaRadius : this.circleCenterX + this.areaRadius,\n          centerY: this.circleCenterY,\n          angle: smithchart.renderType === 'Impedance' ? 180 : 360,\n          value: y,\n          radius: this.areaRadius,\n          region: null\n        });\n      }\n    }\n  };\n\n  AxisRender.prototype.circleXYRadianValue = function (centerX, centerY, outterX, outterY) {\n    var radian;\n    radian = Math.atan2(outterY - centerY, outterX - centerX);\n    radian = radian < 0 ? radian + 360 * Math.PI / 180 : radian;\n    return radian;\n  };\n\n  AxisRender.prototype.calculateMajorArcStartEndPoints = function (radialPoint, value, smithchart) {\n    var arcPoints = [];\n    var circlePoint = [];\n    var cx;\n    var cy;\n    cx = this.circleCenterX;\n    cy = this.circleCenterY;\n\n    if (value >= 10) {\n      arcPoints[0] = smithchart.renderType === 'Impedance' ? {\n        x: cx + this.areaRadius,\n        y: cy\n      } : {\n        x: cx - this.areaRadius,\n        y: cy\n      };\n    } else if (value >= 3) {\n      circlePoint = this.horizontalLabelCollections.filter(function (c) {\n        return c.value === 10;\n      });\n    } else if (value >= 1) {\n      circlePoint = this.horizontalLabelCollections.filter(function (c) {\n        return c.value === 5;\n      });\n    } else {\n      circlePoint = this.horizontalLabelCollections.filter(function (c) {\n        return c.value === 3;\n      });\n    }\n\n    if (circlePoint.length > 0) {\n      arcPoints[0] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);\n    }\n\n    arcPoints[1] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, cx, cy, this.areaRadius, smithchart.renderType);\n    return arcPoints;\n  };\n\n  AxisRender.prototype.calculateHMajorArcStartEndPoints = function (value) {\n    var arcHPoints = [];\n    var calValue1;\n    var calValue2;\n\n    if (value <= 0.3) {\n      calValue1 = 2.0;\n      calValue2 = -2.0;\n    } else if (value <= 1.0) {\n      calValue1 = 3.0;\n      calValue2 = -3.0;\n    } else if (value <= 2.0) {\n      calValue1 = 5.0;\n      calValue2 = -5.0;\n    } else if (value <= 5.0) {\n      calValue1 = 10.0;\n      calValue2 = -10.0;\n    } else {\n      calValue1 = 50.0;\n      calValue2 = -50.0;\n    }\n\n    arcHPoints[0] = this.radialLabelCollections.filter(function (c) {\n      return c.value === calValue1;\n    });\n    arcHPoints[1] = this.radialLabelCollections.filter(function (c) {\n      return c.value === calValue2;\n    });\n    return arcHPoints;\n  };\n\n  AxisRender.prototype.calculateMinorArcStartEndPoints = function (value) {\n    var calValue1;\n    var calValue2;\n    var marcHPoints = [];\n\n    if (value <= 0.1) {\n      calValue1 = 1.0;\n      calValue2 = -1.0;\n    } else if (value <= 0.2) {\n      calValue1 = 0.8;\n      calValue2 = -0.8;\n    } else if (value <= 0.3) {\n      calValue1 = 0.4;\n      calValue2 = -0.4;\n    } else if (value <= 0.6) {\n      calValue1 = 1.0;\n      calValue2 = -1.0;\n    } else if (value <= 1.0) {\n      calValue1 = 1.5;\n      calValue2 = -1.5;\n    } else if (value <= 1.5) {\n      calValue1 = 2.0;\n      calValue2 = -2.0;\n    } else if (value <= 2.0) {\n      calValue1 = 1.0;\n      calValue2 = -1.0;\n    } else if (value <= 5.0) {\n      calValue1 = 3.0;\n      calValue2 = -3.0;\n    } else {\n      calValue1 = 10.0;\n      calValue2 = -10.0;\n    }\n\n    marcHPoints[0] = this.radialLabelCollections.filter(function (c) {\n      return c['value'] === calValue1;\n    });\n    marcHPoints[1] = this.radialLabelCollections.filter(function (c) {\n      return c['value'] === calValue2;\n    });\n    return marcHPoints;\n  };\n\n  AxisRender.prototype.intersectingCirclePoints = function (x1, y1, r1, x2, y2, r2, renderType) {\n    var cx;\n    var cy;\n    var midRadius;\n    var radiusSquare;\n    var a;\n    var radiusSquare2;\n    var c;\n    var fx;\n    var gx;\n    var ix1;\n    var ix2;\n    var fy;\n    var gy;\n    var iy1;\n    var iy2;\n    var point = {\n      x: 0,\n      y: 0\n    };\n    cx = x1 - x2;\n    cy = y1 - y2;\n    midRadius = Math.sqrt(cx * cx + cy * cy);\n    radiusSquare = midRadius * midRadius;\n    a = (r1 * r1 - r2 * r2) / (2 * radiusSquare);\n    radiusSquare2 = r1 * r1 - r2 * r2;\n    c = Math.sqrt(2 * (r1 * r1 + r2 * r2) / radiusSquare - radiusSquare2 * radiusSquare2 / (radiusSquare * radiusSquare) - 1);\n    fx = (x1 + x2) / 2 + a * (x2 - x1);\n    gx = c * (y2 - y1) / 2;\n    ix1 = fx + gx;\n    ix2 = fx - gx;\n    fy = (y1 + y2) / 2 + a * (y2 - y1);\n    gy = c * (x1 - x2) / 2;\n    iy1 = fy + gy;\n    iy2 = fy - gy;\n\n    if (renderType === 'Impedance') {\n      if (ix2 < ix1) {\n        point.x = ix2;\n        point.y = iy2;\n      } else {\n        point.x = ix1;\n        point.y = iy1;\n      }\n    } else {\n      if (ix1 > ix2) {\n        point.x = ix1;\n        point.y = iy1;\n      } else {\n        point.x = ix2;\n        point.y = iy2;\n      }\n    }\n\n    return {\n      x: point.x,\n      y: point.y\n    };\n  };\n\n  AxisRender.prototype.updateHMajorGridLines = function (smithchart) {\n    var majorGridLine = smithchart.horizontalAxis.majorGridLines;\n    var groupElement;\n    var element;\n    var path;\n    groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_horizontalAxisMajorGridLines'\n    });\n    path = this.calculateGridLinesPath(this.majorHGridArcPoints);\n    var haxismgoptions = new PathOption(smithchart.element.id + '_horizontalAxisMajorGridLines', 'none', majorGridLine['width'], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine['opacity'], majorGridLine['dashArray'], path);\n    element = smithchart.renderer.drawPath(haxismgoptions);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.updateRMajorGridLines = function (smithchart) {\n    var majorGridLine = smithchart.radialAxis.majorGridLines;\n    var groupElement;\n    var element;\n    var path;\n    groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_radialAxisMajorGridLines'\n    });\n    path = this.calculateGridLinesPath(this.majorRGridArcPoints);\n    var raxismgoptions = new PathOption(smithchart.element.id + '_radialAxisMajorGridLines', 'none', majorGridLine['width'], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine['opacity'], majorGridLine['dashArray'], path);\n    element = smithchart.renderer.drawPath(raxismgoptions);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.updateHAxisLine = function (smithchart) {\n    var radius = this.areaRadius;\n    var point1;\n    var point2;\n    var size;\n    var sweep;\n    var isLargeArc;\n    var angle;\n    var axisLine = smithchart.horizontalAxis.axisLine;\n    var direction;\n    var groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_hAxisLine'\n    });\n    point1 = {\n      x: this.circleCenterX + radius,\n      y: this.circleCenterY\n    };\n    point2 = {\n      x: this.circleCenterX + radius,\n      y: this.circleCenterY - 0.05\n    };\n    size = {\n      width: radius,\n      height: radius\n    };\n    sweep = this.direction['clockwise'];\n    isLargeArc = 1;\n    angle = Math.PI * 2;\n    direction = 'M' + '' + point1.x + ' ' + point1.y + ' ' + 'A' + ' ' + size.width + ' ' + size.height + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' + point2.x + ' ' + point2.y + '';\n    var options = new PathOption(smithchart.element.id + '_horizontalAxisLine', 'none', axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);\n    var element = smithchart.renderer.drawPath(options);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.updateRAxisLine = function (smithchart) {\n    var radius = this.areaRadius;\n    var point1;\n    var point2;\n    var size;\n    var sweep;\n    var isLargeArc;\n    var angle;\n    var axisLine = smithchart.radialAxis.axisLine;\n    var direction;\n    point1 = {\n      x: this.circleCenterX - radius,\n      y: this.circleCenterY\n    };\n    point2 = {\n      x: this.circleCenterX + radius,\n      y: this.circleCenterY\n    };\n    size = {\n      width: 0,\n      height: 0\n    };\n    sweep = this.direction['counterclockwise'];\n    isLargeArc = 0;\n    angle = 0;\n    direction = 'M' + ' ' + point1.x + ' ' + point1.y + ' ' + 'A' + ' ' + size.width + ' ' + size.height + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' + point2.x + ' ' + point2.y + '';\n    var options = new PathOption(smithchart.element.id + '_radialAxisLine', 'none', axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);\n    var groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_rAxisLine'\n    });\n    var element = smithchart.renderer.drawPath(options);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.drawHAxisLabels = function (smithchart) {\n    var hAxis = smithchart.horizontalAxis;\n    smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;\n    var font = smithchart.horizontalAxis.labelStyle;\n    var circleAxis;\n    var label;\n    var x;\n    var y;\n    var textSize;\n    var curLabel;\n    var curLabelBounds;\n    var curWidth;\n    var curX;\n    var preLabel;\n    var preLabelBounds;\n    var preWidth;\n    var preX;\n    var groupEle = smithchart.renderer.createGroup({\n      id: smithchart.element.id + '_HAxisLabels'\n    });\n\n    for (var i = 0; i < this.horizontalLabelCollections.length; i++) {\n      circleAxis = this.horizontalLabelCollections[i];\n      label = this.horizontalLabelCollections[i].value.toString();\n\n      if (circleAxis.value !== 0.0) {\n        x = smithchart.renderType === 'Impedance' ? circleAxis.centerX - circleAxis.radius : circleAxis.centerX + circleAxis.radius;\n        y = circleAxis.centerY;\n        textSize = measureText(label, font);\n        x = smithchart.renderType === 'Impedance' ? x - textSize.width : x;\n\n        if (hAxis.labelPosition === 'Outside') {\n          y -= textSize.height / 4;\n        } else {\n          y += textSize.height;\n        }\n\n        this.horizontalLabelCollections[i].region = this.calculateRegion(label, textSize, x, y);\n\n        if (hAxis.labelIntersectAction === 'Hide') {\n          curLabel = this.horizontalLabelCollections[i];\n          curLabelBounds = curLabel.region.bounds;\n          curWidth = curLabelBounds.width;\n          curX = curLabelBounds.x;\n\n          for (var j = 1; j < i; j++) {\n            preLabel = this.horizontalLabelCollections[j];\n            preLabelBounds = preLabel.region.bounds;\n            preWidth = preLabelBounds.width;\n            preX = preLabelBounds.x;\n\n            if (smithchart.renderType === 'Impedance' && preX + preWidth > curX) {\n              label = '';\n            }\n\n            if (smithchart.renderType === 'Admittance' && preX < curX + curWidth) {\n              label = '';\n            }\n          }\n        }\n\n        var axisLabelRenderEventArgs = {\n          text: label.toString(),\n          x: x,\n          y: y,\n          name: 'axisLabelRender',\n          cancel: false\n        };\n        smithchart.trigger('axisLabelRender', axisLabelRenderEventArgs);\n        var options = new TextOption(smithchart.element.id + '_HLabel_' + i, axisLabelRenderEventArgs.x, axisLabelRenderEventArgs.y, 'none', axisLabelRenderEventArgs.text);\n        var color = font.color ? font.color : smithchart.themeStyle.axisLabel;\n        font.fontFamily = font.fontFamily || smithchart.themeStyle.labelFontFamily;\n        var element = renderTextElement(options, font, color, groupEle);\n        groupEle.appendChild(element);\n      }\n    }\n\n    smithchart.svgObject.appendChild(groupEle);\n  };\n\n  AxisRender.prototype.drawRAxisLabels = function (smithchart) {\n    var paddingRadius = 2;\n    smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;\n    var font = smithchart.radialAxis.labelStyle;\n    var interSectPoint = new RadialLabelCollections();\n    var label;\n    var textSize;\n    var angle;\n    var position;\n    var textPosition;\n    var curX;\n    var curY;\n    var curWidth;\n    var curHeight;\n    var curLabel;\n    var curLabelBounds;\n    var preX;\n    var preY;\n    var preWidth;\n    var preHeight;\n    var preLabel;\n    var preLabelBounds;\n    var rAxis = smithchart.radialAxis;\n    var groupEle = smithchart.renderer.createGroup({\n      id: smithchart.element.id + '_RAxisLabels'\n    });\n\n    for (var i = 0; i < this.labelCollections.length; i++) {\n      interSectPoint = this.labelCollections[i];\n      label = interSectPoint.value.toString();\n      textSize = measureText(label, font);\n      angle = Math.round(interSectPoint.angle * 100) / 100;\n\n      if (rAxis.labelPosition === 'Outside') {\n        position = this.circlePointPosition(this.circleCenterX, this.circleCenterY, interSectPoint['angle'], this.areaRadius + paddingRadius);\n        textPosition = this.setLabelsOutsidePosition(angle, position.x, position.y, textSize);\n      } else {\n        position = this.circlePointPosition(this.circleCenterX, this.circleCenterY, interSectPoint['angle'], this.areaRadius - paddingRadius);\n        textPosition = this.setLabelsInsidePosition(angle, position.x, position.y, textSize);\n      }\n\n      this.labelCollections[i]['region'] = this.calculateRegion(label, textSize, textPosition.x, textPosition.y);\n\n      if (rAxis.labelIntersectAction === 'Hide') {\n        curLabel = this.labelCollections[i];\n        curLabelBounds = curLabel['region']['bounds'];\n        curWidth = curLabelBounds['width'];\n        curHeight = curLabelBounds['height'];\n        curX = curLabelBounds['x'];\n        curY = curLabelBounds['y'];\n\n        for (var j = 0; j < i; j++) {\n          preLabel = this.labelCollections[j];\n          preLabelBounds = preLabel['region']['bounds'];\n          preWidth = preLabelBounds['width'];\n          preHeight = preLabelBounds['height'];\n          preX = preLabelBounds['x'];\n          preY = preLabelBounds['y'];\n\n          if (preX <= curX + curWidth && curX <= preX + preWidth && preY <= curY + curHeight && curY <= preY + preHeight) {\n            label = ' ';\n          }\n        }\n      }\n\n      var axisLabelRenderEventArgs = {\n        text: label.toString(),\n        x: textPosition.x,\n        y: textPosition.y,\n        name: 'axisLabelRender',\n        cancel: false\n      };\n      smithchart.trigger('axisLabelRender', axisLabelRenderEventArgs);\n      var options = new TextOption(smithchart.element.id + '_RLabel_' + i, axisLabelRenderEventArgs.x, axisLabelRenderEventArgs.y, 'none', axisLabelRenderEventArgs.text);\n      var color = font.color ? font.color : smithchart.themeStyle.axisLabel;\n      font.fontFamily = smithchart.themeStyle.labelFontFamily ? smithchart.themeStyle.labelFontFamily : font.fontFamily;\n      var element = renderTextElement(options, font, color, groupEle);\n      groupEle.appendChild(element);\n    }\n\n    smithchart.svgObject.appendChild(groupEle);\n  };\n\n  AxisRender.prototype.calculateRegion = function (label, textSize, textPositionX, textPositionY) {\n    var xAxisLabelRegions = new LabelRegion();\n    var bounds = {\n      x: textPositionX,\n      y: textPositionY,\n      width: textSize.width,\n      height: textSize.height\n    };\n    xAxisLabelRegions = {\n      bounds: bounds,\n      labelText: label\n    };\n    return xAxisLabelRegions;\n  };\n\n  AxisRender.prototype.updateHMinorGridLines = function (smithchart) {\n    var minorGridLine = smithchart.horizontalAxis.minorGridLines;\n    var groupElement;\n    var element;\n    var path;\n    groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_horizontalAxisMinorGridLines'\n    });\n    path = this.calculateGridLinesPath(this.minorHGridArcPoints);\n    var haxismioptions = new PathOption(smithchart.element.id + '_horizontalAxisMinorGridLines', 'none', minorGridLine['width'], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine['opacity'], minorGridLine['dashArray'], path);\n    element = smithchart.renderer.drawPath(haxismioptions);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.updateRMinorGridLines = function (smithchart) {\n    var minorGridLine = smithchart.radialAxis.minorGridLines;\n    var groupElement;\n    var element;\n    var path;\n    groupElement = smithchart.renderer.createGroup({\n      'id': smithchart.element.id + '_svg' + '_radialAxisMinorGridLines'\n    });\n    path = this.calculateGridLinesPath(this.minorGridArcPoints);\n    var raxismioptions = new PathOption(smithchart.element.id + '_radialAxisMinorGridLines', 'none', minorGridLine['width'], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine['opacity'], minorGridLine['dashArray'], path);\n    element = smithchart.renderer.drawPath(raxismioptions);\n    groupElement.appendChild(element);\n    smithchart.svgObject.appendChild(groupElement);\n  };\n\n  AxisRender.prototype.calculateGridLinesPath = function (points) {\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    var r1;\n    var r2;\n    var pathSegment = new GridArcPoints();\n    var angle;\n    var isLargeArc;\n    var sweep;\n    var sb = '';\n    var path;\n\n    for (var i = 0; i < points.length; i++) {\n      pathSegment = points[i];\n      x1 = pathSegment.startPoint.x;\n      y1 = pathSegment.startPoint.y;\n      x2 = pathSegment.endPoint.x;\n      y2 = pathSegment.endPoint.y;\n      r1 = pathSegment.size ? pathSegment.size.width : 0;\n      r2 = pathSegment.size ? pathSegment.size.height : 0;\n      angle = pathSegment.rotationAngle ? pathSegment.rotationAngle : 0;\n      isLargeArc = pathSegment.isLargeArc ? 1 : 0;\n      sweep = pathSegment.sweepDirection ? pathSegment.sweepDirection : 0;\n      sb = sb + ('M' + ' ' + x1 + ' ' + y1 + ' ' + 'A' + ' ' + r1 + ' ' + r2 + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' + x2 + ' ' + y2 + ' ');\n    }\n\n    path = sb.toString();\n    return path;\n  };\n\n  AxisRender.prototype.measureHMinorGridLines = function (smithchart) {\n    var radialPoint1;\n    var radialPoint2;\n    var k = 0;\n    var arcPoints = [];\n    var isLargeArc;\n    var startPoint;\n    var endPoint;\n    var size;\n    var cx;\n    var maxCount = smithchart.horizontalAxis.minorGridLines.count;\n    var diameter;\n    var previous;\n    var next;\n    var space;\n    var count;\n    var interval;\n    var radius;\n    var leftX;\n    this.minorHGridArcPoints = [];\n    diameter = this.areaRadius * 2;\n\n    for (var i = 0; i < this.horizontalLabelCollections.length - 3; i++) {\n      previous = this.horizontalLabelCollections[i];\n      next = this.horizontalLabelCollections[i + 1];\n      space = (previous['radius'] - next['radius']) * 2;\n      count = Math.floor(maxCount / 100 * space);\n      interval = space / count;\n\n      for (var j = 0; j < count; j++) {\n        radius = next['radius'] + j * interval / 2;\n        leftX = smithchart.renderType === 'Impedance' ? this.circleLeftX + diameter - radius * 2 : this.circleLeftX;\n        cx = leftX + radius;\n        isLargeArc = next['value'] > 5;\n        arcPoints = this.calculateMinorArcStartEndPoints(next['value']);\n\n        if (smithchart.renderType === 'Impedance') {\n          radialPoint1 = arcPoints[0];\n          radialPoint2 = arcPoints[1];\n        } else {\n          radialPoint1 = arcPoints[1];\n          radialPoint2 = arcPoints[0];\n        }\n\n        startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, cx, previous['centerY'], radius, smithchart.renderType);\n        endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, cx, previous['centerY'], radius, smithchart.renderType);\n        size = {\n          width: radius,\n          height: radius\n        };\n        this.minorHGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          rotationAngle: 2 * Math.PI,\n          sweepDirection: smithchart.renderType === 'Impedance' ? this.direction['counterclockwise'] : this.direction['clockwise'],\n          isLargeArc: isLargeArc,\n          size: size\n        });\n        k++;\n      }\n    }\n  };\n\n  AxisRender.prototype.measureRMinorGridLines = function (smithchart) {\n    var maxCount = smithchart.radialAxis.minorGridLines.count;\n    var arcCx;\n    var nextAngle;\n    var k = 0;\n    var betweenAngle;\n    var circlePoint;\n    var circumference;\n    var arcStartX;\n    var arcStartY;\n    var arcStartPoint;\n    var previous;\n    var next;\n    var size;\n    var distance;\n    var count;\n    var interval;\n    var centerValue;\n    circumference = Math.PI * (this.areaRadius * 2);\n    arcStartX = arcCx = smithchart.renderType === 'Impedance' ? this.circleCenterX + this.areaRadius : this.circleCenterX - this.areaRadius;\n    arcStartY = this.circleCenterY;\n    this.minorGridArcPoints = [];\n    arcStartPoint = {\n      x: arcStartX,\n      y: arcStartY\n    };\n\n    for (var i = 2; i < this.labelCollections.length - 3; i++) {\n      previous = this.labelCollections[i];\n      next = this.labelCollections[i + 1];\n\n      if (smithchart.renderType === 'Impedance') {\n        nextAngle = next['angle'] === 360 ? 0 : next['angle'];\n        betweenAngle = Math.abs(nextAngle - previous['angle']);\n      } else {\n        nextAngle = previous['angle'] === 360 ? 0 : previous['angle'];\n        betweenAngle = Math.abs(nextAngle - next['angle']);\n      }\n\n      distance = circumference / 360 * betweenAngle;\n      count = Math.floor(maxCount / 100 * distance);\n      interval = betweenAngle / count;\n      centerValue = next['value'] > 0 ? next['value'] : previous['value'];\n      circlePoint = this.minorGridLineArcIntersectCircle(Math.abs(centerValue));\n\n      for (var j = 1; j < count; j++) {\n        var outterInterSectAngle = interval * j + (previous['angle'] === 360 ? nextAngle : previous['angle']);\n        var outerInterSectPoint = this.circlePointPosition(this.circleCenterX, this.circleCenterY, outterInterSectAngle, this.areaRadius);\n        var radius = this.arcRadius(arcStartPoint, outerInterSectPoint, outterInterSectAngle);\n        var arcCy = outterInterSectAngle > 180 ? this.circleCenterY - radius : this.circleCenterY + radius;\n        var innerInterSectPoint = this.intersectingCirclePoints(arcCx, arcCy, radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);\n        var startPoint = {\n          x: innerInterSectPoint.x,\n          y: innerInterSectPoint.y\n        };\n        var endPoint = {\n          x: outerInterSectPoint.x,\n          y: outerInterSectPoint.y\n        };\n        size = {\n          width: radius,\n          height: radius\n        };\n        var sweepDirection = previous['value'] >= 0 ? this.direction['clockwise'] : this.direction['counterclockwise'];\n        this.minorGridArcPoints.push({\n          startPoint: startPoint,\n          endPoint: endPoint,\n          rotationAngle: 2 * Math.PI,\n          sweepDirection: sweepDirection,\n          isLargeArc: false,\n          size: size\n        });\n        k++;\n      }\n    }\n  };\n\n  AxisRender.prototype.minorGridLineArcIntersectCircle = function (centerValue) {\n    var circlePoint;\n    var calValue;\n\n    if (centerValue >= 3) {\n      calValue = 20;\n    } else if (centerValue >= 1.5) {\n      calValue = 10;\n    } else if (centerValue >= 0.6) {\n      calValue = 3;\n    } else {\n      calValue = 2;\n    }\n\n    circlePoint = this.horizontalLabelCollections.filter(function (c) {\n      return c['value'] === calValue;\n    });\n    return circlePoint;\n  };\n\n  AxisRender.prototype.circlePointPosition = function (cx, cy, angle, r) {\n    var pointX;\n    var pointY;\n    var radian;\n    radian = angle * (Math.PI / 180);\n    pointX = cx + r * Math.cos(radian);\n    pointY = cy + r * Math.sin(radian);\n    return {\n      x: pointX,\n      y: pointY\n    };\n  };\n\n  AxisRender.prototype.setLabelsInsidePosition = function (angle, px, py, textSize) {\n    var x = px;\n    var y = py;\n\n    if (angle === 0 || angle === 360) {\n      x -= textSize.width;\n      y -= textSize.height / 2;\n    } else if (angle === 90) {\n      x -= textSize.width;\n      y += textSize.height / 8;\n    } else if (angle === 180) {\n      y += textSize.height;\n    } else if (angle === 270) {\n      y += textSize.height / 2;\n    } else if (angle > 0 && angle <= 20) {\n      x -= textSize.width;\n    } else if (angle > 20 && angle <= 60) {\n      x -= textSize.width + textSize.width / 2;\n      y += textSize.height / 2;\n    } else if (angle > 60 && angle < 90) {\n      x -= textSize.width + textSize.width / 4;\n      y += textSize.height / 4;\n    } else if (angle > 90 && angle <= 135) {\n      x -= textSize.width / 2;\n      y += textSize.height / 16;\n    } else if (angle > 135 && angle <= 150) {\n      x += textSize.width / 2;\n      y += textSize.height / 2;\n    } else if (angle > 150 && angle < 180) {\n      x += textSize.width / 2;\n      y += textSize.height;\n    } else if (angle > 180 && angle <= 210) {\n      x += textSize.width / 6;\n      y += textSize.height / 6;\n    } else if (angle > 210 && angle < 240) {\n      y += textSize.height / 4;\n    } else if (angle > 225 && angle < 270) {\n      y += textSize.height / 3;\n    } else if (angle > 270 && angle <= 300) {\n      x -= textSize.width + textSize.width / 4;\n      y += textSize.height / 4;\n    } else if (angle > 300 && angle <= 330) {\n      x -= textSize.width + textSize.width / 3;\n      y += textSize.height / 4;\n    } else if (angle > 330 && angle <= 340) {\n      x -= textSize.width + textSize.width / 2;\n      y += textSize.height / 4;\n    } else if (angle > 340) {\n      x -= textSize.width;\n      y += textSize.height / 8;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  AxisRender.prototype.setLabelsOutsidePosition = function (angle, px, py, textSize) {\n    var x = px;\n    var y = py;\n\n    if (angle === 90) {\n      x -= textSize.width / 2;\n      y += textSize.height;\n    } else if (angle === 180) {\n      x -= textSize.width + 5;\n      y -= textSize.height / 4;\n    } else if (angle === 270) {\n      x -= textSize.width / 2;\n      y -= textSize.height / 4;\n    } else if (angle === 360) {\n      x += 5;\n      y -= textSize.height / 2;\n    } else if (angle > 0 && angle <= 30) {\n      x += textSize.width / 4;\n      y += textSize.height / 8;\n    } else if (angle > 30 && angle <= 60) {\n      x += textSize.width / 2;\n      y += textSize.height / 4;\n    } else if (angle > 60 && angle <= 90) {\n      x -= textSize.width / 2;\n      y += textSize.height;\n    } else if (angle > 90 && angle <= 135) {\n      x -= textSize.width;\n      y += textSize.height;\n    } else if (angle > 135 && angle <= 180) {\n      x -= textSize.width + textSize.width / 4;\n      y += textSize.height / 4;\n    } else if (angle > 180 && angle <= 210) {\n      x -= textSize.width + textSize.width / 4;\n      y -= textSize.height / 4;\n    } else if (angle > 210 && angle <= 270) {\n      x -= textSize.width;\n      y -= textSize.height / 4;\n    } else if (angle > 270 && angle <= 340) {\n      y -= textSize.height / 4;\n    } else if (angle > 340) {\n      y += textSize.height / 4;\n      x += textSize.width / 6;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  AxisRender.prototype.arcRadius = function (startPoint, endPoint, angle) {\n    var mx;\n    var my;\n    var u;\n    var t;\n    var cy;\n    var radius;\n    var radian;\n    radian = angle > 180 ? 90 * Math.PI / 180 : 270 * Math.PI / 180; // Angle 90 and 270 used for calculating upper and lower circle\n\n    mx = (endPoint.x - startPoint.x) / 2;\n    my = (endPoint.y - startPoint.y) / 2;\n    u = (Math.cos(radian) * my - Math.sin(radian) * mx) / (Math.cos(radian) * mx + Math.sin(radian) * my);\n    t = (my - mx * u) / Math.sin(radian);\n    cy = startPoint.y + Math.sin(radian) * t;\n    radius = Math.abs(startPoint.y - cy);\n    return radius;\n  };\n\n  return AxisRender;\n}();\n\nexport { AxisRender };","map":null,"metadata":{},"sourceType":"module"}