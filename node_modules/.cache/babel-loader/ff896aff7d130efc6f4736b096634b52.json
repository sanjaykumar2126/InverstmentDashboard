{"ast":null,"code":"/**\n * Defines the behavior of a funnel series\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { appendChildElement, removeElement } from '../../common/utils/helper';\nimport { TriangularBase } from './triangular-base';\n/**\n * FunnelSeries module used to render `Funnel` Series.\n */\n\nvar FunnelSeries =\n/** @class */\nfunction (_super) {\n  __extends(FunnelSeries, _super);\n\n  function FunnelSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Defines the path of a funnel segment\n   */\n\n\n  FunnelSeries.prototype.getSegmentData = function (point, series, chart) {\n    var lineWidth;\n    var topRadius;\n    var bottomRadius;\n    var endTop;\n    var endBottom;\n    var minRadius;\n    var endMin;\n    var bottomY;\n    var area = series.triangleSize;\n    var offset = 0;\n    var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;\n    var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x;\n    var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2; //defines the top and bottom of a segment\n\n    var top = point.yRatio * area.height;\n    var bottom = top + point.heightRatio * area.height;\n    var neckSize = series.neckSize;\n    lineWidth = neckSize.width + (area.width - neckSize.width) * ((area.height - neckSize.height - top) / (area.height - neckSize.height));\n    topRadius = area.width / 2 - lineWidth / 2; //Calculating the middle slope change and bottom\n\n    endTop = topRadius + lineWidth;\n\n    if (bottom > area.height - neckSize.height || area.height === neckSize.height) {\n      lineWidth = neckSize.width;\n    } else {\n      lineWidth = neckSize.width + (area.width - neckSize.width) * ((area.height - neckSize.height - bottom) / (area.height - neckSize.height));\n    }\n\n    bottomRadius = area.width / 2 - lineWidth / 2;\n    endBottom = bottomRadius + lineWidth;\n\n    if (top >= area.height - neckSize.height) {\n      topRadius = bottomRadius = minRadius = area.width / 2 - neckSize.width / 2;\n      endTop = endBottom = endMin = area.width / 2 + neckSize.width / 2;\n    } else if (bottom > area.height - neckSize.height) {\n      minRadius = bottomRadius = area.width / 2 - lineWidth / 2;\n      endMin = endBottom = minRadius + lineWidth;\n      bottomY = area.height - neckSize.height;\n    }\n\n    top += seriesTop;\n    bottom += seriesTop;\n    bottomY += seriesTop;\n    var line1 = {\n      x: emptySpaceAtLeft + offset + topRadius,\n      y: top\n    };\n    var line2 = {\n      x: emptySpaceAtLeft + offset + endTop,\n      y: top\n    };\n    var line4 = {\n      x: emptySpaceAtLeft + offset + endBottom,\n      y: bottom\n    };\n    var line5 = {\n      x: emptySpaceAtLeft + offset + bottomRadius,\n      y: bottom\n    };\n    var line3 = {\n      x: emptySpaceAtLeft + offset + endBottom,\n      y: bottom\n    };\n    var line6 = {\n      x: emptySpaceAtLeft + offset + bottomRadius,\n      y: bottom\n    };\n\n    if (bottomY) {\n      line3 = {\n        x: emptySpaceAtLeft + offset + endMin,\n        y: bottomY\n      };\n      line6 = {\n        x: emptySpaceAtLeft + offset + minRadius,\n        y: bottomY\n      };\n    }\n\n    var polygon = [line1, line2, line3, line4, line5, line6];\n    this.setLabelLocation(series, point, polygon);\n    var direction = this.findPath(polygon);\n    return direction;\n  };\n  /**\n   * Renders a funnel segment\n   * @private\n   */\n\n\n  FunnelSeries.prototype.renderPoint = function (point, series, chart, options, seriesGroup, redraw) {\n    if (!point.visible) {\n      removeElement(options.id);\n      return null;\n    }\n\n    var direction = this.getSegmentData(point, series, chart);\n    point.midAngle = 0;\n    options.d = direction;\n    appendChildElement(false, seriesGroup, chart.renderer.drawPath(options), redraw);\n\n    if (point.isExplode) {\n      chart.accBaseModule.explodePoints(point.index, chart, true);\n    }\n  };\n  /**\n   * To get the module name of the funnel series.\n   */\n\n\n  FunnelSeries.prototype.getModuleName = function () {\n    return 'FunnelSeries';\n  };\n  /**\n   * To destroy the funnel series.\n   * @return {void}\n   * @private\n   */\n\n\n  FunnelSeries.prototype.destroy = function (accumulation) {\n    /**\n     * Destroys the funnel series\n     */\n  };\n\n  return FunnelSeries;\n}(TriangularBase);\n\nexport { FunnelSeries };","map":null,"metadata":{},"sourceType":"module"}