{"ast":null,"code":"import { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { textWrap, appendClipElement, appendChildElement } from '../../common/utils/helper';\nimport { valueToCoefficient, textTrim, textElement } from '../../common/utils/helper';\nimport { measureText, TextOption, PathOption } from '@syncfusion/ej2-svg-base';\nimport { axisMultiLabelRender, multiLevelLabelClick } from '../../common/model/constants';\n/**\n * `MultiLevelLabel` module is used to render the multi level label in chart.\n */\n\nvar MultiLevelLabel =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the logerithmic module.\n   * @private\n   */\n  function MultiLevelLabel(chart) {\n    /** @private */\n    this.xAxisPrevHeight = [];\n    /** @private */\n\n    this.xAxisMultiLabelHeight = [];\n    /** @private */\n\n    this.yAxisPrevHeight = [];\n    /** @private */\n\n    this.yAxisMultiLabelHeight = [];\n    this.chart = chart;\n    this.addEventListener();\n  }\n  /**\n   * Binding events for multi level module.\n   */\n\n\n  MultiLevelLabel.prototype.addEventListener = function () {\n    if (this.chart.isDestroyed) {\n      return;\n    }\n\n    this.chart.on('click', this.click, this);\n  };\n  /**\n   * Finds multilevel label height\n   * @return {void}\n   */\n\n\n  MultiLevelLabel.prototype.getMultilevelLabelsHeight = function (axis) {\n    var value = 0;\n    var multiLevelLabelsHeight = [];\n    var prevHeight = [];\n    var isVertical = axis.orientation === 'Vertical';\n    var axisValue = isVertical ? axis.rect.height : axis.rect.width;\n    var labelSize;\n    var height;\n    var padding = 10;\n    var gap;\n    axis.multiLevelLabels.map(function (multiLevel, index) {\n      multiLevel.categories.map(function (categoryLabel) {\n        if (categoryLabel.text !== '' && categoryLabel.start !== null && categoryLabel.end !== null) {\n          labelSize = measureText(categoryLabel.text, multiLevel.textStyle);\n          height = isVertical ? labelSize.width : labelSize.height;\n          height += 2 * multiLevel.border.width + (multiLevel.border.type === 'CurlyBrace' ? padding : 0);\n          gap = categoryLabel.maximumTextWidth !== null ? categoryLabel.maximumTextWidth : valueToCoefficient(typeof categoryLabel.end === 'string' ? Number(new Date(categoryLabel.end)) : categoryLabel.end, axis) * axisValue - valueToCoefficient(typeof categoryLabel.start === 'string' ? Number(new Date(categoryLabel.start)) : categoryLabel.start, axis) * axisValue;\n\n          if (labelSize.width > gap - padding && gap > 0 && multiLevel.overflow === 'Wrap' && !isVertical) {\n            height = height * textWrap(categoryLabel.text, gap - padding, multiLevel.textStyle).length;\n          }\n\n          multiLevelLabelsHeight[index] = !multiLevelLabelsHeight[index] ? height : multiLevelLabelsHeight[index] < height ? height : multiLevelLabelsHeight[index];\n        }\n      });\n      prevHeight[index] = value;\n      value += multiLevelLabelsHeight[index] ? multiLevelLabelsHeight[index] + padding : 0;\n    });\n    axis.multiLevelLabelHeight = value + (axis.title !== '' || this.chart.legendModule && this.chart.legendSettings.visible ? padding / 2 : 0);\n\n    if (isVertical) {\n      this.yAxisMultiLabelHeight = multiLevelLabelsHeight;\n      this.yAxisPrevHeight = prevHeight;\n    } else {\n      this.xAxisMultiLabelHeight = multiLevelLabelsHeight;\n      this.xAxisPrevHeight = prevHeight;\n    }\n  };\n  /**\n   * render x axis multi level labels\n   * @private\n   * @return {void}\n   */\n\n\n  MultiLevelLabel.prototype.renderXAxisMultiLevelLabels = function (axis, index, parent, axisRect) {\n    var _this = this;\n\n    var x;\n    var y;\n    var padding = 10;\n    var startX;\n    var pointIndex;\n    var startY = (axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0) + axis.maxLabelSize.height + padding;\n    var endX;\n    var endY;\n    var pathRect = '';\n    var start;\n    var end;\n    var labelSize;\n    var clipY;\n    var isOutside = axis.labelPosition === 'Outside';\n    var gap;\n    var anchor;\n    var isInversed = axis.isInversed;\n    var argsData;\n    var opposedPosition = axis.opposedPosition;\n    var scrollBarHeight = axis.scrollbarSettings.enable || isOutside && isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;\n    clipY = opposedPosition && !isOutside || !opposedPosition && isOutside ? axisRect.y + startY - axis.majorTickLines.width : axisRect.y - startY - axis.multiLevelLabelHeight;\n    this.createClipRect(axisRect.x - axis.majorTickLines.width, clipY + scrollBarHeight, axis.multiLevelLabelHeight + padding, axisRect.width + 2 * axis.majorTickLines.width, this.chart.element.id + '_XAxis_Clippath_' + index, this.chart.element.id + 'XAxisMultiLevelLabel' + index);\n    axis.multiLevelLabels.map(function (multiLevel, level) {\n      pointIndex = 0;\n      _this.labelElement = _this.chart.renderer.createGroup({\n        id: _this.chart.element.id + index + '_MultiLevelLabel' + level\n      });\n      multiLevel.categories.map(function (categoryLabel, i) {\n        pathRect = '';\n        start = typeof categoryLabel.start === 'string' ? Number(new Date(categoryLabel.start)) : categoryLabel.start;\n        end = typeof categoryLabel.end === 'string' ? Number(new Date(categoryLabel.end)) : categoryLabel.end;\n        argsData = _this.triggerMultiLabelRender(axis, categoryLabel.text, axis.multiLevelLabels[level].textStyle, axis.multiLevelLabels[level].alignment, categoryLabel.customAttributes);\n\n        if (!argsData.cancel) {\n          startX = valueToCoefficient(start, axis) * axisRect.width;\n          endX = valueToCoefficient(end, axis) * axisRect.width;\n          endX = isInversed ? [startX, startX = endX][0] : endX;\n          labelSize = measureText(argsData.text, argsData.textStyle);\n          gap = (categoryLabel.maximumTextWidth === null ? endX - startX : categoryLabel.maximumTextWidth) - padding;\n          x = startX + axisRect.x + padding;\n          y = (opposedPosition && !isOutside || !opposedPosition && isOutside ? startY + axisRect.y + labelSize.height / 2 + padding + _this.xAxisPrevHeight[level] : axisRect.y - startY + labelSize.height / 2 - _this.xAxisMultiLabelHeight[level] - _this.xAxisPrevHeight[level]) + scrollBarHeight;\n\n          if (argsData.alignment === 'Center') {\n            x += (endX - startX - padding) / 2;\n            anchor = 'middle';\n          } else if (argsData.alignment === 'Far') {\n            x = x + (endX - startX - padding) - multiLevel.border.width / 2;\n            anchor = 'end';\n          } else {\n            anchor = 'start';\n            x += multiLevel.border.width / 2;\n          }\n\n          y = multiLevel.border.type === 'CurlyBrace' ? !opposedPosition && isOutside || opposedPosition && !isOutside ? y + padding : y - padding / 2 : y;\n          var options = new TextOption(_this.chart.element.id + index + '_Axis_MultiLevelLabel_Level_' + level + '_Text_' + i, x, y, anchor, argsData.text);\n\n          if (multiLevel.overflow !== 'None') {\n            options.text = multiLevel.overflow === 'Wrap' ? textWrap(argsData.text, gap, argsData.textStyle) : textTrim(gap, argsData.text, argsData.textStyle);\n            options.x = options.x - padding / 2;\n          }\n\n          textElement(_this.chart.renderer, options, argsData.textStyle, argsData.textStyle.color || _this.chart.themeStyle.axisLabel, _this.labelElement, false, _this.chart.redraw, true);\n\n          if (multiLevel.border.width > 0 && multiLevel.border.type !== 'WithoutBorder') {\n            pathRect = _this.renderXAxisLabelBorder(level, endX - startX - padding, axis, startX, startY, labelSize, options, axisRect, argsData.alignment, pathRect, isOutside, opposedPosition, pointIndex); // fix for generating seperate rect \n\n            if (pathRect !== '') {\n              _this.createBorderElement(level, index, axis, pathRect, pointIndex);\n\n              pointIndex++;\n            }\n          }\n\n          _this.multiElements.appendChild(_this.labelElement);\n        }\n      });\n    });\n    parent.appendChild(this.multiElements);\n  };\n  /**\n   * render x axis multi level labels border\n   * @private\n   * @return {void}\n   */\n\n\n  MultiLevelLabel.prototype.renderXAxisLabelBorder = function (labelIndex, gap, axis, startX, startY, labelSize, textOptions, axisRect, alignment, path, isOutside, opposedPosition, categoryIndex) {\n    var padding = 10;\n    var padding1;\n    var padding2;\n    var value;\n    var value1;\n    var groupLabel = axis.multiLevelLabels[labelIndex];\n    var categoryType = groupLabel.categories[categoryIndex].type;\n    var width = gap + padding;\n    var height = this.xAxisMultiLabelHeight[labelIndex] + padding;\n    var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\n    var x = startX + axisRect.x;\n    var y = !opposedPosition && isOutside || opposedPosition && !isOutside ? startY + axisRect.y + this.xAxisPrevHeight[labelIndex] + scrollBarHeight : axisRect.y - startY - this.xAxisPrevHeight[labelIndex] - scrollBarHeight;\n    var borderType = categoryType ? categoryType : groupLabel.border.type;\n\n    switch (borderType) {\n      case 'WithoutTopandBottomBorder':\n      case 'Rectangle':\n      case 'WithoutTopBorder':\n        height = !opposedPosition && isOutside || opposedPosition && !isOutside ? height : -height;\n        path += 'M ' + x + ' ' + y + ' L ' + x + ' ' + (y + height) + ' M ' + (x + width) + ' ' + y + ' L ' + (x + width) + ' ' + (y + height);\n        path += borderType !== 'WithoutTopandBottomBorder' ? ' L' + ' ' + x + ' ' + (y + height) + ' ' : ' ';\n        path += borderType === 'Rectangle' ? ' M ' + x + ' ' + y + ' L ' + (x + width) + ' ' + y : ' ';\n        break;\n\n      case 'Brace':\n        if (alignment === 'Near') {\n          value = textOptions.x;\n          value1 = textOptions.x + labelSize.width + 2;\n        } else if (alignment === 'Center') {\n          value = textOptions.x - labelSize.width / 2 - 2;\n          value1 = textOptions.x + labelSize.width / 2 + 2;\n        } else {\n          value = textOptions.x - labelSize.width - 2;\n          value1 = textOptions.x;\n        }\n\n        height = !opposedPosition && isOutside || opposedPosition && !isOutside ? height : -height;\n        path += 'M ' + x + ' ' + y + ' L ' + x + ' ' + (y + height / 2) + ' M ' + x + ' ' + (y + height / 2) + ' L ' + (value - 2) + ' ' + (y + height / 2) + ' M ' + value1 + ' ' + (y + height / 2) + ' L ' + (x + width) + ' ' + (y + height / 2) + ' M ' + (x + width) + ' ' + (y + height / 2) + ' L ' + (x + width) + ' ' + y;\n        break;\n\n      case 'CurlyBrace':\n        if (!opposedPosition && isOutside || opposedPosition && !isOutside) {\n          padding = 10;\n          padding1 = 15;\n          padding2 = 5;\n        } else {\n          padding = -10;\n          padding1 = -15;\n          padding2 = -5;\n        }\n\n        if (alignment === 'Center') {\n          path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + 5) + ' ' + (y + padding) + ' ' + (x + 10) + ' ' + (y + padding) + ' L ' + (x + width / 2 - 5) + ' ' + (y + padding) + ' L ' + (x + width / 2) + ' ' + (y + padding1) + ' L ' + (x + width / 2 + 5) + ' ' + (y + padding) + ' L ' + (x + width - 10) + ' ' + (y + padding) + ' C ' + (x + width - 10) + ' ' + (y + padding) + ' ' + (x + width) + ' ' + (y + padding2) + ' ' + (x + width) + ' ' + y;\n        } else if (alignment === 'Near') {\n          path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + 5) + ' ' + (y + padding) + ' ' + (x + 10) + ' ' + (y + padding) + ' L ' + (x + 15) + ' ' + (y + padding1) + ' L ' + (x + 20) + ' ' + (y + padding) + ' L ' + (x + width - 10) + ' ' + (y + padding) + ' C ' + (x + width - 10) + ' ' + (y + padding) + ' ' + (x + width) + ' ' + (y + padding2) + ' ' + (x + width) + ' ' + y;\n        } else {\n          path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + 5) + ' ' + (y + padding) + ' ' + (x + 10) + ' ' + (y + padding) + ' L ' + (x + width - 20) + ' ' + (y + padding) + ' L ' + (x + width - 15) + ' ' + (y + padding1) + ' L ' + (x + width - 10) + ' ' + (y + padding) + ' L ' + (x + width - 10) + ' ' + (y + padding) + ' C ' + (x + width - 10) + ' ' + (y + padding) + ' ' + (x + width) + ' ' + (y + padding2) + ' ' + (x + width) + ' ' + y;\n        }\n\n        break;\n    }\n\n    return path;\n  };\n  /**\n   * render y axis multi level labels\n   * @private\n   * @return {void}\n   */\n\n\n  MultiLevelLabel.prototype.renderYAxisMultiLevelLabels = function (axis, index, parent, rect) {\n    var _this = this;\n\n    var labelSize;\n    var clipX;\n    var isOutside = axis.labelPosition === 'Outside';\n    var x;\n    var y;\n    var padding = 10;\n    var startX = (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0) + axis.maxLabelSize.width + padding;\n    var startY;\n    var path = '';\n    var endY;\n    var argsData;\n    var pointIndex;\n    var isInversed = axis.isInversed;\n    var start;\n    var end;\n    var gap;\n    var anchor = 'middle';\n    var opposedPosition = axis.opposedPosition;\n    var scrollBarHeight = isOutside && isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;\n    scrollBarHeight = scrollBarHeight * (opposedPosition ? 1 : -1);\n    clipX = opposedPosition && !isOutside || !opposedPosition && isOutside ? rect.x - axis.multiLevelLabelHeight - startX - padding : rect.x + startX;\n    this.createClipRect(clipX + scrollBarHeight, rect.y - axis.majorTickLines.width, rect.height + 2 * axis.majorTickLines.width, axis.multiLevelLabelHeight + padding, this.chart.element.id + '_YAxis_Clippath_' + index, this.chart.element.id + 'YAxisMultiLevelLabel' + index);\n    axis.multiLevelLabels.map(function (multiLevel, level) {\n      _this.labelElement = _this.chart.renderer.createGroup({\n        id: _this.chart.element.id + index + '_MultiLevelLabel' + level\n      });\n      pointIndex = 0;\n      multiLevel.categories.map(function (categoryLabel, i) {\n        path = '';\n        end = typeof categoryLabel.end === 'string' ? Number(new Date(categoryLabel.end)) : categoryLabel.end;\n        start = typeof categoryLabel.start === 'string' ? Number(new Date(categoryLabel.start)) : categoryLabel.start;\n        startY = valueToCoefficient(start, axis) * rect.height;\n        endY = valueToCoefficient(end, axis) * rect.height;\n        endY = isInversed ? [startY, startY = endY][0] : endY;\n        argsData = _this.triggerMultiLabelRender(axis, categoryLabel.text, multiLevel.textStyle, multiLevel.alignment, categoryLabel.customAttributes);\n\n        if (!argsData.cancel) {\n          labelSize = measureText(argsData.text, argsData.textStyle);\n          gap = endY - startY;\n          x = rect.x - startX - _this.yAxisPrevHeight[level] - _this.yAxisMultiLabelHeight[level] / 2 - padding / 2;\n          y = rect.height + rect.y - startY - gap / 2;\n\n          if (opposedPosition) {\n            x = isOutside ? rect.x + startX + padding / 2 + _this.yAxisMultiLabelHeight[level] / 2 + _this.yAxisPrevHeight[level] + scrollBarHeight : rect.x - startX - _this.yAxisMultiLabelHeight[level] / 2 - _this.yAxisPrevHeight[level] - padding / 2;\n          } else {\n            x = isOutside ? x + scrollBarHeight : rect.x + startX + padding / 2 + _this.yAxisMultiLabelHeight[level] / 2 + _this.yAxisPrevHeight[level];\n          }\n\n          if (argsData.alignment === 'Center') {\n            y += labelSize.height / 4;\n          } else if (argsData.alignment === 'Far') {\n            y += gap / 2 - labelSize.height / 2;\n          } else {\n            y = y - gap / 2 + labelSize.height;\n          }\n\n          x = multiLevel.border.type === 'CurlyBrace' ? !opposedPosition && isOutside || opposedPosition && !isOutside ? x - padding : x + padding : x;\n          var options = new TextOption(_this.chart.element.id + index + '_Axis_MultiLevelLabel_Level_' + level + '_Text_' + i, x, y, anchor, argsData.text);\n          options.text = multiLevel.overflow === 'Trim' ? textTrim(categoryLabel.maximumTextWidth === null ? _this.yAxisMultiLabelHeight[level] : categoryLabel.maximumTextWidth, argsData.text, argsData.textStyle) : options.text;\n          textElement(_this.chart.renderer, options, argsData.textStyle, argsData.textStyle.color || _this.chart.themeStyle.axisLabel, _this.labelElement, _this.chart.redraw, true);\n\n          if (multiLevel.border.width > 0 && multiLevel.border.type !== 'WithoutBorder') {\n            path = _this.renderYAxisLabelBorder(level, gap, axis, endY, startX, startY, labelSize, options, rect, argsData.alignment, path, isOutside, opposedPosition, pointIndex);\n\n            if (path !== '') {\n              _this.createBorderElement(level, index, axis, path, pointIndex);\n\n              pointIndex++;\n            }\n          }\n\n          _this.multiElements.appendChild(_this.labelElement);\n        }\n      });\n    });\n    parent.appendChild(this.multiElements);\n  };\n  /**\n   * render y axis multi level labels border\n   * @private\n   * @return {void}\n   */\n\n\n  MultiLevelLabel.prototype.renderYAxisLabelBorder = function (labelIndex, gap, axis, endY, startX, startY, labelSize, textOptions, rect, alignment, path, isOutside, opposedPosition, categoryIndex) {\n    var height = endY - startY;\n    var padding = 10;\n    var padding1;\n    var padding2;\n    var groupLabel = axis.multiLevelLabels[labelIndex];\n    var categoryType = groupLabel.categories[categoryIndex].type;\n    var y = rect.y + rect.height - endY;\n    var scrollBarHeight = isOutside && isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;\n    scrollBarHeight = scrollBarHeight * (opposedPosition ? 1 : -1);\n    var width = this.yAxisMultiLabelHeight[labelIndex] + padding;\n    var x = (!opposedPosition && isOutside || opposedPosition && !isOutside ? rect.x - startX - this.yAxisPrevHeight[labelIndex] : rect.x + startX + this.yAxisPrevHeight[labelIndex]) + scrollBarHeight;\n    var borderType = categoryType ? categoryType : groupLabel.border.type;\n\n    switch (borderType) {\n      case 'WithoutTopandBottomBorder':\n      case 'Rectangle':\n      case 'WithoutTopBorder':\n        width = !opposedPosition && isOutside || opposedPosition && !isOutside ? -width : width;\n        path += 'M ' + x + ' ' + y + ' L ' + (x + width) + ' ' + y + ' M ' + x + ' ' + (y + height) + ' L ' + (x + width) + ' ' + (y + height);\n        path += borderType !== 'WithoutTopandBottomBorder' ? ' L' + ' ' + (x + width) + ' ' + y + ' ' : ' ';\n        path += borderType === 'Rectangle' ? 'M ' + x + ' ' + (y + height) + 'L' + ' ' + x + ' ' + y + ' ' : ' ';\n        break;\n\n      case 'Brace':\n        width = !opposedPosition && isOutside || opposedPosition && !isOutside ? width : -width;\n        path += 'M ' + x + ' ' + y + ' L ' + (x - width / 2) + ' ' + y + ' L ' + (x - width / 2) + ' ' + (textOptions.y - labelSize.height / 2 - 4) + ' M ' + (x - width / 2) + ' ' + (textOptions.y + labelSize.height / 4 + 2) + ' L ' + (x - width / 2) + ' ' + (y + height) + ' L ' + x + ' ' + (y + height);\n        break;\n\n      case 'CurlyBrace':\n        if (!opposedPosition && isOutside || opposedPosition && !isOutside) {\n          padding = -10;\n          padding1 = -15;\n          padding2 = -5;\n        } else {\n          padding = 10;\n          padding1 = 15;\n          padding2 = 5;\n        }\n\n        if (alignment === 'Center') {\n          path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + padding) + ' ' + y + ' ' + (x + padding) + ' ' + (y + 10) + ' L ' + (x + padding) + ' ' + (y + (height - 10) / 2) + ' L ' + (x + padding1) + ' ' + (y + (height - 10) / 2 + 5) + ' L ' + (x + padding) + ' ' + (y + (height - 10) / 2 + 10) + ' L ' + (x + padding) + ' ' + (y + (height - 10)) + ' C ' + (x + padding) + ' ' + (y + (height - 10)) + ' ' + (x + padding2) + ' ' + (y + height) + ' ' + x + ' ' + (y + height);\n        } else if (alignment === 'Far') {\n          path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + padding) + ' ' + y + ' ' + (x + padding) + ' ' + (y + 10) + ' L ' + (x + padding) + ' ' + (y + height - 20) + ' ' + ' L ' + (x + padding1) + ' ' + (y + (height - 15)) + ' L ' + (x + padding) + ' ' + (y + (height - 10)) + ' L ' + (x + padding) + ' ' + (y + (height - 10)) + ' C ' + (x + padding) + ' ' + (y + (height - 10)) + ' ' + (x + padding) + ' ' + (y + height) + ' ' + x + ' ' + (y + height);\n        } else {\n          path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + padding) + ' ' + y + ' ' + (x + padding) + ' ' + (y + 10) + ' L ' + (x + padding1) + ' ' + (y + 15) + ' L ' + (x + padding) + ' ' + (y + 20) + ' L ' + (x + padding) + ' ' + (y + (height - 10)) + ' C ' + (x + padding) + ' ' + (y + (height - 10)) + ' ' + (x + padding2) + ' ' + (y + height) + ' ' + x + ' ' + (y + height);\n        }\n\n        break;\n    }\n\n    return path;\n  };\n  /**\n   * create cliprect\n   * @return {void}\n   * @private\n   */\n\n\n  MultiLevelLabel.prototype.createClipRect = function (x, y, height, width, clipId, axisId) {\n    this.multiElements = this.chart.renderer.createGroup({\n      'id': axisId,\n      'clip-path': 'url(#' + clipId + ')'\n    });\n    this.multiElements.appendChild(appendClipElement(this.chart.redraw, {\n      'id': clipId,\n      'x': x,\n      'y': y,\n      'width': width,\n      'height': height,\n      'fill': 'white',\n      'stroke-width': 1,\n      'stroke': 'Gray'\n    }, this.chart.renderer));\n  };\n  /**\n   * create borer element\n   * @return {void}\n   * @private\n   */\n\n\n  MultiLevelLabel.prototype.createBorderElement = function (borderIndex, axisIndex, axis, path, pointIndex) {\n    var direction = path;\n    var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + axisIndex + '_Axis_MultiLevelLabel_Rect_' + borderIndex + '_' + pointIndex, 'Transparent', axis.multiLevelLabels[borderIndex].border.width, axis.multiLevelLabels[borderIndex].border.color || this.chart.themeStyle.axisLine, 1, '', path));\n    borderElement.setAttribute('style', 'pointer-events: none');\n    appendChildElement(this.chart.enableCanvas, this.labelElement, borderElement, this.chart.redraw, true, 'x', 'y', null, direction);\n  };\n  /**\n   * Triggers the event.\n   * @return {void}\n   * @private\n   */\n\n\n  MultiLevelLabel.prototype.triggerMultiLabelRender = function (axis, text, textStyle, textAlignment, customAttributes) {\n    var argsData;\n    argsData = {\n      cancel: false,\n      name: axisMultiLabelRender,\n      axis: axis,\n      text: text,\n      textStyle: textStyle,\n      alignment: textAlignment,\n      customAttributes: customAttributes\n    };\n    this.chart.trigger(axisMultiLabelRender, argsData);\n    return argsData;\n  };\n  /**\n   * Triggers the event.\n   * @return {void}\n   * @private\n   */\n\n\n  MultiLevelLabel.prototype.MultiLevelLabelClick = function (labelIndex, axisIndex) {\n    var level = parseInt(labelIndex.substr(0, 1), 10);\n    var textElement = parseInt(labelIndex.substr(7), 10);\n    var chart = this.chart;\n    var axis = chart.axisCollections[axisIndex];\n    var categories = axis.multiLevelLabels[level].categories;\n    var text = categories[textElement].text;\n    var start = categories[textElement].start;\n    var end = categories[textElement].end;\n    var customAttributes = categories[textElement].customAttributes;\n    var multilevelclickArgs;\n    multilevelclickArgs = {\n      axis: axis,\n      level: level,\n      text: text,\n      customAttributes: customAttributes,\n      start: start,\n      end: end,\n      name: multiLevelLabelClick,\n      cancel: false\n    };\n    this.chart.trigger(multiLevelLabelClick, multilevelclickArgs);\n    return multilevelclickArgs;\n  };\n  /**\n   * To click the multi level label\n   * @return {void}\n   * @private\n   */\n\n\n  MultiLevelLabel.prototype.click = function (event) {\n    var targetId = event.target.id;\n    var multiLevelID = '_Axis_MultiLevelLabel_Level_';\n    var textId;\n    var elementId;\n    var axisIndex;\n\n    if (targetId.indexOf(multiLevelID) > -1) {\n      textId = targetId.split(multiLevelID)[1];\n      elementId = targetId.split(multiLevelID)[0];\n      axisIndex = parseInt(elementId.charAt(elementId.length - 1), 10);\n      this.MultiLevelLabelClick(textId, axisIndex);\n    }\n  };\n  /**\n   * To get the module name for `MultiLevelLabel`.\n   * @private\n   */\n\n\n  MultiLevelLabel.prototype.getModuleName = function () {\n    return 'MultiLevelLabel';\n  };\n  /**\n   * To destroy the `MultiLevelLabel` module.\n   * @private\n   */\n\n\n  MultiLevelLabel.prototype.destroy = function () {// destroy peform here\n  };\n\n  return MultiLevelLabel;\n}();\n\nexport { MultiLevelLabel };","map":null,"metadata":{},"sourceType":"module"}